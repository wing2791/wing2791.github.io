

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="wing2791">
  <meta name="keywords" content="">
  
    <meta name="description" content="22. 运算符重载  在C#中，运算符重载允许为用户自定义的类型（如类或结构体）定义或重载运算符的行为。这使得用户可以对自定义类型使用标准的运算符（如 +, -, *, &#x2F;, 相等, !&#x3D; 等），就像对内置类型操作一样。 运算符重载的基本规则 必须是 static 方法：重载的运算符方法必须声明为静态的。 通常为 public 访问修饰符：以便在外部使用。 参数数量：一元运算符（如 ++, --,">
<meta property="og:type" content="article">
<meta property="og:title" content="CSharp知识整理(二)">
<meta property="og:url" content="https://wing2791.github.io/2024/10/25/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%BA%8C)/index.html">
<meta property="og:site_name" content="Day Day Up!">
<meta property="og:description" content="22. 运算符重载  在C#中，运算符重载允许为用户自定义的类型（如类或结构体）定义或重载运算符的行为。这使得用户可以对自定义类型使用标准的运算符（如 +, -, *, &#x2F;, 相等, !&#x3D; 等），就像对内置类型操作一样。 运算符重载的基本规则 必须是 static 方法：重载的运算符方法必须声明为静态的。 通常为 public 访问修饰符：以便在外部使用。 参数数量：一元运算符（如 ++, --,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s21.ax1x.com/2024/10/26/pAwb64s.png">
<meta property="article:published_time" content="2024-10-25T14:06:38.028Z">
<meta property="article:modified_time" content="2024-11-07T16:20:41.006Z">
<meta property="article:author" content="wing2791">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s21.ax1x.com/2024/10/26/pAwb64s.png">
  
  
  
  <title>CSharp知识整理(二) - Day Day Up!</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wing2791.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>wing2791的小窝</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CSharp知识整理(二)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-10-25 22:06" pubdate>
          2024年10月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          173 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CSharp知识整理(二)</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="22-运算符重载"><a href="#22-运算符重载" class="headerlink" title="22. 运算符重载"></a>22. 运算符重载</h1><p>  在C#中，运算符重载允许为用户自定义的类型（如类或结构体）定义或重载运算符的行为。这使得用户可以对自定义类型使用标准的运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>相等</code>, <code>!=</code> 等），就像对内置类型操作一样。</p>
<h3 id="运算符重载的基本规则"><a href="#运算符重载的基本规则" class="headerlink" title="运算符重载的基本规则"></a>运算符重载的基本规则</h3><ol>
<li><strong>必须是 <code>static</code> 方法</strong>：重载的运算符方法必须声明为静态的。</li>
<li><strong>通常为 <code>public</code> 访问修饰符</strong>：以便在外部使用。</li>
<li><strong>参数数量</strong>：一元运算符（如 <code>++</code>, <code>--</code>, <code>!</code>）只有一个参数，二元运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>）只有两个参数。</li>
<li><strong>返回类型</strong>：可以是任何类型，不一定要与操作数类型相同。</li>
<li>运算符的参数必须是包含当前类的类型</li>
<li>不能使用ref和out修饰参数，ref和out参数在此上下文中无效</li>
</ol>
<h3 id="重载一元运算符的示例"><a href="#重载一元运算符的示例" class="headerlink" title="重载一元运算符的示例"></a>重载一元运算符的示例</h3><p>一元运算符重载允许你为自定义类型定义操作符（如 <code>++</code>、<code>--</code>、<code>-</code>、<code>!</code> 等）的行为。与二元运算符重载相似，在C#中，一元运算符的重载也必须是静态方法，且通常只需要一个参数，且该参数通常是包含运算符重载方法的类型。</p>
<ul>
<li>C#中的++和–重载部分前缀和后缀，具体看下面的第二个例子</li>
<li>不管前置后置运算，程序只执行唯一的重载运算符函数，其实C#不分前缀和后缀的写法，和Cpp不一样。C#对++&#x2F;–运算符重载的要求：<ul>
<li>参数必须是一个，而且只能是包含它的类型，也就是它的所在类类型</li>
<li>返回值，必须是所在类类型或其派生类</li>
<li>所有重载的运算符必须是 public 和 static的，这是编译时要求</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是一个示例，展示如何重载一元运算符 <code>++</code> 和 <code>--</code>，以及负号运算符 <code>-</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>	<span class="hljs-comment">// 不可以用ref或者out修饰int</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialValue</span>)</span><br>    &#123;<br>        Value = initialValue;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载前缀 ++ 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> ++(Counter c)<br>    &#123;<br>        c.Value++;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 重载前缀 -- 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> --(Counter c)<br>    &#123;<br>        c.Value--;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载负号运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> -(Counter c)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(-c.Value);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，以便输出格式化的计数器值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Value.ToString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Counter counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 使用重载的 ++ 运算符</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Initial Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Increment: <span class="hljs-subst">&#123;++counter&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Decrement: <span class="hljs-subst">&#123;--counter&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用重载的负号运算符</span><br>        Counter negativeCounter = -counter;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Negative Value: <span class="hljs-subst">&#123;negativeCounter&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>重载<code>++</code>和<code>--</code>的另一个例子<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>()</span> &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialValue</span>)</span><br>    &#123;<br>        Value = initialValue;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载前缀和后缀 ++ 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> ++(Counter c)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;operator++&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">1</span> + c.Value);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载前缀和后缀 -- 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> --(Counter c)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;operator--&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(c.Value - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载负号运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> -(Counter c)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(-c.Value);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，以便输出格式化的计数器值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Value.ToString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Counter counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 使用重载的 ++ 和 -- 运算符</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Initial Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Prefix Increment: <span class="hljs-subst">&#123;++counter.Value&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Prefix Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Postfix Increment: <span class="hljs-subst">&#123;(counter++).Value&#125;</span>&quot;</span>);<br>        <span class="hljs-comment">// 上面一行等价于下面两行，不一定是+=1，实际看返回的new Counter(1 + c.Value);是怎么操作的，也可以+2</span><br>        <span class="hljs-comment">// Console.WriteLine($&quot;After Postfix Increment: &#123;counter.Value&#125;&quot;); // 输出当前值</span><br>        <span class="hljs-comment">// counter.Value += 1; // 实际上增1操作是直接对原对象进行修改的</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Postfix Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Prefix Decrement: <span class="hljs-subst">&#123;--counter.Value&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Prefix Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Postfix Decrement: <span class="hljs-subst">&#123;(counter--).Value&#125;</span>&quot;</span>);<br>        <span class="hljs-comment">// 上面一行等价于下面两行，不一定是-=1，实际看返回的new Counter(c.Value - 1);是怎么操作的，也可以-2</span><br>        <span class="hljs-comment">// Console.WriteLine($&quot;After Postfix Increment: &#123;counter.Value&#125;&quot;); // 输出当前值</span><br>        <span class="hljs-comment">// counter.Value -= 1; // 实际上增1操作是直接对原对象进行修改的</span><br>        <span class="hljs-comment">// 查看最终计数器值</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Postfix Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用重载的负号运算符</span><br>        Counter negativeCounter = -counter;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Negative Value: <span class="hljs-subst">&#123;negativeCounter&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">//Initial Value: 5</span><br><span class="hljs-comment">//After Prefix Increment: 6</span><br><span class="hljs-comment">//After Prefix Value: 6</span><br><span class="hljs-comment">//operator ++</span><br><span class="hljs-comment">//After Postfix Increment: 6</span><br><span class="hljs-comment">//After Postfix Value: 7</span><br><span class="hljs-comment">//After Prefix Decrement: 6</span><br><span class="hljs-comment">//After Prefix Value: 6</span><br><span class="hljs-comment">//operator--</span><br><span class="hljs-comment">//After Postfix Decrement: 6</span><br><span class="hljs-comment">//After Postfix Value: 5</span><br><span class="hljs-comment">//Negative Value: -5</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><strong>访问修饰符</strong>：重载运算符的方法必须是 <code>public</code> 和 <code>static</code>。</li>
<li><strong>返回类型</strong>：重载运算符的方法返回一个新对象或修改后的对象。</li>
<li>一元运算符的参数必须是包含类型</li>
</ol>
<h3 id="重载二元运算符的示例"><a href="#重载二元运算符的示例" class="headerlink" title="重载二元运算符的示例"></a>重载二元运算符的示例</h3><p>以下是一个重载加法运算符的示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ComplexNumber</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Real &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Imaginary &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComplexNumber</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> real, <span class="hljs-built_in">double</span> imaginary</span>)</span><br>    &#123;<br>        Real = real;<br>        Imaginary = imaginary;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载加法运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ComplexNumber <span class="hljs-keyword">operator</span> +(ComplexNumber c1, ComplexNumber c2)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ComplexNumber(c1.Real + c2.Real, c1.Imaginary + c2.Imaginary);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，以便输出格式化的复数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Real&#125;</span> + <span class="hljs-subst">&#123;Imaginary&#125;</span>i&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        ComplexNumber c1 = <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>);<br>        ComplexNumber c2 = <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);<br>        ComplexNumber sum = c1 + c2; <span class="hljs-comment">// 使用重载的加法运算符</span><br><br>        Console.WriteLine(<span class="hljs-string">$&quot;c1 + c2 = <span class="hljs-subst">&#123;sum&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><ul>
<li><code>ComplexNumber</code> 类表示一个复数，包含两个字段：<code>Real</code> 和 <code>Imaginary</code>。</li>
<li>加法运算符 <code>+</code> 被重载，使得可以对两个 <code>ComplexNumber</code> 实例进行相加操作。</li>
<li><code>operator +</code> 方法返回一个新的 <code>ComplexNumber</code> 对象，其 <code>Real</code> 和 <code>Imaginary</code> 分别是两个操作数相加的结果。</li>
<li>在 <code>Main</code> 方法中，<code>c1</code> 和 <code>c2</code> 被相加，并输出相加的结果。</li>
</ul>
<h3 id="支持重载的运算符列表"><a href="#支持重载的运算符列表" class="headerlink" title="支持重载的运算符列表"></a>支持重载的运算符列表</h3><p>C# 支持重载的运算符包括：</p>
<ul>
<li>算术运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li>
<li>比较运算符：<code>相等</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li>
<li>位运算符：<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li>
<li>自增、自减运算符：<code>++</code>, <code>--</code></li>
</ul>
<h3 id="不支持重载的运算符列表"><a href="#不支持重载的运算符列表" class="headerlink" title="不支持重载的运算符列表"></a>不支持重载的运算符列表</h3><ul>
<li><strong>成员访问运算符</strong>：<code>.</code>（点运算符）<ul>
<li>用于访问类型的成员（字段、属性、方法等）。</li>
</ul>
</li>
<li><strong>条件运算符</strong>：<code>?:</code>（三元运算符）<ul>
<li>用于条件表达式。</li>
</ul>
</li>
<li><strong>委托运算符</strong>：<code>delegate</code><ul>
<li>用于声明委托。</li>
</ul>
</li>
<li><strong>指针运算符</strong>：<code>*</code>（指针解引用运算符）和<code>&amp;</code>（地址运算符）<ul>
<li>用于处理指针。</li>
</ul>
</li>
<li><strong>类型测试运算符</strong>：<code>is</code> 和 <code>as</code><ul>
<li>用于检查对象类型和进行类型转换。</li>
</ul>
</li>
<li><strong>数组下标运算符</strong>：<code>[]</code><ul>
<li>用于数组索引访问。</li>
</ul>
</li>
<li><strong>new 关键字</strong><ul>
<li>用于对象的创建。</li>
</ul>
</li>
<li><strong>default 关键字</strong><ul>
<li>用于获取类型的默认值。</li>
</ul>
</li>
<li><strong>sizeof 关键字</strong><ul>
<li>用于获取类型的大小。</li>
</ul>
</li>
<li>赋值符号&#x3D;</li>
<li>强转运算符()</li>
</ul>
<h3 id="重载运算符的注意事项"><a href="#重载运算符的注意事项" class="headerlink" title="重载运算符的注意事项"></a>重载运算符的注意事项</h3><ul>
<li>条件运算符需要成对实现<ul>
<li>如果重载 <code>相等</code> 运算符，通常也需要重载 <code>!=</code> 运算符。</li>
<li>如果重载比较运算符（如 <code>&lt;</code> 和 <code>&gt;</code>），还需要重载其相应的 <code>&lt;=</code> 和 <code>&gt;=</code> 运算符。</li>
</ul>
</li>
<li>二元运算符的参数之一必须是包含类型</li>
<li>为了更好地实现运算符的语义，一般还需要重写 <code>Equals()</code> 和 <code>GetHashCode()</code> 方法。<ul>
<li><ol>
<li><code>Equals()</code> 方法<br>  <code>Equals()</code> 用于比较两个对象是否相等。它通常用于判断两个对象的内容是否相等，而不仅仅是它们是否是同一个对象（即是否是同一个内存地址）。</li>
</ol>
<ul>
<li><strong>重写场景：</strong> 当你定义了一个自定义类型并且想要比较两个实例的内容是否相等时，就需要重写 <code>Equals()</code> 方法。默认的 <code>Equals()</code> 比较的是引用相等性（即对象的地址），但是如果你希望比较的是对象的实际内容（例如 <code>Counter</code> 类中的 <code>Value</code>），就需要重写它。<br>  <strong>重写 <code>Equals()</code> 时应遵循以下规则：</strong><ul>
<li>自反性：<code>a.Equals(b)</code> 和 <code>b.Equals(a)</code> 都应返回相同的结果。</li>
<li>对称性：如果 <code>a.Equals(b)</code> 返回 <code>true</code>，那么 <code>b.Equals(a)</code> 也应返回 <code>true</code>。</li>
<li>传递性：如果 <code>a.Equals(b)</code> 返回 <code>true</code> 且 <code>b.Equals(c)</code> 返回 <code>true</code>，那么 <code>a.Equals(c)</code> 应该返回 <code>true</code>。</li>
<li>一致性：多次调用相同的对象对比应始终返回相同的结果，除非对象的状态改变。</li>
</ul>
</li>
</ul>
</li>
<li><ol start="2">
<li><code>GetHashCode()</code> 方法<br>  <code>GetHashCode()</code> 方法用于为对象提供一个哈希值，哈希值通常用于哈希表（如 <code>Dictionary</code> 或 <code>HashSet</code>）中，以便在查找、插入或删除时快速定位对象。哈希值应该尽量均匀地分布，以减少冲突。</li>
</ol>
<ul>
<li><strong>重写场景：</strong> 当你重写 <code>Equals()</code> 方法时，通常也需要重写 <code>GetHashCode()</code> 方法，以确保相等的对象有相同的哈希值。这样才能确保在哈希集合（如 <code>HashSet</code> 或 <code>Dictionary</code>）中，比较相等的对象能够正确地存储和查找。<br>  <strong>重写 <code>GetHashCode()</code> 时的一些建议：</strong><ul>
<li>如果两个对象相等（通过 <code>Equals()</code> 判断），那么它们的哈希值必须相同。</li>
<li>如果两个对象不相等，它们的哈希值不必不同，但尽量避免大量哈希冲突，以提高性能。</li>
<li><code>GetHashCode()</code> 生成的哈希值应该基于对象的“值”，而不是其引用地址。</li>
</ul>
</li>
<li>为什么重写这两个方法<br>  在许多场景中，特别是在使用集合类（如 <code>Dictionary</code>、<code>HashSet</code>）时，<code>Equals()</code> 和 <code>GetHashCode()</code> 起着关键作用。集合会利用哈希值来高效地存储和查找对象，因此正确地重写这两个方法能确保自定义类型在这些集合中的正常使用。</li>
<li>示例：<br>  假设你有一个 <code>Counter</code> 类，你想要通过值来判断两个计数器是否相等，并将它们作为键存储在 <code>Dictionary</code> 中。你需要重写 <code>Equals()</code> 和 <code>GetHashCode()</code> 方法。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialValue</span>)</span><br>	&#123;<br>		Value = initialValue;<br>	&#125;<br><br>	<span class="hljs-comment">// 重载 Equals 方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>	&#123;<br>		<span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Counter otherCounter)<br>		&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.Value == otherCounter.Value;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// 重载 GetHashCode 方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> Value.GetHashCode();<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>	&#123;<br>		<span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">new</span> Dictionary&lt;Counter, <span class="hljs-built_in">string</span>&gt;();<br>		<span class="hljs-keyword">var</span> counter1 = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br>		<span class="hljs-keyword">var</span> counter2 = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br><br>		dict[counter1] = <span class="hljs-string">&quot;First&quot;</span>;<br>		Console.WriteLine(dict[counter2]); <span class="hljs-comment">// 输出 &quot;First&quot;，因为 counter1 和 counter2 的值相等，且哈希值相同</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
  在这个例子中，如果没有重写 <code>Equals()</code> 和 <code>GetHashCode()</code>，<code>counter1</code> 和 <code>counter2</code> 将被认为是不同的对象（基于引用），即使它们的 <code>Value</code> 相同。但通过重写这两个方法，我们确保了它们在比较时是基于 <code>Value</code> 属性的。<br>  运算符重载使自定义类型在运算时可以更符合直观的数学表示，提高代码的可读性和易用性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="强转运算符（类型转换运算符）特定的重载方式"><a href="#强转运算符（类型转换运算符）特定的重载方式" class="headerlink" title="强转运算符（类型转换运算符）特定的重载方式"></a>强转运算符（类型转换运算符）特定的重载方式</h3><ul>
<li><strong>类型转换运算符</strong>：C# 允许你定义类型转换运算符，但不是通过传统的运算符重载语法。你可以通过定义显式或隐式转换运算符来实现类型转换的行为。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 显式转换运算符，如果隐式使用，会报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-keyword">value</span> &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 隐式转换运算符,如果显式的使用，不会报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">MyClass myClass</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> myClass.Value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = (MyClass)<span class="hljs-number">5</span>; <span class="hljs-comment">// 显式转换</span><br>        <span class="hljs-comment">// MyClass myObject2 = 5; // 隐式转换，报错</span><br>        <span class="hljs-built_in">int</span> number = myObject;          <span class="hljs-comment">// 隐式转换</span><br>        <span class="hljs-built_in">int</span> number2 = (<span class="hljs-built_in">int</span>)myObject;          <span class="hljs-comment">// 显式转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="23-explicit-implicit"><a href="#23-explicit-implicit" class="headerlink" title="23. explicit implicit"></a>23. explicit implicit</h1><p>在C#中，<code>explicit</code> 和 <code>implicit</code> 是用来定义类型转换运算符的关键字，它们决定了类型转换的方式和使用场景。下面是对这两个关键字的详细解释以及它们的区别。</p>
<h3 id="1-implicit（隐式转换）"><a href="#1-implicit（隐式转换）" class="headerlink" title="1. implicit（隐式转换）"></a>1. <code>implicit</code>（隐式转换）</h3><ul>
<li><strong>定义</strong>：隐式转换运算符允许自动转换类型，无需显式地进行类型转换。</li>
<li><strong>使用场景</strong>：当你希望一个类型可以被安全地转换为另一个类型，并且这种转换不可能导致数据丢失或异常时，可以使用隐式转换。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 隐式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-keyword">value</span> &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = <span class="hljs-number">10</span>; <span class="hljs-comment">// 隐式转换</span><br>        Console.WriteLine(myObject.Value); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-explicit（显式转换）"><a href="#2-explicit（显式转换）" class="headerlink" title="2. explicit（显式转换）"></a>2. <code>explicit</code>（显式转换）</h3><ul>
<li><strong>定义</strong>：显式转换运算符需要使用强制类型转换符进行转换，不能隐式转换。</li>
<li><strong>使用场景</strong>：当你希望转换可能导致数据丢失或需要显式指明时，可以使用显式转换。这样可以防止意外的类型转换。</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 显式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">MyClass myClass</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> myClass.Value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-number">10</span> &#125;;<br>        <span class="hljs-built_in">int</span> number = (<span class="hljs-built_in">int</span>)myObject; <span class="hljs-comment">// 显式转换</span><br>        Console.WriteLine(number); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>implicit</code>：允许类型自动转换，适用于安全且无损的转换。</li>
<li><code>explicit</code>：要求使用强制转换，适用于可能导致数据丢失或不安全的转换。</li>
</ul>
<h1 id="24-内部类"><a href="#24-内部类" class="headerlink" title="24. 内部类"></a>24. 内部类</h1><p>在C#中，内部类是定义在另一个类中的类，也称为嵌套类。内部类可以用来组织代码，使外部类更紧凑，同时为外部类提供额外的功能。以下是关于C#内部类的一些关键点：</p>
<h3 id="1-内部类的定义"><a href="#1-内部类的定义" class="headerlink" title="1. 内部类的定义"></a>1. 内部类的定义</h3><p>内部类可以定义在外部类的任何地方（类体内），并且可以访问外部类的私有成员。内部类本身也可以有自己的成员和方法。</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是内部类的方法.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 外部类的方法可以创建内部类的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass();<br>        inner.Display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-访问外部类的成员"><a href="#2-访问外部类的成员" class="headerlink" title="2. 访问外部类的成员"></a>2. 访问外部类的成员</h3><p>内部类可以访问外部类的所有成员，包括私有成员。</p>
<ul>
<li>C#中的内部类要访问外部类的成员（包括私有成员），需要持有外部类的实例的引用。这是因为内部类与外部类是两个不同的对象，要访问外部类的成员，必须通过外部类的实例进行访问。通常，可以通过构造函数传递外部类的实例，然后使用该实例访问外部类的成员。</li>
</ul>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> OuterClass outer;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> pubInt;<br><br>        <span class="hljs-comment">// 构造函数接收外部类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClass</span>(<span class="hljs-params">OuterClass outer</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.outer = outer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayOuterValue</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 访问外部类的私有字段</span><br>            <span class="hljs-comment">// 访问外部类的私有字段,必须使用接收的实例才能够使用其中的变量，不然无法直接使用outerValue</span><br>            Console.WriteLine(<span class="hljs-string">&quot;外部类的值是: &quot;</span> + outer.outerValue);<br>        &#125;<br><br>        <span class="hljs-comment">// 给外部类提供访问内部类的公共方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayInnerInfo</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是内部类的方法&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass(<span class="hljs-keyword">this</span>);<br>        inner.DisplayOuterValue();<br>        inner.DisplayInnerInfo();  <span class="hljs-comment">// 外部类可以访问内部类的公共方法</span><br>        inner.pubInt = <span class="hljs-number">42</span>;<br>        Console.WriteLine(<span class="hljs-string">$&quot;内部类的pubInt的值是:<span class="hljs-subst">&#123;inner.pubInt&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 内部类可以访问外部类的私有成员，不过也必须传入外部类到构造函数</span><br>        <span class="hljs-comment">// 外部类无法直接访问内部类的私有成员，但是可以通过公共方法或者属性来访问。</span><br>        OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();<br>        outer.CreateInner();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-内部类的访问修饰符"><a href="#3-内部类的访问修饰符" class="headerlink" title="3. 内部类的访问修饰符"></a>3. 内部类的访问修饰符</h3><p>内部类可以具有自己的访问修饰符，比如<code>public</code>、<code>private</code>、<code>protected</code>、<code>internal</code>等，这决定了内部类在外部类之外的可见性。</p>
<ul>
<li><code>private</code>：内部类只能被外部类访问。</li>
<li><code>public</code>：内部类可以被外部类之外的代码访问。</li>
<li><code>protected</code>：内部类只能被外部类及其派生类访问。</li>
<li><code>internal</code>：内部类可以被同一个程序集中的其他代码访问。程序集的理解就是一个解决方案中的项目<ul>
<li>在C#中，“程序集”（Assembly）是指一个已编译的代码库，通常是一个 <code>.exe</code> 或 <code>.dll</code> 文件。它是 .NET 中的基本部署单元，包含可执行代码、资源文件和元数据。</li>
<li>元数据的意思就是描述数据的数据</li>
<li><a target="_blank" rel="noopener" href="https://imgse.com/i/pAwb64s"><img src="https://s21.ax1x.com/2024/10/26/pAwb64s.png" srcset="/img/loading.gif" lazyload alt="pAwb64s.png"></a></li>
</ul>
</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul>
<li><strong>封装相关功能</strong>：内部类可以作为外部类的辅助类，帮助封装某些复杂的功能。</li>
<li><strong>访问控制</strong>：通过嵌套类的访问修饰符，可以严格控制类的访问权限。</li>
<li><strong>代码组织</strong>：将相关的类组织在一起，使代码更整洁。</li>
</ul>
<h3 id="5-示例：使用访问修饰符"><a href="#5-示例：使用访问修饰符" class="headerlink" title="5. 示例：使用访问修饰符"></a>5. 示例：使用访问修饰符</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 私有内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是私有的内部类.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass();<br>        inner.Display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>InnerClass</code>是<code>private</code>的，因此只能在<code>OuterClass</code>中使用，不能在外部类之外的地方访问。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>内部类</strong>用于在类中嵌套另一个类，具有封装性和灵活性。</li>
<li>可以通过访问修饰符控制内部类的访问权限。</li>
<li>内部类可以访问外部类的所有成员，包括私有成员。</li>
</ul>
<h1 id="25-OuterClass-outer-new-OuterClass-和OuterClass-outer2-区别"><a href="#25-OuterClass-outer-new-OuterClass-和OuterClass-outer2-区别" class="headerlink" title="25. OuterClass outer &#x3D; new OuterClass();和OuterClass outer2;区别"></a>25. OuterClass outer &#x3D; new OuterClass();和OuterClass outer2;区别</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> OuterClass outer;<br><br>        <span class="hljs-comment">// 构造函数接收外部类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClass</span>(<span class="hljs-params">OuterClass outer</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.outer = outer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayOuterValue</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 访问外部类的私有字段</span><br>            Console.WriteLine(<span class="hljs-string">&quot;外部类的值是: &quot;</span> + outer.outerValue);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass(<span class="hljs-keyword">this</span>);<br>        inner.DisplayOuterValue();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();<br>        OuterClass outer2;<br>        outer.CreateInner();<br>        <span class="hljs-comment">// outer2.CreateInner(); //CS0165 使用了未赋值的局部变量&quot;outer2&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在C#中，这两个声明的确有区别：</p>
<ol>
<li><code>OuterClass outer = new OuterClass();</code><ul>
<li>这里声明了一个名为 <code>outer</code> 的变量，并且通过 <code>new OuterClass()</code> 创建了一个 <code>OuterClass</code> 类型的实例，然后将这个实例的引用赋值给变量 <code>outer</code>。</li>
<li>这样，<code>outer</code> 就指向了一个已经被实例化的对象，可以访问对象的成员。</li>
</ul>
</li>
<li><code>OuterClass outer2;</code><ul>
<li>这里声明了一个名为 <code>outer2</code> 的变量，但没有初始化它，即没有创建对象实例。</li>
<li>此时，<code>outer2</code> 只是一个未赋值的变量，如果尝试使用它（如访问成员），会导致编译错误，因为变量尚未初始化。</li>
</ul>
</li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>OuterClass outer = new OuterClass();</code>：创建了一个 <code>OuterClass</code> 对象，并将其赋值给 <code>outer</code>。</li>
<li><code>OuterClass outer2;</code>：仅声明了变量 <code>outer2</code>，但并未指向任何对象。使用前需要先进行初始化，例如：<code>outer2 = new OuterClass();</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;test:show&quot;</span> &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	Test* test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br>	Test test2;<br>	test-&gt;<span class="hljs-built_in">show</span>();<br>	test<span class="hljs-number">2.</span><span class="hljs-built_in">show</span>();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
在C++中，这两种声明方式有明显的区别：</li>
</ul>
<ol>
<li><code>Test* test = new Test();</code><ul>
<li>这会创建一个指向<code>Test</code>对象的指针，并且该对象是在堆上分配的。使用<code>new</code>关键字会动态分配内存，这时需要手动管理内存，在合适的时候使用<code>delete test</code>释放内存，否则会导致内存泄漏。</li>
</ul>
</li>
<li><code>Test test2;</code><ul>
<li>这会在栈上创建一个<code>Test</code>对象实例。当该对象的作用域结束时，会自动销毁，不需要手动管理内存。<br>第一种方式适用于需要在当前作用域之外持续存在的对象，而第二种方式在对象生命周期较短时效率更高。</li>
</ul>
</li>
</ol>
<h1 id="26-分部类"><a href="#26-分部类" class="headerlink" title="26. 分部类"></a>26. 分部类</h1><p>在C#中，<strong>分部类（Partial Class）</strong> 允许将一个类的定义分散到多个文件中。这在大型项目中很有用，特别是当多个开发者需要同时对同一个类进行修改，或者自动生成的代码和手写的代码需要分开时。</p>
<h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ol>
<li><strong>使用 <code>partial</code> 关键字</strong>：分部类的定义需要使用 <code>partial</code> 关键字来标识。每个部分都必须使用 <code>partial</code> 声明，并且具有相同的类名。</li>
<li><strong>文件位于同一个命名空间下</strong>：分部类的各部分可以在不同的文件中定义，但它们必须在同一个命名空间下。</li>
<li><strong>编译时合并</strong>：在编译时，所有分部类会被合并为一个完整的类。因此，分部类的所有方法、属性和成员变量在使用时是共享的。</li>
<li><strong>访问修饰符一致性</strong>：分部类的各个部分可以有不同的访问修饰符（如 <code>public</code>、<code>internal</code>），但最终编译后的类只能具有一种可见性。</li>
<li>分部类中不能有重复成员，可以重载</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>文件 <code>Person1.cs</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintName</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;FirstName&#125;</span> <span class="hljs-subst">&#123;LastName&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>文件 <code>Person2.cs</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintAge</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Age: <span class="hljs-subst">&#123;Age&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>Person</code> 类被拆分到了两个文件 <code>Person1.cs</code> 和 <code>Person2.cs</code> 中。在编译时，这两个部分会被合并成一个完整的 <code>Person</code> 类，拥有所有的属性和方法。</p>
<h3 id="分部类的用途："><a href="#分部类的用途：" class="headerlink" title="分部类的用途："></a>分部类的用途：</h3><ul>
<li><strong>自动生成代码</strong>：比如在一些工具（如Visual Studio设计器或Entity Framework）中，自动生成的代码和用户手写的代码可以放在不同的分部类中，方便管理。</li>
<li><strong>模块化开发</strong>：团队开发时，可以将一个类分割成不同部分，方便不同开发人员同时修改。</li>
<li><strong>代码组织</strong>：对于大类，可以将不同功能放在不同的文件中，提高代码的可读性和可维护性。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在C#的分部类中，<strong>访问修饰符一致性</strong>的意思是：虽然你可以在不同的分部类定义中使用不同的访问修饰符（如 <code>public</code> 或 <code>internal</code>），但是编译器最终会将所有部分合并为一个完整的类，这个类只能有一个最终的可见性（即访问级别）。</p>
<p>具体来说，编译器会根据以下规则来确定最终的访问修饰符：</p>
<ol>
<li><strong>如果所有分部类都指定了相同的访问修饰符</strong>，那么最终类的访问修饰符就是这个一致的修饰符。例如，如果所有部分都是 <code>public</code>，那么合并后的类也是 <code>public</code>。</li>
<li><strong>如果有的部分指定了访问修饰符，而有的没有指定</strong>，编译器会选择访问级别最高的修饰符。例如，如果一个部分是 <code>public</code>，而另一个部分没有指定修饰符（默认是 <code>internal</code>），那么最终类的可见性将是 <code>public</code>。</li>
<li><strong>如果不同部分的修饰符不一致</strong>，并且存在冲突（如一个部分是 <code>public</code>，另一个部分是 <code>internal</code>），编译器会报错，因为访问修饰符必须在所有部分中一致，或者必须选择可以合并的修饰符。</li>
</ol>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>文件 <code>Person1.cs</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>文件 <code>Person2.cs</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，<code>Person1.cs</code> 中的 <code>Person</code> 类是 <code>public</code> 的，而 <code>Person2.cs</code> 中的 <code>Person</code> 类是 <code>internal</code> 的。这会导致编译错误，因为编译器不知道该选择 <code>public</code> 还是 <code>internal</code> 作为最终类的可见性。<br>要解决这个问题，你可以确保所有分部类都使用相同的访问修饰符，或者明确指定某一种修饰符，如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-comment">// 修改为 public</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样就保证了所有部分的访问修饰符一致，编译器就能确定 <code>Person</code> 类的可见性是 <code>public</code>。</p>
<h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p>在C#中，<strong>分部方法（Partial Methods）</strong> 是一种特殊的方法，可以在分部类（<code>partial</code>）中使用。分部方法的定义可以分成两个部分<strong>声明</strong>和<strong>实现</strong>，它们可以分别位于分部类的不同部分中。</p>
<h4 id="分部方法的特点"><a href="#分部方法的特点" class="headerlink" title="分部方法的特点"></a>分部方法的特点</h4><ol>
<li><strong>必须定义在分部类或结构中</strong> ： 分部方法只能在使用了<code>partial</code>关键字的分部类或结构中定义。</li>
<li><strong>必须是<code>void</code>类型</strong> ： 分部方法不能有返回值，必须是<code>void</code>类型。</li>
<li><strong>隐式<code>private</code></strong> ： 分部方法默认为私有（<code>private</code>），不能使用访问修饰符，因为它只能在当前类中使用。</li>
<li><strong>可选实现</strong> ： 分部方法的实现是可选的。如果没有提供实现，则在编译时，声明将被忽略，不会生成任何代码。因此，调用未实现的分部方法不会产生任何影响。</li>
<li><strong>不支持输出参数（<code>out</code>）</strong> ： 分部方法不能使用<code>out</code>修饰符，但可以使用<code>ref</code>修饰符。</li>
</ol>
<h4 id="分部方法的语法"><a href="#分部方法的语法" class="headerlink" title="分部方法的语法"></a>分部方法的语法</h4><ol>
<li><strong>声明</strong>： 在一个分部类中声明分部方法，使用<code>partial</code>关键字。</li>
<li><strong>实现</strong>： 可以在类的另一个分部文件中实现这个方法，也可以不实现。</li>
</ol>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下示例演示了分部方法的声明和实现。<br>文件 <code>Person1.cs</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-comment">// 分部方法的声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNameChanged</span>()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            name = <span class="hljs-keyword">value</span>;<br>            <span class="hljs-comment">// 调用分部方法</span><br>            OnNameChanged();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>文件 <code>Person2.cs</code>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// 分部方法的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNameChanged</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Name changed to: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>OnNameChanged</code>方法在<code>Person1.cs</code>中进行了声明，并在<code>Person2.cs</code>中进行了实现。如果不提供实现，编译器会忽略它的声明。如果调用了声明但没有定义的方法也没事，直接忽略了。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><strong>在生成代码中扩展功能</strong>：分部方法常用于自动生成的代码中，比如工具生成的类中声明分部方法，用户可以选择性地在另外的文件中实现它们。</li>
<li><strong>模块化设计</strong>：通过将方法拆分为不同的文件，可以更好地管理和维护大型项目。<br>分部方法提供了一种灵活的方式来设计和实现方法，同时保持代码的模块化和清晰性。</li>
</ul>
<h1 id="27-类的继承"><a href="#27-类的继承" class="headerlink" title="27. 类的继承"></a>27. 类的继承</h1><p>在C#中，<strong>类的继承</strong>是一种面向对象编程的机制，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。通过继承，可以实现代码重用、扩展类的功能以及多态性。</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><p>在C#中使用<code>:</code>符号来表示继承关系，语法如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-comment">// 子类的成员</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>BaseClass</code>是基类或父类，提供了一些基本功能。</li>
<li><code>DerivedClass</code>是子类或派生类，它继承了<code>BaseClass</code>的所有公有和受保护的成员（字段、方法、属性等）。</li>
</ul>
<h3 id="2-继承的特点"><a href="#2-继承的特点" class="headerlink" title="2. 继承的特点"></a>2. 继承的特点</h3><ul>
<li><strong>单继承</strong>：C#只支持单继承，一个类只能有一个直接的父类。但是，一个类可以实现多个接口。</li>
<li>传递性：子类可以继承父类的父类</li>
<li><strong>成员访问</strong>：子类可以访问父类的<code>public</code>和<code>protected</code>成员，但不能直接访问父类的<code>private</code>成员。</li>
<li><strong>构造函数的调用</strong>：子类的构造函数会首先调用父类的构造函数，在调用子类得构造函数。可以使用<code>base</code>关键字来指定调用父类的哪个构造函数。</li>
<li>类中会默认提供默认构造函数（无参），如果定义了有参构造函数，那么默认构造函数就不会提供</li>
</ul>
<h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><p>以下是一个简单的继承示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Animal&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal 默认构造函数&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Dog&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is barking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">//Animal 默认构造函数 Dog 默认构造函数</span><br>        dog.Name = <span class="hljs-string">&quot;Buddy&quot;</span>;<br>        dog.Eat(); <span class="hljs-comment">// 调用从父类继承的方法</span><br>        dog.Bark(); <span class="hljs-comment">// 调用子类的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Animal 默认构造函数<br>Dog 默认构造函数<br>Buddy <span class="hljs-keyword">is</span> eating.<br>Buddy <span class="hljs-keyword">is</span> barking.<br></code></pre></td></tr></table></figure>

<h4 id="改变父类的成员的访问修饰符的权限"><a href="#改变父类的成员的访问修饰符的权限" class="headerlink" title="改变父类的成员的访问修饰符的权限"></a>改变父类的成员的访问修饰符的权限</h4><h5 id="1-如何将继承的-public-改为-protected-或者-protected-改为-public"><a href="#1-如何将继承的-public-改为-protected-或者-protected-改为-public" class="headerlink" title="1. 如何将继承的 public 改为 protected 或者 protected 改为 public"></a>1. <strong>如何将继承的 <code>public</code> 改为 <code>protected</code> 或者 <code>protected</code> 改为 <code>public</code></strong></h5><ul>
<li><code>public</code> 成员可以在任何地方访问，包括子类和外部代码。</li>
<li><code>protected</code> 成员只能在当前类和其子类中访问，外部代码无法访问。<br>如果你希望将继承的 <code>public</code> 改为 <code>protected</code>，或者将 <code>protected</code> 改为 <code>public</code>，你可以在子类中通过访问修饰符的修改来实现。比如：</li>
</ul>
<h6 id="将-public-成员改为-protected："><a href="#将-public-成员改为-protected：" class="headerlink" title="将 public 成员改为 protected："></a>将 <code>public</code> 成员改为 <code>protected</code>：</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 修改继承的 Name 属性为 protected</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Dog&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 子类独有的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is barking.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="将-protected-成员改为-public："><a href="#将-protected-成员改为-public：" class="headerlink" title="将 protected 成员改为 public："></a>将 <code>protected</code> 成员改为 <code>public</code>：</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 将 protected 的 Name 改为 public</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Animal&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal 默认构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Dog&quot;</span>; <span class="hljs-comment">// 访问父类的公开 Name 属性</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is barking.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2-父类有-private-成员能继承吗？"><a href="#2-父类有-private-成员能继承吗？" class="headerlink" title="2. 父类有 private 成员能继承吗？"></a>2. <strong>父类有 <code>private</code> 成员能继承吗？</strong></h5><ul>
<li><code>private</code> 成员 <strong>不能</strong> 被子类直接访问或继承。它只能在父类的内部被访问。</li>
<li>但是，子类可以继承父类的 <code>private</code> 成员 <strong>通过公有或保护的访问方法</strong>，例如父类提供公共的 <code>getter</code> 和 <code>setter</code> 方法来访问这些私有成员。</li>
</ul>
<h6 id="示例：父类的-private-成员如何通过-protected-或-public-方法访问"><a href="#示例：父类的-private-成员如何通过-protected-或-public-方法访问" class="headerlink" title="示例：父类的 private 成员如何通过 protected 或 public 方法访问"></a>示例：父类的 <code>private</code> 成员如何通过 <code>protected</code> 或 <code>public</code> 方法访问</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// private 成员</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> privateName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>()</span><br>    &#123;<br>        privateName = <span class="hljs-string">&quot;Animal Private&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal 默认构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 提供公共方法来访问 private 成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetPrivateName</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> privateName;<br>    &#125;<br><br>    <span class="hljs-comment">// 提供公共方法来修改 private 成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetPrivateName</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        privateName = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Eating...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 无法直接访问父类的 private 成员</span><br>        <span class="hljs-comment">// privateName = &quot;Dog&quot;;  // 编译错误：无法访问</span><br>        SetPrivateName(<span class="hljs-string">&quot;Dog&quot;</span>); <span class="hljs-comment">// 使用父类提供的公共方法</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Barking...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">// 无法直接访问 private 成员</span><br>        <span class="hljs-comment">// Console.WriteLine(dog.privateName);  // 编译错误</span><br>        Console.WriteLine(dog.GetPrivateName()); <span class="hljs-comment">// 通过父类的公共方法访问 private 成员</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li><strong><code>public</code> 成员</strong>：可以直接在子类和外部访问。</li>
<li><strong><code>protected</code> 成员</strong>：只能在子类和父类中访问，外部代码无法访问。</li>
<li><strong><code>private</code> 成员</strong>：只能在父类内部访问，不能直接在子类中访问，但可以通过父类提供的公共方法进行访问。</li>
<li><strong>改变访问修饰符</strong>：子类可以通过 <code>new</code> 关键字隐藏父类的成员，或者通过修改继承的成员的访问修饰符来改变访问权限。</li>
</ul>
<h3 id="4-base关键字"><a href="#4-base关键字" class="headerlink" title="4. base关键字"></a>4. <code>base</code>关键字</h3><ul>
<li><code>base</code>关键字用于在子类中访问父类的成员。</li>
<li>它可以用来调用父类的构造函数或方法。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>	<span class="hljs-comment">// 无默认构造函数，如果new Animal()会报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> makes a noise.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 如果父类中没有默认构造函数，使用下面得构造函数会报错</span><br>    <span class="hljs-comment">//public Dog(string name)</span><br>    <span class="hljs-comment">//&#123; &#125;</span><br>    <span class="hljs-comment">// 否则需要显示调用父类得构造函数，因为总是会先调用父类得构造函数，然后调用子类得构造函数，如果子类没有写构造函数，会提供一个子类得默认构造函数，而不是使用父类得默认构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.Speak(); <span class="hljs-comment">// 调用父类的Speak方法</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> barks.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-方法重写（override）"><a href="#5-方法重写（override）" class="headerlink" title="5. 方法重写（override）"></a>5. 方法重写（<code>override</code>）</h3><ul>
<li><p>如果子类需要修改父类的方法行为，可以使用<code>override</code>关键字重写父类的方法。</p>
</li>
<li><p>父类的方法必须使用<code>virtual</code>关键字进行标记。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">//public virtual两种顺序都行</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果不使用virtual关键字</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise=1.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 如果是有意隐藏父类中的相同的方法，需要加new，否则会警告</span><br>    <span class="hljs-comment">// 但是和Cpp不一样，父类中其他同名的还是可以用，重载的都可以用，不会全部隐藏。Cpp里面叫名字遮蔽</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        dog.Speak();<br>        dog.Speak(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-继承的限制"><a href="#6-继承的限制" class="headerlink" title="6. 继承的限制"></a>6. 继承的限制</h3><ul>
<li><strong>不能继承<code>sealed</code>类</strong>：如果一个类被标记为<code>sealed</code>，则不能被继承。</li>
<li><strong><code>static</code>类不能被继承</strong>：静态类不能被继承或实例化。</li>
</ul>
<h3 id="7-里氏替换原则"><a href="#7-里氏替换原则" class="headerlink" title="7. 里氏替换原则"></a>7. 里氏替换原则</h3><p>可以将子类对象赋值给父类引用（基类类型的引用可以指向派生类对象），这样可以利用多态实现灵活的代码设计。<br>继承提供了一种强大的代码复用和扩展功能的方式，在设计类的层次结构时需要合理使用。<br>在C#中，可以将子类对象赋值给父类引用，这种行为称为<strong>多态</strong>。通过这种方式，可以利用父类引用来处理不同子类的对象，从而实现灵活的代码设计。下面是一个简单的示例来展示这一点。</p>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal speaks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类：Dog</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类：Cat</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Cat meows.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 Dog 和 Cat 的实例</span><br>        Animal myDog = <span class="hljs-keyword">new</span> Dog();<br>        Animal myCat = <span class="hljs-keyword">new</span> Cat();<br><br>        <span class="hljs-comment">// 调用 Speak 方法，实际调用的是派生类的方法</span><br>        myDog.Speak(); <span class="hljs-comment">// 输出: Dog barks.</span><br>        myCat.Speak(); <span class="hljs-comment">// 输出: Cat meows.</span><br><br>        <span class="hljs-comment">// 使用多态的集合</span><br>        Animal[] animals = &#123; myDog, myCat &#125;;<br><br>        <span class="hljs-comment">// 遍历集合并调用 Speak 方法</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> animal <span class="hljs-keyword">in</span> animals)<br>        &#123;<br>            animal.Speak();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Dog barks.<br>Cat meows.<br>Dog barks.<br>Cat meows.<br></code></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol>
<li><strong>基类 <code>Animal</code></strong> ：<ul>
<li>定义了一个虚方法 <code>Speak()</code>，这个方法可以在派生类中被重写。</li>
</ul>
</li>
<li><strong>派生类 <code>Dog</code> 和 <code>Cat</code></strong> ：<ul>
<li>分别重写了 <code>Speak()</code> 方法，提供了特定的实现。</li>
<li><code>Dog</code> 类输出 <code>&quot;Dog barks.&quot;</code>，而 <code>Cat</code> 类输出 <code>&quot;Cat meows.&quot;</code></li>
</ul>
</li>
<li><strong>多态</strong> ：<ul>
<li>在 <code>Main</code> 方法中，创建了 <code>Dog</code> 和 <code>Cat</code> 的实例，并将它们赋值给 <code>Animal</code> 类型的引用 <code>myDog</code> 和 <code>myCat</code>。</li>
<li>通过调用 <code>Speak()</code> 方法，尽管引用类型是 <code>Animal</code>，实际调用的是子类 <code>Dog</code> 和 <code>Cat</code> 的实现。</li>
</ul>
</li>
<li><strong>集合与多态</strong> ：<ul>
<li>使用 <code>Animal</code> 数组存储不同类型的动物，通过遍历数组调用 <code>Speak()</code> 方法，展现了多态的灵活性和可扩展性。</li>
</ul>
</li>
</ol>
<h3 id="子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数"><a href="#子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数" class="headerlink" title="子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数"></a>子类的构造函数会首先调用父类的构造函数。可以使用<code>base</code>关键字来指定调用父类的哪个构造函数</h3><p>在C#中，子类的构造函数在创建对象时会首先调用父类的构造函数。这可以确保父类的初始化逻辑在子类的初始化之前执行。使用<code>base</code>关键字可以指定调用父类的特定构造函数。</p>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个简单的示例，展示了如何在子类构造函数中调用父类构造函数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 父类的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> has been created.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Breed &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 子类的构造函数，调用父类的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> breed</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>    &#123;<br>        Breed = breed;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is a <span class="hljs-subst">&#123;Breed&#125;</span>.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog myDog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-string">&quot;Golden Retriever&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Buddy has been created.<br>Buddy <span class="hljs-keyword">is</span> a Golden Retriever.<br></code></pre></td></tr></table></figure>
<h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><ol>
<li><strong>父类构造函数</strong>：<code>Animal</code>类有一个构造函数，接收一个参数<code>name</code>，用于初始化<code>Name</code>属性，并打印消息。</li>
<li><strong>子类构造函数</strong>：<code>Dog</code>类的构造函数接收两个参数：<code>name</code>和<code>breed</code>。在构造函数的参数列表中，使用<code>base(name)</code>调用父类<code>Animal</code>的构造函数，将<code>name</code>传递给它。</li>
<li><strong>实例化对象</strong>：在<code>Main</code>方法中，创建了一个<code>Dog</code>类的实例<code>myDog</code>，传递了<code>&quot;Buddy&quot;</code>和<code>&quot;Golden Retriever&quot;</code>。创建对象时，首先调用<code>Animal</code>类的构造函数，然后再执行<code>Dog</code>类的构造函数。<br>这个例子展示了如何在子类中通过<code>base</code>关键字调用父类构造函数，确保父类的初始化逻辑被正确执行。</li>
</ol>
<h1 id="28-is和as"><a href="#28-is和as" class="headerlink" title="28. is和as"></a>28. is和as</h1><blockquote>
<p>在C#中，<code>is</code> 和 <code>as</code> 是两个用于类型检查和类型转换的关键字</p>
</blockquote>
<h3 id="is-关键字"><a href="#is-关键字" class="headerlink" title="is 关键字"></a><code>is</code> 关键字</h3><p><code>is</code> 用于检查一个对象是否是某个特定类型或是否实现了某个接口。它返回一个布尔值，指示对象是否可以安全地转换为指定的类型。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-comment">// 使用 is 检查 obj 是否是字符串类型</span><br>        <span class="hljs-comment">// “模式匹配”（Pattern Matching）</span><br>        <span class="hljs-comment">// obj is string str 的意思是：</span><br>        <span class="hljs-comment">// 检查 obj 是否是 string 类型。</span><br>        <span class="hljs-comment">// 如果 obj 是 string 类型，则将 obj 转换为 string 类型，并赋值给新的局部变量 str。</span><br>        <span class="hljs-comment">// 这个str只能在if的作用域内使用，只是一个局部变量</span><br>        <span class="hljs-comment">// 如果类型检查成功（即 obj 是 string 类型），表达式的值为 true，并且可以在之后的代码中使用 str 变量。</span><br>        <span class="hljs-comment">// 否则表达式的值为false，那么 str 不会被定义，也无法在 if 语句块外使用 str。</span><br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> str)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;The object is a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The object is not a string.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">The <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> a <span class="hljs-built_in">string</span>: Hello, World!<br></code></pre></td></tr></table></figure>

<h3 id="as-关键字"><a href="#as-关键字" class="headerlink" title="as 关键字"></a><code>as</code> 关键字</h3><p><code>as</code> 用于尝试将一个<code>对象</code>转换为指定的类型，值类型不可以。如果转换成功，它会返回转换后的对象；如果失败，它会返回 <code>null</code>，而不会抛出异常。这在需要进行类型转换时非常有用，可以避免潜在的运行时错误。</p>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-comment">// 使用 as 尝试将 obj 转换为字符串类型</span><br>        <span class="hljs-built_in">string</span> str = obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br><br>        <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;The object was successfully converted to a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The object could not be converted to a string.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">The <span class="hljs-selector-tag">object</span> was successfully converted <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">a</span> string: Hello, World!<br></code></pre></td></tr></table></figure>
<h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol>
<li><strong>用途</strong>：<ul>
<li><code>is</code>：用于检查对象的类型，返回一个布尔值。</li>
<li><code>as</code>：用于进行安全的类型转换，返回转换后的对象或 <code>null</code>。</li>
</ul>
</li>
<li><strong>返回值</strong>：<ul>
<li><code>is</code> 返回 <code>true</code> 或 <code>false</code>。</li>
<li><code>as</code> 返回转换后的对象或 <code>null</code>。</li>
</ul>
</li>
<li><strong>异常处理</strong>：<ul>
<li>使用 <code>is</code> 进行类型检查时，不会抛出异常。</li>
<li>使用 <code>as</code> 进行类型转换时，如果转换失败，不会抛出异常，而是返回 <code>null</code>。</li>
</ul>
</li>
</ol>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>使用 <code>is</code> 当你只需要知道一个对象的类型时。</li>
<li>使用 <code>as</code> 当你希望将一个对象转换为特定类型，并且希望在失败时得到 <code>null</code> 而不是异常时。</li>
</ul>
<h1 id="29-模式匹配（Pattern-Matching）"><a href="#29-模式匹配（Pattern-Matching）" class="headerlink" title="29. 模式匹配（Pattern Matching）"></a>29. 模式匹配（Pattern Matching）</h1><p><strong>模式匹配</strong>（Pattern Matching）是C#中的一种特性，用于检查某个对象是否符合指定的类型或条件，并在匹配成功时将其转换为相应类型或结构。这种特性可以简化类型检查和转换的代码，使代码更加简洁和可读。</p>
<h3 id="模式匹配的常见用法"><a href="#模式匹配的常见用法" class="headerlink" title="模式匹配的常见用法"></a>模式匹配的常见用法</h3><h4 id="1-类型模式匹配（Type-Pattern-Matching）"><a href="#1-类型模式匹配（Type-Pattern-Matching）" class="headerlink" title="1. 类型模式匹配（Type Pattern Matching）"></a>1. <strong>类型模式匹配（Type Pattern Matching）</strong></h4><ul>
<li>用于检查一个对象是否属于某种类型，并在成功时将其转换为该类型。这种模式在<code>is</code>关键字后面使用。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> str)<br>&#123;<br>    <span class="hljs-comment">// str 现在是一个 string 类型</span><br>    Console.WriteLine(<span class="hljs-string">$&quot;The object is a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is not a string.&quot;</span>);<br><br></code></pre></td></tr></table></figure>
在这个示例中，如果<code>obj</code>是<code>string</code>类型，则将其转换为<code>str</code>，并可以在<code>if</code>语句块中使用。</li>
</ul>
<h4 id="2-常量模式匹配（Constant-Pattern-Matching）"><a href="#2-常量模式匹配（Constant-Pattern-Matching）" class="headerlink" title="2. 常量模式匹配（Constant Pattern Matching）"></a>2. <strong>常量模式匹配（Constant Pattern Matching）</strong></h4><ul>
<li>可以用于比较对象是否与某个常量相等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (number <span class="hljs-keyword">is</span> <span class="hljs-number">10</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The number is 10.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The number is not 10.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
这里通过<code>is</code>来检查<code>number</code>是否等于常量10。</li>
<li>上面的例子太简单，看这个<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// 使用常量模式匹配</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-number">42</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is 42&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用==操作符</span><br><span class="hljs-keyword">if</span> (obj.Equals(<span class="hljs-number">42</span>))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is also 42&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-表达式模式匹配（Expression-Pattern-Matching）"><a href="#3-表达式模式匹配（Expression-Pattern-Matching）" class="headerlink" title="3. 表达式模式匹配（Expression Pattern Matching）"></a>3. <strong>表达式模式匹配（Expression Pattern Matching）</strong></h4><ul>
<li>允许在<code>switch</code>表达式中使用模式匹配。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">42</span>;<br><br><span class="hljs-keyword">switch</span> (obj)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &gt; <span class="hljs-number">0</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Positive integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &lt; <span class="hljs-number">0</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Negative integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">string</span> s:<br>        Console.WriteLine(<span class="hljs-string">$&quot;String: <span class="hljs-subst">&#123;s&#125;</span>&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Unknown type or condition.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
在这里，<code>switch</code>表达式结合<code>when</code>条件可以对对象的不同模式进行匹配并处理。</li>
</ul>
<h5 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h5><p>这个<code>switch</code>语句使用了模式匹配的功能来处理不同类型和条件的<code>obj</code>值，<code>when</code>关键字用于指定额外的条件约束。具体解释如下：</p>
<ol>
<li><code>case int i when i &gt; 0</code>：<ul>
<li>这里的<code>case</code>语句匹配<code>obj</code>的类型，如果<code>obj</code>是一个整数（<code>int</code>），定义一个局部变量<code>i</code>，<code>i</code>就是<code>obj</code>转换为<code>int</code>的变量，进行下一步判断。</li>
<li><code>when i &gt; 0</code> 表示只有当<code>i</code>大于0时，这个<code>case</code>才会匹配，输出“Positive integer.”。</li>
</ul>
</li>
<li><code>case int i when i &lt; 0</code>：<ul>
<li>同样，这个分支首先检查<code>obj</code>的类型是否为整数（<code>int</code>），然后判断这个整数是否小于0。</li>
<li>当<code>i &lt; 0</code>时，匹配成功，输出“Negative integer.”。</li>
</ul>
</li>
<li><code>case string s</code>：<ul>
<li>如果前面的条件都不满足，则检查<code>obj</code>是否为字符串（<code>string</code>）类型。</li>
<li>如果是，则匹配成功，并输出字符串内容，例如“String: …”。</li>
</ul>
</li>
<li><code>default</code>：<ul>
<li>如果<code>obj</code>的类型不匹配前面的任何一个<code>case</code>，则执行<code>default</code>分支，输出“Unknown type or condition.”。</li>
</ul>
</li>
</ol>
<h5 id="when关键字的作用"><a href="#when关键字的作用" class="headerlink" title="when关键字的作用"></a><code>when</code>关键字的作用</h5><p><code>when</code>用于在匹配类型的基础上添加条件约束。即使类型匹配成功，也要满足<code>when</code>后面的条件，才能执行该分支。它可以用于进一步筛选具体的情况，使模式匹配更灵活和精确。</p>
<h4 id="4-位置模式匹配（Positional-Pattern-Matching）"><a href="#4-位置模式匹配（Positional-Pattern-Matching）" class="headerlink" title="4. 位置模式匹配（Positional Pattern Matching）"></a>4. <strong>位置模式匹配（Positional Pattern Matching）</strong></h4><ul>
<li>用于解构对象，匹配对象的属性或字段。这在C# 8.0及更高版本中得到支持。</li>
<li>位置模式匹配用于检查元组或某些类型的值是否与指定的模式匹配。这里的<code>(3, 4)</code>是一个位置模式，它表示检查元组中的每个元素是否与指定的值匹配。</li>
<li>例如，<code>point is (3, 4)</code>意味着检查<code>point</code>是否是一个有两个元素的元组，并且第一个元素的值为<code>3</code>，第二个元素的值为<code>4</code>。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-function">point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>))</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The point is (3, 4).&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
这个例子检查一个元组是否具有指定的值。</li>
</ul>
<h4 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h4><ol>
<li><strong>元组的定义</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>
这里定义了一个元组<code>point</code>，它有两个元素<code>X</code>和<code>Y</code>，分别赋值为<code>3</code>和<code>4</code>。这个元组的类型是<code>(int X, int Y)</code>，表示一个包含两个整型值的元组。</li>
<li><strong>模式匹配检查</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (<span class="hljs-function">point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>))</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The point is (3, 4).&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
这段代码中的<code>point is (3, 4)</code>使用了<strong>位置模式匹配（Positional Pattern Matching）</strong> 来检查<code>point</code>的值是否为<code>(3, 4)</code>。</li>
</ol>
<ul>
<li><code>point is (3, 4)</code>表示检查<code>point</code>是否是一个元组，并且其第一个元素的值为<code>3</code>，第二个元素的值为<code>4</code>。</li>
<li>如果<code>point</code>的值确实为<code>(3, 4)</code>，则条件成立，执行<code>Console.WriteLine(&quot;The point is (3, 4).&quot;);</code>。</li>
</ul>
<h4 id="元组和模式匹配"><a href="#元组和模式匹配" class="headerlink" title="元组和模式匹配"></a>元组和模式匹配</h4><ul>
<li>C#中的元组可以用来存储一组相关的数据，并且可以通过模式匹配来对元组的值进行检查。</li>
<li>在<code>if</code>语句中使用<code>is</code>关键字进行模式匹配时，会将元组的值与指定的常量进行比较。</li>
<li>这种方法可以用于简洁地检查多个值是否匹配特定的组合。</li>
</ul>
<h4 id="代码运行结果"><a href="#代码运行结果" class="headerlink" title="代码运行结果"></a>代码运行结果</h4><p>如果<code>point</code>的值为<code>(3, 4)</code>，那么程序会输出：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">The point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>).</span><br></code></pre></td></tr></table></figure>
<p>如果<code>point</code>的值不同，比如<code>(5, 6)</code>，则不会输出任何内容。</p>
<h3 id="模式匹配的优势"><a href="#模式匹配的优势" class="headerlink" title="模式匹配的优势"></a>模式匹配的优势</h3><ul>
<li><strong>简洁性</strong>：无需额外的类型转换代码。</li>
<li><strong>安全性</strong>：通过类型检查和转换结合，减少显式类型转换带来的潜在错误。</li>
<li><strong>灵活性</strong>：可以根据不同的条件和类型编写简洁的控制流。<br>模式匹配在C# 7.0及更高版本中引入，并在后续版本中不断扩展，使得类型检查、条件分支处理更加直观。</li>
</ul>
<h1 id="30-when的使用场景"><a href="#30-when的使用场景" class="headerlink" title="30. when的使用场景"></a>30. when的使用场景</h1><p><code>when</code>关键字主要用于<code>switch</code>表达式和<code>case</code>语句中，提供对模式匹配的额外条件约束。常见的使用场景包括：</p>
<h3 id="1-精确控制匹配条件"><a href="#1-精确控制匹配条件" class="headerlink" title="1. 精确控制匹配条件"></a>1. <strong>精确控制匹配条件</strong></h3><ul>
<li>当对类型匹配不够时，<code>when</code>可以进一步限定匹配的条件。例如，在类型匹配的基础上，还可以检查数值范围、字符串内容等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">switch</span> (obj)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &gt; <span class="hljs-number">100</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Large number.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &lt;= <span class="hljs-number">100</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Small number.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Not an integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-处理多个条件的组合"><a href="#2-处理多个条件的组合" class="headerlink" title="2. 处理多个条件的组合"></a>2. <strong>处理多个条件的组合</strong></h3><ul>
<li>适用于多个条件的组合场景。比如同时对类型和某些属性进行匹配时，可以用<code>when</code>来增加逻辑判断。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">switch</span> (person)<br>&#123;<br>    <span class="hljs-keyword">case</span> Employee e <span class="hljs-keyword">when</span> e.YearsOfService &gt; <span class="hljs-number">10</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Senior Employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Employee e <span class="hljs-keyword">when</span> e.YearsOfService &lt;= <span class="hljs-number">10</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Junior Employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Not an employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-在异常处理中的使用"><a href="#3-在异常处理中的使用" class="headerlink" title="3. 在异常处理中的使用"></a>3. <strong>在异常处理中的使用</strong></h3><ul>
<li>可以在<code>catch</code>语句中结合<code>when</code>条件处理特定的异常情况。例如，在捕获异常时，根据异常的某个属性来判断是否执行该捕获块。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">// Some code that might throw exceptions</span><br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) <span class="hljs-keyword">when</span> (ex.Message.Contains(<span class="hljs-string">&quot;disk&quot;</span>))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Disk-related error.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;General I/O error.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-筛选集合中的元素"><a href="#4-筛选集合中的元素" class="headerlink" title="4. 筛选集合中的元素"></a>4. <strong>筛选集合中的元素</strong></h3><ul>
<li>在处理集合数据时，使用<code>when</code>可以根据元素的条件筛选匹配的元素。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>&#123;<br>    <span class="hljs-keyword">switch</span> (number)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> n <span class="hljs-keyword">when</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;n&#125;</span> is even.&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> n:<br>            Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;n&#125;</span> is odd.&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h1 id="31-var"><a href="#31-var" class="headerlink" title="31. var"></a>31. var</h1><p><code>var</code> 是 C# 中的一种隐式类型声明方式，用于让编译器自动推断变量的类型。在使用 <code>var</code> 时，编译器会根据赋值的表达式确定变量的具体类型。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>var</code> 可以在以下情况下使用：</p>
<ol>
<li><strong>局部变量的类型推断</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> number = <span class="hljs-number">10</span>; <span class="hljs-comment">// 编译器推断为 int 类型</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 编译器推断为 string 类型</span><br><span class="hljs-keyword">var</span> isCompleted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 编译器推断为 bool 类型</span><br></code></pre></td></tr></table></figure></li>
<li><strong>集合或复杂对象</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">// 编译器推断为 List&lt;int&gt; 类型</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span>, Age = <span class="hljs-number">30</span> &#125;; <span class="hljs-comment">// 匿名类型</span><br></code></pre></td></tr></table></figure></li>
<li><strong>LINQ 查询结果</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> numbers<br>             <span class="hljs-keyword">where</span> n &gt; <span class="hljs-number">5</span><br>             <span class="hljs-keyword">select</span> n;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>var</code> 时，必须立即对变量进行初始化，因为编译器需要根据赋值来推断类型。</li>
<li>一旦类型推断完成，变量的类型在编译时就已经确定，不能改变。</li>
</ul>
<h3 id="var-的优缺点"><a href="#var-的优缺点" class="headerlink" title="var 的优缺点"></a><code>var</code> 的优缺点</h3><p><strong>优点</strong>：</p>
<ul>
<li>代码更简洁，避免重复声明类型。</li>
<li>适合处理匿名类型和复杂类型。<br><strong>缺点</strong>：</li>
<li>可能会降低代码的可读性，尤其是在类型不明显时。</li>
</ul>
<h3 id="C-的var和C-的auto"><a href="#C-的var和C-的auto" class="headerlink" title="C#的var和C++的auto"></a>C#的var和C++的auto</h3><h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><ol>
<li><strong>类型自动推断</strong>：在两者中，编译器根据右侧的表达式来推断变量的类型。例如：<ul>
<li><strong>C#</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 编译器推断为 int</span><br></code></pre></td></tr></table></figure></li>
<li><strong>C++</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 编译器推断为 int</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>简化代码</strong>：使用 <code>var</code> 或 <code>auto</code> 可以减少重复的类型声明，使代码更简洁。</li>
<li><strong>必须初始化</strong>：两者在声明时都必须立即进行初始化，因为编译器需要根据赋值来确定类型。</li>
</ol>
<h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><ol>
<li><strong>使用场景</strong>：<ul>
<li>在 C# 中，<code>var</code> 只能用于局部变量的类型推断，而不能用于方法参数、返回类型或字段。</li>
<li>在 C++ 中，<code>auto</code> 可以用于函数的返回类型推断（C++14 起支持），也可以在循环中使用 <code>auto</code> 来自动推断迭代器的类型。</li>
</ul>
</li>
<li><strong>类型推断的时间点</strong>：<ul>
<li>C# 的类型推断是在编译时进行的，变量的类型一旦确定，就无法更改。</li>
<li>C++ 中的 <code>auto</code> 也是在编译时进行类型推断，但由于 C++ 支持模板和类型推断的多样性，<code>auto</code> 可以用于更复杂的场景，如模板编程。</li>
</ul>
</li>
<li><strong>类型推断的灵活性</strong>：<ul>
<li>C++ 中的 <code>auto</code> 还可以和 <code>const</code>、<code>&amp;</code>（引用）等结合使用，来推断更复杂的类型，如常量引用。</li>
<li>C# 中的 <code>var</code> 不支持这样的组合用法。</li>
</ul>
</li>
</ol>
<h1 id="32-元组"><a href="#32-元组" class="headerlink" title="32. 元组"></a>32. 元组</h1><p>在 C# 中，元组（Tuple）是一种数据结构，可以存储多个不同类型的值。元组的主要特点是简单、轻量，可以快速创建和传递多个相关的数据。以下是对 C# 中元组的详细介绍：</p>
<h3 id="1-定义和创建元组"><a href="#1-定义和创建元组" class="headerlink" title="1. 定义和创建元组"></a>1. <strong>定义和创建元组</strong></h3><p>在 C# 中，你可以使用 <code>Tuple</code> 类或更简洁的语法来创建元组。C# 7.0 引入了更简化的元组语法，使用小括号和命名元素。</p>
<h4 id="使用-Tuple-类"><a href="#使用-Tuple-类" class="headerlink" title="使用 Tuple 类"></a><strong>使用 <code>Tuple</code> 类</strong></h4><p><code>Tuple</code> 类可以包含最多 <strong>8</strong> 个元素。如果需要更多的元素，可以嵌套使用元组。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = <span class="hljs-keyword">new</span> Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">double</span>, <span class="hljs-built_in">char</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>Console.WriteLine(tuple.Item1); <span class="hljs-comment">// 输出: 1</span><br>Console.WriteLine(tuple.Item2); <span class="hljs-comment">// 输出: Hello</span><br>Console.WriteLine(tuple.Item3); <span class="hljs-comment">// 输出: 3.14</span><br>Console.WriteLine(tuple.Item4); <span class="hljs-comment">// 输出: A</span><br></code></pre></td></tr></table></figure>
<h4 id="使用-C-7-0-及以上的元组简化语法"><a href="#使用-C-7-0-及以上的元组简化语法" class="headerlink" title="使用 C# 7.0 及以上的元组简化语法"></a><strong>使用 C# 7.0 及以上的元组简化语法</strong></h4><p>C# 7.0 引入了更简洁的元组语法，可以轻松创建和使用多个元素的元组：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = (Id: <span class="hljs-number">1</span>, Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>, Height: <span class="hljs-number">1.75</span>, IsStudent: <span class="hljs-literal">false</span>);<br>Console.WriteLine(tuple.Id);      <span class="hljs-comment">// 输出: 1</span><br>Console.WriteLine(tuple.Name);     <span class="hljs-comment">// 输出: Alice</span><br>Console.WriteLine(tuple.Age);      <span class="hljs-comment">// 输出: 30</span><br>Console.WriteLine(tuple.Height);   <span class="hljs-comment">// 输出: 1.75</span><br>Console.WriteLine(tuple.IsStudent); <span class="hljs-comment">// 输出: False</span><br></code></pre></td></tr></table></figure>
<h4 id="嵌套元组"><a href="#嵌套元组" class="headerlink" title="嵌套元组"></a><strong>嵌套元组</strong></h4><p>如果需要更多的元素，可以通过嵌套元组的方式来实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> tuple = (Person: (Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>), Coordinates: (X: <span class="hljs-number">10</span>, Y: <span class="hljs-number">20</span>));<br>        Console.WriteLine(tuple.Person); <span class="hljs-comment">// 输出: (Alice, 30)</span><br>        Console.WriteLine(tuple.Coordinates.X); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-访问元组元素"><a href="#2-访问元组元素" class="headerlink" title="2. 访问元组元素"></a>2. <strong>访问元组元素</strong></h3><p>可以通过属性（对于 <code>Tuple</code> 类）或直接使用字段（对于简化语法）来访问元组的元素。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = (X: <span class="hljs-number">10</span>, Y: <span class="hljs-number">20</span>);<br>Console.WriteLine(tuple.X); <span class="hljs-comment">// 输出: 10</span><br>Console.WriteLine(tuple.Y); <span class="hljs-comment">// 输出: 20</span><br></code></pre></td></tr></table></figure>
<h3 id="3-元组的解构"><a href="#3-元组的解构" class="headerlink" title="3. 元组的解构"></a>3. <strong>元组的解构</strong></h3><p>C# 支持元组解构，可以将元组的元素赋值给多个变量。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br><span class="hljs-keyword">var</span> (x, y) = point;<br>Console.WriteLine(x); <span class="hljs-comment">// 输出: 3</span><br>Console.WriteLine(y); <span class="hljs-comment">// 输出: 4</span><br></code></pre></td></tr></table></figure>
<h3 id="4-元组的用途"><a href="#4-元组的用途" class="headerlink" title="4. 元组的用途"></a>4. <strong>元组的用途</strong></h3><p>元组通常用于以下场景：</p>
<ul>
<li>返回多个值：可以用元组来返回多个相关的值，而不需要创建一个新的类或结构体。</li>
<li>临时数据存储：在不需要定义一个完整的类的情况下，快速存储和处理小规模的数据。</li>
</ul>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h3><ul>
<li>元组的元素类型可以不同，但元组本身是不可变的，这意味着一旦创建，元组的元素值不能被改变。</li>
<li>对于需要更多功能和可读性的场景，建议使用自定义类或结构体。</li>
</ul>
<h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><p>下面是一个完整的示例，演示了如何使用元组：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> person = (Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;person.Name&#125;</span>, Age: <span class="hljs-subst">&#123;person.Age&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 解构元组</span><br>        <span class="hljs-keyword">var</span> (name, age) = person;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;name&#125;</span>, Age: <span class="hljs-subst">&#123;age&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="33-LINQ"><a href="#33-LINQ" class="headerlink" title="33. LINQ"></a>33. LINQ</h1><p>LINQ（Language Integrated Query）是 C# 中的一种用于处理数据的查询语言。它使开发人员能够使用类似于 SQL 的语法来查询和操作数据，而不需要具体了解数据的存储方式。LINQ 可以用于多种数据源，包括数组、集合、XML、数据库等。</p>
<ul>
<li>只是简单记录，以后用到再说</li>
</ul>
<h3 id="LINQ-的主要特点"><a href="#LINQ-的主要特点" class="headerlink" title="LINQ 的主要特点"></a>LINQ 的主要特点</h3><ol>
<li><strong>集成查询</strong>：LINQ 提供了一种将查询逻辑直接嵌入 C# 代码中的方式。</li>
<li><strong>强类型</strong>：LINQ 查询是强类型的，编译时会检查类型安全。</li>
<li><strong>可读性</strong>：LINQ 语法简洁易读，类似于 SQL，使得代码更容易理解。</li>
<li><strong>延迟执行</strong>：LINQ 查询支持延迟执行，即查询直到实际需要结果时才会执行。</li>
</ol>
<h3 id="LINQ-的基本用法"><a href="#LINQ-的基本用法" class="headerlink" title="LINQ 的基本用法"></a>LINQ 的基本用法</h3><p>以下是 LINQ 的一些常见用法示例：</p>
<h4 id="1-LINQ-to-Objects"><a href="#1-LINQ-to-Objects" class="headerlink" title="1. LINQ to Objects"></a>1. <strong>LINQ to Objects</strong></h4><p>查询集合中的数据。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br><br>        <span class="hljs-comment">// 查询所有大于 3 的数字</span><br>        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> numbers<br>                     <span class="hljs-keyword">where</span> n &gt; <span class="hljs-number">3</span><br>                     <span class="hljs-keyword">select</span> n;<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>        &#123;<br>            Console.WriteLine(number); <span class="hljs-comment">// 输出: 4, 5, 6</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-LINQ-to-SQL"><a href="#2-LINQ-to-SQL" class="headerlink" title="2. LINQ to SQL"></a>2. <strong>LINQ to SQL</strong></h4><p>查询数据库中的数据。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> YourDataContext())<br>&#123;<br>    <span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> c <span class="hljs-keyword">in</span> context.Customers<br>                <span class="hljs-keyword">where</span> c.City == <span class="hljs-string">&quot;London&quot;</span><br>                <span class="hljs-keyword">select</span> c;<br><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> customer <span class="hljs-keyword">in</span> query)<br>    &#123;<br>        Console.WriteLine(customer.Name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-方法语法"><a href="#3-方法语法" class="headerlink" title="3. 方法语法"></a>3. <strong>方法语法</strong></h4><p>LINQ 支持两种语法：查询语法和方法语法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = numbers.Where(n =&gt; n &gt; <span class="hljs-number">3</span>); <span class="hljs-comment">// 方法语法</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出: 4, 5, 6</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-组合查询"><a href="#4-组合查询" class="headerlink" title="4. 组合查询"></a>4. <strong>组合查询</strong></h4><p>你可以将多个 LINQ 查询组合在一起。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = numbers<br>    .Where(n =&gt; n &gt; <span class="hljs-number">2</span>)<br>    .Select(n =&gt; n * <span class="hljs-number">2</span>); <span class="hljs-comment">// 先过滤，然后乘以 2</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出: 6, 8, 10, 12</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="5-进一步处理，不仅仅是LINQ可以用"><a href="#5-进一步处理，不仅仅是LINQ可以用" class="headerlink" title="5. 进一步处理，不仅仅是LINQ可以用"></a>5. 进一步处理，不仅仅是LINQ可以用</h4><p>除了 <code>ToList()</code>，LINQ 查询结果还可以通过其他方法进行转换或进一步处理。常用的 LINQ 转换方法包括：</p>
<ol>
<li><strong><code>ToArray()</code></strong><br> 将查询结果转换为数组。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersArray = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToArray();<br></code></pre></td></tr></table></figure></li>
<li><strong><code>ToDictionary()</code></strong><br> 将查询结果转换为字典，需要指定键和值的选择器。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersDictionary = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                                   .ToDictionary(n =&gt; n, n =&gt; n.ToString());<br><span class="hljs-comment">// 这里键是数字本身，值是对应的字符串表示</span><br></code></pre></td></tr></table></figure></li>
<li><strong><code>ToHashSet()</code></strong><br> 将查询结果转换为 <code>HashSet</code>，去除重复项。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersSet = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToHashSet();<br></code></pre></td></tr></table></figure></li>
<li><strong><code>First()</code> &#x2F; <code>FirstOrDefault()</code></strong><br> 返回第一个符合条件的元素，<code>FirstOrDefault()</code> 如果没有找到元素会返回类型的默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> firstEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).First();<br><span class="hljs-keyword">var</span> firstEvenOrDefault = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).FirstOrDefault();<br></code></pre></td></tr></table></figure></li>
<li><strong><code>Last()</code> &#x2F; <code>LastOrDefault()</code></strong><br> 返回最后一个符合条件的元素，<code>LastOrDefault()</code> 如果没有找到元素会返回类型的默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> lastEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Last();<br><span class="hljs-keyword">var</span> lastEvenOrDefault = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).LastOrDefault();<br></code></pre></td></tr></table></figure></li>
<li><strong><code>Single()</code> &#x2F; <code>SingleOrDefault()</code></strong><br> 返回唯一一个符合条件的元素，如果有多个或没有找到则抛出异常，<code>SingleOrDefault()</code> 在没有找到时返回默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> singleEven = numbers.Where(n =&gt; n == <span class="hljs-number">2</span>).Single();<br><span class="hljs-keyword">var</span> singleEvenOrDefault = numbers.Where(n =&gt; n == <span class="hljs-number">2</span>).SingleOrDefault();<br></code></pre></td></tr></table></figure></li>
<li><strong><code>Count()</code></strong><br> 计算符合条件的元素个数。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> evenCount = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Count();<br></code></pre></td></tr></table></figure></li>
<li><strong><code>Any()</code></strong><br> 判断是否有任何元素符合条件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> hasEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Any();<br></code></pre></td></tr></table></figure></li>
<li><strong><code>All()</code></strong><br> 判断是否所有元素都符合条件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> allEven = numbers.All(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li>
<li><strong><code>Max()</code> &#x2F; <code>Min()</code></strong><br>查找最大或最小值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> maxEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Max();<br><span class="hljs-built_in">int</span> minEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Min();<br></code></pre></td></tr></table></figure></li>
<li><strong><code>Sum()</code> &#x2F; <code>Average()</code></strong><br>计算总和或平均值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> sumEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Sum();<br><span class="hljs-built_in">double</span> avgEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Average();<br><br></code></pre></td></tr></table></figure></li>
<li><strong><code>ToList()</code></strong><br>将查询结果转换为List。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 示例列表</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> &#125;;<br><br>        <span class="hljs-comment">// 使用 LINQ 查询筛选出所有偶数，并转换为 List&lt;int&gt;</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; evenNumbers = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToList();<br><br>        <span class="hljs-comment">// 输出结果</span><br>        Console.WriteLine(<span class="hljs-string">&quot;偶数列表:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> evenNumbers)<br>        &#123;<br>            Console.WriteLine(num);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="LINQ-的常用操作"><a href="#LINQ-的常用操作" class="headerlink" title="LINQ 的常用操作"></a>LINQ 的常用操作</h3><ul>
<li><strong>Where</strong>：过滤数据。</li>
<li><strong>Select</strong>：投影数据。</li>
<li><strong>OrderBy</strong> 和 <strong>OrderByDescending</strong>：排序。</li>
<li><strong>GroupBy</strong>：分组。</li>
<li><strong>Join</strong>：连接多个数据源。</li>
<li><strong>Count</strong>、<strong>Sum</strong>、<strong>Average</strong>、<strong>Max</strong>、<strong>Min</strong>：聚合操作。</li>
</ul>
<h1 id="34-C-中的Object，装箱和拆箱"><a href="#34-C-中的Object，装箱和拆箱" class="headerlink" title="34. C#中的Object，装箱和拆箱"></a>34. C#中的Object，装箱和拆箱</h1><p>在C#中，<strong>装箱</strong>（Boxing）和<strong>拆箱</strong>（Unboxing）是指值类型和引用类型之间的转换过程。理解这两个概念有助于掌握C#中的内存管理和类型转换。</p>
<h3 id="装箱（Boxing）"><a href="#装箱（Boxing）" class="headerlink" title="装箱（Boxing）"></a>装箱（Boxing）</h3><p>装箱是将一个值类型转换为对象类型（引用类型）的过程。此过程会在堆上分配内存，并将值类型的值复制到该内存位置。<br><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 值类型</span><br><span class="hljs-built_in">object</span> boxedNumber = number; <span class="hljs-comment">// 装箱</span><br></code></pre></td></tr></table></figure>
<p>在上述示例中，<code>number</code> 是一个值类型的 <code>int</code>，当我们将它赋值给 <code>object</code> 类型的 <code>boxedNumber</code> 时，发生了装箱。<code>number</code> 的值被复制到堆上一个新的对象中。</p>
<h3 id="拆箱（Unboxing）"><a href="#拆箱（Unboxing）" class="headerlink" title="拆箱（Unboxing）"></a>拆箱（Unboxing）</h3><p>拆箱是将一个已装箱的对象转换回值类型的过程。此过程会将对象的值复制回值类型变量。<br><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> boxedNumber = <span class="hljs-number">42</span>; <span class="hljs-comment">// 装箱</span><br><span class="hljs-built_in">int</span> unboxedNumber = (<span class="hljs-built_in">int</span>)boxedNumber; <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure>
<p>在上述示例中，<code>boxedNumber</code> 是一个对象，它包含了一个整型值。通过将其强制转换为 <code>int</code>，我们执行了拆箱操作。</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><strong>性能开销</strong>：装箱和拆箱会导致额外的性能开销，因为它们涉及内存分配和数据复制。因此，尽量避免频繁的装箱和拆箱。<br>装箱和拆箱会导致性能开销的原因主要在于它们涉及<strong>内存分配</strong>和<strong>数据复制</strong>。具体来说：</li>
</ol>
<ul>
<li>装箱的性能开销<br>  装箱是将一个<strong>值类型</strong>转换为<strong>引用类型</strong>（对象）的过程。这个过程涉及以下几个步骤：<ul>
<li><strong>在堆上分配内存</strong>：装箱时，值类型的值需要被封装到一个对象中，而这个对象是在堆上分配的。堆上的内存分配比栈上的内存分配要慢，因为它涉及到更多的管理工作（如内存分配、垃圾回收等）。</li>
<li><strong>复制数据</strong>：在装箱的过程中，需要将值类型的数据复制到堆上分配的对象中。这意味着需要额外的内存操作。</li>
</ul>
</li>
<li>拆箱的性能开销<br>  拆箱是将一个已装箱的对象转换回值类型的过程。拆箱操作也会带来一定的开销，原因如下：<ul>
<li><strong>类型检查</strong>：拆箱时，C#运行时会进行类型检查，以确保对象的类型与要转换的值类型匹配。如果类型不匹配，会引发 <code>InvalidCastException</code> 异常。这种类型检查会有一定的性能开销。</li>
<li><strong>数据复制</strong>：拆箱时，需要将对象中的数据复制回值类型变量。这也意味着会有额外的内存操作。</li>
</ul>
</li>
<li>垃圾回收的影响<ul>
<li>由于装箱会在堆上创建新的对象，这些对象可能在将来需要被垃圾回收。当堆上分配了大量装箱产生的对象时，会增加垃圾回收的频率和负担，从而进一步影响性能。</li>
</ul>
</li>
<li>为什么栈上的分配更快？<ul>
<li>栈上的内存分配只需调整栈指针即可，非常高效。而堆上的内存分配涉及复杂的内存管理，例如查找适合的内存块、记录内存使用状态、处理垃圾回收等，因此要慢得多。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>类型安全</strong>：拆箱时，如果对象不包含相应的值类型，程序将抛出 <code>InvalidCastException</code>。</li>
<li><strong>值类型与引用类型</strong>：值类型（如 <code>int</code>、<code>float</code>、<code>struct</code>）直接存储在栈上，而引用类型（如 <code>object</code>、<code>string</code>）则存储在堆上。</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>理解装箱和拆箱是C#中的一个重要概念，特别是在处理集合或需要多态时。尽量减少不必要的装箱和拆箱可以提高程序性能。</p>
<h1 id="35-值类型和引用类型的内存分配"><a href="#35-值类型和引用类型的内存分配" class="headerlink" title="35. 值类型和引用类型的内存分配"></a>35. 值类型和引用类型的内存分配</h1><p>在C#中，<strong>值类型</strong>和<strong>引用类型</strong>的内存分配方式有所不同：</p>
<h3 id="值类型的内存分配"><a href="#值类型的内存分配" class="headerlink" title="值类型的内存分配"></a>值类型的内存分配</h3><ul>
<li><strong>值类型</strong>（如 <code>int</code>、<code>float</code>、<code>struct</code> 等）通常分配在<strong>栈</strong>上。这意味着它们的内存是在方法调用时分配，并在方法返回时释放。</li>
<li>栈上的内存分配非常快，因为它按照顺序管理，只需调整栈指针即可。</li>
<li>值类型直接包含其数据，这意味着访问值类型时没有间接性。</li>
<li><strong>例外情况</strong>：如果值类型是某个对象的一部分（例如，作为类的字段），那么这个值类型的实例将存储在堆上，因为包含它的对象位于堆上。</li>
</ul>
<h3 id="引用类型的内存分配"><a href="#引用类型的内存分配" class="headerlink" title="引用类型的内存分配"></a>引用类型的内存分配</h3><ul>
<li><strong>引用类型</strong>（如 <code>class</code>、<code>array</code>、<code>string</code> 等）通常分配在<strong>堆</strong>上。堆内存适用于动态分配，内存分配和回收由垃圾收集器管理。</li>
<li>引用类型的变量实际上是一个指向堆上对象的<strong>引用</strong>，它本身存储在栈上。引用指向的对象实际存储在堆中。</li>
<li>当引用类型的对象不再被引用时，垃圾收集器会回收它所占用的堆内存。</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 值类型，分配在栈上</span><br><br>MyClass obj = <span class="hljs-keyword">new</span> MyClass(); <span class="hljs-comment">// 引用类型，obj的引用存储在栈上，对象本身分配在堆上</span><br><br><span class="hljs-keyword">struct</span> MyStruct<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> y;<br>    <span class="hljs-keyword">public</span> MyStruct myStruct; <span class="hljs-comment">// myStruct存储在堆上，因为它是对象的一部分</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>a</code> 是一个值类型变量，分配在栈上。<code>obj</code> 是一个引用类型变量，指向堆上分配的 <code>MyClass</code> 实例。<code>MyClass</code> 的实例包含 <code>MyStruct</code> 类型的字段 <code>myStruct</code>，由于它是对象的一部分，因此也存储在堆上。</p>
<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>值类型直接包含数据，存储在栈上（或在某些情况下存储在堆上，比如作为类的字段）。常见的值类型包括：</p>
<ol>
<li><strong>基本数据类型</strong>：<ul>
<li><code>int</code></li>
<li><code>float</code></li>
<li><code>double</code></li>
<li><code>char</code></li>
<li><code>bool</code></li>
<li><code>byte</code>, <code>sbyte</code></li>
<li><code>short</code>, <code>ushort</code></li>
<li><code>long</code>, <code>ulong</code></li>
<li><code>decimal</code></li>
</ul>
</li>
<li><strong>结构体</strong>（<code>struct</code>）：C#中的结构体是值类型。<ul>
<li>自定义的<code>struct</code></li>
<li>预定义的结构体，如 <code>DateTime</code>, <code>TimeSpan</code>, <code>Guid</code></li>
</ul>
</li>
<li><strong>枚举</strong>（<code>enum</code>）：在C#中，枚举也是值类型。</li>
</ol>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型的变量存储在栈上，但它们指向存储在堆上的实际数据。常见的引用类型包括：</p>
<ol>
<li><strong>类</strong>（<code>class</code>）<ul>
<li>自定义的类</li>
<li>预定义的类，如 <code>string</code>, <code>ArrayList</code>, <code>List&lt;T&gt;</code></li>
</ul>
</li>
<li><strong>接口</strong>（<code>interface</code>）：实现接口的类型也是引用类型。</li>
<li><strong>数组</strong>：无论是 <code>int[]</code>, <code>string[]</code>，还是自定义类型的数组，都是引用类型。</li>
<li><strong>委托</strong>（<code>delegate</code>）：委托类型也是引用类型。</li>
<li><strong>字符串</strong>（<code>string</code>）：尽管字符串表现得像值类型（不可变），但它是引用类型。</li>
</ol>
<h4 id="值类型与引用类型的主要区别"><a href="#值类型与引用类型的主要区别" class="headerlink" title="值类型与引用类型的主要区别"></a>值类型与引用类型的主要区别</h4><ul>
<li><strong>内存分配</strong>：值类型通常在栈上分配，而引用类型在堆上分配。</li>
<li><strong>赋值操作</strong>：值类型赋值时会复制值，引用类型赋值时会复制引用（地址）。</li>
<li><strong>默认值</strong>：值类型的默认值是类型本身的默认值（如 <code>int</code> 的默认值为 <code>0</code>），而引用类型的默认值是 <code>null</code>。</li>
</ul>
<h1 id="36-类型转换"><a href="#36-类型转换" class="headerlink" title="36. 类型转换"></a>36. 类型转换</h1><p>在C#中，<strong>类型转换</strong>是将一个数据类型的值转换为另一个数据类型的过程。根据转换的方式和适用的场景，类型转换可以分为几种类型：<strong>隐式转换</strong>、<strong>显式转换</strong>、<strong>装箱和拆箱</strong>、以及<strong>类型转换方法</strong>。</p>
<h3 id="1-隐式转换"><a href="#1-隐式转换" class="headerlink" title="1. 隐式转换"></a>1. 隐式转换</h3><ul>
<li>隐式转换是一种<strong>自动进行</strong>的转换，不需要显式地使用类型转换运算符。</li>
<li>这种转换通常在<strong>不会丢失数据</strong>的情况下进行，例如从较小范围的数值类型转换为较大范围的数值类型。</li>
<li>常见的隐式转换示例：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">double</span> b = a; <span class="hljs-comment">// int 隐式转换为 double</span><br>```   <br>在上述示例中，`<span class="hljs-built_in">int</span>` 转换为 `<span class="hljs-built_in">double</span>` 是安全的，因为 `<span class="hljs-built_in">double</span>` 的范围比 `<span class="hljs-built_in">int</span>` 大，不会丢失精度。<br><span class="hljs-meta">### 2. 显式转换（强制转换）</span><br>- 显式转换要求使用**强制转换运算符**，即 `(目标类型)`，因为这种转换可能会**丢失数据**或导致异常。<br>- 这种转换用于从大范围的数值类型转换为小范围的数值类型，或者从一种兼容的类型转换为另一种。<br>- 示例：<br>```csharp<br><span class="hljs-built_in">double</span> a = <span class="hljs-number">9.78</span>;<br><span class="hljs-built_in">int</span> b = (<span class="hljs-built_in">int</span>)a; <span class="hljs-comment">// 显式转换，结果为 9</span><br></code></pre></td></tr></table></figure>
在这个例子中，将 <code>double</code> 显式转换为 <code>int</code> 会导致小数部分丢失。</li>
</ul>
<h3 id="3-装箱和拆箱"><a href="#3-装箱和拆箱" class="headerlink" title="3. 装箱和拆箱"></a>3. 装箱和拆箱</h3><ul>
<li><strong>装箱（Boxing）</strong>：将<strong>值类型</strong>转换为<strong>引用类型</strong>（对象）的过程。会在堆上分配一个新的对象来存储该值类型的值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">object</span> obj = num; <span class="hljs-comment">// 装箱</span><br></code></pre></td></tr></table></figure></li>
<li><strong>拆箱（Unboxing）</strong>：将已装箱的<strong>对象</strong>转换回<strong>值类型</strong>的过程。这需要显式地进行转换。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">int</span> num = (<span class="hljs-built_in">int</span>)obj; <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-使用类型转换方法"><a href="#4-使用类型转换方法" class="headerlink" title="4. 使用类型转换方法"></a>4. 使用类型转换方法</h3><p>C#提供了一些用于类型转换的内置方法和类，如 <code>Convert</code> 类、<code>Parse</code> 方法和 <code>TryParse</code> 方法。</p>
<ul>
<li><strong>Convert类</strong>：可用于将基本数据类型之间进行转换。如果转换失败会抛出异常。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-built_in">int</span> num = Convert.ToInt32(str); <span class="hljs-comment">// 将字符串转换为整数</span><br></code></pre></td></tr></table></figure></li>
<li><strong>Parse方法</strong>：用于将字符串转换为对应的数值类型。如果转换失败会抛出异常。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-built_in">double</span> num = <span class="hljs-built_in">double</span>.Parse(str); <span class="hljs-comment">// 将字符串转换为 double</span><br></code></pre></td></tr></table></figure></li>
<li><strong>TryParse方法</strong>：与 <code>Parse</code> 类似，但在转换失败时不会抛出异常，而是返回 <code>false</code>。</li>
<li>为什么 <code>TryParse</code> 使用 <code>out</code><br>  <code>TryParse</code> 方法的设计初衷是尝试将字符串解析为数值类型（例如 <code>double</code>、<code>int</code> 等），并返回一个布尔值，表示转换是否成功。<code>out</code> 参数用于接收解析后的数值。<ul>
<li><strong>如果解析成功</strong>：<code>TryParse</code> 返回 <code>true</code>，并且通过 <code>out</code> 参数将解析后的结果赋值给调用者定义的变量。</li>
<li><strong>如果解析失败</strong>：<code>TryParse</code> 返回 <code>false</code>，<code>out</code> 参数的值不会被赋给任何有效的数值（可能是类型的默认值，如 <code>0.0</code>）。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">double</span>.TryParse(str, <span class="hljs-keyword">out</span> <span class="hljs-built_in">double</span> result))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;转换成功，值为 <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;转换失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="5-类型转换的注意事项"><a href="#5-类型转换的注意事项" class="headerlink" title="5. 类型转换的注意事项"></a>5. 类型转换的注意事项</h3><ul>
<li><strong>兼容性</strong>：转换前要确保类型兼容，不兼容的类型转换会导致编译错误或运行时异常。</li>
<li><strong>数据丢失</strong>：从大范围类型转换为小范围类型可能会丢失数据（例如，浮点数转换为整数会丢失小数部分）。</li>
<li><strong>异常处理</strong>：使用显式转换时，建议进行异常处理以防止转换失败导致程序崩溃。</li>
</ul>
<h3 id="as呢"><a href="#as呢" class="headerlink" title="as呢"></a>as呢</h3><p><code>as</code> 关键字在C#中也用于类型转换，但它的用法和普通的显式类型转换有一些区别。虽然它也可以实现类型转换的功能，但它的工作方式与传统的强制转换有所不同。</p>
<h4 id="as-关键字的特点"><a href="#as-关键字的特点" class="headerlink" title="as 关键字的特点"></a><code>as</code> 关键字的特点</h4><ol>
<li><strong>用于引用类型和可空类型的转换</strong>：<code>as</code> 关键字只能用于将一个<strong>引用类型</strong>或<strong>可空类型</strong>转换为另一种引用类型或可空类型。对于值类型的转换，不能使用 <code>as</code>。</li>
<li><strong>安全的类型转换</strong>：<code>as</code> 是一种<strong>安全的类型转换</strong>方法，如果转换失败，它会返回 <code>null</code>，而不是抛出异常。传统的强制转换在转换失败时会抛出 <code>InvalidCastException</code> 异常。</li>
<li><strong>转换失败返回 null</strong>：当类型转换无法进行时，<code>as</code> 会返回 <code>null</code>，这意味着你可以通过检查转换结果是否为 <code>null</code> 来判断转换是否成功。</li>
</ol>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> str = obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 成功转换，str 现在是 &quot;Hello, World!&quot;</span><br><br><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str2 = num <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 转换失败，str2 为 null</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>obj</code> 是一个字符串，因此可以使用 <code>as</code> 转换为 <code>string</code> 类型。而 <code>num</code> 是一个整数，不能转换为 <code>string</code>，所以 <code>as</code> 返回 <code>null</code>。</p>
<h4 id="与强制转换的对比"><a href="#与强制转换的对比" class="headerlink" title="与强制转换的对比"></a>与强制转换的对比</h4><ul>
<li><strong>强制转换</strong>（<code>(目标类型)obj</code>）在转换失败时会抛出异常：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str = (<span class="hljs-built_in">string</span>)num; <span class="hljs-comment">// 运行时会抛出 InvalidCastException</span><br></code></pre></td></tr></table></figure></li>
<li><strong><code>as</code> 转换</strong>则会返回 <code>null</code>，而不会抛出异常：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str = num <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 转换失败，str 为 null</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>当你不确定转换是否会成功时，使用 <code>as</code> 可以避免异常，并通过 <code>null</code> 检查来判断转换的结果。</li>
<li><code>as</code> 只能用于引用类型的转换，如果需要对值类型进行安全转换，可以结合 <code>Nullable&lt;T&gt;</code> 或使用其他方法（如 <code>TryParse</code>）。</li>
</ul>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><code>as</code> 可以看作是一种特殊的类型转换方式，主要用于引用类型的安全转换。它的主要特点是在转换失败时返回 <code>null</code> 而不是抛出异常，因此适合在不确定转换是否能成功的情况下使用。</p>
<h1 id="37-密封类（sealed-class）"><a href="#37-密封类（sealed-class）" class="headerlink" title="37. 密封类（sealed class）"></a>37. 密封类（sealed class）</h1><p>在C#中，<strong>密封类</strong>（<code>sealed class</code>）是一种不允许被继承的类。通过使用 <code>sealed</code> 关键字修饰类，可以防止其他类从该类派生。这样做的目的是增强安全性、提高性能或限制类的使用方式。</p>
<h3 id="密封类的特点"><a href="#密封类的特点" class="headerlink" title="密封类的特点"></a>密封类的特点</h3><ol>
<li><strong>不能被继承</strong>：密封类禁止其他类从它派生。这意味着你无法创建该类的子类。</li>
<li><strong>可以实例化</strong>：虽然密封类不能被继承，但它仍然可以像普通类一样被实例化并使用。</li>
<li><strong>提高性能</strong>：对于某些虚方法，JIT编译器可以针对密封类进行优化，因为它知道该方法不会被重写，从而减少方法调用的开销。</li>
</ol>
<h3 id="密封类的定义示例"><a href="#密封类的定义示例" class="headerlink" title="密封类的定义示例"></a>密封类的定义示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySealedClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is a sealed class.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 下面的代码会导致编译错误，因为 MySealedClass 是密封的，不能被继承</span><br><span class="hljs-comment">// class DerivedClass : MySealedClass</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>MySealedClass</code> 是一个密封类，禁止其他类从它派生。如果尝试继承这个类，会导致编译错误。</p>
<h3 id="使用密封类的场景"><a href="#使用密封类的场景" class="headerlink" title="使用密封类的场景"></a>使用密封类的场景</h3><ol>
<li><strong>安全性需求</strong>：当你希望某个类的功能不被扩展或修改时，可以将其声明为密封类。这样可以确保类的行为在使用时不会被子类改变。</li>
<li><strong>性能优化</strong>：密封类在某些情况下可以提高性能，因为编译器可以针对它们进行优化，特别是方法调用。</li>
<li><strong>设计限制</strong>：有时，设计一个不可扩展的类是必要的，例如一些工具类或帮助类，这些类的行为应该是固定的。</li>
</ol>
<h3 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h3><p>除了密封类，C#还允许在继承类中将<strong>方法</strong>标记为密封。密封方法使用 <code>sealed</code> 关键字，并且必须是<strong>重写</strong>的（即继承自父类的虚方法或抽象方法）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Base class display method.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Derived class sealed display method.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不能进一步重写 Display 方法</span><br><span class="hljs-comment">// class AnotherDerivedClass : DerivedClass</span><br><span class="hljs-comment">// &#123;</span><br>		<span class="hljs-comment">// 如果关键字override变成new或者删除override，不会编译报错，这个是会隐藏DerivedClass的Display()方法</span><br><span class="hljs-comment">//     public override void Display() // 这会导致编译错误</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         Console.WriteLine(&quot;Another derived class display method.&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;</span><br><br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>DerivedClass</code> 重写了 <code>BaseClass</code> 的 <code>Display</code> 方法并将其密封，防止进一步的重写。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>密封类</strong>：通过 <code>sealed</code> 关键字修饰的类，不能被继承，用于提高安全性和性能。</li>
<li><strong>密封方法</strong>：用 <code>sealed</code> 修饰的重写方法，防止其在子类中被进一步重写。</li>
<li>使用密封类和方法有助于控制类层次结构和优化性能。</li>
</ul>
<h1 id="38-多态"><a href="#38-多态" class="headerlink" title="38. 多态"></a>38. 多态</h1><p><strong>多态</strong>（Polymorphism）是面向对象编程中的一个重要概念，它指的是<strong>同一个方法或属性在不同的对象中可以有不同的实现</strong>。多态性允许程序在不同的类中定义相同的接口或方法名称，并根据具体对象的类型来调用适当的方法。这种特性增强了代码的灵活性和可维护性。</p>
<h3 id="多态的类型"><a href="#多态的类型" class="headerlink" title="多态的类型"></a>多态的类型</h3><p>在C#中，多态可以通过<strong>编译时多态（静态多态）</strong> 和<strong>运行时多态（动态多态）</strong> 来实现。</p>
<h4 id="1-编译时多态（静态多态）"><a href="#1-编译时多态（静态多态）" class="headerlink" title="1. 编译时多态（静态多态）"></a>1. 编译时多态（静态多态）</h4><p>编译时多态通常通过<strong>方法重载</strong>和<strong>运算符重载</strong>来实现。</p>
<ul>
<li><strong>方法重载（Method Overloading）</strong>：同一个类中可以定义多个具有相同名称但参数不同的方法。这些方法会根据传入的参数来决定调用哪个具体的实现。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MathOperations</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> a, <span class="hljs-built_in">double</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>MathOperations math = <span class="hljs-keyword">new</span> MathOperations();<br>Console.WriteLine(math.Add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));       <span class="hljs-comment">// 调用 Add(int, int)</span><br>Console.WriteLine(math.Add(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>));   <span class="hljs-comment">// 调用 Add(double, double)</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-运行时多态（动态多态）"><a href="#2-运行时多态（动态多态）" class="headerlink" title="2. 运行时多态（动态多态）"></a>2. 运行时多态（动态多态）</h4><p>运行时多态通过<strong>继承</strong>和<strong>虚方法</strong>、<strong>抽象类</strong>或<strong>接口</strong>来实现。最常见的实现方式是<strong>方法重写（Method Overriding）</strong>。</p>
<ul>
<li><p><strong>虚方法和重写</strong>：在基类中定义一个方法为 <code>virtual</code>，然后在派生类中使用 <code>override</code> 关键字重写这个方法。调用时根据对象的实际类型来决定执行哪个版本的方法。</p>
</li>
<li><p>当然，virtual虚函数也可以不重写，这样调用的就是父类的虚函数了</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Some generic animal sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Bark&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span><br>&#123;<br>	<span class="hljs-comment">// 不重写父类的MakeSound()虚函数</span><br>    <span class="hljs-comment">//public override void MakeSound()</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    Console.WriteLine(&quot;Meow&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        Animal myAnimal;<br>        myAnimal = <span class="hljs-keyword">new</span> Dog();<br>        myAnimal.MakeSound(); <span class="hljs-comment">// 输出 &quot;Bark&quot;</span><br><br>        myAnimal = <span class="hljs-keyword">new</span> Cat();<br>        myAnimal.MakeSound(); <span class="hljs-comment">// 输出 &quot;Some generic animal sound&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>MakeSound</code> 方法在基类 <code>Animal</code> 中是虚方法，允许派生类 <code>Dog</code>  重写它。当我们调用 <code>MakeSound</code> 时，实际执行的是对象所属类型（<code>Dog</code>）的具体实现。</p>
</li>
<li><p><strong>接口</strong>与重写：在C#中，<strong>接口</strong>（Interface）是一种定义类和结构应遵循的契约。接口可以包含方法、属性、事件和索引器，但不能包含字段或实现。任何实现接口的类或结构都必须提供接口中定义的所有成员的实现。</p>
</li>
<li><p>接口不包含成员变量</p>
</li>
<li><p>接口包含的成员不能被实现</p>
</li>
<li><p>接口包含的成员访问修饰符可以不写，默认是public，但是不能写成私有</p>
</li>
<li><p>接口不能继承类，但是可以继承另一个接口</p>
</li>
<li><p>接口不能被实例化，但是可以作为容器存储对象</p>
</li>
<li><p>继承了接口，必须是public方式实现</p>
</li>
<li><p>接口也遵循历史转换原则</p>
<ul>
<li>接口的基本定义  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span>;      <span class="hljs-comment">// 定义一个方法，计算面积</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;       <span class="hljs-comment">// 定义一个方法，绘制形状</span><br>&#125;<br></code></pre></td></tr></table></figure>
  在这个例子中，我们定义了一个名为 <code>IShape</code> 的接口，它包含两个方法：<code>Area</code> 和 <code>Draw</code>。继承结构的类，必须实现这两个方法，否则报错</li>
<li>实现接口的类<br>  多个类可以实现同一个接口，并提供各自的实现。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius; <span class="hljs-comment">// 圆的面积公式</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Circle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>    &#123;<br>        Width = width;<br>        Height = height;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Width * Height; <span class="hljs-comment">// 矩形的面积公式</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Rectangle&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
  在这个例子中，<code>Circle</code> 和 <code>Rectangle</code> 类实现了 <code>IShape</code> 接口。它们都提供了 <code>Area</code> 和 <code>Draw</code> 方法的具体实现。</li>
<li>使用接口的示例<br>  通过接口类型，可以编写更灵活的代码，处理不同的实现。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        IShape circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        IShape rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>); <span class="hljs-comment">// 调用圆的面积方法</span><br>        circle.Draw(); <span class="hljs-comment">// 绘制圆</span><br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>); <span class="hljs-comment">// 调用矩形的面积方法</span><br>        rectangle.Draw(); <span class="hljs-comment">// 绘制矩形</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>输出结果  <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Circle</span> <span class="hljs-built_in">Area</span><span class="hljs-operator">:</span> <span class="hljs-number">78.53981633974483</span><br><span class="hljs-variable">Drawing</span> <span class="hljs-variable">a</span> <span class="hljs-built_in">Circle</span><br><span class="hljs-built_in">Rectangle</span> <span class="hljs-built_in">Area</span><span class="hljs-operator">:</span> <span class="hljs-number">24</span><br><span class="hljs-variable">Drawing</span> <span class="hljs-variable">a</span> <span class="hljs-built_in">Rectangle</span><br></code></pre></td></tr></table></figure></li>
<li>其他示例  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs csharp">		<span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义接口 IShape</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-comment">// 方法声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br><br>    <span class="hljs-comment">// 属性声明</span><br>    <span class="hljs-built_in">double</span> Area &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-comment">// 事件声明</span><br>    <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器声明</span><br>    <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Circle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Draw 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Drawing a circle with radius: <span class="hljs-subst">&#123;Radius&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Area 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Area =&gt; Math.PI * Radius * Radius;<br><br>    <span class="hljs-comment">// 事件的实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Radius;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                Radius = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 触发 ShapeChanged 事件的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShapeChanged</span>()</span><br>    &#123;<br>        ShapeChanged?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Rectangle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>    &#123;<br>        Width = width;<br>        Height = height;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Draw 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Drawing a rectangle with width: <span class="hljs-subst">&#123;Width&#125;</span> and height: <span class="hljs-subst">&#123;Height&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Area 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Area =&gt; Width * Height;<br><br>    <span class="hljs-comment">// 事件的实现 </span><br>    <span class="hljs-comment">// EventHandler是自带的事件</span><br>    <span class="hljs-comment">// public delegate void EventHandler(object? sender, EventArgs e);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Width;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Height;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                Width = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>)<br>            &#123;<br>                Height = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 触发 ShapeChanged 事件的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShapeChanged</span>()</span><br>    &#123;<br>        ShapeChanged?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        IShape circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        circle.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a circle with radius: 5&quot;</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出圆的面积</span><br><br>        IShape rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        rectangle.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a rectangle with width: 4 and height: 6&quot;</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出矩形的面积</span><br><br>        <span class="hljs-comment">// 使用索引器</span><br>        circle[<span class="hljs-number">0</span>] = <span class="hljs-number">7</span>; <span class="hljs-comment">// 修改半径</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Updated Circle Area: <span class="hljs-subst">&#123;circle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出更新后的面积</span><br><br>        <span class="hljs-comment">// 订阅事件</span><br>        rectangle.ShapeChanged += (sender, e) =&gt; Console.WriteLine(<span class="hljs-string">&quot;Rectangle shape changed!&quot;</span>);<br>        rectangle[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>; <span class="hljs-comment">// 修改宽度，触发事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>如果两个接口中存在同名方法时，需要显式实现接口</li>
<li>显式实现接口时，不能写访问修饰符  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义接口 IShape</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>; <span class="hljs-comment">// 方法声明</span><br>&#125;<br><br><span class="hljs-comment">// 定义接口 IFigure</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFigure</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>; <span class="hljs-comment">// 方法声明</span><br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Circle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span>, <span class="hljs-title">IFigure</span><br>&#123;<br>    <span class="hljs-comment">// 显式实现 IShape 的 Draw 方法</span><br>    <span class="hljs-keyword">void</span> IShape.Draw()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a shape as IShape.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 显式实现 IFigure 的 Draw 方法</span><br>    <span class="hljs-keyword">void</span> IFigure.Draw()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a shape as IFigure.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 Circle 的实例</span><br>        Circle circle = <span class="hljs-keyword">new</span> Circle();<br><br>        <span class="hljs-comment">// 使用 IShape 接口调用 Draw 方法</span><br>        IShape shape = circle;<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a shape as IShape.&quot;</span><br><br>        <span class="hljs-comment">// 使用 IFigure 接口调用 Draw 方法</span><br>        IFigure figure = circle;<br>        figure.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a shape as IFigure.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>接口的优点<ol>
<li><strong>松耦合</strong>：接口允许类之间松散耦合，方便替换和扩展。你可以在不修改现有代码的情况下，引入新的实现。</li>
<li><strong>多态</strong>：通过接口可以实现多态性，允许不同的对象以相同的方式进行处理。</li>
<li><strong>强制实现</strong>：接口强制实现类遵循特定的协议，从而确保一致性。</li>
</ol>
</li>
<li>继承多个接口<br>  C#允许一个类实现多个接口，从而支持多重继承的特性。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDrawable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IColorable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Color</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ColoredCircle</span> : <span class="hljs-title">IShape</span>, <span class="hljs-title">IDrawable</span>, <span class="hljs-title">IColorable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColoredCircle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Colored Circle&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Color</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Coloring the circle with <span class="hljs-subst">&#123;color&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>抽象类和抽象方法</strong>：如果一个类中有抽象方法（没有方法体的方法），该类必须被声明为抽象类，不能被直接实例化，必须由派生类实现抽象方法。</p>
</li>
<li><p>抽象类不可以被实例化，但是遵循里氏转换原则，可以作为父类接受子类</p>
</li>
<li><p>抽象类需要用abstract关键字声明，放在class前面</p>
</li>
<li><p>抽象类可以没有抽象方法，但是抽象方法必须在抽象类里面</p>
</li>
<li><p>抽象方法不能是私有的，不然无法继承后重写。抽象方法一定是没有函数体的。且必须在抽象类中</p>
</li>
<li><p>如果继承了抽象类，子类不是抽象类，则必须实现抽象类，否则可以不实现</p>
</li>
<li><p>如果某个子类，继承的父类已经实现了抽象函数，那么可以直接继承，不继续实现。如果实现，用的是override，和普通的实现抽象函数一样，多态。如果使用的是new，则是和普通的重载规则一样，具体下面注释写了</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape2</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Shape2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果不实现抽象类Shape中的Draw方法，也必须声明为abstract类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a rectangle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果这里继承实现了Draw，使用new关键字，下面是用Shape接受，那么会使用Rectangle的方法，输出&quot;Drawing a rectangle&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle2</span> : <span class="hljs-title">Rectangle</span><br>&#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle3</span> : <span class="hljs-title">Shape2</span><br>&#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        Shape shape;<br>        shape = <span class="hljs-keyword">new</span> Circle();<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a circle&quot;</span><br><br>        shape = <span class="hljs-keyword">new</span> Rectangle2();<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a rectangle&quot;</span><br><br>        Shape2 shape2;<br>        shape2 = <span class="hljs-keyword">new</span> Rectangle3();<br>        shape2.Draw(); <span class="hljs-comment">//输出 &quot;Shape2&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ol>
<li><strong>代码可维护性高</strong>：多态可以让程序在不修改现有代码的情况下，方便地扩展新的功能。例如，新增一种 <code>Shape</code> 类型的子类只需实现 <code>Draw</code> 方法，不影响其他代码。</li>
<li><strong>提高代码的灵活性和可扩展性</strong>：通过接口或基类编程，可以编写通用的代码，这些代码可以应用于各种具体的对象。</li>
<li><strong>面向接口编程</strong>：多态性鼓励面向接口编程，而不是面向实现编程，从而提高系统的可扩展性。</li>
</ol>
<h3 id="多态的实现注意事项"><a href="#多态的实现注意事项" class="headerlink" title="多态的实现注意事项"></a>多态的实现注意事项</h3><ul>
<li>当使用虚方法或抽象方法时，子类应使用 <code>override</code> 关键字重写基类方法。</li>
<li>接口方法在实现时也类似于虚方法，可以实现多态。</li>
</ul>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p>抽象类和接口在面向对象编程中用于定义抽象的类型成员，帮助实现多态性，但它们有不同的特点和使用场景。以下是抽象类和接口之间的主要区别：</p>
<h4 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1. 定义方式"></a>1. <strong>定义方式</strong></h4><ul>
<li><strong>抽象类</strong>：使用 <code>abstract</code> 关键字定义，允许包含抽象方法（没有实现）和非抽象方法（有实现）。</li>
<li><strong>接口</strong>：使用 <code>interface</code> 关键字定义，不能包含任何方法的实现（从 C# 8.0 开始，接口可以包含默认实现）。<ul>
<li>如果接口是类的唯一父类，如果用这个父类接收，可以调用其中原有的方法</li>
<li>接口中的方法，只能是public，不能是private，protected的话不可以在类外使用，也不可以用virtual  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">Itest</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;interface Itest 的默认实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> : <span class="hljs-title">Itest</span><br>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-comment">//test.show();// 报错</span><br><br>        <span class="hljs-comment">// 通过接口引用来调用默认实现的方法</span><br>        Itest itest = test;<br>        itest.show(); <span class="hljs-comment">// 输出: interface Itest 的默认实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-继承关系"><a href="#2-继承关系" class="headerlink" title="2. 继承关系"></a>2. <strong>继承关系</strong></h4><ul>
<li><strong>抽象类</strong>：支持单继承，即一个类只能继承一个抽象类。</li>
<li><strong>接口</strong>：支持多继承，一个类可以实现多个接口。</li>
<li>如果是抽象类和接口都继承，也就是一个类继承了单个类和多个接口，那么其中的父类，只能调用自己相关的方法，而不能调用其他接口或者类的方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BaseMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method from BaseClass&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IInterface1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InterfaceMethod</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IInterface1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InterfaceMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method from IInterface1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        DerivedClass derivedClass = <span class="hljs-keyword">new</span> DerivedClass();<br>        derivedClass.BaseMethod();        <span class="hljs-comment">// 输出: Method from BaseClass</span><br>        derivedClass.InterfaceMethod();   <span class="hljs-comment">// 输出: Method from IInterface1</span><br><br><br>        BaseClass derivedClass2 = <span class="hljs-keyword">new</span> DerivedClass();<br>        derivedClass2.BaseMethod();        <span class="hljs-comment">// 输出: Method from BaseClass</span><br>        <span class="hljs-comment">// derivedClass2.InterfaceMethod();   // 报错</span><br><br>        IInterface1 derivedClass3 = <span class="hljs-keyword">new</span> DerivedClass();<br>        <span class="hljs-comment">// derivedClass3.BaseMethod();        // 报错</span><br>        derivedClass3.InterfaceMethod();   <span class="hljs-comment">// 输出: Method from IInterface1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-成员类型"><a href="#3-成员类型" class="headerlink" title="3. 成员类型"></a>3. <strong>成员类型</strong></h4><ul>
<li><strong>抽象类</strong>：可以包含字段、属性、方法、构造函数、事件等成员，可以有访问修饰符（如 <code>public</code>、<code>protected</code>）。</li>
<li><strong>接口</strong>：不能包含字段或构造函数，成员默认是 <code>public</code>，且只能包含方法、属性、事件和索引器的声明（在 C# 8.0 之前）。从 C# 8.0 开始，接口可以包含静态方法、默认实现、属性和事件。(这个8.0之前和之后的属性和事件没区别，只是允许有默认实现了)</li>
</ul>
<h4 id="4-实现方式"><a href="#4-实现方式" class="headerlink" title="4. 实现方式"></a>4. <strong>实现方式</strong></h4><ul>
<li><strong>抽象类</strong>：子类继承抽象类并实现其抽象方法，可以使用 <code>override</code> 关键字来实现父类的抽象方法。</li>
<li><strong>接口</strong>：实现接口的类必须实现接口中定义的所有成员，不能使用 <code>override</code> 关键字。</li>
</ul>
<h4 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5. 构造函数"></a>5. <strong>构造函数</strong></h4><ul>
<li><strong>抽象类</strong>：可以有构造函数，用于初始化抽象类的字段。不能创建抽象类的实例。</li>
<li><strong>接口</strong>：不能有构造函数，不能创建接口的实例。</li>
</ul>
<h4 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. <strong>使用场景</strong></h4><ul>
<li><strong>抽象类</strong>：适用于描述具有相似属性和行为的类，并且需要在基类中提供一些默认实现时。</li>
<li><strong>接口</strong>：适用于定义一组不相关类的行为约定，或者需要多重继承时。</li>
</ul>
<h4 id="7-字段支持"><a href="#7-字段支持" class="headerlink" title="7. 字段支持"></a>7. <strong>字段支持</strong></h4><ul>
<li><strong>抽象类</strong>：可以定义字段。</li>
<li><strong>接口</strong>：不能定义字段，接口的成员只能是方法、属性、事件或索引器的签名。</li>
</ul>
<h4 id="8-访问修饰符"><a href="#8-访问修饰符" class="headerlink" title="8. 访问修饰符"></a>8. <strong>访问修饰符</strong></h4><ul>
<li><strong>抽象类</strong>：可以为成员指定不同的访问修饰符（<code>public</code>、<code>protected</code>、<code>private</code>）。</li>
<li><strong>接口</strong>：接口成员默认是 <code>public</code>，不能使用其他访问修饰符。</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>; <span class="hljs-comment">// 抽象方法，没有实现</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>() <span class="hljs-comment">// 非抽象方法，有实现</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>() <span class="hljs-comment">// 必须实现抽象方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Woof!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMovable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>()</span>; <span class="hljs-comment">// 接口成员没有实现</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISpeakable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Robot</span> : <span class="hljs-title">IMovable</span>, <span class="hljs-title">ISpeakable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>() <span class="hljs-comment">// 实现接口方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Robot is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>() <span class="hljs-comment">// 实现接口方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Beep beep!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul>
<li>抽象类适合有默认行为的基类，而接口适合定义无关类的契约。</li>
<li>使用抽象类可以提供部分实现，而接口更注重行为规范的定义和多继承的支持。</li>
</ul>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>多态是面向对象编程的核心概念之一，它可以通过方法重载、方法重写、抽象类和接口等多种方式实现。编译时多态主要通过方法重载和运算符重载实现，而运行时多态通过继承、虚方法、抽象类和接口实现。它使得代码更加灵活、易于扩展和维护。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/">MS-Learning</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zjzzjzzjzzjzzjz/article/details/8984057">解决方案、项目、程序集、命名空间之间的联系与区别</a><br><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/1446226042843310700.html?qbl=relate_question_0">c# 重载++（前后）</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CSharp知识整理(二)</div>
      <div>https://wing2791.github.io/2024/10/25/CSharp知识整理(二)/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>wing2791</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年10月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/10/26/Csharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%89)/" title="CSharp知识整理(三)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CSharp知识整理(三)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80_inline,%20const,%20static/" title="知识点一_inline, const, static">
                        <span class="hidden-mobile">知识点一_inline, const, static</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-bilibili-fill"></i> <a href="https://space.bilibili.com/384847565" target="_blank" rel="nofollow noopener"><span>B站主页</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
