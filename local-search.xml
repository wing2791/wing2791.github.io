<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSharp知识整理(四)</title>
    <link href="/2024/10/28/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E5%9B%9B)/"/>
    <url>/2024/10/28/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<h1 id="63-协变-out-和逆变-in"><a href="#63-协变-out-和逆变-in" class="headerlink" title="63. 协变(out)和逆变(in)"></a>63. 协变(out)和逆变(in)</h1><p>协变（covariance）和逆变（contravariance）是泛型类型参数的一种变换方式，主要用于解决泛型类型的继承关系，特别是在处理委托和接口时。这些概念在 C# 中尤其重要，因为它们帮助我们在类型安全的同时实现灵活的类型转换。</p><ul><li>out一般指返回值</li><li>in一般指参数</li><li>都是里氏转换原则，out是使用父类接收子类，没问题</li><li>in是将参数为父类的赋值为参数为子类的，但是调用的时候还是子类进行调用，传入的参数也是子类。但是由于子类的函数是父类，此时就是父类的参数接收子类，符合里氏转换原则。可以看文后的参考<a href="https://www.cnblogs.com/VVStudy/p/11404300.html" title="发布于 2019-08-28 12:04">C# - 协变、逆变 看完这篇就懂了</a></li></ul><h3 id="1-协变（Covariance）"><a href="#1-协变（Covariance）" class="headerlink" title="1. 协变（Covariance）"></a>1. 协变（Covariance）</h3><p><strong>协变</strong>允许你使用更具体的类型替换泛型类型参数。例如，协变允许你将一个返回类型为派生类的方法赋值给一个返回类型为基类的方法。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123; &#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span> &#123; &#125;<br><br><span class="hljs-comment">// 协变的委托</span><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> TOutput <span class="hljs-title">MyDelegate</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">TOutput</span>&gt;()</span>;<br><br><span class="hljs-comment">// 使用协变</span><br>MyDelegate&lt;Dog&gt; dogDelegate = () =&gt; <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">// 可以使用 Dog</span><br>MyDelegate&lt;Animal&gt; animalDelegate = dogDelegate; <span class="hljs-comment">// 可以向上转型到 Animal</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>MyDelegate&lt;out TOutput&gt;</code> 中的 <code>out</code> 关键字指示该类型参数是协变的，这意味着它只会出现在返回类型中。</p><h3 id="2-逆变（Contravariance）"><a href="#2-逆变（Contravariance）" class="headerlink" title="2. 逆变（Contravariance）"></a>2. 逆变（Contravariance）</h3><p><strong>逆变</strong>允许你使用更一般的类型替换泛型类型参数。例如，逆变允许你将一个接受派生类的方法赋值给一个接受基类的方法。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123; &#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span> &#123; &#125;<br><br><span class="hljs-comment">// 逆变的委托</span><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyAction</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">TInput</span>&gt;(<span class="hljs-params">TInput input</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleAnimal</span>(<span class="hljs-params">Animal animal</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Handling animal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建逆变的委托</span><br>        MyAction&lt;Animal&gt; animalAction = HandleAnimal;<br>        MyAction&lt;Dog&gt; dogAction = animalAction; <span class="hljs-comment">// 使用逆变</span><br><br>        <span class="hljs-comment">// 这段代码不会报错，因为 HandleAnimal 可以接受 Dog</span><br>        dogAction(<span class="hljs-keyword">new</span> Dog()); <span class="hljs-comment">// 输出: Handling animal</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul><li><strong>协变</strong>（使用 <code>out</code>）:<ul><li>适用于返回类型。</li><li>可以将派生类赋值给基类。</li></ul></li><li><strong>逆变</strong>（使用 <code>in</code>）:<ul><li>适用于参数类型。</li><li>可以将基类赋值给派生类。</li></ul></li></ul><h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h3><ul><li><strong>协变</strong>通常用于处理返回值的场景，比如泛型集合的查询操作。</li><li><strong>逆变</strong>通常用于处理接受参数的场景，比如事件处理和回调函数。</li></ul><h1 id="64-object和Object的区别"><a href="#64-object和Object的区别" class="headerlink" title="64. object和Object的区别"></a>64. object和Object的区别</h1><p>在C#中，<code>object</code>和<code>Object</code>指向的是同一个类型，但它们的用法和意义略有不同：</p><h3 id="1-object（小写）"><a href="#1-object（小写）" class="headerlink" title="1. object（小写）"></a>1. <code>object</code>（小写）</h3><ul><li><code>object</code> 是 C# 的关键字，表示 .NET 类型系统中的基类 <code>System.Object</code>。</li><li>它是所有类型（包括值类型和引用类型）的基类，意味着任何类型都可以作为 <code>object</code> 的实例。</li><li>在代码中，使用 <code>object</code> 关键字是表示类型时的常见做法。<br>例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> myObject = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-Object（大写）"><a href="#2-Object（大写）" class="headerlink" title="2. Object（大写）"></a>2. <code>Object</code>（大写）</h3><ul><li><code>Object</code> 是 .NET 框架中的类，完整名称是 <code>System.Object</code>。</li><li>它位于 <code>System</code> 命名空间中，是所有类型在 .NET 类型系统中的根类型。</li><li>可以通过 <code>System.Object</code> 直接引用它，但通常情况下使用 <code>object</code> 关键字。<br>例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">System.Object myObject = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. 主要区别</h3><ul><li><code>object</code> 是关键字，作为语法糖使用，更简洁。</li><li><code>Object</code> 是 .NET 类，可以通过完全限定名 <code>System.Object</code> 访问。<br>在大多数场合下，两者是可以互换使用的，但通常推荐使用 <code>object</code> 关键字，因为它更符合 C# 的编码风格。</li></ul><h1 id="65-匿名函数"><a href="#65-匿名函数" class="headerlink" title="65. 匿名函数"></a>65. 匿名函数</h1><p>匿名函数是指没有名称的函数，通常用于简化代码、实现短小的功能，尤其是在处理回调、事件或作为<code>参数传递</code>时。C# 支持两种匿名函数的形式：<strong>匿名方法</strong> 和 <strong>Lambda 表达式</strong>。</p><ul><li>脱离委托和事件，是不会使用匿名函数的</li><li>添加到委托或者事件容器后，不记录，无法单独移除，只能Clear()</li></ul><h3 id="1-匿名方法"><a href="#1-匿名方法" class="headerlink" title="1. 匿名方法"></a>1. 匿名方法</h3><p>匿名方法使用 <code>delegate</code> 关键字来定义一个没有名称的函数。适用于不需要重用的简单逻辑。<br>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 使用匿名方法定义一个委托</span><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = <span class="hljs-built_in">delegate</span> (<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-comment">// 调用匿名方法</span><br><span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>Console.WriteLine(result); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><h3 id="2-Lambda-表达式"><a href="#2-Lambda-表达式" class="headerlink" title="2. Lambda 表达式"></a>2. Lambda 表达式</h3><p>Lambda 表达式是一种更简洁的语法形式，用于编写匿名函数。语法为 <code>(参数列表) =&gt; 表达式或语句块</code>。<br>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 使用 Lambda 表达式定义一个委托</span><br><span class="hljs-comment">// 也可以写(int a,int b)=&gt;a+b;</span><br><span class="hljs-comment">// 参数类型和委托或事件一致</span><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; a + b;<br><br><span class="hljs-comment">// 调用 Lambda 表达式</span><br><span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>Console.WriteLine(result); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><h4 id="带块体的-Lambda-表达式"><a href="#带块体的-Lambda-表达式" class="headerlink" title="带块体的 Lambda 表达式"></a>带块体的 Lambda 表达式</h4><p>如果 Lambda 表达式包含多条语句，可以用 <code>&#123;&#125;</code> 包围，并显式使用 <code>return</code> 返回值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Adding numbers&quot;</span>);<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>Console.WriteLine(result); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><h3 id="3-匿名方法与-Lambda-表达式的区别"><a href="#3-匿名方法与-Lambda-表达式的区别" class="headerlink" title="3. 匿名方法与 Lambda 表达式的区别"></a>3. 匿名方法与 Lambda 表达式的区别</h3><ul><li><strong>语法</strong>：Lambda 表达式的语法更加简洁，通常更易于阅读。</li><li><strong>特性</strong>：Lambda 表达式支持类型推断，不需要显式指定参数的类型。</li><li><strong>捕获外部变量</strong>：匿名方法和 Lambda 表达式都可以捕获外部作用域中的变量。</li></ul><h1 id="66-闭包"><a href="#66-闭包" class="headerlink" title="66. 闭包"></a>66. 闭包</h1><ul><li>闭包是一个编程概念，指的是一个函数可以捕获并访问其所在作用域（外部函数或环境）中的变量，即使在这些变量的生命周期结束后，该函数依然可以访问这些变量的值。闭包可以让函数“记住”创建它时的环境。</li><li>在 C# 中，闭包通常与匿名函数（匿名方法或 Lambda 表达式）结合使用。当一个匿名函数捕获了外部作用域中的变量时，就形成了一个闭包。这些捕获的变量会与匿名函数一起存储，即使这些变量在创建闭包的作用域中已经不存在，闭包仍然可以访问它们。</li></ul><h3 id="闭包的示例"><a href="#闭包的示例" class="headerlink" title="闭包的示例"></a>闭包的示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-title">makeAdder</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 返回一个 Lambda 表达式，捕获外部变量 x</span><br>    <span class="hljs-comment">// 这里y被外部使用，作为了返回值，所以其声明周期和makeAdder一样</span><br>    <span class="hljs-keyword">return</span> y =&gt; x + y;<br>&#125;<br><br><span class="hljs-keyword">var</span> addFive = makeAdder(<span class="hljs-number">5</span>);<span class="hljs-comment">//此时addFive中的y为5</span><br>Console.WriteLine(addFive(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 8</span><br><br><span class="hljs-keyword">var</span> addTen = makeAdder(<span class="hljs-number">10</span>);<span class="hljs-comment">//此时addTen中的y为10</span><br>Console.WriteLine(addTen(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 13</span><br></code></pre></td></tr></table></figure><p>在上面的示例中：</p><ol><li><code>makeAdder</code> 方法返回一个 <code>Func&lt;int, int&gt;</code> 类型的 Lambda 表达式。</li><li>这个 Lambda 表达式捕获了 <code>makeAdder</code> 方法的参数 <code>x</code>，即形成了一个闭包。</li><li>当 <code>addFive</code> 和 <code>addTen</code> 调用时，即使 <code>makeAdder</code> 方法已经执行完毕并退出，其返回的 Lambda 表达式依然可以访问被捕获的 <code>x</code> 值（分别为 5 和 10）。</li></ol><h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ol><li><strong>捕获变量而非值</strong>：闭包捕获的是外部变量的引用，而不是它的值。这意味着如果外部变量的值发生变化，闭包访问的值也会相应改变。</li><li><strong>持久性</strong>：即使捕获变量所在的作用域已经结束，闭包仍然可以访问这些变量。</li></ol><h3 id="捕获变量的行为"><a href="#捕获变量的行为" class="headerlink" title="捕获变量的行为"></a>捕获变量的行为</h3><p>闭包在捕获变量时会捕获其引用，而不是当前值。这可能会导致意料之外的行为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;Func&lt;<span class="hljs-built_in">int</span>&gt;&gt; actions = <span class="hljs-keyword">new</span> List&lt;Func&lt;<span class="hljs-built_in">int</span>&gt;&gt;();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>    actions.Add(() =&gt; i);<br>&#125;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> action <span class="hljs-keyword">in</span> actions)<br>&#123;<br>    Console.WriteLine(action()); <span class="hljs-comment">// 输出 3, 3, 3，而不是 0, 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>i</code> 被捕获为引用，因此当循环结束时，<code>i</code> 的最终值是 3，因此所有的闭包都会返回 3。</p><h3 id="解决上述问题的方式"><a href="#解决上述问题的方式" class="headerlink" title="解决上述问题的方式"></a>解决上述问题的方式</h3><p>可以使用一个临时变量来解决这个问题，让闭包捕获不同的值：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>    <span class="hljs-built_in">int</span> temp = i; <span class="hljs-comment">// 临时变量，闭包捕获的是 temp</span><br>    actions.Add(() =&gt; temp);<br>&#125;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> action <span class="hljs-keyword">in</span> actions)<br>&#123;<br>    Console.WriteLine(action()); <span class="hljs-comment">// 输出 0, 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>闭包是一个非常强大的概念，可以使得函数在定义时记住它们的环境。闭包与匿名函数的结合使用为 C# 增添了函数式编程的特性，使得代码更加灵活和简洁。</p><h1 id="67-多线程"><a href="#67-多线程" class="headerlink" title="67. 多线程"></a>67. 多线程</h1><p>多线程是指在一个程序中同时执行多个线程的技术。线程是操作系统调度的最小单位，多个线程共享同一进程的内存空间，每个线程都有自己的栈空间和寄存器上下文。多线程可以提高程序的并发性和响应速度，尤其在处理 I&#x2F;O 操作、长时间运行的任务或用户界面响应时非常有用。</p><ul><li>默认是前台线程t，主线程会等待t线程结束，如果t线程不结束，主线程就不会结束。t设置为后台线程以后，Main主线程结束以后，t线程也会一起结束。</li></ul><h3 id="在-C-中使用多线程"><a href="#在-C-中使用多线程" class="headerlink" title="在 C# 中使用多线程"></a>在 C# 中使用多线程</h3><p>在 C# 中，可以使用多种方法来实现多线程编程。常见的方法包括：</p><ol><li><strong><code>Thread</code> 类</strong></li><li><strong><code>Task</code> 并行库</strong></li><li><strong>异步编程 (<code>async</code>&#x2F;<code>await</code>)</strong></li><li><strong>线程池</strong></li></ol><h4 id="1-Thread-类"><a href="#1-Thread-类" class="headerlink" title="1. Thread 类"></a>1. <code>Thread</code> 类</h4><p><code>Thread</code> 类是最基本的创建和管理线程的方法。可以使用 <code>Thread</code> 类来创建一个新线程并启动它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个线程，执行方法为 PrintNumbers</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(PrintNumbers);<br>        thread.IsBackground = <span class="hljs-literal">true</span>;<br>        thread.Start(); <span class="hljs-comment">// 启动线程</span><br><br><br>        <span class="hljs-comment">// 主线程继续执行其他任务</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>        <span class="hljs-comment">// 注释下面这行，并且thread为后台线程，一旦主线程运行完毕，则主线程会自动退出，子线程也会结束</span><br>        thread.Join(); <span class="hljs-comment">// 等待子线程执行完成,此时主线程在这里暂停不动</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行2...&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;子线程输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 让线程休眠500毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>thread.Join()</code> 方法用于阻塞调用线程（通常是主线程），直到指定的线程（子线程）完成执行。这意味着，调用 <code>Join()</code> 的线程会等待子线程执行完成后再继续执行后续的代码。</li><li>运行结果<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">主线程继续运行...<br>子线程输出: <span class="hljs-number">1</span><br>子线程输出: <span class="hljs-number">2</span><br>子线程输出: <span class="hljs-number">3</span><br>子线程输出: <span class="hljs-number">4</span><br>子线程输出: <span class="hljs-number">5</span><br>主线程继续运行<span class="hljs-number">2.</span>..<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Task-并行库"><a href="#2-Task-并行库" class="headerlink" title="2. Task 并行库"></a>2. <code>Task</code> 并行库</h4><p><code>Task</code> 类提供了更高级的抽象，用于处理并行编程。与 <code>Thread</code> 类相比，<code>Task</code> 更加灵活，并且能够更好地管理线程的生命周期。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个 Program 类，并声明一个 Main 方法，该方法返回 Task。</span><br>    <span class="hljs-comment">// 由于它被标记为 async，表示它可以使用 await 关键字。</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 启动一个异步任务</span><br>        <span class="hljs-comment">// 使用 Task.Run 方法启动一个新的任务。这个任务会执行 PrintNumbers 方法。</span><br>        <span class="hljs-comment">// Task.Run 方法用于在线程池中异步执行代码，因此 PrintNumbers 方法会在一个独立的线程上运行，</span><br>        <span class="hljs-comment">// 而主线程不会被阻塞。</span><br>        Task task = Task.Run(() =&gt; PrintNumbers());<br><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>        <span class="hljs-comment">// 使用 await 关键字等待 task 完成。此时，主线程会在 await 处暂停，</span><br>        <span class="hljs-comment">// 直到 PrintNumbers 任务执行完毕。此操作确保在程序结束之前，所有的异步操作都已经完成。</span><br>        <span class="hljs-keyword">await</span> task; <span class="hljs-comment">// 等待任务完成,不会继续运行下面的主线程代码</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行2...&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Task 输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            Task.Delay(<span class="hljs-number">500</span>).Wait(); <span class="hljs-comment">// 等待500毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-异步编程-async-await"><a href="#3-异步编程-async-await" class="headerlink" title="3. 异步编程 (async&#x2F;await)"></a>3. 异步编程 (<code>async</code>&#x2F;<code>await</code>)</h4><p>C# 提供了异步编程的支持，通过 <code>async</code> 和 <code>await</code> 关键字，可以方便地进行异步操作，特别适合 I&#x2F;O 密集型任务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">await</span> PrintNumbersAsync(); <span class="hljs-comment">// 阻塞，不会继续运行下面的代码</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PrintNumbersAsync</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;异步输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">500</span>); <span class="hljs-comment">// 异步等待500毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h4><p>线程池用于管理一组预先创建的线程，可以减少创建和销毁线程的开销。可以使用 <code>ThreadPool.QueueUserWorkItem</code> 方法将工作项排队到线程池。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 将任务排队到线程池</span><br>        ThreadPool.QueueUserWorkItem(PrintNumbers);<br>        <span class="hljs-comment">// 不会阻塞运行，主线程会继续运行，导致子线程没有运行完就结束了</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 主线程等待一段时间以确保输出</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> state</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;线程池输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 等待500毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h5><p>线程池的线程数量在 .NET 中是动态管理的，通常不会固定在一个特定的数量上。以下是一些关于线程池的关键信息：</p><h6 id="1-动态调整"><a href="#1-动态调整" class="headerlink" title="1. 动态调整"></a>1. 动态调整</h6><ul><li>线程池会根据当前的工作负载动态增加或减少线程数量。</li><li>当工作线程的数量低于线程池的最低数量时，线程池会创建新线程来处理新的任务。</li><li>当没有任务需要处理时，线程池会减少空闲线程的数量，以释放系统资源。</li></ul><h6 id="2-最大线程数量"><a href="#2-最大线程数量" class="headerlink" title="2. 最大线程数量"></a>2. 最大线程数量</h6><ul><li>线程池的最大线程数量可以通过 <code>ThreadPool.SetMaxThreads</code> 方法进行设置。默认情况下，这个上限通常是系统可以支持的最大线程数量，但具体的值可能依赖于系统配置和负载。</li><li>&#96;public static void SetMaxThreads(int workerThreads, int completionPortThreads);<ul><li><strong><code>workerThreads</code></strong>: 指定工作线程的最大数量。</li><li><strong><code>completionPortThreads</code></strong>: 指定用于处理异步 IO 操作的最大线程数量。&#96;</li></ul></li></ul><h6 id="3-最小线程数量"><a href="#3-最小线程数量" class="headerlink" title="3. 最小线程数量"></a>3. 最小线程数量</h6><ul><li>线程池的最小线程数量也可以通过 <code>ThreadPool.SetMinThreads</code> 方法进行设置。这个值定义了线程池在没有任务时保持的最小线程数量。</li><li><code>ThreadPool.SetMinThreads(int workerThreads, int completionPortThreads)</code> 用于设置线程池中工作线程和异步 IO 线程的最小数量。</li></ul><h6 id="4-默认行为"><a href="#4-默认行为" class="headerlink" title="4. 默认行为"></a>4. 默认行为</h6><ul><li>在没有特殊配置的情况下，线程池会自动管理线程数量，通常在较低负载时只会保持几个线程。</li><li>当高负载时，线程池会创建更多线程以满足需求，具体数量会根据需要而变化。</li></ul><h6 id="5-线程池的优点"><a href="#5-线程池的优点" class="headerlink" title="5. 线程池的优点"></a>5. 线程池的优点</h6><ul><li>通过重用线程，减少了创建和销毁线程的开销，能够提高性能。</li><li>适用于处理大量短任务，避免了频繁创建和销毁线程的开销。</li></ul><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>使用 <code>ThreadPool.QueueUserWorkItem</code> 提交任务的代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 向线程池队列中添加多个任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            <span class="hljs-comment">// i是PrintNumbers()的参数</span><br>            <span class="hljs-comment">// 设置最大工作线程数量为 10，最大异步 IO 线程数量为 5</span><br>            <span class="hljs-comment">// ThreadPool.SetMaxThreads(10, 5);</span><br>            <span class="hljs-comment">// 如果你提交了 15 个计算任务（需要工作线程），</span><br>            <span class="hljs-comment">// 线程池会调度最多 10 个工作线程来执行这些任务。</span><br>            <span class="hljs-comment">// 同时，如果还有 10 个异步文件读取操作（需要异步 IO 线程），</span><br>            <span class="hljs-comment">// 线程池最多会使用 5 个线程来处理这些异步 IO 操作。</span><br>            ThreadPool.QueueUserWorkItem(PrintNumbers, i);<br>        &#125;<br><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>        <span class="hljs-comment">// 等待用户输入以防程序提前结束</span><br>        Console.ReadLine();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> state</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> num = (<span class="hljs-built_in">int</span>)state;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;任务 <span class="hljs-subst">&#123;num&#125;</span> 输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟工作负载</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，主线程提交了多个任务到线程池，线程池会处理这些任务，而主线程则继续执行其他操作。具体有多少个线程被创建会根据线程池的管理策略而变化。</p><h3 id="多线程的常见问题"><a href="#多线程的常见问题" class="headerlink" title="多线程的常见问题"></a>多线程的常见问题</h3><ul><li><strong>线程安全</strong>：多个线程访问共享资源时，可能会出现竞争条件，导致数据不一致。可以使用锁 (<code>lock</code>) 或同步机制解决。</li><li><strong>死锁</strong>：两个或多个线程互相等待对方释放资源，导致程序无法继续执行。</li><li><strong>资源管理</strong>：创建太多线程可能会耗尽系统资源，应该合理使用线程池或任务。</li></ul><h3 id="线程安全的例子"><a href="#线程安全的例子" class="headerlink" title="线程安全的例子"></a>线程安全的例子</h3><p>使用 <code>lock</code> 关键字防止多个线程同时访问共享资源：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> _lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IncrementCounter</span>()</span><br>&#123;<br><span class="hljs-comment">// lock(引用类型对象)</span><br>    <span class="hljs-keyword">lock</span> (_lock)<br>    &#123;<br>        _counter++;<br>        Console.WriteLine(<span class="hljs-string">$&quot;计数器值: <span class="hljs-subst">&#123;_counter&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多线程是一个复杂而强大的工具，正确使用可以显著提高程序的性能和响应性。</p><h1 id="68-关闭死循环的线程"><a href="#68-关闭死循环的线程" class="headerlink" title="68. 关闭死循环的线程"></a>68. 关闭死循环的线程</h1><p>如果一个线程进入了死循环，需要通过合适的方法来关闭或释放它，以避免资源浪费或程序无法正常退出。可以使用以下几种方法来处理：</p><h3 id="1-使用线程间的信号（如-bool-标志位）"><a href="#1-使用线程间的信号（如-bool-标志位）" class="headerlink" title="1. 使用线程间的信号（如 bool 标志位）"></a>1. 使用线程间的信号（如 <code>bool</code> 标志位）</h3><ul><li>在线程执行的死循环中检查一个 <code>bool</code> 标志位，当需要退出时，设置这个标志位来结束循环，从而退出线程。<br><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> keepRunning = <span class="hljs-literal">true</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ThreadMethod</span>()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (keepRunning)<br>    &#123;<br>        <span class="hljs-comment">// 执行任务</span><br>        Thread.Sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟一些工作</span><br>    &#125;<br>    Console.WriteLine(<span class="hljs-string">&quot;线程已终止&quot;</span>);<br>&#125;<br><br>Thread thread = <span class="hljs-keyword">new</span> Thread(ThreadMethod);<br>thread.Start();<br><br><span class="hljs-comment">// 需要终止线程时，将标志位设为 false</span><br>keepRunning = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-使用-CancellationToken"><a href="#2-使用-CancellationToken" class="headerlink" title="2. 使用 CancellationToken"></a>2. 使用 <code>CancellationToken</code></h3><ul><li><code>CancellationToken</code> 是专为取消异步任务和线程而设计的机制，可以在需要时向线程发送取消请求。<br><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        CancellationTokenSource cancellationTokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ThreadMethod</span>(<span class="hljs-params">CancellationToken token</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">while</span> (!token.IsCancellationRequested)<br>            &#123;<br>                <span class="hljs-comment">// 执行任务</span><br>                Thread.Sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟一些工作</span><br>            &#125;<br>            Console.WriteLine(<span class="hljs-string">&quot;线程已取消&quot;</span>);<br>        &#125;<br><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt; ThreadMethod(cancellationTokenSource.Token));<br>        thread.Start();<br><br>        <span class="hljs-comment">// 需要终止线程时，调用 Cancel 方法</span><br>        cancellationTokenSource.Cancel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-使用-Abort-方法（不推荐）"><a href="#3-使用-Abort-方法（不推荐）" class="headerlink" title="3. 使用 Abort() 方法（不推荐）"></a>3. 使用 <code>Abort()</code> 方法（不推荐）</h3><ul><li>在非常特殊的情况下，可以调用 <code>Thread.Abort()</code> 强制终止线程，不过这种方法不安全，可能会导致资源没有正确释放和程序的不稳定性。</li><li>在 .NET Core 和 .NET 5 及更高版本中，<code>Thread.Abort()</code> 已被移除。</li><li><code>System.PlatformNotSupportedException:“Thread abort is not supported on this platform.”</code><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Thread thread = <span class="hljs-keyword">new</span> Thread();<br>thread.Abort();<br>thread = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-使用-Join-等待线程退出"><a href="#4-使用-Join-等待线程退出" class="headerlink" title="4. 使用 Join() 等待线程退出"></a>4. 使用 <code>Join()</code> 等待线程退出</h3><ul><li>配合上述方法使用 <code>Join()</code> 等待线程完成，有助于确保线程在主线程结束前正确退出。</li></ul><h3 id="5-CancellationToken-感觉和bool标志位一样啊，有什么优势"><a href="#5-CancellationToken-感觉和bool标志位一样啊，有什么优势" class="headerlink" title="5. CancellationToken 感觉和bool标志位一样啊，有什么优势"></a>5. CancellationToken 感觉和bool标志位一样啊，有什么优势</h3><p><code>CancellationToken</code> 和 <code>bool</code> 标志位在某种程度上都可以用于控制线程的停止，但 <code>CancellationToken</code> 提供了一些更强大和灵活的功能。以下是它们之间的主要区别和 <code>CancellationToken</code> 的优势：</p><h4 id="1-更强的并发控制"><a href="#1-更强的并发控制" class="headerlink" title="1. 更强的并发控制"></a>1. <strong>更强的并发控制</strong></h4><ul><li><strong>CancellationToken</strong> 可以与多个任务、线程或异步操作一起使用，允许它们共享同一个取消请求。这使得在复杂的并发场景中更容易管理任务的取消。</li><li><strong>标志位</strong> 通常只在单个线程中使用，不便于在多个线程之间共享。</li></ul><h4 id="2-内置机制"><a href="#2-内置机制" class="headerlink" title="2. 内置机制"></a>2. <strong>内置机制</strong></h4><ul><li><code>CancellationToken</code> 是 .NET 中设计的一个专门用于取消操作的机制，提供了一种标准的方式来处理取消请求。它通过 <code>CancellationTokenSource</code> 提供了一个清晰的结构。</li><li>使用 <strong>标志位</strong> 时，开发者需要手动管理状态，容易引入错误，比如忘记检查标志位。</li></ul><h4 id="3-可取消操作的通知"><a href="#3-可取消操作的通知" class="headerlink" title="3. 可取消操作的通知"></a>3. <strong>可取消操作的通知</strong></h4><ul><li>使用 <code>CancellationToken</code>，可以很方便地在执行操作时检查取消请求。例如，在异步方法中，可以传递 <code>CancellationToken</code>，在特定的点检查是否被取消。</li><li>通过 <code>CancellationToken</code>，还可以在需要的地方抛出 <code>OperationCanceledException</code>，提供更明确的取消处理逻辑。</li></ul><h4 id="4-与-Task-并行库的兼容性"><a href="#4-与-Task-并行库的兼容性" class="headerlink" title="4. 与 Task 并行库的兼容性"></a>4. <strong>与 Task 并行库的兼容性</strong></h4><ul><li><code>CancellationToken</code> 与 Task 并行库（TPL）紧密集成，可以在使用 <code>Task</code> 的场景中直接使用，比如 <code>Task.Run</code>、<code>async/await</code> 结构中，允许更自然的取消行为。</li><li><strong>标志位</strong> 需要额外的逻辑来与 <code>Task</code> 一起使用，整合不如 <code>CancellationToken</code> 流畅。</li></ul><h4 id="5-异步操作的支持"><a href="#5-异步操作的支持" class="headerlink" title="5. 异步操作的支持"></a>5. <strong>异步操作的支持</strong></h4><ul><li>在异步编程中，<code>CancellationToken</code> 是非常有用的，可以在执行异步操作时轻松管理取消逻辑。</li><li>使用 <strong>标志位</strong> 可能会导致代码的可读性下降，因为你需要在每个异步方法中手动传递和检查标志位。</li></ul><h5 id="使用-CancellationToken"><a href="#使用-CancellationToken" class="headerlink" title="使用 CancellationToken"></a>使用 <code>CancellationToken</code></h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>CancellationToken token = cts.Token;<br><br>Task.Run(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        token.ThrowIfCancellationRequested();<br>        Console.WriteLine(i);<br>        Thread.Sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;, token);<br><br><span class="hljs-comment">// 取消操作</span><br>cts.Cancel();<br></code></pre></td></tr></table></figure><h5 id="使用-bool-标志位"><a href="#使用-bool-标志位" class="headerlink" title="使用 bool 标志位"></a>使用 <code>bool</code> 标志位</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> keepRunning = <span class="hljs-literal">true</span>;<br><br>Task.Run(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!keepRunning) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(i);<br>        Thread.Sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 取消操作</span><br>keepRunning = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>CancellationToken</strong> 提供了一个更强大和灵活的方式来管理取消请求，特别是在复杂的并发和异步编程中。</li><li>虽然 <code>bool</code> 标志位可以简单地实现基本的取消逻辑，但在需要更复杂或可重用的取消机制时，<code>CancellationToken</code> 是更推荐的选择。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>使用标志位和 <code>CancellationToken</code> 是更推荐的做法</strong>，因为它们允许线程在执行任务时检查退出条件，能够安全地终止线程。</li><li>**避免使用 <code>Thread.Abort()</code>**，除非没有其他选择。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/zh-cn/">MS-Learning</a><br><a href="https://www.cnblogs.com/VVStudy/p/11404300.html" title="发布于 2019-08-28 12:04">C# - 协变、逆变 看完这篇就懂了</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSharp知识整理(三)</title>
    <link href="/2024/10/26/Csharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%89)/"/>
    <url>/2024/10/26/Csharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h1 id="39-命名空间"><a href="#39-命名空间" class="headerlink" title="39. 命名空间"></a>39. 命名空间</h1><blockquote><p>命名空间（Namespace）是 C# 中用于组织代码的一种方式。它提供了一种机制来将相关的类、结构、接口、枚举和委托分组在一起，从而避免名称冲突，并提供更好的代码管理和结构。</p></blockquote><ul><li>命名空间中的类，默认为internal</li><li>internal表示只能在该程序集中使用，也就是只能在当前的项目中使用</li><li>不同命名空间中允许有同名类</li><li>命名空间中可以包裹命名空间</li></ul><h3 id="1-创建命名空间"><a href="#1-创建命名空间" class="headerlink" title="1. 创建命名空间"></a>1. 创建命名空间</h3><p>可以使用 <code>namespace</code> 关键字定义一个命名空间。以下是一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>        &#123;<br>            Radius = radius;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>        &#123;<br>            Width = width;<br>            Height = height;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Width * Height;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用命名空间"><a href="#2-使用命名空间" class="headerlink" title="2. 使用命名空间"></a>2. 使用命名空间</h3><p>在使用命名空间中的类时，您可以使用完整名称，或者使用 <code>using</code> 指令来引入命名空间，以便在代码中更方便地使用它们。</p><h4 id="完整名称"><a href="#完整名称" class="headerlink" title="完整名称"></a>完整名称</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Geometry.Circle circle = <span class="hljs-keyword">new</span> Geometry.Circle(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>);<br><br>        Geometry.Rectangle rectangle = <span class="hljs-keyword">new</span> Geometry.Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-using-指令"><a href="#使用-using-指令" class="headerlink" title="使用 using 指令"></a>使用 <code>using</code> 指令</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> Geometry; <span class="hljs-comment">// 引入 Geometry 命名空间</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>);<br><br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-嵌套命名空间"><a href="#3-嵌套命名空间" class="headerlink" title="3. 嵌套命名空间"></a>3. 嵌套命名空间</h3><p>C# 还支持嵌套命名空间，可以通过在命名空间中定义另一个命名空间来实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span><br>&#123;<br>    <span class="hljs-keyword">namespace</span> <span class="hljs-title">Shapes</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span><br>        &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Base &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Triangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> baseLength, <span class="hljs-built_in">double</span> height</span>)</span><br>            &#123;<br>                Base = baseLength;<br>                Height = height;<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * Base * Height;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用嵌套命名空间时，可以这样访问：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Geometry.Shapes;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Triangle triangle = <span class="hljs-keyword">new</span> Triangle(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Triangle Area: <span class="hljs-subst">&#123;triangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-在同一文件中定义命名空间"><a href="#4-在同一文件中定义命名空间" class="headerlink" title="4. 在同一文件中定义命名空间"></a>4. 在同一文件中定义命名空间</h3><p>在一个文件中定义多个类，并将它们放在同一个命名空间下。<br><strong>文件名：<code>Geometry.cs</code></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span> <span class="hljs-comment">// 命名空间</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>        &#123;<br>            Radius = radius;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>        &#123;<br>            Width = width;<br>            Height = height;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Width * Height;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> Geometry; <span class="hljs-comment">// 引入 Geometry 命名空间</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>);<br><br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-将命名空间分散到多个文件中"><a href="#5-将命名空间分散到多个文件中" class="headerlink" title="5. 将命名空间分散到多个文件中"></a>5. 将命名空间分散到多个文件中</h3><p>可以在多个文件中定义属于同一个命名空间的类。这样做有助于代码的模块化和可维护性。<br><strong>文件名：<code>Circle.cs</code></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span> <span class="hljs-comment">// 命名空间</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>        &#123;<br>            Radius = radius;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>文件名：<code>Rectangle.cs</code></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span> <span class="hljs-comment">// 命名空间</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>        &#123;<br>            Width = width;<br>            Height = height;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Width * Height;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> Geometry; <span class="hljs-comment">// 引入 Geometry 命名空间</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>);<br><br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>命名空间</strong> 是组织代码的有力工具，帮助管理和避免名称冲突。</li><li>可以使用 <code>namespace</code> 关键字定义命名空间，并通过 <code>using</code> 指令引入命名空间。</li><li>支持嵌套命名空间，允许创建更复杂的结构以组织相关类。</li><li><strong>同一文件定义</strong>：在一个文件中定义多个类，适合小型项目或紧密相关的类。</li><li><strong>分散到多个文件</strong>：将类分散到多个文件中，每个文件定义一个类，适合较大项目，能够提高可维护性和可读性。</li></ul><h1 id="40-Object中的方法"><a href="#40-Object中的方法" class="headerlink" title="40. Object中的方法"></a>40. Object中的方法</h1><p><a href="https://imgse.com/i/pA0EdxK"><img src="https://s21.ax1x.com/2024/10/26/pA0EdxK.png" alt="pA0EdxK.png"></a><br>在 C# 中，<code>Object</code> 是所有类型的基类。每个类、结构、接口等都隐式地继承自 <code>Object</code>，因此它包含了一些通用的方法，这些方法可以在任何对象上调用。以下是 <code>Object</code> 类中的一些重要方法：</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="1-ToString"><a href="#1-ToString" class="headerlink" title="1 ToString()"></a>1 <code>ToString()</code></h4><ul><li><strong>描述</strong>: 返回对象的字符串表示形式。</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;Name&#125;</span>&quot;</span>;<br>    &#125;<br>&#125;<br><br>Person person = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>Console.WriteLine(person.ToString()); <span class="hljs-comment">// 输出: Name: Alice</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Equals-Object-obj"><a href="#2-Equals-Object-obj" class="headerlink" title="2 Equals(Object obj)"></a>2 <code>Equals(Object obj)</code></h4><ul><li><strong>描述</strong>: 确定两个对象是否相等。默认实现比较对象的引用（即内存地址），可以在子类中重写该方法来比较对象的内容。</li><li>还有一个是静态实现的</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? obj</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Person other)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Name == other.Name; <span class="hljs-comment">// 比较名称</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person p1 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        Person p2 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        Console.WriteLine(p1.Equals(p2)); <span class="hljs-comment">// 输出: True</span><br>        Console.WriteLine(Object.Equals(p1, p2)); <span class="hljs-comment">// 输出: True</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-GetHashCode"><a href="#3-GetHashCode" class="headerlink" title="3 GetHashCode()"></a>3 <code>GetHashCode()</code></h4><ul><li><strong>描述</strong>: 返回对象的哈希代码。通常与 <code>Equals()</code> 一起重写，以确保相等的对象具有相同的哈希值。</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? obj</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Person other)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Name == other.Name; <span class="hljs-comment">// 比较名称</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Name.GetHashCode(); <span class="hljs-comment">// 根据名称生成哈希代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person p1 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        Person p2 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        Console.WriteLine(p1.Equals(p2)); <span class="hljs-comment">// 输出: True</span><br>        Console.WriteLine(Object.Equals(p1, p2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-GetType"><a href="#4-GetType" class="headerlink" title="4 GetType()"></a>4 <code>GetType()</code></h4><ul><li><strong>描述</strong>: 获取当前实例的 <code>Type</code> 对象，该对象表示当前实例的类型。</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> PersonSpace;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">PersonSpace</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? obj</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Person other)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Name == other.Name; <span class="hljs-comment">// 比较名称</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Name.GetHashCode(); <span class="hljs-comment">// 根据名称生成哈希代码</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        Type type = person.GetType();<br>        Console.WriteLine(type);<span class="hljs-comment">// 输出: Namespace.Person，如果没有命名空间输出Person</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-Finalize"><a href="#5-Finalize" class="headerlink" title="5 Finalize()"></a>5 <code>Finalize()</code></h4><ul><li><strong>描述</strong>: 释放对象所占用的资源。在垃圾回收过程中被调用，通常不需要手动调用。可以重写来定义释放非托管资源的逻辑。</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    ~Person()<br>    &#123;<br>        <span class="hljs-comment">// 清理代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-public-static-bool-ReferenceEquals-object-objA-object-objB"><a href="#6-public-static-bool-ReferenceEquals-object-objA-object-objB" class="headerlink" title="6 public static bool ReferenceEquals(object objA, object objB);"></a>6 <code>public static bool ReferenceEquals(object objA, object objB);</code></h4><ul><li><strong>描述</strong>: <code>Object.ReferenceEquals()</code> 是 C# 中的一个静态方法，用于比较两个对象的引用是否相同。它直接检查两个对象的内存地址，以确定它们是否指向同一个实例。这个方法与 <code>Equals</code> 方法不同， <code>Equals</code>通常用于检查对象内容是否相等，而 <code>ReferenceEquals</code> 专注于引用的比较。</li><li>值类型对象返回值始终是false</li></ul><h3 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ReferenceEquals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> objA, <span class="hljs-built_in">object</span> objB</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><code>objA</code>：第一个要比较的对象。</li><li><code>objB</code>：第二个要比较的对象。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回 <code>true</code> 如果 <code>objA</code> 和 <code>objB</code> 是同一个引用（即它们指向同一个对象），否则返回 <code>false</code>。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，展示了如何使用 <code>Object.ReferenceEquals</code> 方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建两个不同的对象</span><br>        <span class="hljs-built_in">object</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>        <span class="hljs-built_in">object</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>        <span class="hljs-comment">// 创建一个指向同一对象的引用</span><br>        <span class="hljs-built_in">object</span> obj3 = obj1;<br><br>        <span class="hljs-comment">// 比较对象引用</span><br>        Console.WriteLine(Object.ReferenceEquals(obj1, obj2)); <span class="hljs-comment">// 输出: False</span><br>        Console.WriteLine(Object.ReferenceEquals(obj1, obj3)); <span class="hljs-comment">// 输出: True</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ul><li><strong>比较两个不同的对象</strong>: 在上面的示例中，<code>obj1</code> 和 <code>obj2</code> 是两个不同的对象，因此 <code>Object.ReferenceEquals(obj1, obj2)</code> 返回 <code>false</code>。</li><li><strong>比较相同的对象引用</strong>: <code>obj3</code> 是对 <code>obj1</code> 的引用，因此 <code>Object.ReferenceEquals(obj1, obj3)</code> 返回 <code>true</code>。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><code>Object.ReferenceEquals</code> 通常用于需要明确区分对象的引用时，例如在性能敏感的代码中。</li><li>它可以用于确定对象是否为 <code>null</code>，因为比较 <code>null</code> 和非 <code>null</code> 对象时，<code>ReferenceEquals</code> 会返回 <code>false</code>。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>Object.ReferenceEquals</code> 不会触发任何重写的 <code>Equals</code> 方法，所以它的比较仅仅基于对象的引用，而不涉及内容的比较。</li><li>在比较值类型时，由于值类型通常在栈上分配，它们的比较通常是基于值而不是引用。因此，使用 <code>ReferenceEquals</code> 在比较值类型的实例时，效果有限。</li></ul><h1 id="41-System-ValueType"><a href="#41-System-ValueType" class="headerlink" title="41. System.ValueType"></a>41. System.ValueType</h1><p>在 C# 中，<code>System.ValueType</code> 是所有值类型的基类。所有的结构体（<code>struct</code>）和枚举（<code>enum</code>）都隐式地继承自 <code>ValueType</code>。理解 <code>ValueType</code> 的作用有助于更好地理解 C# 中的值类型及其行为。</p><h3 id="1-值类型与引用类型"><a href="#1-值类型与引用类型" class="headerlink" title="1. 值类型与引用类型"></a>1. 值类型与引用类型</h3><ul><li><strong>值类型</strong>：包含数据本身，存储在栈上（或内联分配在堆上）。例如，基本类型如 <code>int</code>、<code>double</code>、<code>char</code>，以及用户定义的结构体和枚举都是值类型。</li><li><strong>引用类型</strong>：包含指向数据的引用，存储在堆上。例如，类（<code>class</code>）、数组（<code>array</code>）和字符串（<code>string</code>）都是引用类型。</li></ul><h4 id="内联分配在堆上"><a href="#内联分配在堆上" class="headerlink" title="内联分配在堆上"></a>内联分配在堆上</h4><p>在 C# 中，值类型通常分配在栈上，但在某些情况下，它们也可以内联分配在堆上。这里是一些详细的解释：</p><h5 id="1-值类型的基本特性"><a href="#1-值类型的基本特性" class="headerlink" title="1. 值类型的基本特性"></a>1. 值类型的基本特性</h5><ul><li><strong>栈分配</strong>：值类型通常直接存储在栈上。当一个值类型变量被声明时，它的值会被直接分配到栈内存中。例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// x 存储在栈上</span><br></code></pre></td></tr></table></figure></li><li><strong>堆分配</strong>：虽然值类型通常在栈上分配，但在某些情况下，它们会被分配到堆上。这种情况主要发生在以下场景中：</li><li><strong>作为引用类型的字段</strong>：当值类型作为类的字段时，该值类型的实例会存储在堆上，因为类是引用类型。例如： <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyValue; <span class="hljs-comment">// MyValue 是值类型，但它存储在堆上</span><br>&#125;<br><br>MyClass obj = <span class="hljs-keyword">new</span> MyClass(); <span class="hljs-comment">// obj 的地址在堆上</span><br>obj.MyValue = <span class="hljs-number">10</span>; <span class="hljs-comment">// MyValue 存储在 obj 所在的堆内存中</span><br></code></pre></td></tr></table></figure></li><li><strong>内联分配</strong>：在某些情况下，值类型可以被 “内联分配” 在堆上，这意味着它们的值会被直接嵌入到包含它们的对象中。这种情况通常发生在使用 <strong>结构体</strong> 作为类字段时。例如：    <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> MyStruct<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span><br>&#123;<br>    <span class="hljs-keyword">public</span> MyStruct myStruct; <span class="hljs-comment">// myStruct 是值类型，但内联存储在堆上</span><br>&#125;<br><br>Container container = <span class="hljs-keyword">new</span> Container(); <span class="hljs-comment">// container 存储在堆上</span><br>container.myStruct.Value = <span class="hljs-number">42</span>; <span class="hljs-comment">// myStruct 的数据存储在 container 的堆内存中</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-值类型在堆中的存储"><a href="#2-值类型在堆中的存储" class="headerlink" title="2. 值类型在堆中的存储"></a>2. 值类型在堆中的存储</h5><ul><li>当值类型作为类的字段或属性时，它们的实例实际上会存储在堆上。这个特性使得值类型可以在类的生命周期内存在，并且可以通过引用访问。例如，当你创建一个类实例并使用该类的字段时，字段值会在堆上分配。</li><li>在内联分配的情况下，值类型的内存布局会与引用类型相结合，以提高性能。这种内联分配允许在一个对象中组合多个值类型和引用类型，避免了不必要的内存分配。</li></ul><h5 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h5><ul><li><strong>栈分配</strong>：值类型通常直接在栈上分配。</li><li><strong>堆分配</strong>：当值类型作为类字段时，它们的值在堆上分配。</li><li><strong>内联分配</strong>：值类型可以内联到对象中，优化内存使用和性能。</li></ul><h3 id="2-ValueType-的主要特性"><a href="#2-ValueType-的主要特性" class="headerlink" title="2. ValueType 的主要特性"></a>2. <code>ValueType</code> 的主要特性</h3><ul><li><strong>封装</strong>：<code>ValueType</code> 提供了一些基本的行为实现，例如 <code>Equals()</code>、<code>GetHashCode()</code> 和 <code>ToString()</code> 方法。这些方法可以在值类型的实例上被调用。</li><li><strong>值语义</strong>：当值类型被赋值给另一个变量或作为参数传递时，整个对象的值被复制。这与引用类型不同，后者只复制引用。</li><li><strong>装箱和拆箱</strong>：值类型可以被装箱（将其转换为 <code>object</code> 类型）和拆箱（将其从 <code>object</code> 转换回值类型），这会引入额外的性能开销。</li></ul><h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><p>以下是一个简单的示例，演示了如何使用值类型和 <code>ValueType</code> 的一些特性：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">struct</span> MyStruct : IComparable<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStruct</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Value = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CompareTo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> MyStruct other)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Value.CompareTo(other.Value);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Object is not a MyStruct&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Value.ToString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyStruct struct1 = <span class="hljs-keyword">new</span> MyStruct(<span class="hljs-number">10</span>);<br>        MyStruct struct2 = <span class="hljs-keyword">new</span> MyStruct(<span class="hljs-number">20</span>);<br><br>        Console.WriteLine(struct1.ToString()); <span class="hljs-comment">// 输出: 10</span><br>        Console.WriteLine(struct2.ToString()); <span class="hljs-comment">// 输出: 20</span><br><br>        Console.WriteLine(struct1.Equals(struct2)); <span class="hljs-comment">// 输出: False</span><br><br>        <span class="hljs-comment">// 装箱</span><br>        <span class="hljs-built_in">object</span> boxed = struct1;<br>        <span class="hljs-comment">// 拆箱</span><br>        MyStruct unboxed = (MyStruct)boxed;<br><br>        Console.WriteLine(unboxed.ToString()); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-重要方法"><a href="#4-重要方法" class="headerlink" title="4. 重要方法"></a>4. 重要方法</h3><p><code>ValueType</code> 提供了几个重要的方法，通常被重写以支持特定的值类型：</p><ul><li>**<code>Equals(object obj)</code>**：判断当前实例与给定对象是否相等。默认实现比较引用，通常应被重写以比较值。</li><li>**<code>GetHashCode()</code>**：返回当前对象的哈希代码，通常应根据对象的字段重写。</li><li>**<code>ToString()</code>**：返回当前对象的字符串表示形式，通常应被重写以提供有意义的输出。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>System.ValueType</code> 是 C# 中所有值类型的基类，提供了一些基础方法和值语义的支持。理解值类型的行为及其与引用类型的区别，对于有效地编写 C# 代码至关重要。通过实现自定义结构体和重写 <code>ValueType</code> 中的方法，可以创建更丰富的值类型功能。</p><h1 id="42-string相关方法和操作"><a href="#42-string相关方法和操作" class="headerlink" title="42. string相关方法和操作"></a>42. string相关方法和操作</h1><p>在 C# 中，<code>string</code> 是一个常用的引用类型，表示不可变的文本序列。以下是一些常用的 <code>string</code> 相关方法和操作：</p><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><ul><li><strong>创建字符串</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 创建 &quot;aaaaa&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>字符串拼接</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str3 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">string</span> str4 = <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-built_in">string</span> result = str3 + <span class="hljs-string">&quot;, &quot;</span> + str4 + <span class="hljs-string">&quot;!&quot;</span>; <span class="hljs-comment">// &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>字符串格式化</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> age = <span class="hljs-number">25</span>;<br><span class="hljs-built_in">string</span> formattedString = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;I am &#123;0&#125; years old.&quot;</span>, age); <span class="hljs-comment">// &quot;I am 25 years old.&quot;</span><br><span class="hljs-built_in">string</span> interpolatedString = <span class="hljs-string">$&quot;I am <span class="hljs-subst">&#123;age&#125;</span> years old.&quot;</span>; <span class="hljs-comment">// 使用字符串插值</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h3><ul><li>**<code>Length</code>**：获取字符串的长度。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">int</span> length = str.Length; <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure></li><li>**<code>ToUpper()</code> &#x2F; <code>ToLower()</code>**：将字符串转换为大写或小写。</li><li>不会改变原字符串<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> upper = str.ToUpper(); <span class="hljs-comment">// &quot;HELLO&quot;</span><br><span class="hljs-built_in">string</span> lower = str.ToLower(); <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure></li><li>**<code>Trim()</code> &#x2F; <code>TrimStart()</code> &#x2F; <code>TrimEnd()</code>**：去除字符串开头或结尾的空白字符。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> strWithSpaces = <span class="hljs-string">&quot;  Hello  &quot;</span>;<br><span class="hljs-built_in">string</span> trimmed = strWithSpaces.Trim(); <span class="hljs-comment">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li><li>**<code>Substring(int startIndex)</code>**：从指定位置开始截取后续字符串的全部。</li><li>**<code>Substring(int startIndex, int length)</code>**：从指定位置开始截取字符串的一部分。<ul><li>Substring有第二个参数的时候会要求<code>startIndex+length</code>小于等于str长度，否则报错<code>System.ArgumentOutOfRangeException</code></li></ul></li><li>不会改变原字符串<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> subAll = str.Substring(<span class="hljs-number">1</span>); <span class="hljs-comment">// &quot;ello&quot;</span><br><span class="hljs-built_in">string</span> sub = str.Substring(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// &quot;ell&quot;</span><br></code></pre></td></tr></table></figure></li><li>**<code>Contains(string value)</code>**：检查字符串是否包含指定的子字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> contains = str.Contains(<span class="hljs-string">&quot;ell&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li>**<code>StartsWith(string value)</code> &#x2F; <code>EndsWith(string value)</code>**：检查字符串是否以指定的子字符串开头或结尾。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> startsWith = str.StartsWith(<span class="hljs-string">&quot;He&quot;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">bool</span> endsWith = str.EndsWith(<span class="hljs-string">&quot;lo&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li>**<code>IndexOf(string value)</code> &#x2F; <code>LastIndexOf(string value)</code>**：返回指定子字符串的第一个或最后一个出现的位置。</li><li>字符可以是中文</li><li>没找到返回-1<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> index = str.IndexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">int</span> lastIndex = str.LastIndexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li><li>**<code>Replace(string oldValue, string newValue)</code>**：替换字符串中的<code>所有</code>匹配子字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> replaced = str.Replace(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>); <span class="hljs-comment">// &quot;Hexxo&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-字符串分割与连接"><a href="#3-字符串分割与连接" class="headerlink" title="3. 字符串分割与连接"></a>3. 字符串分割与连接</h3><ul><li>**<code>Split(char[] separator)</code>**：根据指定字符分隔符分割字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span>[] words = sentence.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span> &#125;); <span class="hljs-comment">// &#123;&quot;Hello&quot;, &quot;&quot;, &quot;World!&quot;&#125;</span><br></code></pre></td></tr></table></figure></li><li>**<code>Join(string separator, string[] values)</code>**：连接字符串数组中的元素。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>[] array = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br><span class="hljs-built_in">string</span> joined = <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, array); <span class="hljs-comment">// &quot;Hello, World&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-字符串比较"><a href="#4-字符串比较" class="headerlink" title="4. 字符串比较"></a>4. 字符串比较</h3><ul><li>**<code>Equals(string value)</code>**：比较字符串是否相等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> isEqual = str.Equals(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li>**<code>Compare(string strA, string strB)</code>**：比较两个字符串的大小。</li><li>每个字符的比较是基于其 <code>Unicode 编码值</code>的大小。</li><li>A小于B，a小于b</li><li>A小于a<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> comparisonResult = <span class="hljs-built_in">string</span>.Compare(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;xyz&quot;</span>); <span class="hljs-comment">// 返回负数，表示 &quot;abc&quot; 小于 &quot;xyz&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-其他操作"><a href="#5-其他操作" class="headerlink" title="5. 其他操作"></a>5. 其他操作</h3><ul><li>**<code>IsNullOrEmpty(string value)</code>**：检查字符串是否为 <code>null</code> 或空字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> isNullOrEmpty = <span class="hljs-built_in">string</span>.IsNullOrEmpty(str); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li>**<code>IsNullOrWhiteSpace(string value)</code>**：检查字符串是否为 <code>null</code>、空字符串或仅包含空白字符。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> isNullOrWhiteSpace = <span class="hljs-built_in">string</span>.IsNullOrWhiteSpace(<span class="hljs-string">&quot;   &quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-不可变性和性能"><a href="#6-不可变性和性能" class="headerlink" title="6. 不可变性和性能"></a>6. 不可变性和性能</h3><p>由于字符串是不可变的，每次执行类似于 <code>Replace</code>、<code>ToUpper</code> 等操作时，都会创建一个新的字符串对象。这会带来一些性能开销，因此如果需要大量字符串操作，建议使用 <code>StringBuilder</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Text;<br><br>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>sb.Append(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.Append(<span class="hljs-string">&quot;, &quot;</span>);<br>sb.Append(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-built_in">string</span> finalString = sb.ToString(); <span class="hljs-comment">// &quot;Hello, World&quot;</span><br></code></pre></td></tr></table></figure><p>这些方法和操作涵盖了 C# 中 <code>string</code> 类型的常用功能，有助于处理各种字符串操作需求。</p><h3 id="7-移除指定位置后的字符"><a href="#7-移除指定位置后的字符" class="headerlink" title="7. 移除指定位置后的字符"></a>7. 移除指定位置后的字符</h3><p>在 C# 中，<code>string.Remove</code> 方法用于删除字符串中的某一部分。这个方法会返回一个新的字符串，因为字符串在 C# 中是不可变的（即操作后原字符串不会被改变）。</p><h4 id="方法签名-1"><a href="#方法签名-1" class="headerlink" title="方法签名"></a>方法签名</h4><p><code>string.Remove</code> 有两个重载版本：</p><ol><li>**<code>Remove(int startIndex)</code>**：删除从指定索引处开始的所有字符。</li><li>**<code>Remove(int startIndex, int count)</code>**：删除从指定索引处开始的指定数量的字符。</li></ol><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>startIndex</code>：要开始删除的字符的零基索引位置。</li><li><code>count</code>（可选）：要删除的字符数。不填，则后续的所有字符都删除</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol><li><strong>删除从指定索引开始的所有字符</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> result = str.Remove(<span class="hljs-number">5</span>); <span class="hljs-comment">// 从索引 5 开始删除，即删除 &quot;, World!&quot;</span><br><br>Console.WriteLine(result); <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>删除从指定索引开始的指定数量的字符</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> result = str.Remove(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 从索引 7 开始删除 5 个字符，即删除 &quot;World&quot;</span><br><br>Console.WriteLine(result); <span class="hljs-comment">// 输出 &quot;Hello, !&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>如果 <code>startIndex</code> 超出字符串的范围，会抛出 <code>ArgumentOutOfRangeException</code>。</li><li>如果 <code>count</code> 的值导致删除的范围超出字符串的长度，也会抛出 <code>ArgumentOutOfRangeException</code>。</li><li><code>Remove</code> 方法不会修改原始字符串，而是返回一个新的字符串。</li></ul><h3 id="8-字符串分割"><a href="#8-字符串分割" class="headerlink" title="8. 字符串分割"></a>8. 字符串分割</h3><p>在 C# 中，<code>string.Split</code> 方法用于将字符串拆分为子字符串数组，基于一个或多个分隔符。分割后的子字符串不包含分隔符。</p><h4 id="方法签名-2"><a href="#方法签名-2" class="headerlink" title="方法签名"></a>方法签名</h4><p><code>string.Split</code> 有多种重载，常用的有以下几种：</p><ol><li><code>Split(char[] separator)</code> ：使用一个或多个字符作为分隔符进行分割。</li><li><code>Split(char[] separator, int count)</code> ：使用分隔符进行分割，并限定返回的子字符串的数量。</li><li><code>Split(char[] separator, StringSplitOptions options)</code> ：使用分隔符进行分割，并通过 <code>StringSplitOptions</code> 控制是否移除空字符串。</li><li><code>Split(string[] separator, StringSplitOptions options)</code>：使用字符串数组作为分隔符。</li></ol><h4 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>separator</code>：用于分割的字符数组或字符串数组。如果传入 <code>null</code> 或空数组，则使用空白字符（如空格、制表符）作为默认分隔符。</li><li><code>count</code>：限定返回的子字符串数量。</li><li><code>options</code>：<code>StringSplitOptions</code> 枚举，用于控制是否移除空字符串。可以为 <code>StringSplitOptions.None</code>（不移除空字符串）或 <code>StringSplitOptions.RemoveEmptyEntries</code>（移除空字符串）。</li><li>‘,’也是一个<code>char[]</code>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br><br><span class="hljs-comment">// 使用字符数组作为分隔符</span><br><span class="hljs-built_in">string</span>[] fruits1 = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27;,&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 使用单个字符作为分隔符，自动转换为字符数组</span><br><span class="hljs-built_in">string</span>[] fruits2 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>);<br><br><span class="hljs-comment">// 两种方式的结果是相同的</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits1)<br>&#123;<br>    Console.WriteLine(fruit); <span class="hljs-comment">// 输出: apple, banana, orange</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><ol><li><strong>使用单个字符分隔符</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>); <span class="hljs-comment">// 使用逗号分隔</span><br><br><span class="hljs-comment">// 输出: apple, banana, orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>使用多个字符作为分隔符</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple;banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;;&#x27;</span> &#125;); <span class="hljs-comment">// 使用逗号和分号分隔</span><br><br><span class="hljs-comment">// 输出: apple, banana, orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>限定返回的子字符串数量</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27;,&#x27;</span> &#125;, <span class="hljs-number">2</span>); <span class="hljs-comment">// 只分割成两个子字符串</span><br><br><span class="hljs-comment">// 输出: apple, banana,orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>移除空字符串</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,,banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27;,&#x27;</span> &#125;, StringSplitOptions.RemoveEmptyEntries); <span class="hljs-comment">// 移除空字符串</span><br><br><span class="hljs-comment">// 输出: apple, banana, orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>使用字符串作为分隔符</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple#banana#orange&quot;</span>;<br><span class="hljs-comment">// string[] fruits = str.Split(new char[] &#123; &#x27;#&#x27; &#125;, StringSplitOptions.None); // 使用 &#x27;#&#x27; 作为分隔符一样的</span><br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;#b&quot;</span> &#125;, StringSplitOptions.None); <span class="hljs-comment">// 使用 &quot;#&quot; 作为分隔符，&quot;&quot;里面可以更长，比如&quot;#b&quot;</span><br><br><span class="hljs-comment">// 输出: apple anana#orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>Split</code> 返回的数组中可能包含空字符串，特别是在分隔符连续出现时。</li><li>如果需要移除结果中的空字符串，可以使用 <code>StringSplitOptions.RemoveEmptyEntries</code>。<br>  在 C# 中，<code>StringSplitOptions</code> 枚举用于控制 <code>string.Split</code> 方法的行为，它有三个可选值，分别是 <code>None</code>、<code>RemoveEmptyEntries</code> 和 <code>TrimEntries</code>，每个选项的作用如下：<h5 id="1-None"><a href="#1-None" class="headerlink" title="1. None"></a>1. <code>None</code></h5><ul><li>默认选项，值为 <code>0</code>。</li><li>当使用此选项时，<code>Split</code> 方法不会忽略空字符串，也不会去除空白字符。</li><li>返回的数组中会包含原字符串中所有的子字符串，即使其中有空字符串。</li></ul><h5 id="2-RemoveEmptyEntries"><a href="#2-RemoveEmptyEntries" class="headerlink" title="2. RemoveEmptyEntries"></a>2. <code>RemoveEmptyEntries</code></h5><ul><li>值为 <code>1</code>。</li><li>如果选择此选项，<code>Split</code> 方法会从返回的数组中移除任何空字符串。</li><li>空字符串通常出现在分隔符连续出现的情况下。</li><li>如果与 <code>TrimEntries</code> 结合使用，则仅包含空白字符的子字符串也会被移除。</li></ul><h5 id="3-TrimEntries-仅在-NET-5-及更高版本可用"><a href="#3-TrimEntries-仅在-NET-5-及更高版本可用" class="headerlink" title="3. TrimEntries (仅在 .NET 5 及更高版本可用)"></a>3. <code>TrimEntries</code> (仅在 .NET 5 及更高版本可用)</h5><ul><li>值为 <code>2</code>。</li><li>当使用此选项时，<code>Split</code> 方法会去除每个子字符串前后的空白字符。</li><li>如果与 <code>RemoveEmptyEntries</code> 结合使用，那么只包含空白字符的子字符串也会被移除。</li><li>组合使用<br>  <code>StringSplitOptions</code> 是一个带有 <code>[Flags]</code> 特性的枚举，可以组合多个选项一起使用。例如，使用 <code>RemoveEmptyEntries | TrimEntries</code> 可以同时移除空字符串并修剪子字符串中的空白字符。</li><li>示例  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot; apple , banana , , orange ,  &quot;</span>;<br><br><span class="hljs-comment">// 使用 StringSplitOptions.None，默认行为</span><br><span class="hljs-built_in">string</span>[] result1 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>, StringSplitOptions.None);<br><span class="hljs-comment">// 输出: &quot; apple &quot;, &quot; banana &quot;, &quot; &quot;, &quot; orange &quot;, &quot;  &quot;</span><br><br><span class="hljs-comment">// 使用 StringSplitOptions.RemoveEmptyEntries，移除空字符串</span><br><span class="hljs-built_in">string</span>[] result2 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>, StringSplitOptions.RemoveEmptyEntries);<br><span class="hljs-comment">// 输出: &quot; apple &quot;, &quot; banana &quot;, &quot; orange &quot;, &quot;  &quot;</span><br><br><span class="hljs-comment">// 使用 StringSplitOptions.TrimEntries，去除每个子字符串的空白</span><br><span class="hljs-built_in">string</span>[] result3 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>, StringSplitOptions.TrimEntries);<br><span class="hljs-comment">// 输出: &quot;apple&quot;, &quot;banana&quot;, &quot;&quot;, &quot;orange&quot;, &quot;&quot;</span><br><br><span class="hljs-comment">// 使用 StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries，组合行为</span><br><span class="hljs-built_in">string</span>[] result4 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);<br><span class="hljs-comment">// 输出: &quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="43-ArrayList"><a href="#43-ArrayList" class="headerlink" title="43. ArrayList"></a>43. ArrayList</h1><p><code>ArrayList</code> 是 C# 中的一个非泛型集合类，位于 <code>System.Collections</code> 命名空间中。它可以存储任何类型的对象，并且大小是动态调整的。尽管 <code>ArrayList</code> 具有灵活性和动态性，但因为它是非泛型的，通常在现代开发中会推荐使用泛型集合（如 <code>List&lt;T&gt;</code>）以获得更好的类型安全和性能。</p><h3 id="1-ArrayList-的特点"><a href="#1-ArrayList-的特点" class="headerlink" title="1. ArrayList 的特点"></a>1. <strong>ArrayList 的特点</strong></h3><ul><li><strong>非泛型集合</strong>：<code>ArrayList</code> 可以存储不同类型的对象（<code>object</code> 类型），但这会导致类型不安全和装箱&#x2F;拆箱的开销。</li><li><strong>动态大小</strong>：不像数组那样大小固定，<code>ArrayList</code> 的大小可以根据需要自动增加。</li><li><strong>实现了 <code>IList</code>、<code>ICollection</code> 和 <code>IEnumerable</code> 接口</strong>：因此，它可以与这些接口一起使用。</li></ul><h3 id="2-常用方法和属性"><a href="#2-常用方法和属性" class="headerlink" title="2. 常用方法和属性"></a>2. <strong>常用方法和属性</strong></h3><ul><li>**<code>Add(object value)</code>**：将对象添加到 <code>ArrayList</code> 的末尾。</li><li><code>AddRange(ICollection c)</code> 是 <code>ArrayList</code> 类中的一个方法，用于将一个集合中的元素添加到 <code>ArrayList</code> 的末尾。与 <code>Add</code> 方法不同的是，<code>AddRange</code> 可以一次性添加多个元素，而不是一个一个地添加。<ul><li><strong>支持不同的集合类型</strong>：只要实现了 <code>ICollection</code> 接口的集合，都可以使用 <code>AddRange</code> 方法添加。</li></ul></li><li>**<code>Insert(int index, object value)</code>**：在指定索引位置插入一个元素。</li><li>**<code>Remove(object value)</code>**：移除 <code>ArrayList</code> 中第一次出现的指定对象。</li><li>**<code>RemoveAt(int index)</code>**：移除指定索引处的元素。</li><li>**<code>Clear()</code>**：移除所有元素。</li><li>**<code>Contains(object value)</code>**：确定某个对象是否在 <code>ArrayList</code> 中。</li><li>**<code>IndexOf(object value)</code>**：返回指定对象在 <code>ArrayList</code> 中的第一个匹配项的索引。正向查找元素位置，找不到返回-1</li><li><code>LastIndexOf(object value)</code> 是 <code>ArrayList</code> 类中的一个方法，用于查找指定元素在 <code>ArrayList</code> 中最后一次出现的索引位置。这个方法从 <code>ArrayList</code> 的末尾向前搜索，返回匹配的元素的索引。<ul><li>**<code>LastIndexOf(object value, int startIndex)</code>**：从指定的索引位置向前搜索。</li><li>**<code>LastIndexOf(object value, int startIndex, int count)</code>**：从指定的索引位置开始，向前搜索指定数量的元素。</li></ul></li><li>**<code>Count</code>**：获取 <code>ArrayList</code> 中的元素数量。</li><li>**<code>Capacity</code>**：获取或设置 <code>ArrayList</code> 能够包含的元素数量。</li><li>**<code>Sort()</code>**：对 <code>ArrayList</code> 中的元素进行排序。</li><li>**<code>Reverse()</code>**：反转 <code>ArrayList</code> 中元素的顺序。</li></ul><h3 id="3-ArrayList-的使用示例"><a href="#3-ArrayList-的使用示例" class="headerlink" title="3. ArrayList 的使用示例"></a>3. <strong>ArrayList 的使用示例</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的 ArrayList</span><br>        ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.Add(<span class="hljs-number">1</span>);<br>        list.Add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        list.Add(<span class="hljs-number">3.14</span>);<br>        list.Add(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 插入元素</span><br>        list.Insert(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Inserted Element&quot;</span>);<br><br>        <span class="hljs-comment">// 遍历 ArrayList</span><br>        Console.WriteLine(<span class="hljs-string">&quot;ArrayList elements:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> list)<br>        &#123;<br>            Console.WriteLine(item);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否包含某个元素</span><br>        <span class="hljs-built_in">bool</span> containsHello = list.Contains(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;\nContains &#x27;Hello&#x27;: <span class="hljs-subst">&#123;containsHello&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 获取索引</span><br>        <span class="hljs-built_in">int</span> index = list.IndexOf(<span class="hljs-number">3.14</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Index of 3.14: <span class="hljs-subst">&#123;index&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 移除元素</span><br>        list.Remove(<span class="hljs-literal">true</span>);<br>        list.RemoveAt(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 清空 ArrayList</span><br>        list.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;\nArrayList count after clearing: <span class="hljs-subst">&#123;list.Count&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-ArrayList-的缺点"><a href="#4-ArrayList-的缺点" class="headerlink" title="4. ArrayList 的缺点"></a>4. <strong>ArrayList 的缺点</strong></h3><ul><li><strong>类型安全性差</strong>：因为 <code>ArrayList</code> 是非泛型的，它可以存储不同类型的数据，这在运行时可能会导致类型转换异常。</li><li><strong>装箱和拆箱的性能开销</strong>：对于值类型（如 <code>int</code>），在添加到 <code>ArrayList</code> 时需要装箱，将其转换为 <code>object</code> 类型，而在访问时又需要拆箱，带来性能损耗。</li></ul><h3 id="5-替代方案"><a href="#5-替代方案" class="headerlink" title="5. 替代方案"></a>5. <strong>替代方案</strong></h3><p>在 C# 中，如果需要类型安全的集合，建议使用泛型集合类，如 <code>List&lt;T&gt;</code>，它在提供与 <code>ArrayList</code> 类似功能的同时还支持类型检查，并<code>避免装箱/拆箱</code>的性能开销。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>intList.Add(<span class="hljs-number">1</span>);<br>intList.Add(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><code>List&lt;T&gt;</code> 是 <code>ArrayList</code> 更加推荐的替代方案，因为它支持泛型，提供更好的性能和类型安全性。</p><h1 id="44-栈"><a href="#44-栈" class="headerlink" title="44. 栈"></a>44. 栈</h1><p>栈（Stack）是一种后进先出（LIFO，Last In, First Out）的数据结构，这意味着最后添加的元素最先被移除。栈具有以下几个主要特点和操作：</p><h3 id="1-栈的基本概念"><a href="#1-栈的基本概念" class="headerlink" title="1. 栈的基本概念"></a>1. <strong>栈的基本概念</strong></h3><ul><li><strong>后进先出（LIFO）</strong>：栈的特点是“后进先出”，即最后压入栈的元素最先被弹出。</li><li><strong>栈的两个主要操作</strong>：<ul><li>**Push()**：将元素压入栈顶。</li><li>**Pop()**：从栈顶移除并返回元素。</li></ul></li><li><strong>其他常见操作</strong>：<ul><li>**Peek()**：查看栈顶的元素但不移除它。</li><li>Contains&lt;&gt;()或Contains()：是否存在某个元素<ul><li><strong>类型安全性</strong>：在编译时检查类型，避免类型转换的错误。例如，如果 <code>List&lt;int&gt;</code> 类型的集合调用 <code>Contains</code> 方法，就只能传入 <code>int</code> 类型的值，否则会出现编译错误。</li><li><strong>性能更高</strong>：泛型集合在检查元素时不需要进行装箱和拆箱操作（适用于值类型），直接比较元素的值，因此性能较高。</li><li><strong>避免类型转换问题</strong>：由于泛型集合存储的是具体类型的元素，所以 <code>Contains</code> 方法可以直接对该类型的值进行比较，而不需要进行类型转换。</li></ul></li><li>Count：栈内元素个数</li><li>Clear()：清空栈内元素</li></ul></li></ul><h3 id="2-栈的实现"><a href="#2-栈的实现" class="headerlink" title="2. 栈的实现"></a>2. <strong>栈的实现</strong></h3><p>栈可以用数组或链表来实现。数组实现栈时，栈顶的位置随着元素的增加或移除而变化。链表实现栈时，新元素总是插入到链表的头部。</p><h3 id="3-栈在编程中的应用"><a href="#3-栈在编程中的应用" class="headerlink" title="3. 栈在编程中的应用"></a>3. <strong>栈在编程中的应用</strong></h3><ul><li><strong>函数调用栈</strong>：程序执行时，每个函数调用都会把当前执行状态（如局部变量、返回地址）压入调用栈，函数返回时，从栈顶弹出恢复状态。</li><li><strong>表达式求值和语法分析</strong>：在编译器中，栈用于解析表达式的操作顺序和括号匹配。</li><li><strong>撤销操作</strong>：应用程序（如文本编辑器）中常用栈来记录操作历史，以便进行撤销（Undo）操作。</li></ul><h3 id="4-C-中的栈"><a href="#4-C-中的栈" class="headerlink" title="4. C# 中的栈"></a>4. <strong>C# 中的栈</strong></h3><p>在 C# 中，可以使用 <code>System.Collections.Generic</code> 命名空间中的 <code>Stack&lt;T&gt;</code> 泛型类来实现栈操作。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//************************************</span><br>        <span class="hljs-comment">// 非泛型 using System.Collections;其他操作和泛型一致</span><br>        Stack stackObj = <span class="hljs-keyword">new</span> Stack();<br><br><br>        <span class="hljs-comment">// using System.Collections.Generic;</span><br>        Stack&lt;<span class="hljs-built_in">int</span>&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// Push操作：将元素压入栈</span><br>        stack.Push(<span class="hljs-number">1</span>);<br>        stack.Push(<span class="hljs-number">2</span>);<br>        stack.Push(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 遍历一</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> stack)<br>        &#123;<br>            Console.WriteLine(item);<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历二</span><br>        <span class="hljs-built_in">int</span>[] array = stack.ToArray();<br>        <span class="hljs-comment">// object[] array = stack.ToArray();</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>        &#123;<br>            Console.WriteLine(array[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// Peek操作：查看栈顶元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Top element is: &quot;</span> + stack.Peek());<br><br>        <span class="hljs-comment">// Pop操作：弹出栈顶元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Popped element is: &quot;</span> + stack.Pop());<br><br>        <span class="hljs-comment">// Contains操作：查看元素是否存在</span><br>        <span class="hljs-keyword">if</span> (stack.Contains(<span class="hljs-number">1</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;存在1&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 再次查看栈顶元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Top element after pop is: &quot;</span> + stack.Peek());<br><br>        <span class="hljs-comment">// 检查栈是否为空</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Is stack empty? &quot;</span> + (stack.Count == <span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">// 循环弹栈</span><br>        <span class="hljs-keyword">while</span> (stack.Count &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(stack.Pop());<br>        &#125;<br><br>        <span class="hljs-comment">// 清空栈</span><br>        stack.Clear();<br>        <span class="hljs-comment">// 查看栈的元素个数</span><br>        Console.WriteLine(stack.Count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br>Top element <span class="hljs-keyword">is</span>: <span class="hljs-number">3</span><br>Popped element <span class="hljs-keyword">is</span>: <span class="hljs-number">3</span><br>存在<span class="hljs-number">1</span><br>Top element after pop <span class="hljs-keyword">is</span>: <span class="hljs-number">2</span><br>Is stack empty? False<br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="5-栈在内存管理中的应用"><a href="#5-栈在内存管理中的应用" class="headerlink" title="5. 栈在内存管理中的应用"></a>5. <strong>栈在内存管理中的应用</strong></h3><p>在程序运行时，栈内存用于存储函数的局部变量和参数。当函数调用时，局部变量会被压入栈，函数返回时会自动从栈中弹出这些变量。</p><ul><li><strong>栈内存</strong>：栈内存管理快速，但容量有限，适用于生命周期短的对象和变量。</li><li><strong>堆内存</strong>：用于动态分配的内存，适合存储生命周期较长或大小可变的数据。</li></ul><h3 id="6-泛型栈-Stack"><a href="#6-泛型栈-Stack" class="headerlink" title="6. 泛型栈 (Stack&lt;T&gt;)"></a>6. 泛型栈 (<code>Stack&lt;T&gt;</code>)</h3><ul><li><strong>定义</strong>：栈是一种后进先出（LIFO，Last In First Out）的数据结构。最后放入栈中的元素最先被取出。</li><li><strong>常用方法</strong>：和普通栈一样<ul><li><code>Push(T item)</code>：将元素推入栈中。</li><li><code>Pop()</code>：移除并返回栈顶的元素。</li><li><code>Peek()</code>：返回栈顶的元素，但不移除它。</li><li><code>Count</code>：获取栈中元素的数量。</li></ul></li><li><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个泛型栈</span><br>        Stack&lt;<span class="hljs-built_in">int</span>&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// 压入元素</span><br>        stack.Push(<span class="hljs-number">1</span>);<br>        stack.Push(<span class="hljs-number">2</span>);<br>        stack.Push(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 输出栈顶元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;栈顶元素: &quot;</span> + stack.Peek()); <span class="hljs-comment">// 输出 3</span><br><br>        <span class="hljs-comment">// 弹出元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;弹出元素: &quot;</span> + stack.Pop()); <span class="hljs-comment">// 输出 3</span><br><br>        <span class="hljs-comment">// 栈中剩余元素数量</span><br>        Console.WriteLine(<span class="hljs-string">&quot;栈中元素数量: &quot;</span> + stack.Count); <span class="hljs-comment">// 输出 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="45-队列"><a href="#45-队列" class="headerlink" title="45. 队列"></a>45. 队列</h1><p>队列（Queue）是一种先进先出（FIFO，First In, First Out）的数据结构，这意味着第一个加入队列的元素最先被移除。队列的基本操作和特点如下：</p><h3 id="1-队列的基本概念"><a href="#1-队列的基本概念" class="headerlink" title="1. 队列的基本概念"></a>1. <strong>队列的基本概念</strong></h3><ul><li><strong>先进先出（FIFO）</strong>：队列的特点是“先进先出”，即最先入队的元素最先被移出队列。</li><li><strong>队列的主要操作</strong>：<ul><li>**Enqueue()**：将元素添加到队列的末尾（尾部）。</li><li>**Dequeue()**：移除并返回队列的第一个元素（头部）。</li></ul></li><li><strong>其他常见操作</strong>：<ul><li>**Peek()**：查看队列的第一个元素但不移除它。</li><li>Count：查看队列元素个数,没有IsEmpty()方法</li><li>Clear()：清空队列元素</li><li>Contains&lt;&gt;()或Contains()：是否存在某个元素<ul><li><strong>类型安全性</strong>：在编译时检查类型，避免类型转换的错误。例如，如果 <code>List&lt;int&gt;</code> 类型的集合调用 <code>Contains</code> 方法，就只能传入 <code>int</code> 类型的值，否则会出现编译错误。</li><li><strong>性能更高</strong>：泛型集合在检查元素时不需要进行装箱和拆箱操作（适用于值类型），直接比较元素的值，因此性能较高。</li><li><strong>避免类型转换问题</strong>：由于泛型集合存储的是具体类型的元素，所以 <code>Contains</code> 方法可以直接对该类型的值进行比较，而不需要进行类型转换。</li></ul></li></ul></li></ul><h3 id="2-队列的实现"><a href="#2-队列的实现" class="headerlink" title="2. 队列的实现"></a>2. <strong>队列的实现</strong></h3><p>队列可以通过数组或链表来实现。用数组实现时，需要处理循环队列以节省空间。用链表实现时，新元素添加到链表的尾部，元素移除从链表的头部进行。</p><h3 id="3-队列的应用"><a href="#3-队列的应用" class="headerlink" title="3. 队列的应用"></a>3. <strong>队列的应用</strong></h3><ul><li><strong>任务调度</strong>：在操作系统中，队列用于管理任务的调度，保证先到的任务先执行。</li><li><strong>消息处理</strong>：在网络通信中，队列用于缓冲数据，按顺序处理消息。</li><li><strong>宽度优先搜索（BFS）</strong>：在图的遍历算法中，队列用于按层次遍历图中的节点。</li></ul><h3 id="4-C-中的队列"><a href="#4-C-中的队列" class="headerlink" title="4. C# 中的队列"></a>4. <strong>C# 中的队列</strong></h3><p>在 C# 中，可以使用 <code>System.Collections.Generic</code> 命名空间中的 <code>Queue&lt;T&gt;</code> 泛型类来实现队列操作。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li>遍历什么的和栈一样，方法也基本一致，只是数据结构不同<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 非泛型，就是所有的Object</span><br>        <span class="hljs-comment">// using System.Collections;</span><br>        Queue queueAll = <span class="hljs-keyword">new</span> Queue();<br>        Queue&lt;<span class="hljs-built_in">string</span>&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>        <span class="hljs-comment">// Enqueue操作：将元素添加到队列的末尾</span><br>        queue.Enqueue(<span class="hljs-string">&quot;First&quot;</span>);<br>        queue.Enqueue(<span class="hljs-string">&quot;Second&quot;</span>);<br>        queue.Enqueue(<span class="hljs-string">&quot;Third&quot;</span>);<br><br>        <span class="hljs-comment">// Peek操作：查看队列的第一个元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Front element is: &quot;</span> + queue.Peek());<br><br>        <span class="hljs-comment">// Contains：查看是否包含某个元素 也可以直接Contains,不用泛型</span><br>        Console.WriteLine(<span class="hljs-string">&quot;First element contains?&quot;</span> + queue.Contains&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;First&quot;</span>));<br><br><br>        <span class="hljs-comment">// Dequeue操作：移除并返回队列的第一个元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Dequeued element is: &quot;</span> + queue.Dequeue());<br><br>        <span class="hljs-comment">// 再次查看队列的第一个元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Front element after dequeue is: &quot;</span> + queue.Peek());<br><br><br>        <span class="hljs-comment">// 清空队列</span><br>        queue.Clear();<br>        <span class="hljs-comment">// 检查队列是否为空，队列元素个数</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Is queue empty? &quot;</span> + (queue.Count == <span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Front element <span class="hljs-keyword">is</span>: First<br>First element contains?True<br>Dequeued element <span class="hljs-keyword">is</span>: First<br>Front element after dequeue <span class="hljs-keyword">is</span>: Second<br>Is queue empty? True<br></code></pre></td></tr></table></figure><h3 id="5-双端队列（Deque）"><a href="#5-双端队列（Deque）" class="headerlink" title="5. 双端队列（Deque）"></a>5. <strong>双端队列（Deque）</strong></h3><p>双端队列是一种特殊的队列，允许从两端进行插入和删除操作。在 C# 中，可以使用 <code>System.Collections.Generic</code> 命名空间下的 <code>LinkedList&lt;T&gt;</code> 来实现双端队列的功能。</p><h3 id="6-队列在内存管理中的应用"><a href="#6-队列在内存管理中的应用" class="headerlink" title="6. 队列在内存管理中的应用"></a>6. <strong>队列在内存管理中的应用</strong></h3><p>队列通常用作任务队列或事件队列，用于按顺序处理异步事件或任务。<br>队列是一种简单而灵活的数据结构，在实际开发中广泛应用于各种场景。</p><h3 id="7-泛型队列-Queue"><a href="#7-泛型队列-Queue" class="headerlink" title="7. 泛型队列 (Queue&lt;T&gt;)"></a>7. 泛型队列 (<code>Queue&lt;T&gt;</code>)</h3><ul><li><strong>定义</strong>：队列是一种先进先出（FIFO，First In First Out）的数据结构。最先放入队列中的元素最先被取出。</li><li><strong>常用方法</strong>：和普通队列一样<ul><li><code>Enqueue(T item)</code>：将元素添加到队列的末尾。</li><li><code>Dequeue()</code>：移除并返回队列头部的元素。</li><li><code>Peek()</code>：返回队列头部的元素，但不移除它。</li><li><code>Count</code>：获取队列中元素的数量。</li></ul></li><li><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个泛型队列</span><br>        Queue&lt;<span class="hljs-built_in">string</span>&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>        <span class="hljs-comment">// 入队元素</span><br>        queue.Enqueue(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        queue.Enqueue(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        queue.Enqueue(<span class="hljs-string">&quot;Charlie&quot;</span>);<br><br>        <span class="hljs-comment">// 输出队头元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;队头元素: &quot;</span> + queue.Peek()); <span class="hljs-comment">// 输出 Alice</span><br><br>        <span class="hljs-comment">// 出队元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;出队元素: &quot;</span> + queue.Dequeue()); <span class="hljs-comment">// 输出 Alice</span><br><br>        <span class="hljs-comment">// 队列中剩余元素数量</span><br>        Console.WriteLine(<span class="hljs-string">&quot;队列中元素数量: &quot;</span> + queue.Count); <span class="hljs-comment">// 输出 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="46-Hashtable"><a href="#46-Hashtable" class="headerlink" title="46. Hashtable"></a>46. Hashtable</h1><p>在 C# 中，<code>Hashtable</code> 是一种以键-值对存储数据的集合，属于非泛型集合类，位于 <code>System.Collections</code> 命名空间中。它通过键来快速查找值，使用哈希函数来确定每个键的位置。</p><h3 id="1-基本特点"><a href="#1-基本特点" class="headerlink" title="1. 基本特点"></a>1. <strong>基本特点</strong></h3><ul><li><strong>键值对存储</strong>：<code>Hashtable</code> 存储数据时使用键-值对的形式，每个键必须是唯一的，但值可以重复。</li><li><strong>哈希表实现</strong>：通过哈希算法将键映射到特定的存储位置，从而实现快速的数据查找。</li><li><strong>非泛型集合</strong>：<code>Hashtable</code> 存储的键和值都是 <code>object</code> 类型，因此需要进行类型转换。</li><li><strong>自动调整容量</strong>：当元素数量超过某个阈值时，<code>Hashtable</code> 会自动扩展其容量，以提高性能。</li></ul><h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2. 常用操作"></a>2. <strong>常用操作</strong></h3><ul><li><strong>添加元素</strong>：使用 <code>Add()</code> 方法添加键-值对。</li><li><strong>访问元素</strong>：使用索引器 <code>[]</code> 访问或修改指定键的值。</li><li><strong>删除元素</strong>：使用 <code>Remove()</code> 方法删除指定键的键-值对。<ul><li>如果删除不存在的键，不报错，只是没反应</li></ul></li><li><strong>检查键是否存在</strong>：使用 <code>ContainsKey()</code> 方法判断某个键是否存在。<ul><li>和Contains()一样的，都是判断某个键是否存在</li></ul></li><li><strong>检查值是否存在</strong>：使用 <code>ContainsValue()</code> 方法判断某个值是否存在。</li><li><strong>清空集合</strong>：使用 <code>Clear()</code> 方法清空所有元素。</li><li>键值对对数：使用<code>Count</code>字段获取键值对对数。</li><li>键对：<code>Keys</code>字段获取键对</li><li>值对：<code>Values</code>字段获取值对</li></ul><h3 id="3-示例代码-1"><a href="#3-示例代码-1" class="headerlink" title="3. 示例代码"></a>3. <strong>示例代码</strong></h3><p>下面是一些常用操作的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 Hashtable</span><br>        Hashtable hashtable = <span class="hljs-keyword">new</span> Hashtable();<br><br>        <span class="hljs-comment">// 添加键值对</span><br>        hashtable.Add(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>);<br>        hashtable.Add(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">3</span>);<br>        hashtable.Add(<span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-number">8</span>);<br><br>        <span class="hljs-comment">// 访问元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Apple count: &quot;</span> + hashtable[<span class="hljs-string">&quot;apple&quot;</span>]);<br><br>        <span class="hljs-comment">// 修改元素</span><br>        hashtable[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">10</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Banana count (updated): &quot;</span> + hashtable[<span class="hljs-string">&quot;banana&quot;</span>]);<br><br>        <span class="hljs-comment">// 检查键是否存在</span><br>        <span class="hljs-keyword">if</span> (hashtable.ContainsKey(<span class="hljs-string">&quot;orange&quot;</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Orange is in the hashtable.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 删除元素</span><br>        hashtable.Remove(<span class="hljs-string">&quot;apple&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;After removing apple, count: &quot;</span> + hashtable.Count);<br><br>        <span class="hljs-comment">// 遍历所有键,这里用var或者object都可以</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> hashtable.Keys)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + item);<br>            Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + hashtable[item]);<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历所有的值</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> hashtable.Values)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + item);<br>        &#125;<br><br>        <span class="hljs-comment">// 键值对一起遍历</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> hashtable)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + ((DictionaryEntry)item).Key);<br>            Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + ((DictionaryEntry)item).Value);<br>        &#125;<br><br>        <span class="hljs-comment">// 键值对一起遍历</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> hashtable)<br>        &#123;<br>            <span class="hljs-keyword">var</span> entry = item <span class="hljs-keyword">as</span> DictionaryEntry?;<br><br>            <span class="hljs-comment">// 判断当前对象是否为一个有效值，如果是，返回true</span><br>            <span class="hljs-comment">// 如果不是，意味着是null，返回false</span><br>            <span class="hljs-comment">// entry必须是一个可以为null的值，所以上面加了?</span><br>            <span class="hljs-keyword">if</span> (entry.HasValue)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + entry.Value.Key);<br>                Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + entry.Value.Value);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 GetEnumerator 方法遍历 Hashtable</span><br>        <span class="hljs-comment">// 迭代器遍历法</span><br>        IDictionaryEnumerator enumerator = hashtable.GetEnumerator();<br><br>        <span class="hljs-keyword">while</span> (enumerator.MoveNext())<br>        &#123;<br>            <span class="hljs-comment">// 访问当前键值对</span><br>            Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + enumerator.Key);<br>            Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + enumerator.Value);<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 LINQ 遍历 Hashtable,不建议用这种方法遍历</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        关键点</span><br><span class="hljs-comment">        类型转换：Cast&lt;DictionaryEntry&gt;() 将 Hashtable 中的每个元素转换为 DictionaryEntry 类型。</span><br><span class="hljs-comment">        这是因为 Hashtable 中的元素实际上是 DictionaryEntry 对象。</span><br><span class="hljs-comment">        LINQ 集合操作：通过将 Hashtable 转换为 IEnumerable&lt;DictionaryEntry&gt;，</span><br><span class="hljs-comment">        你可以使用 LINQ 的其他功能，例如 Where、Select、OrderBy 等，</span><br><span class="hljs-comment">        对元素进行过滤和操作。</span><br><span class="hljs-comment">        安全性：使用 Cast&lt;T&gt;() 进行类型转换时，如果集合中的元素不能转换为指定类型，</span><br><span class="hljs-comment">        将抛出异常。因此，确保 Hashtable 中的元素是 DictionaryEntry 类型是很重要的。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">var</span> entries = hashtable.Cast&lt;DictionaryEntry&gt;();<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> entries)<br>        &#123;<br>            <span class="hljs-comment">// 尝试将 item 转换为可空类型</span><br>            <span class="hljs-keyword">var</span> entry = item <span class="hljs-keyword">as</span> DictionaryEntry?;<br><br>            <span class="hljs-comment">// 检查 entry 是否有值</span><br>            <span class="hljs-keyword">if</span> (entry.HasValue)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + entry.Value.Key);<br>                Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + entry.Value.Value);<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 清空 Hashtable</span><br>        hashtable.Clear();<br>        <span class="hljs-comment">// 得到键值对 对数</span><br>        Console.WriteLine(<span class="hljs-string">&quot;After clearing, count: &quot;</span> + hashtable.Count);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Banana <span class="hljs-title">count</span> (<span class="hljs-params">updated</span>): 10</span><br><span class="hljs-function">Orange <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the hashtable.</span><br><span class="hljs-function">After removing apple, count: 2</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">After clearing, count: 0</span><br></code></pre></td></tr></table></figure><h3 id="4-性能和使用注意事项"><a href="#4-性能和使用注意事项" class="headerlink" title="4. 性能和使用注意事项"></a>4. <strong>性能和使用注意事项</strong></h3><ul><li><strong>性能优势</strong>：<code>Hashtable</code> 具有 O(1) 的查找、插入和删除复杂度（在理想情况下），适用于需要快速查找数据的场景。</li><li><strong>装箱&#x2F;拆箱开销</strong>：由于 <code>Hashtable</code> 是非泛型集合，存储值类型时会发生装箱和拆箱操作，可能导致性能开销。</li><li><strong>线程安全</strong>：<code>Hashtable</code> 本身不是线程安全的，如果需要在多线程环境中使用，可以使用同步方法 <code>Hashtable.Synchronized</code> 或其他线程安全的集合。</li></ul><h3 id="5-与-Dictionary-的比较"><a href="#5-与-Dictionary-的比较" class="headerlink" title="5. 与 Dictionary&lt;TKey, TValue&gt; 的比较"></a>5. <strong>与 <code>Dictionary&lt;TKey, TValue&gt;</code> 的比较</strong></h3><p><code>Hashtable</code> 是早期的非泛型集合类，现在大部分情况下推荐使用 <code>Dictionary&lt;TKey, TValue&gt;</code>，因为：</p><ul><li><strong>类型安全</strong>：<code>Dictionary&lt;TKey, TValue&gt;</code> 是泛型集合，避免了类型转换的错误。</li><li><strong>性能更高</strong>：对于值类型的数据，<code>Dictionary&lt;TKey, TValue&gt;</code> 避免了装箱&#x2F;拆箱操作。</li><li><strong>代码可读性</strong>：使用泛型时，类型信息更加明确，提高了代码的可读性和维护性。</li></ul><p><code>Hashtable</code> 适用于简单的键值存储场景，但在现代 C# 编程中，通常建议使用泛型的 <code>Dictionary&lt;TKey, TValue&gt;</code>。</p><h1 id="47-var和object"><a href="#47-var和object" class="headerlink" title="47. var和object"></a>47. var和object</h1><p>在 C# 中，<code>var</code> 和 <code>object</code> 都可以用来声明变量，但它们有不同的用法和意义：</p><ol><li><strong><code>var</code> 的特点</strong>：<ul><li><strong>类型推断</strong>：<code>var</code> 是编译时的类型推断，编译器会根据右侧赋值的类型自动推断变量的类型。例如，如果赋值是一个 <code>int</code>，<code>var</code> 就会被推断为 <code>int</code> 类型。</li><li><strong>强类型</strong>：使用 <code>var</code> 声明的变量在编译时类型是确定的，并且不能更改。虽然看起来像动态类型，但实际上是强类型的变量。</li><li><strong>优点</strong>：代码更简洁，特别是当类型名称很长或复杂时；减少显式类型声明带来的冗余。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> number = <span class="hljs-number">10</span>; <span class="hljs-comment">// 推断为 int</span><br><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 推断为 string</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong><code>object</code> 的特点</strong>：<ul><li><strong>基础类型</strong>：<code>object</code> 是所有类型的基类，意味着任何类型的变量都可以赋值给 <code>object</code>。当存储值类型时，会发生装箱操作。</li><li><strong>需要类型转换</strong>：如果使用 <code>object</code> 进行类型存储，取出时需要进行显式类型转换，并且在编译时不会检查类型安全。</li><li><strong>优点</strong>：适用于需要存储不同类型的情况或无法提前确定类型的场景。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> number = <span class="hljs-number">10</span>; <span class="hljs-comment">// 装箱为 object</span><br><span class="hljs-built_in">object</span> text = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 作为 object 类型存储</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong>区别和建议</strong>：<ul><li>使用 <code>var</code> 可以保留强类型的优势，同时简化代码，是更推荐的做法，特别是在类型明确的情况下。</li><li>使用 <code>object</code> 需要在取出时进行类型转换，可能会带来额外的性能开销和类型安全性问题。</li><li>在迭代集合时，如果知道集合的元素类型，建议使用 <code>var</code>，因为编译器会推断出正确的类型，代码更清晰且类型安全。<br>在遍历 <code>Hashtable</code> 时，<code>var</code> 会推断出 <code>item</code> 的类型为 <code>object</code>，所以在这种情况下两者都能工作。但是使用 <code>var</code> 是更好的实践，因为它让代码看起来更简洁。</li></ul></li></ol><h1 id="48-泛型"><a href="#48-泛型" class="headerlink" title="48. 泛型"></a>48. 泛型</h1><p>泛型（Generics）是 C# 中的一种强大功能，允许你定义类、接口和方法时使用占位符（类型参数），而不需要在定义时指定具体的类型。这样，你可以在运行时使用不同的数据类型，提升代码的复用性和类型安全性。以下是关于泛型的一些关键点及示例。</p><ul><li>如果有多个泛型占位字母，逗号分开即可</li><li>抽象类和静态类都不能作为泛型<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//泛型约束一共有6种</span><br><span class="hljs-comment">//1.值类型                       where 泛型字母：struct</span><br><span class="hljs-comment">//2.引用类型                     where 泛型字母：class</span><br><span class="hljs-comment">//3.存在无参公共构造函数          where 泛型字母：new（）</span><br><span class="hljs-comment">//4.某个类本身或者其派生类        where 泛型字母：类名</span><br><span class="hljs-comment">//5.某个接口的派生类型            where 泛型字母：接口名</span><br><span class="hljs-comment">//6.另一个泛型类型本身或者派生类型 where 泛型字母：另一个泛型字母</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1. 泛型类"></a>1. 泛型类</h3><p>泛型类允许你创建一个类，其中的成员可以使用类型参数。这使得类可以处理不同的数据类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GenericList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;T&gt; items = <span class="hljs-keyword">new</span> List&lt;T&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>    &#123;<br>        items.Add(item);<br>    &#125;<br><br><span class="hljs-comment">// 泛型类中的泛型方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> items[index];<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用泛型类</span><br>        <span class="hljs-keyword">var</span> intList = <span class="hljs-keyword">new</span> GenericList&lt;<span class="hljs-built_in">int</span>&gt;();<br>        intList.Add(<span class="hljs-number">1</span>);<br>        intList.Add(<span class="hljs-number">2</span>);<br>        Console.WriteLine(intList.Get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出 1</span><br><br>        <span class="hljs-keyword">var</span> stringList = <span class="hljs-keyword">new</span> GenericList&lt;<span class="hljs-built_in">string</span>&gt;();<br>        stringList.Add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        stringList.Add(<span class="hljs-string">&quot;World&quot;</span>);<br>        Console.WriteLine(stringList.Get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 输出 World</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-泛型方法"><a href="#2-泛型方法" class="headerlink" title="2. 泛型方法"></a>2. 泛型方法</h3><p>你可以在类中定义泛型方法，这些方法可以接受不同的数据类型作为参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utilities</span><br>&#123;<br><span class="hljs-comment">// 普通类中的泛型方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">GetMax</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a, T b</span>) <span class="hljs-keyword">where</span> T : IComparable</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (a.CompareTo(b) &gt; <span class="hljs-number">0</span>) ? a : b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用泛型方法</span><br>        Console.WriteLine(Utilities.GetMax(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出 10</span><br>        Console.WriteLine(Utilities.GetMax(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>)); <span class="hljs-comment">// 输出 orange</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3. 泛型接口"></a>3. 泛型接口</h3><p>泛型接口允许你定义接口时使用类型参数，这使得实现该接口的类可以指定具体的类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRepository</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span>;<br>    <span class="hljs-function">T <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IRepository</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;T&gt; items = <span class="hljs-keyword">new</span> List&lt;T&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>    &#123;<br>        items.Add(item);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> items[id];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用泛型接口</span><br>        <span class="hljs-keyword">var</span> repo = <span class="hljs-keyword">new</span> Repository&lt;<span class="hljs-built_in">string</span>&gt;();<br>        repo.Add(<span class="hljs-string">&quot;Item1&quot;</span>);<br>        Console.WriteLine(repo.Get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出 Item1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-约束（Constraints）"><a href="#4-约束（Constraints）" class="headerlink" title="4. 约束（Constraints）"></a>4. 约束（Constraints）</h3><p>泛型允许你使用约束来限制类型参数，这样你可以确保类型参数满足特定的条件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-keyword">class</span> <span class="hljs-comment">// T 必须是引用类型</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123; &#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> personExample = <span class="hljs-keyword">new</span> Example&lt;Person&gt;(<span class="hljs-keyword">new</span> Person());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 C# 中，泛型约束（Generic Constraints）用于限制类型参数的特性。这使得在使用泛型时可以确保某些条件得到满足，从而提供编译时的类型安全性。以下是关于泛型约束的详细说明及示例。</p><h4 id="常见的泛型约束类型"><a href="#常见的泛型约束类型" class="headerlink" title="常见的泛型约束类型"></a>常见的泛型约束类型</h4><h5 id="1-引用类型约束"><a href="#1-引用类型约束" class="headerlink" title="1. 引用类型约束"></a>1. 引用类型约束</h5><p>使用 <code>where T : class</code> 限制类型参数必须是引用类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-keyword">class</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">var</span> example = <span class="hljs-keyword">new</span> Example&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 合法</span><br><span class="hljs-comment">// var example2 = new Example&lt;int&gt;(5); // 不合法，int 是值类型</span><br></code></pre></td></tr></table></figure><h5 id="2-值类型约束"><a href="#2-值类型约束" class="headerlink" title="2. 值类型约束"></a>2. 值类型约束</h5><p>使用 <code>where T : struct</code> 限制类型参数必须是值类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ValueExample</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">struct</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueExample</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">var</span> valueExample = <span class="hljs-keyword">new</span> ValueExample&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">5</span>); <span class="hljs-comment">// 合法</span><br><span class="hljs-comment">// var valueExample2 = new ValueExample&lt;string&gt;(&quot;Hello&quot;); // 不合法，string 是引用类型</span><br></code></pre></td></tr></table></figure><h5 id="3-new-约束"><a href="#3-new-约束" class="headerlink" title="3. new() 约束"></a>3. <code>new()</code> 约束</h5><p><code>new()</code> 约束用于限制泛型类型参数必须具有一个无参数的构造函数。它允许在泛型类或方法中实例化类型参数。<br><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">new</span>() <span class="hljs-comment">// T 必须有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">CreateInstance</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// 使用 new() 创建实例</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span> &#123; &#125; <span class="hljs-comment">// 无参构造函数</span><br>&#125;<br><br><span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> Factory&lt;MyClass&gt;();<br>MyClass instance = factory.CreateInstance(); <span class="hljs-comment">// 合法，创建 MyClass 实例</span><br></code></pre></td></tr></table></figure><h5 id="4-基类约束"><a href="#4-基类约束" class="headerlink" title="4. 基类约束"></a>4. 基类约束</h5><p>使用 <code>where T : BaseClass</code> 限制类型参数必须是指定基类或者其的派生类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span> &#123; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span> &#123; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseExample</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseExample</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        <span class="hljs-keyword">var</span> baseExample = <span class="hljs-keyword">new</span> BaseExample&lt;DerivedClass&gt;(<span class="hljs-keyword">new</span> DerivedClass()); <span class="hljs-comment">// 合法</span><br>        <span class="hljs-keyword">var</span> baseExample2 = <span class="hljs-keyword">new</span> BaseExample&lt;BaseClass&gt;(<span class="hljs-keyword">new</span> DerivedClass());<br>        <span class="hljs-comment">// var baseExample2 = new BaseExample&lt;string&gt;(&quot;Hello&quot;); // 不合法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-接口约束"><a href="#5-接口约束" class="headerlink" title="5. 接口约束"></a>5. 接口约束</h5><p>使用 <code>where T : IMyInterface</code> 限制类型参数必须实现指定的接口或者就是接口本身。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span> &#123; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceExample</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterfaceExample</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        <span class="hljs-keyword">var</span> interfaceExample = <span class="hljs-keyword">new</span> InterfaceExample&lt;MyClass&gt;(<span class="hljs-keyword">new</span> MyClass()); <span class="hljs-comment">// 合法</span><br>        <span class="hljs-keyword">var</span> interfaceExample2 = <span class="hljs-keyword">new</span> InterfaceExample&lt;IMyInterface&gt;(<span class="hljs-keyword">new</span> MyClass());<br>        <span class="hljs-comment">// var interfaceExample2 = new InterfaceExample&lt;string&gt;(&quot;Hello&quot;); // 不合法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-类型参数之间的约束"><a href="#6-类型参数之间的约束" class="headerlink" title="6. 类型参数之间的约束"></a>6. 类型参数之间的约束</h5><p>当你想要限制一个泛型类型参数可以是另一个泛型类型参数的类型时，可以使用 <code>where</code> 关键字结合多个约束。<br><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T1</span> : <span class="hljs-keyword">class</span> <span class="hljs-keyword">where</span> <span class="hljs-title">T2</span> : <span class="hljs-title">T1</span> <span class="hljs-comment">// T2 必须是 T1 的派生类</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T1 First &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> T2 Second &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span>(<span class="hljs-params">T1 first, T2 second</span>)</span><br>    &#123;<br>        First = first;<br>        Second = second;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span> &#123; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span> &#123; &#125;<br><br><span class="hljs-keyword">var</span> pair = <span class="hljs-keyword">new</span> Pair&lt;BaseClass, DerivedClass&gt;(<span class="hljs-keyword">new</span> BaseClass(), <span class="hljs-keyword">new</span> DerivedClass()); <span class="hljs-comment">// 合法</span><br><span class="hljs-comment">// var pair2 = new Pair&lt;DerivedClass, BaseClass&gt;(new DerivedClass(), new BaseClass()); // 不合法，BaseClass 不是 DerivedClass 的派生类</span><br></code></pre></td></tr></table></figure><h5 id="7-结合-new-约束与其他约束"><a href="#7-结合-new-约束与其他约束" class="headerlink" title="7. 结合 new() 约束与其他约束"></a>7. 结合 <code>new()</code> 约束与其他约束</h5><p>可以结合 <code>new()</code> 约束与其他约束。例如，假设你希望一个类同时支持无参构造函数和基类的约束。<br><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">new</span>() <span class="hljs-comment">// T 必须是 BaseClass 的派生类，并且有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">CreateInstance</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// 使用 new() 创建实例</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DerivedClass</span>()</span> &#123; &#125; <span class="hljs-comment">// 无参构造函数</span><br>&#125;<br><br><span class="hljs-keyword">var</span> example = <span class="hljs-keyword">new</span> Example&lt;DerivedClass&gt;();<br>DerivedClass instance = example.CreateInstance(); <span class="hljs-comment">// 合法</span><br></code></pre></td></tr></table></figure><p>可以为一个类型参数指定多个约束，使用 <code>,</code> 分隔。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MultiConstraintExample</span>&lt;<span class="hljs-title">T</span>&gt; <br>    <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IMyInterface</span>, <span class="hljs-title">new</span>() <span class="hljs-comment">// 需要是 BaseClass 的派生类，实现 IMyInterface，并且有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">CreateInstance</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// 使用 new() 约束</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-多个泛型有约束"><a href="#8-多个泛型有约束" class="headerlink" title="8. 多个泛型有约束"></a>8. 多个泛型有约束</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义一个泛型接口，表示实体必须有一个 ID</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEntity</span>&lt;<span class="hljs-title">TId</span>&gt;<br>&#123;<br>    TId Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个具体的实体类，实现 IEntity&lt;int&gt; 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> : <span class="hljs-title">IEntity</span>&lt;<span class="hljs-title">int</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义泛型类 Repository，带有两个泛型参数 TModel 和 TId</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">TModel</span>, <span class="hljs-title">TId</span>&gt;<br>    <span class="hljs-keyword">where</span> <span class="hljs-title">TModel</span> : <span class="hljs-keyword">class</span>, <span class="hljs-title">IEntity</span>&lt;<span class="hljs-title">TId</span>&gt;, <span class="hljs-title">new</span>() <span class="hljs-comment">// TModel 必须是类，实现 IEntity&lt;TId&gt;，且有无参构造函数</span><br>    <span class="hljs-keyword">where</span> <span class="hljs-title">TId</span> : <span class="hljs-title">struct</span> <span class="hljs-comment">// TId 必须是值类型</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TModel <span class="hljs-title">CreateNew</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 可以创建 TModel 的实例，因为有 new() 约束</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TModel();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TId <span class="hljs-title">GetId</span>(<span class="hljs-params">TModel model</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 可以访问 Id，因为 TModel 实现了 IEntity&lt;TId&gt;</span><br>        <span class="hljs-keyword">return</span> model.Id;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Repository&lt;User, int&gt; 创建对象</span><br>        <span class="hljs-keyword">var</span> userRepository = <span class="hljs-keyword">new</span> Repository&lt;User, <span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// 创建一个新的 User 实例</span><br>        User newUser = userRepository.CreateNew();<br>        newUser.Id = <span class="hljs-number">1</span>;<br>        newUser.Name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><br>        <span class="hljs-comment">// 获取 User 的 Id</span><br>        <span class="hljs-built_in">int</span> userId = userRepository.GetId(newUser);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;User ID: <span class="hljs-subst">&#123;userId&#125;</span>, Name: <span class="hljs-subst">&#123;newUser.Name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-泛型集合"><a href="#5-泛型集合" class="headerlink" title="5. 泛型集合"></a>5. 泛型集合</h3><p>C# 中有许多内置的泛型集合，如 <code>List&lt;T&gt;</code>、<code>Dictionary&lt;TKey, TValue&gt;</code> 和 <code>HashSet&lt;T&gt;</code>，这些集合类使得存储和操作不同类型的数据变得简单而安全。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">var</span> names = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;<br>&#123;<br>    &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Developer&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Manager&quot;</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-性能优势"><a href="#6-性能优势" class="headerlink" title="6. 性能优势"></a>6. 性能优势</h3><p>使用泛型可以减少装箱和拆箱操作，这对于值类型（如 <code>int</code>, <code>float</code> 等）特别重要。泛型还可以提高性能，因为它们避免了不必要的类型转换。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>复用性</strong>：泛型提供了一种创建类型安全和可复用的代码的方法。</li><li><strong>类型安全</strong>：编译器可以在编译时检查类型，从而减少运行时错误。</li><li><strong>性能</strong>：泛型可以提高性能，特别是在处理值类型时。<br>泛型是 C# 的一项重要特性，合理使用可以使代码更简洁、高效和可维护。</li></ul><h1 id="49-List"><a href="#49-List" class="headerlink" title="49. List"></a>49. List</h1><p><code>List&lt;T&gt;</code> 是 C# 中常用的泛型集合类，它位于 <code>System.Collections.Generic</code> 命名空间中，提供了动态数组的功能，可以存储类型为 <code>T</code> 的对象。与数组不同，<code>List&lt;T&gt;</code> 可以根据需要自动调整大小，并提供了一些常用的方法来操作集合中的元素。</p><h3 id="List-的基本用法"><a href="#List-的基本用法" class="headerlink" title="List&lt;T&gt; 的基本用法"></a><code>List&lt;T&gt;</code> 的基本用法</h3><ol><li><p><strong>创建 <code>List&lt;T&gt;</code></strong><br> 可以创建一个空的 <code>List&lt;T&gt;</code>，也可以通过指定初始容量或集合来初始化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">// 创建一个空的 List&lt;int&gt;</span><br>List&lt;<span class="hljs-built_in">string</span>&gt; names = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span> &#125;; <span class="hljs-comment">// 使用集合初始化</span><br></code></pre></td></tr></table></figure></li><li><p><strong>添加元素</strong><br> 使用 <code>Add</code> 方法可以将元素添加到 <code>List&lt;T&gt;</code> 的末尾，使用 <code>AddRange</code> 可以添加一个集合的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">numbers.Add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 添加一个元素</span><br>numbers.Add(<span class="hljs-number">20</span>);<br>numbers.Insert(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 在索引位置为2的地方插入值30，如果index&gt;numbers.Count会报错：System.ArgumentOutOfRangeException</span><br><br><span class="hljs-keyword">var</span> moreNumbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span> &#125;;<br>numbers.AddRange(moreNumbers); <span class="hljs-comment">// 添加多个元素 10 20 30 40 50 </span><br></code></pre></td></tr></table></figure></li><li><p><strong>访问元素</strong><br> 可以使用索引访问 <code>List&lt;T&gt;</code> 中的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> firstNumber = numbers[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 访问第一个元素</span><br>numbers[<span class="hljs-number">1</span>] = <span class="hljs-number">25</span>; <span class="hljs-comment">// 修改第二个元素的值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>删除元素</strong><br> 使用 <code>Remove</code> 方法可以删除指定的元素，<code>RemoveAt</code> 可以删除指定索引位置的元素，<code>Clear</code> 可以清空列表。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">numbers.Remove(<span class="hljs-number">20</span>); <span class="hljs-comment">// 删除值为 20 的元素</span><br>numbers.RemoveAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 删除索引为 0 的元素</span><br>numbers.Clear(); <span class="hljs-comment">// 清空列表</span><br></code></pre></td></tr></table></figure></li><li><p><strong>查找元素</strong><br> 可以使用 <code>Contains</code>、<code>IndexOf</code>、<code>LastIndexOf</code> 等方法查找元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> hasTen = numbers.Contains(<span class="hljs-number">10</span>); <span class="hljs-comment">// 检查列表中是否包含 10</span><br><span class="hljs-built_in">int</span> index = numbers.IndexOf(<span class="hljs-number">30</span>); <span class="hljs-comment">// 正向查找第一个 30 的索引，找不到返回-1</span><br><span class="hljs-built_in">int</span> index2 = numbers.LastIndexOf(<span class="hljs-number">30</span>); <span class="hljs-comment">// 反向查找第一个30的索引，找不到返回-1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>排序</strong><br> 可以使用 <code>Sort</code> 方法对列表进行排序，使用 <code>Reverse</code> 方法对列表进行反转。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">numbers.Sort(); <span class="hljs-comment">// 升序排序</span><br>numbers.Reverse(); <span class="hljs-comment">// 反转列表</span><br></code></pre></td></tr></table></figure><p> <code>List&lt;T&gt;.Sort</code> 方法有多个重载，允许根据不同的排序需求指定参数。以下是常见的参数选项：</p><ol><li><strong><code>Sort()</code></strong><br> 使用默认的比较器对列表中的元素进行升序排序。这要求元素类型实现了 <code>IComparable&lt;T&gt;</code> 接口。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span> &#125;;<br>numbers.Sort(); <span class="hljs-comment">// 升序排序</span><br></code></pre></td></tr></table></figure></li><li><strong><code>Sort(Comparison&lt;T&gt; comparison)</code></strong><br> 通过指定一个比较委托 <code>Comparison&lt;T&gt;</code>，根据自定义的比较规则进行排序。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span> &#125;;<br>numbers.Sort((a, b) =&gt; b.CompareTo(a)); <span class="hljs-comment">// 降序排序</span><br></code></pre></td></tr></table></figure></li><li><strong><code>Sort(IComparer&lt;T&gt; comparer)</code></strong><br> 使用指定的比较器 <code>IComparer&lt;T&gt;</code> 对列表中的元素进行排序。可以通过实现 <code>IComparer&lt;T&gt;</code> 接口来定义自定义排序逻辑。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">string</span>&gt; names = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span> &#125;;<br>names.Sort(StringComparer.OrdinalIgnoreCase); <span class="hljs-comment">// 忽略大小写排序,按照Unicode 编码值排序，升序</span><br><span class="hljs-comment">// 使用自定义比较器进行降序排序，忽略大小写</span><br>names.Sort((a, b) =&gt; StringComparer.OrdinalIgnoreCase.Compare(b, a));<br></code></pre></td></tr></table></figure></li><li><strong><code>Sort(int index, int count, IComparer&lt;T&gt; comparer)</code></strong>  <ul><li>对列表的指定范围进行排序，从 <code>index</code> 开始，对接下来的 <code>count</code> 个元素进行排序。可以使用 <code>IComparer&lt;T&gt;</code> 来指定排序规则。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span> &#125;;<br>numbers.Sort(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, Comparer&lt;<span class="hljs-built_in">int</span>&gt;.Default); <span class="hljs-comment">// 对从索引 1 开始的 3 个元素排序</span><br></code></pre></td></tr></table></figure> 示例代码 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>List&lt;<span class="hljs-built_in">string</span>&gt; fruits = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Cherry&quot;</span>, <span class="hljs-string">&quot;Date&quot;</span> &#125;;<br><br><span class="hljs-comment">// 使用默认排序（升序）</span><br>fruits.Sort();<br>Console.WriteLine(<span class="hljs-string">&quot;默认排序:&quot;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>Console.WriteLine(fruit);<br>&#125;<br><br><span class="hljs-comment">// 使用自定义比较器进行降序排序</span><br>fruits.Sort((a, b) =&gt; b.CompareTo(a));<br>Console.WriteLine(<span class="hljs-string">&quot;\n降序排序:&quot;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>Console.WriteLine(fruit);<br>&#125;<br><br><span class="hljs-comment">// 使用部分排序，指定范围</span><br>List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span> &#125;;<br>numbers.Sort(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, Comparer&lt;<span class="hljs-built_in">int</span>&gt;.Default); <span class="hljs-comment">// 对从索引 1 开始的 3 个元素排序</span><br>Console.WriteLine(<span class="hljs-string">&quot;\n部分排序:&quot;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>&#123;<br>Console.WriteLine(number);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></li><li><p><strong>遍历 <code>List&lt;T&gt;</code></strong><br> 可以使用 <code>foreach</code> 或 <code>for</code> 循环遍历列表中的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> number <span class="hljs-keyword">in</span> numbers)<br>&#123;<br>    Console.WriteLine(number);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>List长度</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(numbers.Count);<br></code></pre></td></tr></table></figure></li></ol><h3 id="常用方法总结"><a href="#常用方法总结" class="headerlink" title="常用方法总结"></a>常用方法总结</h3><ul><li><code>Add(T item)</code>: 将元素添加到列表的末尾。</li><li><code>AddRange(IEnumerable&lt;T&gt; collection)</code>: 将指定集合的元素添加到列表的末尾。</li><li><code>Insert(int index, T item)</code>: 在指定索引处插入元素。</li><li><code>Remove(T item)</code>: 删除列表中第一个匹配的元素。</li><li><code>RemoveAt(int index)</code>: 删除指定索引处的元素。</li><li><code>Contains(T item)</code>: 判断列表中是否包含指定元素。</li><li><code>IndexOf(T item)</code>: 查找指定元素的索引。</li><li><code>Sort()</code>: 对列表进行排序。</li><li><code>Clear()</code>: 清空列表。</li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 List&lt;int&gt;</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><br>        <span class="hljs-comment">// 添加元素</span><br>        numbers.Add(<span class="hljs-number">6</span>);<br>        numbers.AddRange(<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;);<br><br>        <span class="hljs-comment">// 访问元素</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;第一个元素: <span class="hljs-subst">&#123;numbers[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 删除元素</span><br>        numbers.Remove(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除值为 3 的元素</span><br>        numbers.RemoveAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 删除第一个元素</span><br><br>        <span class="hljs-comment">// 查找元素</span><br>        <span class="hljs-built_in">bool</span> containsFive = numbers.Contains(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;包含 5: <span class="hljs-subst">&#123;containsFive&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 排序并遍历</span><br>        numbers.Sort();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>List&lt;T&gt;</code> 是一种非常灵活且常用的集合类型，适合需要动态调整大小的场景。</p><h1 id="50-a-b-b-CompareTo-a"><a href="#50-a-b-b-CompareTo-a" class="headerlink" title="50. (a, b) &#x3D;&gt; b.CompareTo(a)"></a>50. (a, b) &#x3D;&gt; b.CompareTo(a)</h1><p>表达式 <code>(a, b) =&gt; b.CompareTo(a)</code> 是一个使用 Lambda 表达式定义的比较委托，用于自定义排序。</p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li><code>(a, b)</code> 是 Lambda 表达式的参数，表示要比较的两个元素。</li><li><code>b.CompareTo(a)</code> 是 Lambda 表达式的主体，它比较 <code>b</code> 和 <code>a</code> 的大小。<br>在 C# 中，<code>CompareTo</code> 方法返回一个整数值：</li><li>如果 <code>b.CompareTo(a)</code> 返回正数，表示 <code>b</code> 大于 <code>a</code>。</li><li>如果返回 0，表示 <code>b</code> 等于 <code>a</code>。</li><li>如果返回负数，表示 <code>b</code> 小于 <code>a</code>。</li></ul><h3 id="如何实现降序排序"><a href="#如何实现降序排序" class="headerlink" title="如何实现降序排序"></a>如何实现降序排序</h3><p>在 <code>List&lt;T&gt;.Sort</code> 方法中，默认的排序顺序是升序（从小到大）。通过 <code>(a, b) =&gt; b.CompareTo(a)</code>，实际上是将两个元素的比较顺序进行了调换，即比较 <code>b</code> 和 <code>a</code>，而不是 <code>a</code> 和 <code>b</code>。这样可以实现降序排序（从大到小）。</p><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下代码演示了使用自定义比较委托来对列表进行降序排序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span> &#125;;<br><br>        <span class="hljs-comment">// 使用自定义比较器进行降序排序</span><br>        numbers.Sort((a, b) =&gt; b.CompareTo(a));<br><br>        Console.WriteLine(<span class="hljs-string">&quot;降序排序后的列表:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">降序排序后的列表:</span><br>10<br>8<br>5<br>3<br>2<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>(a, b) =&gt; b.CompareTo(a)</code> 实现了降序排列，将较大的数排在前面。</p><h1 id="51-Lambda-表达式"><a href="#51-Lambda-表达式" class="headerlink" title="51. Lambda 表达式"></a>51. Lambda 表达式</h1><p>Lambda 表达式是一个匿名函数，用于创建委托或表达式树。它可以包含表达式或语句块，并且非常适合用来简化代码、实现委托、LINQ 查询和事件处理。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Lambda 表达式的基本语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">(parameters) =&gt; expression <span class="hljs-comment">//函数体只有一句，可以不用&#123;&#125;大括号</span><br></code></pre></td></tr></table></figure><ul><li><code>parameters</code>：输入参数，可以有一个或多个，用圆括号括起来。一个可以不用圆括号括起来</li><li>$&#x3D;&gt;$：Lambda 操作符，分隔参数和表达式。</li><li><code>expression</code>：Lambda 表达式的主体，通常是一个单一的表达式。<br>如果 Lambda 表达式的主体包含多条语句，则需要使用大括号：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">(parameters) =&gt; &#123; statements &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><h4 id="1-简单示例"><a href="#1-简单示例" class="headerlink" title="1. 简单示例"></a>1. 简单示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; square = x =&gt; x * x; <span class="hljs-comment">// Func是泛型委托，最后一个int表示返回值是int，第一个参数以及后的参数表示输入的参数</span><br>Console.WriteLine(square(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 25</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>x =&gt; x * x</code> 是一个 Lambda 表达式，它接受一个整数参数 <code>x</code>，并返回它的平方。</p><h4 id="2-多参数的-Lambda-表达式"><a href="#2-多参数的-Lambda-表达式" class="headerlink" title="2. 多参数的 Lambda 表达式"></a>2. 多参数的 Lambda 表达式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; a + b;<br>Console.WriteLine(<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><p>此示例中，Lambda 表达式 <code>(a, b) =&gt; a + b</code> 接受两个整数参数并返回它们的和。</p><h4 id="3-使用语句块的-Lambda-表达式"><a href="#3-使用语句块的-Lambda-表达式" class="headerlink" title="3. 使用语句块的 Lambda 表达式"></a>3. 使用语句块的 Lambda 表达式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action&lt;<span class="hljs-built_in">string</span>&gt; greet = name =&gt;<br>&#123;<br>    <span class="hljs-built_in">string</span> greeting = <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    Console.WriteLine(greeting);<br>&#125;;<br>greet(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 输出 Hello, Alice</span><br></code></pre></td></tr></table></figure><p>此示例中的 Lambda 表达式使用了大括号，因为它包含多条语句。</p><h3 id="Lambda-表达式在-LINQ-中的使用"><a href="#Lambda-表达式在-LINQ-中的使用" class="headerlink" title="Lambda 表达式在 LINQ 中的使用"></a>Lambda 表达式在 LINQ 中的使用</h3><p>Lambda 表达式经常用于 LINQ 查询。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToList();<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> evenNumbers)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出 2 和 4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>n =&gt; n % 2 == 0</code> 是一个 Lambda 表达式，用于过滤出偶数。</p><h3 id="使用-Lambda-表达式的优势"><a href="#使用-Lambda-表达式的优势" class="headerlink" title="使用 Lambda 表达式的优势"></a>使用 Lambda 表达式的优势</h3><ol><li><strong>简洁性</strong>：可以用更少的代码实现功能。</li><li><strong>灵活性</strong>：方便地用于创建委托、事件处理程序或表达式树。</li><li><strong>可读性</strong>：与 C# 语言的其他特性（如 LINQ）结合使用时，可以提高代码的可读性。</li></ol><h1 id="51-HashSet"><a href="#51-HashSet" class="headerlink" title="51. HashSet"></a>51. HashSet</h1><p><code>HashSet&lt;T&gt;</code> 是 C# 中的一种集合类型，它实现了集合的数学概念，特别是无序和唯一性。<code>HashSet&lt;T&gt;</code> 适合用于存储不重复的元素，并提供快速的查找、添加和删除操作。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>无序性</strong>：<code>HashSet&lt;T&gt;</code> 中的元素没有特定的顺序。</li><li><strong>唯一性</strong>：集合中的每个元素都是唯一的，不能重复添加相同的元素。</li><li><strong>快速操作</strong>：由于使用哈希表实现，<code>HashSet&lt;T&gt;</code> 提供 O(1) 的平均时间复杂度用于查找、添加和删除操作。</li></ol><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>**<code>Add(T item)</code>**：向集合中添加元素。如果元素已存在，则不会添加，并返回 <code>false</code>。添加成功返回true。（如果用Console.WriteLine()输出变成了True）</li><li>**<code>Remove(T item)</code>**：从集合中移除元素。如果元素不存在，则返回 <code>false</code>。</li><li>**<code>Contains(T item)</code>**：检查集合中是否包含指定的元素。</li><li>**<code>Clear()</code>**：移除集合中的所有元素。</li><li>**<code>Count</code>**：获取集合中元素的数量。</li><li>**<code>UnionWith(IEnumerable&lt;T&gt; other)</code>**：将当前集合与指定集合的并集合并。</li><li>**<code>IntersectWith(IEnumerable&lt;T&gt; other)</code>**：将当前集合与指定集合的交集更新为当前集合。</li><li>**<code>ExceptWith(IEnumerable&lt;T&gt; other)</code>**：从当前集合中移除与指定集合中相同的元素。</li></ul><h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>HashSet&lt;T&gt;</code> 的示例，展示了如何添加、查找和移除元素：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 HashSet</span><br>        HashSet&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        numbers.Add(<span class="hljs-number">1</span>);<br>        numbers.Add(<span class="hljs-number">2</span>);<br>        numbers.Add(<span class="hljs-number">3</span>);<br>        numbers.Add(<span class="hljs-number">2</span>); <span class="hljs-comment">// 不会添加重复的 2</span><br><br>        Console.WriteLine(<span class="hljs-string">&quot;HashSet 中的元素:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(num); <span class="hljs-comment">// 输出 1, 2, 3</span><br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否包含某个元素</span><br>        <span class="hljs-keyword">if</span> (numbers.Contains(<span class="hljs-number">2</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;集合中包含 2&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 移除元素</span><br>        numbers.Remove(<span class="hljs-number">3</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;移除 3 后的元素:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(num); <span class="hljs-comment">// 输出 1, 2</span><br>        &#125;<br><br>        <span class="hljs-comment">// 清空集合</span><br>        numbers.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;集合是否为空: <span class="hljs-subst">&#123;numbers.Count == <span class="hljs-number">0</span>&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>去重</strong>：存储一组唯一元素，避免重复。</li><li><strong>快速查找</strong>：快速判断某个元素是否存在于集合中。</li><li><strong>集合运算</strong>：执行并集、交集和差集等集合运算。</li></ul><h1 id="52-Dictionary"><a href="#52-Dictionary" class="headerlink" title="52. Dictionary"></a>52. Dictionary</h1><p><code>Dictionary&lt;TKey, TValue&gt;</code> 是 C# 中的一种集合类型，用于存储键值对（key-value pairs）。它是一个哈希表的实现，提供了快速的查找、添加和删除操作，适合需要快速访问和唯一键的场景。</p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>键唯一性</strong>：每个键在字典中都是唯一的，不能重复。</li><li><strong>快速访问</strong>：通过键可以快速访问对应的值，查找、添加和删除操作的平均时间复杂度为 O(1)。</li><li><strong>动态大小</strong>：字典的大小可以动态调整，可以根据需要增加或减少存储的键值对。</li></ol><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>**<code>Add(TKey key, TValue value)</code>**：向字典中添加新的键值对。如果键已存在，则抛出异常。</li><li>**<code>Remove(TKey key)</code>**：移除指定键的键值对，并返回是否成功。</li><li>**<code>TryGetValue(TKey key, out TValue value)</code>**：尝试获取指定键的值，返回一个布尔值指示是否成功。</li><li>**<code>ContainsKey(TKey key)</code>**：检查字典中是否包含指定的键。</li><li>**<code>ContainsValue(TValue value)</code>**：检查字典中是否包含指定的值。</li><li>**<code>Count</code>**：获取字典中键值对的数量。</li><li>**<code>Clear()</code>**：移除字典中的所有键值对。</li><li>**<code>Keys</code>**：获取字典中所有的键。</li><li>**<code>Values</code>**：获取字典中所有的值。</li></ul><h3 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>Dictionary&lt;TKey, TValue&gt;</code> 的示例，展示了如何添加、查找和移除元素：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 Dictionary</span><br>        Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; ages = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// 添加键值对</span><br>        ages.Add(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        ages.Add(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>);<br>        ages.Add(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">35</span>);<br><br>        <span class="hljs-comment">// 输出所有的键值对</span><br>        Console.WriteLine(<span class="hljs-string">&quot;姓名和年龄:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> kvp <span class="hljs-keyword">in</span> ages)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;姓名: <span class="hljs-subst">&#123;kvp.Key&#125;</span>, 年龄: <span class="hljs-subst">&#123;kvp.Value&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否包含某个键</span><br>        <span class="hljs-keyword">if</span> (ages.ContainsKey(<span class="hljs-string">&quot;Bob&quot;</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Bob 的年龄: <span class="hljs-subst">&#123;ages[<span class="hljs-string">&quot;Bob&quot;</span>]&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否包含某个值</span><br>        <span class="hljs-keyword">if</span> (ages.ContainsValue(<span class="hljs-number">25</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;存在值25&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 尝试获取值</span><br>        <span class="hljs-keyword">if</span> (ages.TryGetValue(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> charlieAge))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Charlie 的年龄: <span class="hljs-subst">&#123;charlieAge&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 移除元素</span><br>        ages.Remove(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;移除 Alice 后的键值对:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> kvp <span class="hljs-keyword">in</span> ages)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;姓名: <span class="hljs-subst">&#123;kvp.Key&#125;</span>, 年龄: <span class="hljs-subst">&#123;kvp.Value&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 键值对一起遍历</span><br>        <span class="hljs-comment">// KeyValuePair&lt;string, int&gt;可以改为var</span><br>        <span class="hljs-keyword">foreach</span> (KeyValuePair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; kvp <span class="hljs-keyword">in</span> ages)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;姓名: <span class="hljs-subst">&#123;kvp.Key&#125;</span>, 年龄: <span class="hljs-subst">&#123;kvp.Value&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// key不存在会报错 System.Collections.Generic.KeyNotFoundException</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;修改前Bob 的年龄: <span class="hljs-subst">&#123;ages[<span class="hljs-string">&quot;Bob&quot;</span>]&#125;</span>&quot;</span>);<br>        ages[<span class="hljs-string">&quot;Bob&quot;</span>] = <span class="hljs-number">100</span>; <span class="hljs-comment">// key不存在的话，系统就会默认去创建一个</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;修改后Bob 的年龄: <span class="hljs-subst">&#123;ages[<span class="hljs-string">&quot;Bob&quot;</span>]&#125;</span>&quot;</span>);<br><br><br>        <span class="hljs-comment">// 清空字典</span><br>        ages.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;字典是否为空: <span class="hljs-subst">&#123;ages.Count == <span class="hljs-number">0</span>&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>快速查找</strong>：通过键快速获取对应的值，适用于存储和查找关联数据。</li><li><strong>频率统计</strong>：可用于统计某个元素出现的频率，如单词计数等。</li><li><strong>配置和选项</strong>：存储配置信息或选项，便于通过键快速访问。<br><code>Dictionary&lt;TKey, TValue&gt;</code> 是处理需要快速查找、存储键值对时非常有用的工具，适合多种数据管理和操作场景。</li></ul><h1 id="53-Dictionary和Hashtable区别"><a href="#53-Dictionary和Hashtable区别" class="headerlink" title="53. Dictionary和Hashtable区别"></a>53. Dictionary和Hashtable区别</h1><p><code>Dictionary&lt;TKey, TValue&gt;</code> 和 <code>Hashtable</code> 都是用于存储键值对的集合类型，但它们之间有几个重要的区别：</p><h3 id="1-类型安全"><a href="#1-类型安全" class="headerlink" title="1. 类型安全"></a>1. 类型安全</h3><ul><li>**<code>Dictionary&lt;TKey, TValue&gt;</code>**：是泛型集合，提供类型安全，允许在编译时检查键和值的类型。例如，你可以定义 <code>Dictionary&lt;string, int&gt;</code>，这确保键是字符串，值是整数。</li><li>**<code>Hashtable</code>**：是非泛型集合，可以存储任何类型的对象，键和值都是 <code>object</code> 类型。这意味着在运行时可能会遇到类型不匹配的问题，需要进行显式类型转换。</li></ul><h3 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h3><ul><li>**<code>Dictionary&lt;TKey, TValue&gt;</code>**：因为它是泛型的，所以在使用时不需要进行装箱和拆箱，通常具有更好的性能。</li><li>**<code>Hashtable</code>**：由于其使用 <code>object</code> 类型，可能需要装箱和拆箱，性能上可能会稍差。</li></ul><h3 id="3-访问方式"><a href="#3-访问方式" class="headerlink" title="3. 访问方式"></a>3. 访问方式</h3><ul><li>**<code>Dictionary&lt;TKey, TValue&gt;</code>**：通过键访问值的方式更为简洁和直观，且支持更复杂的键类型（如自定义类型），并且提供方法如 <code>TryGetValue</code> 来尝试获取值而不抛出异常。</li><li>**<code>Hashtable</code>**：使用 <code>ContainsKey</code> 和 <code>ContainsValue</code> 方法来检查键和值，且需要显式类型转换。</li></ul><h3 id="4-默认行为"><a href="#4-默认行为" class="headerlink" title="4. 默认行为"></a>4. 默认行为</h3><ul><li>**<code>Dictionary&lt;TKey, TValue&gt;</code>**：在键不存在时，访问一个不存在的键会抛出 <code>KeyNotFoundException</code>。</li><li>**<code>Hashtable</code>**：如果访问一个不存在的键，则返回 <code>null</code>。</li></ul><h3 id="5-可扩展性"><a href="#5-可扩展性" class="headerlink" title="5. 可扩展性"></a>5. 可扩展性</h3><ul><li>**<code>Dictionary&lt;TKey, TValue&gt;</code>**：支持并发的集合，例如 <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>，适用于多线程环境。</li><li>**<code>Hashtable</code>**：是线程安全的，但使用的同步方法可能会导致性能问题。</li></ul><h3 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是两个集合的基本用法示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Dictionary</span><br>        Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; dictionary = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;<br>        &#123;<br>            &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span> &#125;,<br>            &#123; <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span> &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 访问值</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Alice&#x27;s age: <span class="hljs-subst">&#123;dictionary[<span class="hljs-string">&quot;Alice&quot;</span>]&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 Hashtable</span><br>        Hashtable hashtable = <span class="hljs-keyword">new</span> Hashtable<br>        &#123;<br>            &#123; <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">35</span> &#125;,<br>            &#123; <span class="hljs-string">&quot;Dave&quot;</span>, <span class="hljs-number">40</span> &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 访问值</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Charlie&#x27;s age: <span class="hljs-subst">&#123;hashtable[<span class="hljs-string">&quot;Charlie&quot;</span>]&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>在大多数情况下，建议使用 <code>Dictionary&lt;TKey, TValue&gt;</code> 而不是 <code>Hashtable</code>，因为其类型安全性、性能和功能更优越。<code>Hashtable</code> 主要是为了向后兼容，现代 C# 开发中更推荐使用泛型集合。</p><h1 id="54-LinkedList"><a href="#54-LinkedList" class="headerlink" title="54. LinkedList"></a>54. LinkedList</h1><p><code>LinkedList&lt;T&gt;</code> 是 C# 中的一种双向链表集合，提供了一种高效的方式来存储和操作数据。与数组或列表不同，链表中的元素（称为节点）是动态分配的，因此在插入和删除操作时具有更好的性能，特别是在大数据集的操作中。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>双向链表</strong>：<code>LinkedList&lt;T&gt;</code> 是一个双向链表，节点包含对前一个和后一个节点的引用，因此可以从任何节点轻松遍历链表。</li><li><strong>动态大小</strong>：可以在运行时动态添加或删除节点，无需重新分配整个集合的大小。</li><li><strong>无序存储</strong>：与数组和列表不同，<code>LinkedList&lt;T&gt;</code> 不保持元素的顺序，而是按插入顺序存储节点。</li></ol><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>以下是一些 <code>LinkedList&lt;T&gt;</code> 的常用方法：</p><ul><li><strong>添加元素</strong>：<ul><li><code>AddFirst(T value)</code>：在链表开头添加一个新节点。</li><li><code>AddLast(T value)</code>：在链表末尾添加一个新节点。</li><li><code>AddBefore(LinkedListNode&lt;T&gt; node, T value)</code>：在指定节点之前插入一个新节点。</li><li><code>AddAfter(LinkedListNode&lt;T&gt; node, T value)</code>：在指定节点之后插入一个新节点。</li></ul></li><li><strong>删除元素</strong>：<ul><li><code>Remove(T value)</code>：删除第一个匹配的节点。</li><li><code>RemoveFirst()</code>：删除链表的第一个节点。</li><li><code>RemoveLast()</code>：删除链表的最后一个节点。</li><li><code>Remove(LinkedListNode&lt;T&gt; node)</code>：删除指定的节点。</li></ul></li><li><strong>查找节点</strong>：<ul><li><code>Find(T value)</code>：查找第一个匹配的节点，未找到时返回 <code>null</code>。</li><li>没有提供找最后一个匹配的节点的方法，需要自己手动实现</li></ul></li><li><strong>遍历</strong>：<ul><li>可以使用 <code>foreach</code> 循环遍历链表中的节点。</li></ul></li><li>获取节点：<ul><li><strong><code>First</code></strong>: 获取链表的第一个节点。</li><li><strong><code>Last</code></strong>: 获取链表的最后一个节点。</li></ul></li><li>清空链表<ul><li><strong><code>Clear()</code></strong>: 清空链表中的所有节点。</li></ul></li><li>获取元素数量<ul><li><strong><code>Count</code></strong>: 获取链表中节点的数量。</li></ul></li><li>其他方法<ul><li><strong><code>Contains(T value)</code></strong>: 检查链表中是否包含指定的值。</li></ul></li></ul><h3 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>LinkedList&lt;T&gt;</code> 的简单示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 LinkedList</span><br>        LinkedList&lt;<span class="hljs-built_in">string</span>&gt; linkedList = <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        linkedList.AddLast(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        linkedList.AddLast(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        linkedList.AddFirst(<span class="hljs-string">&quot;Charlie&quot;</span>);<br><br>        <span class="hljs-comment">// 遍历链表</span><br>        Console.WriteLine(<span class="hljs-string">&quot;链表中的元素:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> linkedList)<br>        &#123;<br>            Console.WriteLine(name);<br>        &#125;<br><br>        <span class="hljs-comment">// 删除元素</span><br>        linkedList.Remove(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        linkedList.RemoveFirst();<br><br>        <span class="hljs-comment">// 遍历链表</span><br>        Console.WriteLine(<span class="hljs-string">&quot;\n删除 Bob 和第一个节点后的链表:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> linkedList)<br>        &#123;<br>            Console.WriteLine(name);<br>        &#125;<br><br>        <span class="hljs-comment">// 从头到尾遍历</span><br>        LinkedListNode&lt;<span class="hljs-built_in">string</span>&gt; nowNode = linkedList.First;<br>        <span class="hljs-keyword">while</span> (nowNode != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(nowNode.Value);<br>            nowNode = nowNode.Next;<br>        &#125;<br>        <span class="hljs-comment">// 从尾到头遍历</span><br>        nowNode = linkedList.Last;<br>        <span class="hljs-keyword">while</span> (nowNode != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(nowNode.Value);<br>            nowNode = nowNode.Previous;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找元素</span><br>        <span class="hljs-keyword">var</span> node = linkedList.Find(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;\n找到节点: <span class="hljs-subst">&#123;node.Value&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;\n未找到节点&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 添加元素</span><br>        linkedList.AddAfter(node, <span class="hljs-string">&quot;AddAfter&quot;</span>);<br>        linkedList.AddBefore(node, <span class="hljs-string">&quot;AddBefore&quot;</span>);<br><br>        <span class="hljs-comment">// 获取第一个和最后一个节点</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;第一个节点: <span class="hljs-subst">&#123;linkedList.First.Value&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;最后一个节点: <span class="hljs-subst">&#123;linkedList.Last.Value&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 修改</span><br>        linkedList.First.Value = <span class="hljs-string">&quot;修改了&quot;</span>;<br>        linkedList.Last.Value = <span class="hljs-string">&quot;修改了2&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">$&quot;第一个节点: <span class="hljs-subst">&#123;linkedList.First.Value&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;最后一个节点: <span class="hljs-subst">&#123;linkedList.Last.Value&#125;</span>&quot;</span>);<br>        <span class="hljs-comment">// 清空链表</span><br>        linkedList.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;链表清空后元素数量: <span class="hljs-subst">&#123;linkedList.Count&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>运行上述代码，输出将会是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">链表中的元素:</span><br>Charlie<br>Alice<br>Bob<br><br>删除 Bob 和第一个节点后的链表:<br>Alice<br>Alice<br>Alice<br><br><span class="hljs-section">找到节点: Alice</span><br><span class="hljs-section">第一个节点: AddBefore</span><br><span class="hljs-section">最后一个节点: AddAfter</span><br><span class="hljs-section">第一个节点: 修改了</span><br><span class="hljs-section">最后一个节点: 修改了2</span><br><span class="hljs-section">链表清空后元素数量: 0</span><br><br></code></pre></td></tr></table></figure><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>频繁插入和删除</strong>：<code>LinkedList&lt;T&gt;</code> 特别适合频繁在集合的开头和中间插入和删除元素的场景，例如实现某些数据结构（如队列、栈或图）的底层逻辑。</li><li><strong>不需要随机访问</strong>：由于不支持索引访问，<code>LinkedList&lt;T&gt;</code> 不适合需要频繁随机访问的场景。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>LinkedList&lt;T&gt;</code> 提供了一个灵活且高效的方式来管理动态数据，尤其在插入和删除操作频繁的情况下表现出色。但在需要频繁随机访问的场景中，使用数组或列表可能更为合适。</p><h1 id="55-LinkedList和List区别"><a href="#55-LinkedList和List区别" class="headerlink" title="55. LinkedList和List区别"></a>55. LinkedList和List区别</h1><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><ul><li><code>List&lt;T&gt;</code> ： <ul><li>基于数组实现，是一个动态数组。</li><li>数据存储在连续的内存位置。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>基于双向链表实现，由一系列节点组成。</li><li>每个节点包含数据和指向前后节点的引用。</li></ul></li></ul><h3 id="2-存取性能"><a href="#2-存取性能" class="headerlink" title="2. 存取性能"></a>2. 存取性能</h3><ul><li><code>List&lt;T&gt;</code>：<ul><li>随机访问性能优越，索引访问（如 <code>list[0]</code>）的时间复杂度为 O(1)。</li><li>插入和删除元素的时间复杂度为 O(n)，因为可能需要移动大量元素。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>访问性能较差，索引访问的时间复杂度为 O(n)，因为必须从头部或尾部开始遍历。</li><li>插入和删除元素的时间复杂度为 O(1)，在已知节点的情况下非常高效。</li></ul></li></ul><h3 id="3-内存使用"><a href="#3-内存使用" class="headerlink" title="3. 内存使用"></a>3. 内存使用</h3><ul><li><code>List&lt;T&gt;</code>：<ul><li>内存占用相对较少，因为只需要存储元素本身。</li><li>当数组容量不足时，可能会进行扩展（复制到新数组），这会造成性能开销。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>每个节点需要额外的内存来存储前后节点的引用，因此内存使用较高。</li></ul></li></ul><h3 id="4-功能特性"><a href="#4-功能特性" class="headerlink" title="4. 功能特性"></a>4. 功能特性</h3><ul><li><code>List&lt;T&gt;</code>：<ul><li>提供了索引、排序、查找等多种方法。</li><li>适合需要频繁访问元素的场景。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>支持双向遍历，能够在任意位置高效插入和删除节点。</li><li>适合需要频繁添加和删除元素的场景，特别是在中间位置。</li></ul></li></ul><h3 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h3><ul><li><code>List&lt;T&gt;</code>：<ul><li>当数据量不频繁变化，且需要随机访问的情况，如实现栈、队列等功能。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>当数据量变化频繁，且需要频繁插入和删除元素的情况，如实现双向队列、最近使用缓存等功能。</li></ul></li></ul><h3 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// List&lt;T&gt; 示例</span><br>List&lt;<span class="hljs-built_in">int</span>&gt; numbersList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>numbersList.Add(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加元素</span><br><span class="hljs-built_in">int</span> secondNumber = numbersList[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 随机访问</span><br><br><span class="hljs-comment">// LinkedList&lt;T&gt; 示例</span><br>LinkedList&lt;<span class="hljs-built_in">int</span>&gt; numbersLinkedList = <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);<br>numbersLinkedList.AddLast(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加元素</span><br>numbersLinkedList.Remove(<span class="hljs-number">2</span>); <span class="hljs-comment">// 删除元素</span><br><br></code></pre></td></tr></table></figure><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul><li>选择 <code>List&lt;T&gt;</code> 还是 <code>LinkedList&lt;T&gt;</code> 取决于具体需求。如果需要快速随机访问，使用 <code>List&lt;T&gt;</code> 更加合适；如果需要频繁的插入和删除操作，尤其是在中间位置，使用 <code>LinkedList&lt;T&gt;</code> 更加高效。</li></ul><h1 id="56-委托"><a href="#56-委托" class="headerlink" title="56.  委托"></a>56.  委托</h1><p>委托（Delegate）是 C# 中一种类型，代表对方法的引用，可以用于实现事件、回调和异步编程。委托允许将方法作为参数传递，并提供了一种灵活的方式来组织代码和实现解耦。</p><h3 id="1-委托的定义"><a href="#1-委托的定义" class="headerlink" title="1. 委托的定义"></a>1. 委托的定义</h3><p>委托定义了一种方法的签名（参数类型和返回类型），任何具有相同签名的方法都可以赋值给这个委托。可以理解为函数的容器，可以添加函数，不止添加一个</p><ul><li>默认的访问修饰符为public</li><li>一般写在namespace中，class中也可以写</li></ul><h3 id="2-委托的基本用法"><a href="#2-委托的基本用法" class="headerlink" title="2. 委托的基本用法"></a>2. 委托的基本用法</h3><h4 id="2-1-定义委托"><a href="#2-1-定义委托" class="headerlink" title="2.1 定义委托"></a>2.1 定义委托</h4><p>使用 <code>delegate</code> 关键字定义一个委托类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 访问修饰符 delegate 返回值 委托名(参数列表)</span><br><span class="hljs-comment">// 定义了一个返回值为void，参数为string的委托</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="2-2-实例化委托"><a href="#2-2-实例化委托" class="headerlink" title="2.2 实例化委托"></a>2.2 实例化委托</h4><p>将方法实例化为委托。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// 访问修饰符 delegate 返回值 委托名(参数列表)</span><br>    <span class="hljs-comment">// 定义了一个返回值为void，参数为string的委托</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>    <span class="hljs-comment">// 但是并没有使用这个函数</span><br>        MyDelegate del = MyMethod; <span class="hljs-comment">// 创建委托实例</span><br>        del(<span class="hljs-string">&quot;Hello, Delegates!&quot;</span>); <span class="hljs-comment">// 调用委托</span><br>        MyDelegate del2 = <span class="hljs-keyword">new</span> MyDelegate(MyMethod);<span class="hljs-comment">// 创建委托实例</span><br>        del2(<span class="hljs-string">&quot;你好，委托&quot;</span>);<span class="hljs-comment">// 调用委托</span><br>        del2.Invoke(<span class="hljs-string">&quot;你好委托2&quot;</span>);<span class="hljs-comment">// 调用委托</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-多播委托"><a href="#3-多播委托" class="headerlink" title="3. 多播委托"></a>3. 多播委托</h3><p>委托可以指向多个方法，这是所谓的多播委托。使用 <code>+=</code> 操作符可以将方法添加到委托中，使用 <code>-=</code> 操作符可以将方法从委托中移除。</p><ul><li>按顺序依次执行添加，并以依次执行</li><li>减的时候先减去后添加的</li><li>为空能加也能减</li><li>多减不会报错，无非只是不处理</li><li>委托 &#x3D; null,表示清空容器<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodA</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;MethodA: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodB</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;MethodB: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyDelegate del = MethodA; <span class="hljs-comment">// 创建委托实例，需要先初始化才行或者是del = null;</span><br>        <span class="hljs-comment">// 不可以直接用,比如</span><br>        <span class="hljs-comment">// MyDelegate del;</span><br>        del += MethodB; <span class="hljs-comment">// 添加方法</span><br><br>        del(<span class="hljs-string">&quot;Hello, Multicast Delegates!&quot;</span>); <span class="hljs-comment">// 调用所有方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-带参数和返回值的委托"><a href="#4-带参数和返回值的委托" class="headerlink" title="4. 带参数和返回值的委托"></a>4. 带参数和返回值的委托</h3><p>委托不仅可以没有返回值，也可以有返回值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MathOperation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Subtract</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x - y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MathOperation operation;<br><br>        operation = Add;<br>        Console.WriteLine(operation(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 8</span><br><br>        operation = Subtract;<br>        Console.WriteLine(operation(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-匿名方法"><a href="#5-匿名方法" class="headerlink" title="5. 匿名方法"></a>5. 匿名方法</h3><p>C# 允许使用匿名方法来创建委托，省略方法名称。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-built_in">delegate</span> (<span class="hljs-built_in">string</span> message)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Anonymous: &quot;</span> + message);<br>        &#125;;<br><br>        del(<span class="hljs-string">&quot;Hello, Anonymous Methods!&quot;</span>); <span class="hljs-comment">// 调用匿名方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Lambda-表达式"><a href="#6-Lambda-表达式" class="headerlink" title="6. Lambda 表达式"></a>6. Lambda 表达式</h3><p>从 C# 3.0 开始，支持使用 Lambda 表达式简化委托的创建。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyDelegate del = message =&gt; Console.WriteLine(<span class="hljs-string">&quot;Lambda: &quot;</span> + message);<br>        del(<span class="hljs-string">&quot;Hello, Lambda Expressions!&quot;</span>); <span class="hljs-comment">// 调用 Lambda 表达式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-委托作为函数参数"><a href="#7-委托作为函数参数" class="headerlink" title="7. 委托作为函数参数"></a>7. 委托作为函数参数</h3><p>在这个例子中，我们定义一个委托类型 <code>MathOperation</code>，然后创建一个接受委托作为参数的方法 <code>PerformOperation</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MathOperation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>; <span class="hljs-comment">// 定义委托</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">PerformOperation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y, MathOperation operation</span>) <span class="hljs-comment">// 委托作为参数</span></span><br>    &#123;<br>        <span class="hljs-keyword">return</span> operation(x, y); <span class="hljs-comment">// 调用委托</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x + y; <span class="hljs-comment">// 加法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Subtract</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x - y; <span class="hljs-comment">// 减法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Calculator calculator = <span class="hljs-keyword">new</span> Calculator();<br><br>        <span class="hljs-comment">// 使用委托调用加法</span><br>        <span class="hljs-built_in">int</span> resultAdd = calculator.PerformOperation(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, Add);<br>        Console.WriteLine(<span class="hljs-string">$&quot;5 + 3 = <span class="hljs-subst">&#123;resultAdd&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用委托调用减法</span><br>        <span class="hljs-built_in">int</span> resultSubtract = calculator.PerformOperation(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, Subtract);<br>        Console.WriteLine(<span class="hljs-string">$&quot;5 - 3 = <span class="hljs-subst">&#123;resultSubtract&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-委托作为类的成员"><a href="#8-委托作为类的成员" class="headerlink" title="8. 委托作为类的成员"></a>8. 委托作为类的成员</h3><p>在这个例子中，我们定义一个类 <code>Notifier</code>，其中包含一个委托类型的成员 <code>Notify</code>。这个委托可以指向任何符合签名的方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>; <span class="hljs-comment">// 定义委托</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Notifier</span><br>&#123;<br>    <span class="hljs-keyword">public</span> NotifyDelegate Notify; <span class="hljs-comment">// 委托作为类的成员</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendNotification</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Notify?.Invoke(message); <span class="hljs-comment">// 调用委托</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Notifier notifier = <span class="hljs-keyword">new</span> Notifier();<br><br>        <span class="hljs-comment">// 为委托分配方法</span><br>        notifier.Notify += message =&gt; Console.WriteLine(<span class="hljs-string">&quot;Notification: &quot;</span> + message);<br>        <br>        <span class="hljs-comment">// 发送通知</span><br>        notifier.SendNotification(<span class="hljs-string">&quot;Hello, this is a notification!&quot;</span>);<br>        <br>        <span class="hljs-comment">// 可以添加更多的订阅者</span><br>        notifier.Notify += message =&gt; Console.WriteLine(<span class="hljs-string">&quot;Another listener: &quot;</span> + message);<br>        <br>        <span class="hljs-comment">// 再次发送通知</span><br>        notifier.SendNotification(<span class="hljs-string">&quot;Another notification!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>委托作为函数参数</strong>：使得函数可以接受不同的操作，增加了灵活性。</li><li><strong>委托作为类的成员</strong>：允许类动态地调用不同的方法，方便实现事件处理或通知机制。</li></ul><h3 id="9-泛型委托"><a href="#9-泛型委托" class="headerlink" title="9. 泛型委托"></a>9. 泛型委托</h3><p>泛型委托允许在定义委托时指定一个或多个类型参数，使得委托可以支持不同的数据类型。下面是泛型委托的基本定义及其使用的示例：</p><h4 id="定义泛型委托"><a href="#定义泛型委托" class="headerlink" title="定义泛型委托"></a>定义泛型委托</h4><p>首先，定义一个泛型委托，它接受两个类型参数，并返回一个结果类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TOutput <span class="hljs-title">GenericDelegate</span>&lt;<span class="hljs-title">TInput1</span>, <span class="hljs-title">TInput2</span>, <span class="hljs-title">TOutput</span>&gt;(<span class="hljs-params">TInput1 input1, TInput2 input2</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个泛型委托 <code>GenericDelegate</code> 有两个输入参数类型 <code>TInput1</code> 和 <code>TInput2</code>，返回一个结果类型 <code>TOutput</code>。</p><h4 id="使用泛型委托的示例"><a href="#使用泛型委托的示例" class="headerlink" title="使用泛型委托的示例"></a>使用泛型委托的示例</h4><p>使用上面定义的泛型委托，可以实现不同类型的操作。例如，实现一个函数，将两个数字相加并返回结果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 实例化泛型委托，传入两个int类型并返回int类型</span><br>        GenericDelegate&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (x, y) =&gt; x + y;<br>        <span class="hljs-built_in">int</span> sum = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Sum: <span class="hljs-subst">&#123;sum&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出：Sum: 7</span><br><br>        <span class="hljs-comment">// 实例化泛型委托，传入两个字符串并返回字符串的拼接结果</span><br>        GenericDelegate&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; concatenate = (s1, s2) =&gt; s1 + s2;<br>        <span class="hljs-built_in">string</span> result = concatenate(<span class="hljs-string">&quot;Hello, &quot;</span>, <span class="hljs-string">&quot;World!&quot;</span>);<br>        Console.WriteLine(result); <span class="hljs-comment">// 输出：Hello, World!</span><br><br>        <span class="hljs-comment">// 实例化泛型委托，传入int和double，返回字符串</span><br>        GenericDelegate&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">double</span>, <span class="hljs-built_in">string</span>&gt; combine = (x, y) =&gt; <span class="hljs-string">$&quot;Combined value: <span class="hljs-subst">&#123;x + y&#125;</span>&quot;</span>;<br>        <span class="hljs-built_in">string</span> combinedResult = combine(<span class="hljs-number">5</span>, <span class="hljs-number">7.5</span>);<br>        Console.WriteLine(combinedResult); <span class="hljs-comment">// 输出：Combined value: 12.5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h4><ul><li>**<code>add</code>**：这是一个泛型委托的实例，用于将两个整数相加并返回结果。它的类型参数为 <code>&lt;int, int, int&gt;</code>，表示输入参数和返回值的类型都是 <code>int</code>。</li><li>**<code>concatenate</code>**：用于将两个字符串拼接在一起，并返回拼接结果。其类型参数为 <code>&lt;string, string, string&gt;</code>，表示输入参数和返回值的类型都是 <code>string</code>。</li><li>**<code>combine</code>**：用于将一个整数和一个双精度浮点数相加，并返回结果字符串。其类型参数为 <code>&lt;int, double, string&gt;</code>，表示输入参数分别是 <code>int</code> 和 <code>double</code>，返回值为 <code>string</code>。</li></ul><h3 id="10-使用场景"><a href="#10-使用场景" class="headerlink" title="10. 使用场景"></a>10. 使用场景</h3><ul><li><strong>事件处理</strong>：委托常用于事件处理机制。</li><li><strong>回调</strong>：可以用作异步方法的回调。</li><li><strong>LINQ</strong>：在 LINQ 中广泛使用委托（如 <code>Func&lt;T&gt;</code> 和 <code>Action&lt;T&gt;</code>）。</li></ul><h1 id="57-系统定义好的委托"><a href="#57-系统定义好的委托" class="headerlink" title="57. 系统定义好的委托"></a>57. 系统定义好的委托</h1><p>C# 提供了一些常用的系统定义的委托，用于简化和通用地表达各种方法签名。这些委托类型定义在 <code>System</code> 命名空间中，最常用的系统定义委托包括：</p><ul><li>委托的名字不能和函数一样，不然还是委托，会重复添加之前委托中所有的函数</li></ul><ol><li><strong>Action 系列</strong><br> <code>Action</code> 委托用于定义没有返回值的方法。可以有 0 到 16 个参数。<ul><li>**<code>Action</code>**：没有参数的委托，表示不接受参数且无返回值的方法。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action action = () =&gt; Console.WriteLine(<span class="hljs-string">&quot;Hello, Action!&quot;</span>);<br>action(); <span class="hljs-comment">// 输出：Hello, Action!</span><br></code></pre></td></tr></table></figure></li><li>**<code>Action&lt;T1&gt;</code>**：一个参数的委托。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action&lt;<span class="hljs-built_in">string</span>&gt; greet = name =&gt; Console.WriteLine(<span class="hljs-string">$&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span>);<br>greet(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 输出：Hello, Alice!</span><br></code></pre></td></tr></table></figure></li><li>**<code>Action&lt;T1, T2&gt;</code>**：两个参数的委托。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; Console.WriteLine(a + b);<br><span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 输出：7</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong>Func 系列</strong><br> <code>Func</code> 委托用于定义有返回值的方法。它的最后一个类型参数始终表示返回类型，前面的类型参数表示输入参数。<ul><li>**<code>Func&lt;TResult&gt;</code>**：没有参数的方法，返回一个值。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>&gt; getRandomNumber = () =&gt; <span class="hljs-keyword">new</span> Random().Next(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">int</span> randomNumber = getRandomNumber();<br>Console.WriteLine(randomNumber);<br></code></pre></td></tr></table></figure></li><li>**<code>Func&lt;T1, TResult&gt;</code>**：一个参数的方法，返回一个值。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; square = x =&gt; x * x;<br><span class="hljs-built_in">int</span> result = square(<span class="hljs-number">5</span>); <span class="hljs-comment">// 结果为 25</span><br>Console.WriteLine(result); <br></code></pre></td></tr></table></figure></li><li>**<code>Func&lt;T1, T2, TResult&gt;</code>**：两个参数的方法，返回一个值。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; a + b;<br><span class="hljs-built_in">int</span> sum = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 结果为 7</span><br>Console.WriteLine(sum);<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>Predicate 系列</strong><br> <code>Predicate&lt;T&gt;</code> 委托用于定义返回布尔值的方法，接受一个输入参数。<ul><li>**<code>Predicate&lt;T&gt;</code>**：接受一个参数并返回 <code>bool</code> 类型的委托，用于确定某个条件是否满足。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Predicate&lt;<span class="hljs-built_in">int</span>&gt; isEven = x =&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br><span class="hljs-built_in">bool</span> check = isEven(<span class="hljs-number">4</span>); <span class="hljs-comment">// 结果为 true</span><br>Console.WriteLine(check);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>Action</code></strong> 系列用于不返回值的方法，可以有 0 到 16 个参数。</li><li><strong><code>Func</code></strong> 系列用于有返回值的方法，最后一个泛型参数表示返回值类型，其余参数表示输入参数。</li><li><strong><code>Predicate&lt;T&gt;</code></strong> 专门用于判断某个条件，返回 <code>bool</code> 值。</li></ul><h1 id="58-事件"><a href="#58-事件" class="headerlink" title="58. 事件"></a>58. 事件</h1><p>事件（Event）是 C# 中的一种特殊委托，用于通知订阅者在某个操作发生时执行相应的操作。事件通常用于实现发布&#x2F;订阅模式，使得对象可以向外界通知状态变化或某些操作的发生。</p><ul><li>事件是作为成员变量存在于类中</li><li>委托怎么用，事件怎么用</li><li>事件相对于委托的区别<ul><li>不能在类外部赋值</li><li>不能在类外部调用</li><li>可以在类外部添加或者删除函数</li><li>事件只能作为成员存在于类和接口以及结构体中</li><li>不能作为临时变量在函数中使用</li></ul></li></ul><h3 id="1-定义事件"><a href="#1-定义事件" class="headerlink" title="1. 定义事件"></a>1. 定义事件</h3><p>事件的定义基于委托类型，事件本质上是一个委托类型的实例，但增加了一些限制，以确保事件只能在事件声明的类中调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义一个委托</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-comment">// 定义一个包含事件的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-comment">// 声明事件</span><br>    <span class="hljs-comment">// 访问修饰符 event 委托类型 事件名;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> NotifyEventHandler Notify;<br><br>    <span class="hljs-comment">// 方法触发事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件，通知所有订阅者</span><br>        Notify?.Invoke(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-订阅事件"><a href="#2-订阅事件" class="headerlink" title="2. 订阅事件"></a>2. 订阅事件</h3><p>可以通过创建事件处理方法来订阅事件，当事件触发时，会调用这些处理方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义一个委托</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-comment">// 定义一个包含事件的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-comment">// 声明事件</span><br>    <span class="hljs-comment">// 访问修饰符 event 委托类型 事件名;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> NotifyEventHandler Notify;<br><br>    <span class="hljs-comment">// 方法触发事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件，通知所有订阅者</span><br>        Notify?.Invoke(message);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber</span><br>&#123;<br>    <span class="hljs-comment">// 事件处理方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNotifyReceived</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Subscriber received: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br>        Subscriber subscriber = <span class="hljs-keyword">new</span> Subscriber();<br><br>        <span class="hljs-comment">// 订阅事件,添加了两次</span><br>        publisher.Notify += subscriber.OnNotifyReceived;<br>        publisher.Notify += subscriber.OnNotifyReceived;<br><br>        <span class="hljs-comment">// 触发事件，会调用所有添加的事件</span><br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Hello, Event!&quot;</span>);<br><br>        <span class="hljs-comment">// 取消订阅事件</span><br>        publisher.Notify -= subscriber.OnNotifyReceived;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-代码解释"><a href="#3-代码解释" class="headerlink" title="3. 代码解释"></a>3. 代码解释</h3><ul><li><strong>定义委托</strong>：<code>NotifyEventHandler</code> 是一个接受 <code>string</code> 类型参数并返回 <code>void</code> 的委托类型。</li><li><strong>定义事件</strong>：<code>Notify</code> 是一个基于 <code>NotifyEventHandler</code> 委托类型的事件，声明在 <code>Publisher</code> 类中。</li><li><strong>触发事件</strong>：通过调用 <code>TriggerEvent</code> 方法来触发 <code>Notify</code> 事件，并使用 <code>?.Invoke</code> 语法安全地调用事件订阅者。</li><li><strong>订阅和取消订阅事件</strong>：<code>+=</code> 操作符用于订阅事件，<code>-=</code> 操作符用于取消订阅。</li></ul><h3 id="4-多播事件"><a href="#4-多播事件" class="headerlink" title="4. 多播事件"></a>4. 多播事件</h3><p>事件可以有多个订阅者，这些订阅者的方法会按顺序被调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber2</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnotherEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Subscriber2 received: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br>        Subscriber subscriber1 = <span class="hljs-keyword">new</span> Subscriber();<br>        Subscriber2 subscriber2 = <span class="hljs-keyword">new</span> Subscriber2();<br><br>        <span class="hljs-comment">// 订阅多个事件处理器</span><br>        publisher.Notify += subscriber1.OnNotifyReceived;<br>        publisher.Notify += subscriber2.AnotherEventHandler;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Hello, Multicast Event!&quot;</span>);<br><br>        <span class="hljs-comment">// 输出两个订阅者的消息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-使用内置的-EventHandler"><a href="#5-使用内置的-EventHandler" class="headerlink" title="5. 使用内置的 EventHandler"></a>5. 使用内置的 <code>EventHandler</code></h3><p>C# 提供了一个标准的 <code>EventHandler</code> 委托类型以及泛型的 <code>EventHandler&lt;TEventArgs&gt;</code>，它们用来更简洁地定义事件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PublisherWithEventHandler</span><br>&#123;<br>    <span class="hljs-comment">// 使用 EventHandler&lt;TEventArgs&gt; 定义事件</span><br>    <span class="hljs-comment">// public delegate void EventHandler(object? sender, EventArgs e);</span><br>    <span class="hljs-comment">// public delegate void EventHandler&lt;TEventArgs&gt;(object? sender, TEventArgs e);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;CustomEventArgs&gt; Notify;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Notify?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> CustomEventArgs &#123; Message = message &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        PublisherWithEventHandler publisher = <span class="hljs-keyword">new</span> PublisherWithEventHandler();<br>        publisher.Notify += (sender, e) =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Received message: <span class="hljs-subst">&#123;e.Message&#125;</span>&quot;</span>);<br>        &#125;;<br><br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Using EventHandler!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>以下是对代码的详细解释：</li></ul><h4 id="1-CustomEventArgs-类"><a href="#1-CustomEventArgs-类" class="headerlink" title="1. CustomEventArgs 类"></a>1. <code>CustomEventArgs</code> 类</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>CustomEventArgs</code> 是一个自定义的事件参数类，继承自 <code>EventArgs</code>，这符合 .NET 事件处理的惯例。</li><li>它包含一个 <code>Message</code> 属性，用于传递事件的附加信息。</li></ul><h4 id="2-PublisherWithEventHandler-类"><a href="#2-PublisherWithEventHandler-类" class="headerlink" title="2. PublisherWithEventHandler 类"></a>2. <code>PublisherWithEventHandler</code> 类</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PublisherWithEventHandler</span><br>&#123;<br>    <span class="hljs-comment">// 使用 EventHandler&lt;TEventArgs&gt; 定义事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;CustomEventArgs&gt; Notify;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Notify?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> CustomEventArgs &#123; Message = message &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>PublisherWithEventHandler</code> 是发布事件的类，包含一个名为 <code>Notify</code> 的事件，使用 <code>EventHandler&lt;CustomEventArgs&gt;</code> 泛型委托来定义。<ul><li><code>EventHandler&lt;TEventArgs&gt;</code> 是一个内置的事件委托，允许指定一个类型 <code>TEventArgs</code> 来传递事件数据。在这里，<code>TEventArgs</code> 被替换为自定义的 <code>CustomEventArgs</code> 类型。</li></ul></li><li><code>TriggerEvent</code> 方法用于触发事件，并传递一个消息字符串作为事件数据。<ul><li><code>Notify?.Invoke(this, new CustomEventArgs &#123; Message = message &#125;)</code> 这行代码用于触发事件，其中 <code>this</code> 表示事件的发送者，<code>new CustomEventArgs &#123; Message = message &#125;</code> 创建了一个新的 <code>CustomEventArgs</code> 对象，将 <code>Message</code> 属性设为传入的 <code>message</code> 参数。</li></ul></li></ul><h4 id="3-订阅和触发事件-Main-方法"><a href="#3-订阅和触发事件-Main-方法" class="headerlink" title="3. 订阅和触发事件 (Main 方法)"></a>3. 订阅和触发事件 (<code>Main</code> 方法)</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        PublisherWithEventHandler publisher = <span class="hljs-keyword">new</span> PublisherWithEventHandler();<br><br>        <span class="hljs-comment">// 订阅事件，使用 Lambda 表达式作为事件处理程序</span><br>        publisher.Notify += (sender, e) =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Received message: <span class="hljs-subst">&#123;e.Message&#125;</span>&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Using EventHandler!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建了一个 <code>PublisherWithEventHandler</code> 类的实例 <code>publisher</code>。</li><li>使用 <code>+=</code> 运算符订阅 <code>Notify</code> 事件，将一个 Lambda 表达式作为事件处理程序。<ul><li>该 Lambda 表达式接受两个参数：<code>sender</code>（事件的发送者）和 <code>e</code>（事件数据），这里的 <code>e</code> 类型为 <code>CustomEventArgs</code>。</li><li>处理程序中打印了 <code>e.Message</code> 的值，从而输出事件传递的消息内容。</li></ul></li><li>调用 <code>TriggerEvent</code> 方法触发事件，传递字符串 <code>&quot;Using EventHandler!&quot;</code>，这会导致事件处理程序被调用，并输出 <code>Received message: Using EventHandler!</code>。</li></ul><h4 id="4-代码的工作原理"><a href="#4-代码的工作原理" class="headerlink" title="4. 代码的工作原理"></a>4. 代码的工作原理</h4><ol><li>定义了一个自定义的事件参数类 <code>CustomEventArgs</code>，包含一个 <code>Message</code> 属性。</li><li><code>PublisherWithEventHandler</code> 类通过 <code>EventHandler&lt;CustomEventArgs&gt;</code> 定义了一个事件 <code>Notify</code>，并提供 <code>TriggerEvent</code> 方法来触发事件。</li><li>在 <code>Main</code> 方法中，创建发布者对象并订阅 <code>Notify</code> 事件。</li><li>当事件被触发时，订阅的处理程序会被调用，并接收到传递的消息。</li></ol><h4 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h4><ul><li><strong>事件</strong>用于通知订阅者某个动作发生。</li><li><strong>事件的定义基于委托类型</strong>，可以有多个订阅者。</li><li><strong>事件触发时</strong>，会通知所有已订阅的方法。</li><li><strong><code>EventHandler</code> 和 <code>EventHandler&lt;TEventArgs&gt;</code></strong> 是内置的委托类型，用于更方便地定义事件。<br>事件机制非常适合处理用户输入、状态变化以及异步通知等场景。</li></ul><h1 id="59-EventArgs"><a href="#59-EventArgs" class="headerlink" title="59. EventArgs"></a>59. EventArgs</h1><p><code>EventArgs</code> 是 .NET 中定义的一个基类，用于传递事件相关的信息。它位于 <code>System</code> 命名空间中，并且是所有事件参数类的基类。<code>EventArgs</code> 的作用是为事件处理程序提供一个基础类型，可以在事件被触发时传递事件的相关数据。</p><ul><li>也即是说所有的事件都可以继承EventArgs，类似object</li></ul><h3 id="1-EventArgs-的定义"><a href="#1-EventArgs-的定义" class="headerlink" title="1. EventArgs 的定义"></a>1. <code>EventArgs</code> 的定义</h3><p>在 .NET 框架中，<code>EventArgs</code> 定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> EventArgs Empty;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>EventArgs</code> 是一个空类，不包含任何属性或方法。它的主要作用是作为事件参数的基类，或在事件不需要传递额外数据时使用。</li><li><code>EventArgs.Empty</code> 是一个静态只读字段，表示没有数据的 <code>EventArgs</code> 实例，可以用于不需要传递数据的事件。</li><li><code>readonly</code> 是 C# 中的一个关键字，用于在字段声明中指明字段的值在对象的整个生命周期中只能被赋值一次。<code>readonly</code> 关键字可以确保字段一旦被初始化，就不会再被修改，这种特性适用于对数据的安全性和稳定性有要求的场景。<ul><li><code>readonly</code> 字段可以在声明时初始化，也可以在构造函数中赋值。</li><li>一旦在构造函数或字段声明中赋值后，<code>readonly</code> 字段的值就不能再被更改。</li><li><code>readonly</code> 字段的值在运行时确定，而不是编译时（与 <code>const</code> 相比）。</li><li>在静态字段中使用 <code>readonly</code>，可以在静态构造函数中赋值。</li><li>示例代码<ul><li>示例1：声明时初始化  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><br>&#123;<br>    <span class="hljs-comment">// readonly 字段，在声明时赋值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">double</span> Pi = <span class="hljs-number">3.14159</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintPi</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Pi: <span class="hljs-subst">&#123;Pi&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Circle circle = <span class="hljs-keyword">new</span> Circle();<br>        circle.PrintPi(); <span class="hljs-comment">// 输出：Pi: 3.14159</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，<code>Pi</code> 是一个 <code>readonly</code> 字段，在声明时就被赋值为 <code>3.14159</code>，并且在对象生命周期内不会改变。<br>  示例2：在构造函数中赋值  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// readonly 字段，未在声明时初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;<br><br>    <span class="hljs-comment">// 构造函数中赋值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintName</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;Name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        person.PrintName(); <span class="hljs-comment">// 输出：Name: Alice</span><br><br>        <span class="hljs-comment">// person.Name = &quot;Bob&quot;; // 编译错误：无法为 readonly 字段赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，<code>Name</code> 是一个 <code>readonly</code> 字段，通过构造函数进行初始化，一旦对象被创建后，该字段的值就不能被更改。</li><li>示例3：静态 <code>readonly</code> 字段  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Config</span><br>&#123;<br>    <span class="hljs-comment">// 静态 readonly 字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> AppName;<br><br>    <span class="hljs-comment">// 静态构造函数中初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Config</span>()</span><br>    &#123;<br>        AppName = <span class="hljs-string">&quot;MyApplication&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintAppName</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;App Name: <span class="hljs-subst">&#123;AppName&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Config.PrintAppName(); <span class="hljs-comment">// 输出：App Name: MyApplication</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个示例中，<code>AppName</code> 是一个静态 <code>readonly</code> 字段，在静态构造函数中初始化，这样在整个程序生命周期中该字段的值都是固定的。</li></ul></li></ul></li></ul><h3 id="2-使用-EventArgs-的场景"><a href="#2-使用-EventArgs-的场景" class="headerlink" title="2. 使用 EventArgs 的场景"></a>2. 使用 <code>EventArgs</code> 的场景</h3><p><code>EventArgs</code> 通常在定义事件时作为参数类型。如果一个事件不需要额外的参数，就可以使用 <code>EventArgs</code>。如果需要传递额外的信息，可以创建一个自定义的类，继承自 <code>EventArgs</code>。</p><h4 id="示例1：不传递任何数据的事件"><a href="#示例1：不传递任何数据的事件" class="headerlink" title="示例1：不传递任何数据的事件"></a>示例1：不传递任何数据的事件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个事件，使用 EventArgs 作为参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler SimpleEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件时使用 EventArgs.Empty 传递</span><br>        SimpleEvent?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.SimpleEvent += (sender, e) =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;SimpleEvent triggered&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.TriggerEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，<code>SimpleEvent</code> 使用 <code>EventArgs</code> 作为事件参数，因为不需要传递额外的信息。</li><li>触发事件时使用 <code>EventArgs.Empty</code>，表示不需要任何附加数据。</li><li><code>EventHandler</code> 是 C# 中的一个委托类型，用于定义事件处理方法的标准签名。它是事件机制的核心，用来指定事件处理方法的参数格式。<code>EventHandler</code> 提供了一种标准的方式来处理事件，使事件的声明和使用变得简单和一致。</li><li><code>EventHandler</code> 是一个预定义的委托类型，表示事件处理方法不需要自定义事件数据时的标准签名。</li><li>它的标准方法签名是：<code>void EventHandler(object sender, EventArgs e)</code>。<ul><li><code>sender</code>：事件的发送者，即引发事件的对象。</li><li><code>e</code>：事件数据的对象，通常是 <code>EventArgs</code> 或其派生类的实例。</li></ul></li></ul><h3 id="3-自定义-EventArgs-类"><a href="#3-自定义-EventArgs-类" class="headerlink" title="3. 自定义 EventArgs 类"></a>3. 自定义 <code>EventArgs</code> 类</h3><p>当需要传递附加的事件数据时，可以创建一个继承自 <code>EventArgs</code> 的自定义类。</p><h4 id="示例2：传递额外数据的事件"><a href="#示例2：传递额外数据的事件" class="headerlink" title="示例2：传递额外数据的事件"></a>示例2：传递额外数据的事件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 自定义的 EventArgs 类，继承自 EventArgs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PublisherWithEventArgs</span><br>&#123;<br>    <span class="hljs-comment">// 使用自定义的 EventArgs 类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;CustomEventArgs&gt; CustomEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerCustomEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件，传递 CustomEventArgs 实例</span><br>        CustomEvent?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> CustomEventArgs &#123; Message = message &#125;);<br>        <span class="hljs-comment">//new CustomEventArgs &#123; Message = message &#125; 这段代码做了以下工作：</span><br>        <span class="hljs-comment">//new CustomEventArgs：创建了一个新的 CustomEventArgs 类型的实例。</span><br>        <span class="hljs-comment">//&#123; Message = message &#125;：使用对象初始化器对 Message 属性进行赋值，将传入的 message 值赋给该属性。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        PublisherWithEventArgs publisher = <span class="hljs-keyword">new</span> PublisherWithEventArgs();<br><br>        <span class="hljs-comment">// 订阅事件，处理传递的自定义事件参数</span><br>        <span class="hljs-comment">// 这边的e是自定义的一个EventArgs的事件，可以使用里面的Message参数</span><br>        publisher.CustomEvent += (sender, e) =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Custom event triggered with message: <span class="hljs-subst">&#123;e.Message&#125;</span>&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">// 触发事件，传递消息</span><br>        publisher.TriggerCustomEvent(<span class="hljs-string">&quot;Hello, EventArgs!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个示例中，<code>CustomEventArgs</code> 继承自 <code>EventArgs</code>，增加了一个 <code>Message</code> 属性。</li><li>当触发事件时，将 <code>CustomEventArgs</code> 实例作为事件参数传递，以便处理程序使用。</li></ul><h3 id="4-EventArgs-的作用"><a href="#4-EventArgs-的作用" class="headerlink" title="4. EventArgs 的作用"></a>4. <code>EventArgs</code> 的作用</h3><ul><li><code>EventArgs</code> 提供了一种标准化的方式来定义事件参数。</li><li>通过继承 <code>EventArgs</code>，可以创建自定义事件参数类，添加额外的数据属性，以适应具体的事件需求。</li><li><code>EventHandler&lt;TEventArgs&gt;</code> 泛型委托与自定义的 <code>EventArgs</code> 类结合使用，使得事件处理程序可以获得类型安全的事件数据。<br>总结来说，<code>EventArgs</code> 是事件处理系统的一个基础元素，为事件参数提供了一个统一的基类，同时支持自定义扩展，满足不同事件的数据需求。</li></ul><h1 id="60-对象初始化器"><a href="#60-对象初始化器" class="headerlink" title="60. 对象初始化器"></a>60. 对象初始化器</h1><p>对象初始化器是一种简洁的语法，用于在创建对象的同时设置其公共属性或字段的值。它允许在对象实例化的过程中，使用花括号 <code>&#123;&#125;</code> 来指定属性或字段的初始值，而不必通过构造函数逐个进行赋值。</p><h3 id="使用对象初始化器的语法"><a href="#使用对象初始化器的语法" class="headerlink" title="使用对象初始化器的语法"></a>使用对象初始化器的语法</h3><p>基本语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> objectName = <span class="hljs-keyword">new</span> ClassName<br>&#123;<br>    Property1 = value1,<br>    Property2 = value2,<br>    <span class="hljs-comment">// ...其他属性</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方式在创建对象的同时，通过初始化列表的形式赋值给对象的属性或字段。</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><h4 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1. 类的定义"></a>1. 类的定义</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用对象初始化器来创建对象"><a href="#2-使用对象初始化器来创建对象" class="headerlink" title="2. 使用对象初始化器来创建对象"></a>2. 使用对象初始化器来创建对象</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person<br>&#123;<br>    Name = <span class="hljs-string">&quot;Alice&quot;</span>,<br>    Age = <span class="hljs-number">25</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码做了以下操作：</p><ul><li>使用 <code>new Person</code> 创建了一个新的 <code>Person</code> 类型的对象。</li><li>使用 <code>&#123; Name = &quot;Alice&quot;, Age = 25 &#125;</code> 初始化了 <code>Name</code> 和 <code>Age</code> 两个属性。<br>这种写法等价于以下代码，但更加简洁：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br>person.Name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>person.Age = <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="对象初始化器的优点"><a href="#对象初始化器的优点" class="headerlink" title="对象初始化器的优点"></a>对象初始化器的优点</h3><ol><li><strong>简洁</strong>：减少了代码量，使代码更加简洁易读。</li><li><strong>易于维护</strong>：在对象创建时可以同时初始化多个属性的值，避免后续的逐个赋值。</li><li><strong>灵活性</strong>：可以用于各种引用类型对象的初始化，包括类、结构、集合等。</li></ol><h3 id="使用对象初始化器与集合初始化器结合"><a href="#使用对象初始化器与集合初始化器结合" class="headerlink" title="使用对象初始化器与集合初始化器结合"></a>使用对象初始化器与集合初始化器结合</h3><p>对象初始化器也可以与集合初始化器结合使用，方便地初始化集合中的对象。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> people = <span class="hljs-keyword">new</span> List&lt;Person&gt;<br>&#123;<br>    <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span>, Age = <span class="hljs-number">25</span> &#125;,<br>    <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Bob&quot;</span>, Age = <span class="hljs-number">30</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>people</code> 是一个 <code>List&lt;Person&gt;</code> 类型的集合，通过集合初始化器直接初始化了多个 <code>Person</code> 对象。</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>对象初始化器不仅适用于类的属性初始化，也可以用于匿名类型、结构、集合等场景。</p><h1 id="61-委托和事件的区别"><a href="#61-委托和事件的区别" class="headerlink" title="61. 委托和事件的区别"></a>61. 委托和事件的区别</h1><p>委托和事件是 C# 中用于实现事件驱动编程的重要概念。虽然它们有许多相似之处，但它们之间也存在一些关键的区别。下面是委托和事件的定义、用途以及它们之间的区别。</p><h3 id="1-委托-Delegate"><a href="#1-委托-Delegate" class="headerlink" title="1. 委托 (Delegate)"></a>1. 委托 (Delegate)</h3><p><strong>定义</strong>：委托是一种类型安全的函数指针，可以引用具有特定参数列表和返回类型的方法。委托可以用来定义回调方法。<br><strong>用法</strong>：</p><ul><li>委托可以直接调用。</li><li>可以通过委托实例添加或移除方法。</li><li>委托可以被多播，即一个委托可以指向多个方法。<br><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Notify notifyDelegate = ShowMessage;<br>        notifyDelegate(<span class="hljs-string">&quot;Hello, Delegates!&quot;</span>); <span class="hljs-comment">// 调用委托</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-事件-Event"><a href="#2-事件-Event" class="headerlink" title="2. 事件 (Event)"></a>2. 事件 (Event)</h3><p><strong>定义</strong>：事件是基于委托的，专门用于处理事件通知的机制。它提供了一种在对象之间发布和订阅消息的方式。<br><strong>用法</strong>：</p><ul><li>事件通常是由类定义的，使用委托作为事件的类型。</li><li>事件通常只能被类的内部代码触发，外部代码只能订阅或取消订阅。</li><li>使用事件可以防止外部代码直接调用事件的处理方法，从而保护对象的状态。<br><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Notify NotifyEvent; <span class="hljs-comment">// 声明事件</span><br>    <span class="hljs-keyword">public</span> Notify NotifyDelegate; <span class="hljs-comment">// 声明事件</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        NotifyEvent?.Invoke(message); <span class="hljs-comment">// 触发事件</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br><br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br><br>        publisher.NotifyEvent += ShowMessage; <span class="hljs-comment">// 订阅事件</span><br>        publisher.NotifyDelegate += ShowMessage; <span class="hljs-comment">// 订阅事件</span><br>        <span class="hljs-comment">// publisher.NotifyEvent(&quot;111&quot;); // 报错,不可以在类外调用</span><br>        publisher.NotifyDelegate(<span class="hljs-string">&quot;111&quot;</span>);<br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Hello, Events!&quot;</span>); <span class="hljs-comment">// 触发事件</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-委托和事件的区别"><a href="#3-委托和事件的区别" class="headerlink" title="3. 委托和事件的区别"></a>3. 委托和事件的区别</h3><table><thead><tr><th>特征</th><th>委托</th><th>事件</th></tr></thead><tbody><tr><td>定义</td><td>委托是一种类型，可以直接调用。</td><td>事件是基于委托的，专门用于处理事件通知的机制。</td></tr><tr><td>访问修饰符</td><td>委托可以具有公共或私有修饰符。</td><td>事件通常使用 <code>public</code> 修饰符，但可以通过 <code>add</code> 和 <code>remove</code> 访问器限制访问。</td></tr><tr><td>触发</td><td>可以直接调用委托的方法。</td><td>事件只能由其定义的类内部触发。</td></tr><tr><td>订阅和取消</td><td>委托没有内置的订阅和取消机制。</td><td>事件支持订阅和取消机制，使用 <code>+=</code> 和 <code>-=</code> 操作符。</td></tr><tr><td>事件处理方法</td><td>委托可以直接存储任何匹配其签名的方法。</td><td>事件处理方法不能被外部代码直接调用。</td></tr><tr><td>多播支持</td><td>委托可以多播（即引用多个方法）。</td><td>事件通常是多播的，但它们的处理方法在内部进行管理。</td></tr></tbody></table><h4 id="事件通常使用-public-修饰符，但可以通过-add-和-remove-访问器限制访问。"><a href="#事件通常使用-public-修饰符，但可以通过-add-和-remove-访问器限制访问。" class="headerlink" title="事件通常使用 public 修饰符，但可以通过 add 和 remove 访问器限制访问。"></a>事件通常使用 <code>public</code> 修饰符，但可以通过 <code>add</code> 和 <code>remove</code> 访问器限制访问。</h4><p>在 C# 中，事件可以通过 <code>public</code> 修饰符声明，但其访问级别可以通过 <code>add</code> 和 <code>remove</code> 访问器进行限制。这种机制提供了更好的封装性，允许开发者控制谁可以订阅或取消订阅事件。其实就是在添加或者删除事件的时候提前进行处理。</p><h4 id="访问器的用法"><a href="#访问器的用法" class="headerlink" title="访问器的用法"></a>访问器的用法</h4><ul><li><strong><code>add</code> 访问器</strong>：用于添加事件处理程序。</li><li><strong><code>remove</code> 访问器</strong>：用于移除事件处理程序。</li></ul><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>以下是一个使用 <code>add</code> 和 <code>remove</code> 访问器限制访问的事件示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个私有字段来存储事件处理程序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">event</span> EventHandler _notify;<br><br>    <span class="hljs-comment">// 公开的事件，使用 add 和 remove 访问器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler Notify<br>    &#123;<br><br>        <span class="hljs-comment">// 在 C# 中，value 是一个关键字，用于 add 和 remove 访问器中的参数，</span><br>        <span class="hljs-comment">// 它代表即将被添加或移除的事件处理程序（即方法）。</span><br>        <span class="hljs-comment">// 当你使用 += 或 -= 操作符来订阅或取消订阅事件时，value 充当被传递的委托（delegate）。</span><br>        <span class="hljs-keyword">add</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Subscribing to the event.&quot;</span>);<br>            _notify += <span class="hljs-keyword">value</span>; <span class="hljs-comment">// 订阅事件 // 这里的 value 是传入的事件处理程序</span><br>        &#125;<br>        <span class="hljs-keyword">remove</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Unsubscribing from the event.&quot;</span>);<br>            _notify -= <span class="hljs-keyword">value</span>; <span class="hljs-comment">// 取消订阅事件 // 这里的 value 是要取消订阅的事件处理程序</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件</span><br>        _notify?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Subscribe</span>(<span class="hljs-params">Publisher publisher</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 订阅事件,给订阅者订阅，让发布者发布消息的时候给订阅者，每次都调用订阅者里面的方法</span><br>        publisher.Notify += OnNotify;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Unsubscribe</span>(<span class="hljs-params">Publisher publisher</span>)</span><br>    &#123;<br>        publisher.Notify -= OnNotify; <span class="hljs-comment">// 取消订阅事件</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNotify</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Event received!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br>        Subscriber subscriber = <span class="hljs-keyword">new</span> Subscriber();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        subscriber.Subscribe(publisher);<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.TriggerEvent();<br><br>        <span class="hljs-comment">// 取消订阅事件</span><br>        subscriber.Unsubscribe(publisher);<br><br>        <span class="hljs-comment">// 再次触发事件（不会输出任何内容，因为已经取消订阅）</span><br>        publisher.TriggerEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li><strong>事件定义</strong>：<ul><li><code>private event EventHandler _notify;</code>：这是一个私有事件字段，用于存储实际的事件处理程序。</li><li><code>public event EventHandler Notify</code>：公开的事件，使用 <code>add</code> 和 <code>remove</code> 访问器。</li></ul></li><li><strong><code>add</code> 访问器</strong>：<ul><li>在订阅事件时，输出 “Subscribing to the event.”，并将新的事件处理程序添加到 <code>_notify</code> 字段。</li></ul></li><li><strong><code>remove</code> 访问器</strong>：<ul><li>在取消订阅事件时，输出 “Unsubscribing from the event.”，并将事件处理程序从 <code>_notify</code> 字段中移除。</li></ul></li><li><strong>触发事件</strong>：<ul><li>使用 <code>_notify?.Invoke(this, EventArgs.Empty);</code> 触发事件，调用所有订阅的事件处理程序。</li></ul></li><li><strong>Subscriber 类</strong>：<ul><li>提供 <code>Subscribe</code> 和 <code>Unsubscribe</code> 方法来管理事件的订阅。</li></ul></li></ol><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>委托</strong> 是一种函数指针，允许方法作为参数传递，并可以被直接调用。</li><li><strong>事件</strong> 是基于委托的，用于在对象之间发布和订阅消息，通常用于实现事件驱动编程。事件提供了更多的封装和安全性，防止外部代码直接调用事件处理方法。<br>使用事件的主要原因是它们能够更好地支持事件驱动的设计模式，并提供了更好的封装和可维护性。</li></ul><h1 id="62-Notify-Invoke-message-什么意思"><a href="#62-Notify-Invoke-message-什么意思" class="headerlink" title="62. Notify?.Invoke(message); 什么意思"></a>62. Notify?.Invoke(message); 什么意思</h1><p>在 C# 中，<code>Notify?.Invoke(message);</code> 是一种使用空条件运算符（null-conditional operator）来安全调用委托的方法。这个表达式可以拆分为两部分进行理解：</p><ol><li>**空条件运算符 (<code>?.</code>)**：这是一个安全访问运算符，允许你在调用成员（如方法、属性）之前检查对象是否为 <code>null</code>。如果对象为 <code>null</code>，则整个表达式返回 <code>null</code>，而不会引发 <code>NullReferenceException</code>。</li><li>**<code>Invoke(message)</code>**：这是用于调用委托的方法。通常，调用委托可以直接使用 <code>Notify(message)</code>，但是在这里我们使用 <code>Invoke</code> 也是有效的。</li></ol><h3 id="整体理解"><a href="#整体理解" class="headerlink" title="整体理解"></a>整体理解</h3><ul><li><code>Notify?.Invoke(message);</code> 意味着：<ul><li>如果 <code>Notify</code> 委托不为 <code>null</code>，则调用 <code>Notify</code> 并传递 <code>message</code> 参数。</li><li>如果 <code>Notify</code> 为 <code>null</code>，则不执行任何操作。</li></ul></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>考虑以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>; <span class="hljs-comment">// 委托定义</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Notifier</span><br>&#123;<br>    <span class="hljs-keyword">public</span> NotifyDelegate Notify; <span class="hljs-comment">// 委托作为类的成员</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendNotification</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Notify?.Invoke(message); <span class="hljs-comment">// 安全调用委托</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 <code>SendNotification</code> 方法中，使用 <code>Notify?.Invoke(message)</code> 确保只有在 <code>Notify</code> 委托不为 <code>null</code> 时才会调用它。这避免了在 <code>Notify</code> 为 <code>null</code> 时尝试调用会导致程序崩溃。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这种写法可以帮助避免潜在的 <code>NullReferenceException</code>，使代码更健壮。在处理委托和事件时，常常会使用这种模式，因为委托可以在运行时动态分配或取消，从而可能会为 <code>null</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/zh-cn/">MS-Learning</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSharp知识整理(二)</title>
    <link href="/2024/10/25/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%BA%8C)/"/>
    <url>/2024/10/25/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="22-运算符重载"><a href="#22-运算符重载" class="headerlink" title="22. 运算符重载"></a>22. 运算符重载</h1><p>  在C#中，运算符重载允许为用户自定义的类型（如类或结构体）定义或重载运算符的行为。这使得用户可以对自定义类型使用标准的运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>相等</code>, <code>!=</code> 等），就像对内置类型操作一样。</p><h3 id="运算符重载的基本规则"><a href="#运算符重载的基本规则" class="headerlink" title="运算符重载的基本规则"></a>运算符重载的基本规则</h3><ol><li><strong>必须是 <code>static</code> 方法</strong>：重载的运算符方法必须声明为静态的。</li><li><strong>通常为 <code>public</code> 访问修饰符</strong>：以便在外部使用。</li><li><strong>参数数量</strong>：一元运算符（如 <code>++</code>, <code>--</code>, <code>!</code>）有一个参数，二元运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>）有两个参数。</li><li><strong>返回类型</strong>：可以是任何类型，不一定要与操作数类型相同。</li><li>运算符的参数必须是包含当前类的类型</li><li>不能使用ref和out修饰参数，ref和out参数在此上下文中无效</li></ol><h3 id="重载一元运算符的示例"><a href="#重载一元运算符的示例" class="headerlink" title="重载一元运算符的示例"></a>重载一元运算符的示例</h3><p>一元运算符重载允许你为自定义类型定义操作符（如 <code>++</code>、<code>--</code>、<code>-</code>、<code>!</code> 等）的行为。与二元运算符重载相似，在C#中，一元运算符的重载也必须是静态方法，且通常只需要一个参数，且该参数通常是包含运算符重载方法的类型。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是一个示例，展示如何重载一元运算符 <code>++</code> 和 <code>--</code>，以及负号运算符 <code>-</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br><span class="hljs-comment">// 不可以用ref或者out修饰int</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialValue</span>)</span><br>    &#123;<br>        Value = initialValue;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载前缀 ++ 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> ++(Counter c)<br>    &#123;<br>        c.Value++;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载前缀 -- 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> --(Counter c)<br>    &#123;<br>        c.Value--;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载负号运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> -(Counter c)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(-c.Value);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，以便输出格式化的计数器值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Value.ToString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Counter counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 使用重载的 ++ 运算符</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Initial Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Increment: <span class="hljs-subst">&#123;++counter&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Decrement: <span class="hljs-subst">&#123;--counter&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用重载的负号运算符</span><br>        Counter negativeCounter = -counter;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Negative Value: <span class="hljs-subst">&#123;negativeCounter&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><ul><li><strong>Counter 类</strong>：表示一个计数器，包含一个整型属性 <code>Value</code>。</li><li><strong>重载前缀 <code>++</code> 运算符</strong>：增加 <code>Value</code> 的值并返回修改后的计数器。</li><li><strong>重载前缀 <code>--</code> 运算符</strong>：减少 <code>Value</code> 的值并返回修改后的计数器。</li><li>**重载负号运算符 <code>-</code>**：返回一个新的 <code>Counter</code> 对象，其值为 <code>Value</code> 的负值。</li><li><strong>ToString 方法</strong>：重写该方法以便于输出 <code>Counter</code> 对象时能够显示其 <code>Value</code>。</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><strong>访问修饰符</strong>：重载运算符的方法必须是 <code>public</code> 和 <code>static</code>。</li><li><strong>返回类型</strong>：重载运算符的方法返回一个新对象或修改后的对象。</li><li>一元运算符的参数必须是包含类型</li></ol><h3 id="重载二元运算符的示例"><a href="#重载二元运算符的示例" class="headerlink" title="重载二元运算符的示例"></a>重载二元运算符的示例</h3><p>以下是一个重载加法运算符的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ComplexNumber</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Real &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Imaginary &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComplexNumber</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> real, <span class="hljs-built_in">double</span> imaginary</span>)</span><br>    &#123;<br>        Real = real;<br>        Imaginary = imaginary;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载加法运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ComplexNumber <span class="hljs-keyword">operator</span> +(ComplexNumber c1, ComplexNumber c2)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ComplexNumber(c1.Real + c2.Real, c1.Imaginary + c2.Imaginary);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，以便输出格式化的复数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Real&#125;</span> + <span class="hljs-subst">&#123;Imaginary&#125;</span>i&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        ComplexNumber c1 = <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>);<br>        ComplexNumber c2 = <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);<br>        ComplexNumber sum = c1 + c2; <span class="hljs-comment">// 使用重载的加法运算符</span><br><br>        Console.WriteLine(<span class="hljs-string">$&quot;c1 + c2 = <span class="hljs-subst">&#123;sum&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例说明-1"><a href="#示例说明-1" class="headerlink" title="示例说明"></a>示例说明</h4><ul><li><code>ComplexNumber</code> 类表示一个复数，包含两个字段：<code>Real</code> 和 <code>Imaginary</code>。</li><li>加法运算符 <code>+</code> 被重载，使得可以对两个 <code>ComplexNumber</code> 实例进行相加操作。</li><li><code>operator +</code> 方法返回一个新的 <code>ComplexNumber</code> 对象，其 <code>Real</code> 和 <code>Imaginary</code> 分别是两个操作数相加的结果。</li><li>在 <code>Main</code> 方法中，<code>c1</code> 和 <code>c2</code> 被相加，并输出相加的结果。</li></ul><h3 id="支持重载的运算符列表"><a href="#支持重载的运算符列表" class="headerlink" title="支持重载的运算符列表"></a>支持重载的运算符列表</h3><p>C# 支持重载的运算符包括：</p><ul><li>算术运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li><li>比较运算符：<code>相等</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li><li>位运算符：<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li><li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li><li>自增、自减运算符：<code>++</code>, <code>--</code></li></ul><h3 id="不支持重载的运算符列表"><a href="#不支持重载的运算符列表" class="headerlink" title="不支持重载的运算符列表"></a>不支持重载的运算符列表</h3><ul><li><strong>成员访问运算符</strong>：<code>.</code>（点运算符）<ul><li>用于访问类型的成员（字段、属性、方法等）。</li></ul></li><li><strong>条件运算符</strong>：<code>?:</code>（三元运算符）<ul><li>用于条件表达式。</li></ul></li><li><strong>委托运算符</strong>：<code>delegate</code><ul><li>用于声明委托。</li></ul></li><li><strong>指针运算符</strong>：<code>*</code>（指针解引用运算符）和<code>&amp;</code>（地址运算符）<ul><li>用于处理指针。</li></ul></li><li><strong>类型测试运算符</strong>：<code>is</code> 和 <code>as</code><ul><li>用于检查对象类型和进行类型转换。</li></ul></li><li><strong>数组下标运算符</strong>：<code>[]</code><ul><li>用于数组索引访问。</li></ul></li><li><strong>new 关键字</strong><ul><li>用于对象的创建。</li></ul></li><li><strong>default 关键字</strong><ul><li>用于获取类型的默认值。</li></ul></li><li><strong>sizeof 关键字</strong><ul><li>用于获取类型的大小。</li></ul></li><li>赋值符号&#x3D;</li><li>强转运算符()</li></ul><h3 id="重载运算符的注意事项"><a href="#重载运算符的注意事项" class="headerlink" title="重载运算符的注意事项"></a>重载运算符的注意事项</h3><ul><li>条件运算符需要成对实现<ul><li>如果重载 <code>相等</code> 运算符，通常也需要重载 <code>!=</code> 运算符。</li><li>如果重载比较运算符（如 <code>&lt;</code> 和 <code>&gt;</code>），还需要重载其相应的 <code>&lt;=</code> 和 <code>&gt;=</code> 运算符。</li></ul></li><li>二元运算符的参数之一必须是包含类型</li><li>为了更好地实现运算符的语义，一般还需要重写 <code>Equals()</code> 和 <code>GetHashCode()</code> 方法。<br>运算符重载使自定义类型在运算时可以更符合直观的数学表示，提高代码的可读性和易用性。</li></ul><h3 id="强转运算符（类型转换运算符）特定的重载方式"><a href="#强转运算符（类型转换运算符）特定的重载方式" class="headerlink" title="强转运算符（类型转换运算符）特定的重载方式"></a>强转运算符（类型转换运算符）特定的重载方式</h3><ul><li><strong>类型转换运算符</strong>：C# 允许你定义类型转换运算符，但不是通过传统的运算符重载语法。你可以通过定义显式或隐式转换运算符来实现类型转换的行为。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 显式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-keyword">value</span> &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 隐式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">MyClass myClass</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> myClass.Value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = (MyClass)<span class="hljs-number">5</span>; <span class="hljs-comment">// 显式转换</span><br>        <span class="hljs-built_in">int</span> number = myObject;          <span class="hljs-comment">// 隐式转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="23-explicit-implicit"><a href="#23-explicit-implicit" class="headerlink" title="23. explicit implicit"></a>23. explicit implicit</h1><p>在C#中，<code>explicit</code> 和 <code>implicit</code> 是用来定义类型转换运算符的关键字，它们决定了类型转换的方式和使用场景。下面是对这两个关键字的详细解释以及它们的区别。</p><h3 id="1-implicit（隐式转换）"><a href="#1-implicit（隐式转换）" class="headerlink" title="1. implicit（隐式转换）"></a>1. <code>implicit</code>（隐式转换）</h3><ul><li><strong>定义</strong>：隐式转换运算符允许自动转换类型，无需显式地进行类型转换。</li><li><strong>使用场景</strong>：当你希望一个类型可以被安全地转换为另一个类型，并且这种转换不可能导致数据丢失或异常时，可以使用隐式转换。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 隐式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-keyword">value</span> &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = <span class="hljs-number">10</span>; <span class="hljs-comment">// 隐式转换</span><br>        Console.WriteLine(myObject.Value); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-explicit（显式转换）"><a href="#2-explicit（显式转换）" class="headerlink" title="2. explicit（显式转换）"></a>2. <code>explicit</code>（显式转换）</h3><ul><li><strong>定义</strong>：显式转换运算符需要使用强制类型转换符进行转换，不能隐式转换。</li><li><strong>使用场景</strong>：当你希望转换可能导致数据丢失或需要显式指明时，可以使用显式转换。这样可以防止意外的类型转换。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 显式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">MyClass myClass</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> myClass.Value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-number">10</span> &#125;;<br>        <span class="hljs-built_in">int</span> number = (<span class="hljs-built_in">int</span>)myObject; <span class="hljs-comment">// 显式转换</span><br>        Console.WriteLine(number); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>**<code>implicit</code>**：允许类型自动转换，适用于安全且无损的转换。</li><li>**<code>explicit</code>**：要求使用强制转换，适用于可能导致数据丢失或不安全的转换。</li></ul><h1 id="24-内部类"><a href="#24-内部类" class="headerlink" title="24. 内部类"></a>24. 内部类</h1><p>在C#中，内部类是定义在另一个类中的类，也称为嵌套类。内部类可以用来组织代码，使外部类更紧凑，同时为外部类提供额外的功能。以下是关于C#内部类的一些关键点：</p><h3 id="1-内部类的定义"><a href="#1-内部类的定义" class="headerlink" title="1. 内部类的定义"></a>1. 内部类的定义</h3><p>内部类可以定义在外部类的任何地方（类体内），并且可以访问外部类的私有成员。内部类本身也可以有自己的成员和方法。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是内部类的方法.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 外部类的方法可以创建内部类的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass();<br>        inner.Display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-访问外部类的成员"><a href="#2-访问外部类的成员" class="headerlink" title="2. 访问外部类的成员"></a>2. 访问外部类的成员</h3><p>内部类可以访问外部类的所有成员，包括私有成员。</p><ul><li>C#中的内部类要访问外部类的成员（包括私有成员），需要持有外部类的实例的引用。这是因为内部类与外部类是两个不同的对象，要访问外部类的成员，必须通过外部类的实例进行访问。通常，可以通过构造函数传递外部类的实例，然后使用该实例访问外部类的成员。</li></ul><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> OuterClass outer;<br><br>        <span class="hljs-comment">// 构造函数接收外部类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClass</span>(<span class="hljs-params">OuterClass outer</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.outer = outer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayOuterValue</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 访问外部类的私有字段,必须使用接收的实例才能够使用其中的变量，不然无法直接使用outerValue</span><br>            Console.WriteLine(<span class="hljs-string">&quot;外部类的值是: &quot;</span> + outer.outerValue);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass(<span class="hljs-keyword">this</span>);<br>        inner.DisplayOuterValue();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-内部类的访问修饰符"><a href="#3-内部类的访问修饰符" class="headerlink" title="3. 内部类的访问修饰符"></a>3. 内部类的访问修饰符</h3><p>内部类可以具有自己的访问修饰符，比如<code>public</code>、<code>private</code>、<code>protected</code>、<code>internal</code>等，这决定了内部类在外部类之外的可见性。</p><ul><li>**<code>private</code>**：内部类只能被外部类访问。</li><li>**<code>public</code>**：内部类可以被外部类之外的代码访问。</li><li>**<code>protected</code>**：内部类只能被外部类及其派生类访问。</li><li>**<code>internal</code>**：内部类可以被同一个程序集中的其他代码访问。程序集的理解就是一个解决方案中的项目<ul><li>在C#中，“程序集”（Assembly）是指一个已编译的代码库，通常是一个 <code>.exe</code> 或 <code>.dll</code> 文件。它是 .NET 中的基本部署单元，包含可执行代码、资源文件和元数据。</li><li><a href="https://imgse.com/i/pAwb64s"><img src="https://s21.ax1x.com/2024/10/26/pAwb64s.png" alt="pAwb64s.png"></a></li></ul></li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul><li><strong>封装相关功能</strong>：内部类可以作为外部类的辅助类，帮助封装某些复杂的功能。</li><li><strong>访问控制</strong>：通过嵌套类的访问修饰符，可以严格控制类的访问权限。</li><li><strong>代码组织</strong>：将相关的类组织在一起，使代码更整洁。</li></ul><h3 id="5-示例：使用访问修饰符"><a href="#5-示例：使用访问修饰符" class="headerlink" title="5. 示例：使用访问修饰符"></a>5. 示例：使用访问修饰符</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 私有内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是私有的内部类.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass();<br>        inner.Display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>InnerClass</code>是<code>private</code>的，因此只能在<code>OuterClass</code>中使用，不能在外部类之外的地方访问。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>内部类</strong>用于在类中嵌套另一个类，具有封装性和灵活性。</li><li>可以通过访问修饰符控制内部类的访问权限。</li><li>内部类可以访问外部类的所有成员，包括私有成员。<br>这种结构对于组织复杂的类层次结构非常有用。</li></ul><h1 id="25-OuterClass-outer-new-OuterClass-和OuterClass-outer2-区别"><a href="#25-OuterClass-outer-new-OuterClass-和OuterClass-outer2-区别" class="headerlink" title="25. OuterClass outer &#x3D; new OuterClass();和OuterClass outer2;区别"></a>25. OuterClass outer &#x3D; new OuterClass();和OuterClass outer2;区别</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> OuterClass outer;<br><br>        <span class="hljs-comment">// 构造函数接收外部类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClass</span>(<span class="hljs-params">OuterClass outer</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.outer = outer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayOuterValue</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 访问外部类的私有字段</span><br>            Console.WriteLine(<span class="hljs-string">&quot;外部类的值是: &quot;</span> + outer.outerValue);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass(<span class="hljs-keyword">this</span>);<br>        inner.DisplayOuterValue();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();<br>        OuterClass outer2;<br>        outer.CreateInner();<br>        <span class="hljs-comment">// outer2.CreateInner(); //CS0165 使用了未赋值的局部变量&quot;outer2&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在C#中，这两个声明的确有区别：</p><ol><li><code>OuterClass outer = new OuterClass();</code><ul><li>这里声明了一个名为 <code>outer</code> 的变量，并且通过 <code>new OuterClass()</code> 创建了一个 <code>OuterClass</code> 类型的实例，然后将这个实例的引用赋值给变量 <code>outer</code>。</li><li>这样，<code>outer</code> 就指向了一个已经被实例化的对象，可以访问对象的成员。</li></ul></li><li><code>OuterClass outer2;</code><ul><li>这里声明了一个名为 <code>outer2</code> 的变量，但没有初始化它，即没有创建对象实例。</li><li>此时，<code>outer2</code> 只是一个未赋值的变量，如果尝试使用它（如访问成员），会导致编译错误，因为变量尚未初始化。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><code>OuterClass outer = new OuterClass();</code>：创建了一个 <code>OuterClass</code> 对象，并将其赋值给 <code>outer</code>。</li><li><code>OuterClass outer2;</code>：仅声明了变量 <code>outer2</code>，但并未指向任何对象。使用前需要先进行初始化，例如：<code>outer2 = new OuterClass();</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;test:show&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Test* test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br>Test test2;<br>test-&gt;<span class="hljs-built_in">show</span>();<br>test<span class="hljs-number">2.</span><span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>在C++中，这两种声明方式有明显的区别：</li></ul><ol><li><code>Test* test = new Test();</code><ul><li>这会创建一个指向<code>Test</code>对象的指针，并且该对象是在堆上分配的。使用<code>new</code>关键字会动态分配内存，这时需要手动管理内存，在合适的时候使用<code>delete test</code>释放内存，否则会导致内存泄漏。</li></ul></li><li><code>Test test2;</code><ul><li>这会在栈上创建一个<code>Test</code>对象实例。当该对象的作用域结束时，会自动销毁，不需要手动管理内存。<br>第一种方式适用于需要在当前作用域之外持续存在的对象，而第二种方式在对象生命周期较短时效率更高。</li></ul></li></ol><h1 id="26-分部类"><a href="#26-分部类" class="headerlink" title="26. 分部类"></a>26. 分部类</h1><p>在C#中，<strong>分部类（Partial Class）</strong> 允许将一个类的定义分散到多个文件中。这在大型项目中很有用，特别是当多个开发者需要同时对同一个类进行修改，或者自动生成的代码和手写的代码需要分开时。</p><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ol><li><strong>使用 <code>partial</code> 关键字</strong>：分部类的定义需要使用 <code>partial</code> 关键字来标识。每个部分都必须使用 <code>partial</code> 声明，并且具有相同的类名。</li><li><strong>文件位于同一个命名空间下</strong>：分部类的各部分可以在不同的文件中定义，但它们必须在同一个命名空间下。</li><li><strong>编译时合并</strong>：在编译时，所有分部类会被合并为一个完整的类。因此，分部类的所有方法、属性和成员变量在使用时是共享的。</li><li><strong>访问修饰符一致性</strong>：分部类的各个部分可以有不同的访问修饰符（如 <code>public</code>、<code>internal</code>），但最终编译后的类只能具有一种可见性。</li><li>分部类中不能有重复成员，可以重载</li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>文件 <code>Person1.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintName</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;FirstName&#125;</span> <span class="hljs-subst">&#123;LastName&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件 <code>Person2.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintAge</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Age: <span class="hljs-subst">&#123;Age&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>Person</code> 类被拆分到了两个文件 <code>Person1.cs</code> 和 <code>Person2.cs</code> 中。在编译时，这两个部分会被合并成一个完整的 <code>Person</code> 类，拥有所有的属性和方法。</p><h3 id="分部类的用途："><a href="#分部类的用途：" class="headerlink" title="分部类的用途："></a>分部类的用途：</h3><ul><li><strong>自动生成代码</strong>：比如在一些工具（如Visual Studio设计器或Entity Framework）中，自动生成的代码和用户手写的代码可以放在不同的分部类中，方便管理。</li><li><strong>模块化开发</strong>：团队开发时，可以将一个类分割成不同部分，方便不同开发人员同时修改。</li><li><strong>代码组织</strong>：对于大类，可以将不同功能放在不同的文件中，提高代码的可读性和可维护性。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在C#的分部类中，<strong>访问修饰符一致性</strong>的意思是：虽然你可以在不同的分部类定义中使用不同的访问修饰符（如 <code>public</code> 或 <code>internal</code>），但是编译器最终会将所有部分合并为一个完整的类，这个类只能有一个最终的可见性（即访问级别）。</p><p>具体来说，编译器会根据以下规则来确定最终的访问修饰符：</p><ol><li><strong>如果所有分部类都指定了相同的访问修饰符</strong>，那么最终类的访问修饰符就是这个一致的修饰符。例如，如果所有部分都是 <code>public</code>，那么合并后的类也是 <code>public</code>。</li><li><strong>如果有的部分指定了访问修饰符，而有的没有指定</strong>，编译器会选择访问级别最高的修饰符。例如，如果一个部分是 <code>public</code>，而另一个部分没有指定修饰符（默认是 <code>internal</code>），那么最终类的可见性将是 <code>public</code>。</li><li><strong>如果不同部分的修饰符不一致</strong>，并且存在冲突（如一个部分是 <code>public</code>，另一个部分是 <code>internal</code>），编译器会报错，因为访问修饰符必须在所有部分中一致，或者必须选择可以合并的修饰符。</li></ol><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>文件 <code>Person1.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件 <code>Person2.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Person1.cs</code> 中的 <code>Person</code> 类是 <code>public</code> 的，而 <code>Person2.cs</code> 中的 <code>Person</code> 类是 <code>internal</code> 的。这会导致编译错误，因为编译器不知道该选择 <code>public</code> 还是 <code>internal</code> 作为最终类的可见性。<br>要解决这个问题，你可以确保所有分部类都使用相同的访问修饰符，或者明确指定某一种修饰符，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-comment">// 修改为 public</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就保证了所有部分的访问修饰符一致，编译器就能确定 <code>Person</code> 类的可见性是 <code>public</code>。</p><h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p>在C#中，<strong>分部方法（Partial Methods）</strong> 是一种特殊的方法，可以在分部类（<code>partial</code>）中使用。分部方法的定义可以分成两个部分<strong>声明</strong>和<strong>实现</strong>，它们可以分别位于分部类的不同部分中。</p><h4 id="分部方法的特点"><a href="#分部方法的特点" class="headerlink" title="分部方法的特点"></a>分部方法的特点</h4><ol><li><strong>必须定义在分部类或结构中</strong>： 分部方法只能在使用了<code>partial</code>关键字的分部类或结构中定义。</li><li><strong>必须是<code>void</code>类型</strong>： 分部方法不能有返回值，必须是<code>void</code>类型。</li><li>**隐式<code>private</code>**： 分部方法默认为私有（<code>private</code>），不能使用访问修饰符，因为它只能在当前类中使用。</li><li><strong>可选实现</strong>： 分部方法的实现是可选的。如果没有提供实现，则在编译时，声明将被忽略，不会生成任何代码。因此，调用未实现的分部方法不会产生任何影响。</li><li><strong>不支持输出参数（<code>out</code>）</strong>： 分部方法不能使用<code>out</code>修饰符，但可以使用<code>ref</code>修饰符。</li></ol><h4 id="分部方法的语法"><a href="#分部方法的语法" class="headerlink" title="分部方法的语法"></a>分部方法的语法</h4><ol><li><strong>声明</strong>： 在一个分部类中声明分部方法，使用<code>partial</code>关键字。</li><li><strong>实现</strong>： 可以在类的另一个分部文件中实现这个方法，也可以不实现。</li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下示例演示了分部方法的声明和实现。<br>文件 <code>Person1.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-comment">// 分部方法的声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNameChanged</span>()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            name = <span class="hljs-keyword">value</span>;<br>            <span class="hljs-comment">// 调用分部方法</span><br>            OnNameChanged();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件 <code>Person2.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// 分部方法的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNameChanged</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Name changed to: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>OnNameChanged</code>方法在<code>Person1.cs</code>中进行了声明，并在<code>Person2.cs</code>中进行了实现。如果不提供实现，编译器会忽略它的声明。如果调用了声明但没有定义的方法也没事，直接忽略了。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><strong>在生成代码中扩展功能</strong>：分部方法常用于自动生成的代码中，比如工具生成的类中声明分部方法，用户可以选择性地在另外的文件中实现它们。</li><li><strong>模块化设计</strong>：通过将方法拆分为不同的文件，可以更好地管理和维护大型项目。<br>分部方法提供了一种灵活的方式来设计和实现方法，同时保持代码的模块化和清晰性。</li></ul><h1 id="27-类的继承"><a href="#27-类的继承" class="headerlink" title="27. 类的继承"></a>27. 类的继承</h1><p>在C#中，<strong>类的继承</strong>是一种面向对象编程的机制，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。通过继承，可以实现代码重用、扩展类的功能以及多态性。</p><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><p>在C#中使用<code>:</code>符号来表示继承关系，语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-comment">// 子类的成员</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>BaseClass</code>是基类或父类，提供了一些基本功能。</li><li><code>DerivedClass</code>是子类或派生类，它继承了<code>BaseClass</code>的所有公有和受保护的成员（字段、方法、属性等）。</li></ul><h3 id="2-继承的特点"><a href="#2-继承的特点" class="headerlink" title="2. 继承的特点"></a>2. 继承的特点</h3><ul><li><strong>单继承</strong>：C#只支持单继承，一个类只能有一个直接的父类。但是，一个类可以实现多个接口。</li><li>传递性：子类可以继承父类的父类</li><li><strong>成员访问</strong>：子类可以访问父类的<code>public</code>和<code>protected</code>成员，但不能直接访问父类的<code>private</code>成员。</li><li><strong>构造函数的调用</strong>：子类的构造函数会首先调用父类的构造函数，在调用子类得构造函数。可以使用<code>base</code>关键字来指定调用父类的哪个构造函数。</li><li>类中会默认提供默认构造函数（无参），如果定义了有参构造函数，那么默认构造函数就不会提供</li></ul><h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><p>以下是一个简单的继承示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Animal&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal 默认构造函数&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Dog&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is barking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">//Animal 默认构造函数 Dog 默认构造函数</span><br>        dog.Name = <span class="hljs-string">&quot;Buddy&quot;</span>;<br>        dog.Eat(); <span class="hljs-comment">// 调用从父类继承的方法</span><br>        dog.Bark(); <span class="hljs-comment">// 调用子类的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Animal 默认构造函数<br>Dog 默认构造函数<br>Buddy <span class="hljs-keyword">is</span> eating.<br>Buddy <span class="hljs-keyword">is</span> barking.<br></code></pre></td></tr></table></figure><h3 id="4-base关键字"><a href="#4-base关键字" class="headerlink" title="4. base关键字"></a>4. <code>base</code>关键字</h3><ul><li><code>base</code>关键字用于在子类中访问父类的成员。</li><li>它可以用来调用父类的构造函数或方法。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br><span class="hljs-comment">// 无默认构造函数，如果new Animal()会报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> makes a noise.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 如果父类中没有默认构造函数，使用下面得构造函数会报错</span><br>    <span class="hljs-comment">//public Dog(string name)</span><br>    <span class="hljs-comment">//&#123; &#125;</span><br>    <span class="hljs-comment">// 否则需要显示调用父类得构造函数，因为总是会先调用父类得构造函数，然后调用子类得构造函数，如果子类没有写构造函数，会提供一个子类得默认构造函数，而不是使用父类得默认构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.Speak(); <span class="hljs-comment">// 调用父类的Speak方法</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> barks.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-方法重写（override）"><a href="#5-方法重写（override）" class="headerlink" title="5. 方法重写（override）"></a>5. 方法重写（<code>override</code>）</h3><ul><li><p>如果子类需要修改父类的方法行为，可以使用<code>override</code>关键字重写父类的方法。</p></li><li><p>父类的方法必须使用<code>virtual</code>关键字进行标记。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果不使用virtual关键字</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise=1.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 如果是有意隐藏父类中的相同的方法，需要加new，否则会警告</span><br>    <span class="hljs-comment">// 但是和Cpp不一样，父类中其他同名的还是可以用，重载的都可以用，不会全部隐藏。Cpp里面叫名字遮蔽</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        dog.Speak();<br>        dog.Speak(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-继承的限制"><a href="#6-继承的限制" class="headerlink" title="6. 继承的限制"></a>6. 继承的限制</h3><ul><li><strong>不能继承<code>sealed</code>类</strong>：如果一个类被标记为<code>sealed</code>，则不能被继承。</li><li><strong><code>static</code>类不能被继承</strong>：静态类不能被继承或实例化。</li></ul><h3 id="7-里氏替换原则"><a href="#7-里氏替换原则" class="headerlink" title="7. 里氏替换原则"></a>7. 里氏替换原则</h3><p>可以将子类对象赋值给父类引用（基类类型的引用可以指向派生类对象），这样可以利用多态实现灵活的代码设计。<br>继承提供了一种强大的代码复用和扩展功能的方式，在设计类的层次结构时需要合理使用。<br>在C#中，可以将子类对象赋值给父类引用，这种行为称为<strong>多态</strong>。通过这种方式，可以利用父类引用来处理不同子类的对象，从而实现灵活的代码设计。下面是一个简单的示例来展示这一点。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal speaks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类：Dog</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类：Cat</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Cat meows.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 Dog 和 Cat 的实例</span><br>        Animal myDog = <span class="hljs-keyword">new</span> Dog();<br>        Animal myCat = <span class="hljs-keyword">new</span> Cat();<br><br>        <span class="hljs-comment">// 调用 Speak 方法，实际调用的是派生类的方法</span><br>        myDog.Speak(); <span class="hljs-comment">// 输出: Dog barks.</span><br>        myCat.Speak(); <span class="hljs-comment">// 输出: Cat meows.</span><br><br>        <span class="hljs-comment">// 使用多态的集合</span><br>        Animal[] animals = &#123; myDog, myCat &#125;;<br><br>        <span class="hljs-comment">// 遍历集合并调用 Speak 方法</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> animal <span class="hljs-keyword">in</span> animals)<br>        &#123;<br>            animal.Speak();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Dog barks.<br>Cat meows.<br>Dog barks.<br>Cat meows.<br></code></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol><li>**基类 <code>Animal</code>**：<ul><li>定义了一个虚方法 <code>Speak()</code>，这个方法可以在派生类中被重写。</li></ul></li><li>**派生类 <code>Dog</code> 和 <code>Cat</code>**：<ul><li>分别重写了 <code>Speak()</code> 方法，提供了特定的实现。</li><li><code>Dog</code> 类输出 <code>&quot;Dog barks.&quot;</code>，而 <code>Cat</code> 类输出 <code>&quot;Cat meows.&quot;</code></li></ul></li><li><strong>多态</strong>：<ul><li>在 <code>Main</code> 方法中，创建了 <code>Dog</code> 和 <code>Cat</code> 的实例，并将它们赋值给 <code>Animal</code> 类型的引用 <code>myDog</code> 和 <code>myCat</code>。</li><li>通过调用 <code>Speak()</code> 方法，尽管引用类型是 <code>Animal</code>，实际调用的是子类 <code>Dog</code> 和 <code>Cat</code> 的实现。</li></ul></li><li><strong>集合与多态</strong>：<ul><li>使用 <code>Animal</code> 数组存储不同类型的动物，通过遍历数组调用 <code>Speak()</code> 方法，展现了多态的灵活性和可扩展性。</li></ul></li></ol><h3 id="子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数"><a href="#子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数" class="headerlink" title="子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数"></a>子类的构造函数会首先调用父类的构造函数。可以使用<code>base</code>关键字来指定调用父类的哪个构造函数</h3><p>在C#中，子类的构造函数在创建对象时会首先调用父类的构造函数。这可以确保父类的初始化逻辑在子类的初始化之前执行。使用<code>base</code>关键字可以指定调用父类的特定构造函数。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个简单的示例，展示了如何在子类构造函数中调用父类构造函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 父类的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> has been created.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Breed &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 子类的构造函数，调用父类的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> breed</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>    &#123;<br>        Breed = breed;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is a <span class="hljs-subst">&#123;Breed&#125;</span>.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog myDog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-string">&quot;Golden Retriever&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Buddy has been created.<br>Buddy <span class="hljs-keyword">is</span> a Golden Retriever.<br></code></pre></td></tr></table></figure><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><ol><li><strong>父类构造函数</strong>：<code>Animal</code>类有一个构造函数，接收一个参数<code>name</code>，用于初始化<code>Name</code>属性，并打印消息。</li><li><strong>子类构造函数</strong>：<code>Dog</code>类的构造函数接收两个参数：<code>name</code>和<code>breed</code>。在构造函数的参数列表中，使用<code>base(name)</code>调用父类<code>Animal</code>的构造函数，将<code>name</code>传递给它。</li><li><strong>实例化对象</strong>：在<code>Main</code>方法中，创建了一个<code>Dog</code>类的实例<code>myDog</code>，传递了<code>&quot;Buddy&quot;</code>和<code>&quot;Golden Retriever&quot;</code>。创建对象时，首先调用<code>Animal</code>类的构造函数，然后再执行<code>Dog</code>类的构造函数。<br>这个例子展示了如何在子类中通过<code>base</code>关键字调用父类构造函数，确保父类的初始化逻辑被正确执行。</li></ol><h1 id="28-is和as"><a href="#28-is和as" class="headerlink" title="28. is和as"></a>28. is和as</h1><blockquote><p>在C#中，<code>is</code> 和 <code>as</code> 是两个用于类型检查和类型转换的关键字，它们具有不同的用途和语法。</p></blockquote><h3 id="is-关键字"><a href="#is-关键字" class="headerlink" title="is 关键字"></a><code>is</code> 关键字</h3><p><code>is</code> 用于检查一个对象是否是某个特定类型或是否实现了某个接口。它返回一个布尔值，指示对象是否可以安全地转换为指定的类型。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-comment">// 使用 is 检查 obj 是否是字符串类型</span><br>        <span class="hljs-comment">// “模式匹配”（Pattern Matching）</span><br>        <span class="hljs-comment">// obj is string str 的意思是：</span><br>        <span class="hljs-comment">// 检查 obj 是否是 string 类型。</span><br>        <span class="hljs-comment">// 如果 obj 是 string 类型，则将 obj 转换为 string 类型，并赋值给新的局部变量 str。</span><br>        <span class="hljs-comment">// 这个str只能在if的作用域内使用，只是一个局部变量</span><br>        <span class="hljs-comment">// 如果类型检查成功（即 obj 是 string 类型），表达式的值为 true，并且可以在之后的代码中使用 str 变量。</span><br>        <span class="hljs-comment">// 否则表达式的值为false，那么 str 不会被定义，也无法在 if 语句块外使用 str。</span><br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> str)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;The object is a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The object is not a string.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">The <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> a <span class="hljs-built_in">string</span>: Hello, World!<br></code></pre></td></tr></table></figure><h3 id="as-关键字"><a href="#as-关键字" class="headerlink" title="as 关键字"></a><code>as</code> 关键字</h3><p><code>as</code> 用于尝试将一个<code>对象</code>转换为指定的类型，值类型不可以。如果转换成功，它会返回转换后的对象；如果失败，它会返回 <code>null</code>，而不会抛出异常。这在需要进行类型转换时非常有用，可以避免潜在的运行时错误。</p><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-comment">// 使用 as 尝试将 obj 转换为字符串类型</span><br>        <span class="hljs-built_in">string</span> str = obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br><br>        <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;The object was successfully converted to a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The object could not be converted to a string.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">The <span class="hljs-selector-tag">object</span> was successfully converted <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">a</span> string: Hello, World!<br></code></pre></td></tr></table></figure><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol><li><strong>用途</strong>：<ul><li><code>is</code>：用于检查对象的类型，返回一个布尔值。</li><li><code>as</code>：用于进行安全的类型转换，返回转换后的对象或 <code>null</code>。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>is</code> 返回 <code>true</code> 或 <code>false</code>。</li><li><code>as</code> 返回转换后的对象或 <code>null</code>。</li></ul></li><li><strong>异常处理</strong>：<ul><li>使用 <code>is</code> 进行类型检查时，不会抛出异常。</li><li>使用 <code>as</code> 进行类型转换时，如果转换失败，不会抛出异常，而是返回 <code>null</code>。</li></ul></li></ol><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>使用 <code>is</code> 当你只需要知道一个对象的类型时。</li><li>使用 <code>as</code> 当你希望将一个对象转换为特定类型，并且希望在失败时得到 <code>null</code> 而不是异常时。</li></ul><h1 id="29-模式匹配（Pattern-Matching）"><a href="#29-模式匹配（Pattern-Matching）" class="headerlink" title="29. 模式匹配（Pattern Matching）"></a>29. 模式匹配（Pattern Matching）</h1><p><strong>模式匹配</strong>（Pattern Matching）是C#中的一种特性，用于检查某个对象是否符合指定的类型或条件，并在匹配成功时将其转换为相应类型或结构。这种特性可以简化类型检查和转换的代码，使代码更加简洁和可读。</p><h3 id="模式匹配的常见用法"><a href="#模式匹配的常见用法" class="headerlink" title="模式匹配的常见用法"></a>模式匹配的常见用法</h3><h4 id="1-类型模式匹配（Type-Pattern-Matching）"><a href="#1-类型模式匹配（Type-Pattern-Matching）" class="headerlink" title="1. 类型模式匹配（Type Pattern Matching）"></a>1. <strong>类型模式匹配（Type Pattern Matching）</strong></h4><ul><li>用于检查一个对象是否属于某种类型，并在成功时将其转换为该类型。这种模式在<code>is</code>关键字后面使用。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> str)<br>&#123;<br>    <span class="hljs-comment">// str 现在是一个 string 类型</span><br>    Console.WriteLine(<span class="hljs-string">$&quot;The object is a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is not a string.&quot;</span>);<br><br></code></pre></td></tr></table></figure>在这个示例中，如果<code>obj</code>是<code>string</code>类型，则将其转换为<code>str</code>，并可以在<code>if</code>语句块中使用。</li></ul><h4 id="2-常量模式匹配（Constant-Pattern-Matching）"><a href="#2-常量模式匹配（Constant-Pattern-Matching）" class="headerlink" title="2. 常量模式匹配（Constant Pattern Matching）"></a>2. <strong>常量模式匹配（Constant Pattern Matching）</strong></h4><ul><li>可以用于比较对象是否与某个常量相等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (number <span class="hljs-keyword">is</span> <span class="hljs-number">10</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The number is 10.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The number is not 10.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>这里通过<code>is</code>来检查<code>number</code>是否等于常量10。</li><li>上面的例子不行，看这个<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// 使用常量模式匹配</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-number">42</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is 42&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用==操作符</span><br><span class="hljs-keyword">if</span> (obj.Equals(<span class="hljs-number">42</span>))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is also 42&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-表达式模式匹配（Expression-Pattern-Matching）"><a href="#3-表达式模式匹配（Expression-Pattern-Matching）" class="headerlink" title="3. 表达式模式匹配（Expression Pattern Matching）"></a>3. <strong>表达式模式匹配（Expression Pattern Matching）</strong></h4><ul><li>允许在<code>switch</code>表达式中使用模式匹配。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">42</span>;<br><br><span class="hljs-keyword">switch</span> (obj)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &gt; <span class="hljs-number">0</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Positive integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &lt; <span class="hljs-number">0</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Negative integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">string</span> s:<br>        Console.WriteLine(<span class="hljs-string">$&quot;String: <span class="hljs-subst">&#123;s&#125;</span>&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Unknown type or condition.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>在这里，<code>switch</code>表达式结合<code>when</code>条件可以对对象的不同模式进行匹配并处理。</li></ul><h5 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h5><p>这个<code>switch</code>语句使用了模式匹配的功能来处理不同类型和条件的<code>obj</code>值，<code>when</code>关键字用于指定额外的条件约束。具体解释如下：</p><ol><li>**<code>case int i when i &gt; 0</code>**：<ul><li>这里的<code>case</code>语句匹配<code>obj</code>的类型，如果<code>obj</code>是一个整数（<code>int</code>），定义一个局部变量<code>i</code>，<code>i</code>就是<code>obj</code>转换为<code>int</code>的变量，进行下一步判断。</li><li><code>when i &gt; 0</code> 表示只有当<code>i</code>大于0时，这个<code>case</code>才会匹配，输出“Positive integer.”。</li></ul></li><li>**<code>case int i when i &lt; 0</code>**：<ul><li>同样，这个分支首先检查<code>obj</code>的类型是否为整数（<code>int</code>），然后判断这个整数是否小于0。</li><li>当<code>i &lt; 0</code>时，匹配成功，输出“Negative integer.”。</li></ul></li><li>**<code>case string s</code>**：<ul><li>如果前面的条件都不满足，则检查<code>obj</code>是否为字符串（<code>string</code>）类型。</li><li>如果是，则匹配成功，并输出字符串内容，例如“String: …”。</li></ul></li><li>**<code>default</code>**：<ul><li>如果<code>obj</code>的类型不匹配前面的任何一个<code>case</code>，则执行<code>default</code>分支，输出“Unknown type or condition.”。</li></ul></li></ol><h5 id="when关键字的作用"><a href="#when关键字的作用" class="headerlink" title="when关键字的作用"></a><code>when</code>关键字的作用</h5><p><code>when</code>用于在匹配类型的基础上添加条件约束。即使类型匹配成功，也要满足<code>when</code>后面的条件，才能执行该分支。它可以用于进一步筛选具体的情况，使模式匹配更灵活和精确。</p><h4 id="4-位置模式匹配（Positional-Pattern-Matching）"><a href="#4-位置模式匹配（Positional-Pattern-Matching）" class="headerlink" title="4. 位置模式匹配（Positional Pattern Matching）"></a>4. <strong>位置模式匹配（Positional Pattern Matching）</strong></h4><ul><li>用于解构对象，匹配对象的属性或字段。这在C# 8.0及更高版本中得到支持。</li><li>位置模式匹配用于检查元组或某些类型的值是否与指定的模式匹配。这里的<code>(3, 4)</code>是一个位置模式，它表示检查元组中的每个元素是否与指定的值匹配。</li><li>例如，<code>point is (3, 4)</code>意味着检查<code>point</code>是否是一个有两个元素的元组，并且第一个元素的值为<code>3</code>，第二个元素的值为<code>4</code>。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-function">point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>))</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The point is (3, 4).&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>这个例子检查一个元组是否具有指定的值。</li></ul><h4 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h4><ol><li><strong>元组的定义</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>这里定义了一个元组<code>point</code>，它有两个元素<code>X</code>和<code>Y</code>，分别赋值为<code>3</code>和<code>4</code>。这个元组的类型是<code>(int X, int Y)</code>，表示一个包含两个整型值的元组。</li><li><strong>模式匹配检查</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (<span class="hljs-function">point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>))</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The point is (3, 4).&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>这段代码中的<code>point is (3, 4)</code>使用了<strong>位置模式匹配（Positional Pattern Matching）</strong> 来检查<code>point</code>的值是否为<code>(3, 4)</code>。</li></ol><ul><li><code>point is (3, 4)</code>表示检查<code>point</code>是否是一个元组，并且其第一个元素的值为<code>3</code>，第二个元素的值为<code>4</code>。</li><li>如果<code>point</code>的值确实为<code>(3, 4)</code>，则条件成立，执行<code>Console.WriteLine(&quot;The point is (3, 4).&quot;);</code>。</li></ul><h4 id="元组和模式匹配"><a href="#元组和模式匹配" class="headerlink" title="元组和模式匹配"></a>元组和模式匹配</h4><ul><li>C#中的元组可以用来存储一组相关的数据，并且可以通过模式匹配来对元组的值进行检查。</li><li>在<code>if</code>语句中使用<code>is</code>关键字进行模式匹配时，会将元组的值与指定的常量进行比较。</li><li>这种方法可以用于简洁地检查多个值是否匹配特定的组合。</li></ul><h4 id="代码运行结果"><a href="#代码运行结果" class="headerlink" title="代码运行结果"></a>代码运行结果</h4><p>如果<code>point</code>的值为<code>(3, 4)</code>，那么程序会输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">The point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>).</span><br></code></pre></td></tr></table></figure><p>如果<code>point</code>的值不同，比如<code>(5, 6)</code>，则不会输出任何内容。</p><h3 id="模式匹配的优势"><a href="#模式匹配的优势" class="headerlink" title="模式匹配的优势"></a>模式匹配的优势</h3><ul><li><strong>简洁性</strong>：无需额外的类型转换代码。</li><li><strong>安全性</strong>：通过类型检查和转换结合，减少显式类型转换带来的潜在错误。</li><li><strong>灵活性</strong>：可以根据不同的条件和类型编写简洁的控制流。<br>模式匹配在C# 7.0及更高版本中引入，并在后续版本中不断扩展，使得类型检查、条件分支处理更加直观。</li></ul><h1 id="30-when的使用场景"><a href="#30-when的使用场景" class="headerlink" title="30. when的使用场景"></a>30. when的使用场景</h1><p><code>when</code>关键字主要用于<code>switch</code>表达式和<code>case</code>语句中，提供对模式匹配的额外条件约束。常见的使用场景包括：</p><h3 id="1-精确控制匹配条件"><a href="#1-精确控制匹配条件" class="headerlink" title="1. 精确控制匹配条件"></a>1. <strong>精确控制匹配条件</strong></h3><ul><li>当对类型匹配不够时，<code>when</code>可以进一步限定匹配的条件。例如，在类型匹配的基础上，还可以检查数值范围、字符串内容等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">switch</span> (obj)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &gt; <span class="hljs-number">100</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Large number.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &lt;= <span class="hljs-number">100</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Small number.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Not an integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-处理多个条件的组合"><a href="#2-处理多个条件的组合" class="headerlink" title="2. 处理多个条件的组合"></a>2. <strong>处理多个条件的组合</strong></h3><ul><li>适用于多个条件的组合场景。比如同时对类型和某些属性进行匹配时，可以用<code>when</code>来增加逻辑判断。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">switch</span> (person)<br>&#123;<br>    <span class="hljs-keyword">case</span> Employee e <span class="hljs-keyword">when</span> e.YearsOfService &gt; <span class="hljs-number">10</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Senior Employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Employee e <span class="hljs-keyword">when</span> e.YearsOfService &lt;= <span class="hljs-number">10</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Junior Employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Not an employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-在异常处理中的使用"><a href="#3-在异常处理中的使用" class="headerlink" title="3. 在异常处理中的使用"></a>3. <strong>在异常处理中的使用</strong></h3><ul><li>可以在<code>catch</code>语句中结合<code>when</code>条件处理特定的异常情况。例如，在捕获异常时，根据异常的某个属性来判断是否执行该捕获块。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">// Some code that might throw exceptions</span><br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) <span class="hljs-keyword">when</span> (ex.Message.Contains(<span class="hljs-string">&quot;disk&quot;</span>))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Disk-related error.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;General I/O error.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-筛选集合中的元素"><a href="#4-筛选集合中的元素" class="headerlink" title="4. 筛选集合中的元素"></a>4. <strong>筛选集合中的元素</strong></h3><ul><li>在处理集合数据时，使用<code>when</code>可以根据元素的条件筛选匹配的元素。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>&#123;<br>    <span class="hljs-keyword">switch</span> (number)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> n <span class="hljs-keyword">when</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;n&#125;</span> is even.&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> n:<br>            Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;n&#125;</span> is odd.&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="31-var"><a href="#31-var" class="headerlink" title="31. var"></a>31. var</h1><p><code>var</code> 是 C# 中的一种隐式类型声明方式，用于让编译器自动推断变量的类型。在使用 <code>var</code> 时，编译器会根据赋值的表达式确定变量的具体类型。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>var</code> 可以在以下情况下使用：</p><ol><li><strong>局部变量的类型推断</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> number = <span class="hljs-number">10</span>; <span class="hljs-comment">// 编译器推断为 int 类型</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 编译器推断为 string 类型</span><br><span class="hljs-keyword">var</span> isCompleted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 编译器推断为 bool 类型</span><br></code></pre></td></tr></table></figure></li><li><strong>集合或复杂对象</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">// 编译器推断为 List&lt;int&gt; 类型</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span>, Age = <span class="hljs-number">30</span> &#125;; <span class="hljs-comment">// 匿名类型</span><br></code></pre></td></tr></table></figure></li><li><strong>LINQ 查询结果</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> numbers<br>             <span class="hljs-keyword">where</span> n &gt; <span class="hljs-number">5</span><br>             <span class="hljs-keyword">select</span> n;<br></code></pre></td></tr></table></figure></li></ol><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 <code>var</code> 时，必须立即对变量进行初始化，因为编译器需要根据赋值来推断类型。</li><li>一旦类型推断完成，变量的类型在编译时就已经确定，不能改变。</li></ul><h3 id="var-的优缺点"><a href="#var-的优缺点" class="headerlink" title="var 的优缺点"></a><code>var</code> 的优缺点</h3><p><strong>优点</strong>：</p><ul><li>代码更简洁，避免重复声明类型。</li><li>适合处理匿名类型和复杂类型。<br><strong>缺点</strong>：</li><li>可能会降低代码的可读性，尤其是在类型不明显时。</li></ul><h3 id="C-的var和C-的auto"><a href="#C-的var和C-的auto" class="headerlink" title="C#的var和C++的auto"></a>C#的var和C++的auto</h3><h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><ol><li><strong>类型自动推断</strong>：在两者中，编译器根据右侧的表达式来推断变量的类型。例如：<ul><li><strong>C#</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 编译器推断为 int</span><br></code></pre></td></tr></table></figure></li><li><strong>C++</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 编译器推断为 int</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong>简化代码</strong>：使用 <code>var</code> 或 <code>auto</code> 可以减少重复的类型声明，使代码更简洁。</li><li><strong>必须初始化</strong>：两者在声明时都必须立即进行初始化，因为编译器需要根据赋值来确定类型。</li></ol><h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><ol><li><strong>使用场景</strong>：<ul><li>在 C# 中，<code>var</code> 只能用于局部变量的类型推断，而不能用于方法参数、返回类型或字段。</li><li>在 C++ 中，<code>auto</code> 可以用于函数的返回类型推断（C++14 起支持），也可以在循环中使用 <code>auto</code> 来自动推断迭代器的类型。</li></ul></li><li><strong>类型推断的时间点</strong>：<ul><li>C# 的类型推断是在编译时进行的，变量的类型一旦确定，就无法更改。</li><li>C++ 中的 <code>auto</code> 也是在编译时进行类型推断，但由于 C++ 支持模板和类型推断的多样性，<code>auto</code> 可以用于更复杂的场景，如模板编程。</li></ul></li><li><strong>类型推断的灵活性</strong>：<ul><li>C++ 中的 <code>auto</code> 还可以和 <code>const</code>、<code>&amp;</code>（引用）等结合使用，来推断更复杂的类型，如常量引用。</li><li>C# 中的 <code>var</code> 不支持这样的组合用法。</li></ul></li></ol><h1 id="32-元组"><a href="#32-元组" class="headerlink" title="32. 元组"></a>32. 元组</h1><p>在 C# 中，元组（Tuple）是一种数据结构，可以存储多个不同类型的值。元组的主要特点是简单、轻量，可以快速创建和传递多个相关的数据。以下是对 C# 中元组的详细介绍：</p><h3 id="1-定义和创建元组"><a href="#1-定义和创建元组" class="headerlink" title="1. 定义和创建元组"></a>1. <strong>定义和创建元组</strong></h3><p>在 C# 中，你可以使用 <code>Tuple</code> 类或更简洁的语法来创建元组。C# 7.0 引入了更简化的元组语法，使用小括号和命名元素。</p><h4 id="使用-Tuple-类"><a href="#使用-Tuple-类" class="headerlink" title="使用 Tuple 类"></a><strong>使用 <code>Tuple</code> 类</strong></h4><p><code>Tuple</code> 类可以包含最多 <strong>8</strong> 个元素。如果需要更多的元素，可以嵌套使用元组。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = <span class="hljs-keyword">new</span> Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">double</span>, <span class="hljs-built_in">char</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>Console.WriteLine(tuple.Item1); <span class="hljs-comment">// 输出: 1</span><br>Console.WriteLine(tuple.Item2); <span class="hljs-comment">// 输出: Hello</span><br>Console.WriteLine(tuple.Item3); <span class="hljs-comment">// 输出: 3.14</span><br>Console.WriteLine(tuple.Item4); <span class="hljs-comment">// 输出: A</span><br></code></pre></td></tr></table></figure><h4 id="使用-C-7-0-及以上的元组简化语法"><a href="#使用-C-7-0-及以上的元组简化语法" class="headerlink" title="使用 C# 7.0 及以上的元组简化语法"></a><strong>使用 C# 7.0 及以上的元组简化语法</strong></h4><p>C# 7.0 引入了更简洁的元组语法，可以轻松创建和使用多个元素的元组：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = (Id: <span class="hljs-number">1</span>, Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>, Height: <span class="hljs-number">1.75</span>, IsStudent: <span class="hljs-literal">false</span>);<br>Console.WriteLine(tuple.Id);      <span class="hljs-comment">// 输出: 1</span><br>Console.WriteLine(tuple.Name);     <span class="hljs-comment">// 输出: Alice</span><br>Console.WriteLine(tuple.Age);      <span class="hljs-comment">// 输出: 30</span><br>Console.WriteLine(tuple.Height);   <span class="hljs-comment">// 输出: 1.75</span><br>Console.WriteLine(tuple.IsStudent); <span class="hljs-comment">// 输出: False</span><br></code></pre></td></tr></table></figure><h4 id="嵌套元组"><a href="#嵌套元组" class="headerlink" title="嵌套元组"></a><strong>嵌套元组</strong></h4><p>如果需要更多的元素，可以通过嵌套元组的方式来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> tuple = (Person: (Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>), Coordinates: (X: <span class="hljs-number">10</span>, Y: <span class="hljs-number">20</span>));<br>        Console.WriteLine(tuple.Person); <span class="hljs-comment">// 输出: (Alice, 30)</span><br>        Console.WriteLine(tuple.Coordinates.X); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-访问元组元素"><a href="#2-访问元组元素" class="headerlink" title="2. 访问元组元素"></a>2. <strong>访问元组元素</strong></h3><p>可以通过属性（对于 <code>Tuple</code> 类）或直接使用字段（对于简化语法）来访问元组的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = (X: <span class="hljs-number">10</span>, Y: <span class="hljs-number">20</span>);<br>Console.WriteLine(tuple.X); <span class="hljs-comment">// 输出: 10</span><br>Console.WriteLine(tuple.Y); <span class="hljs-comment">// 输出: 20</span><br></code></pre></td></tr></table></figure><h3 id="3-元组的解构"><a href="#3-元组的解构" class="headerlink" title="3. 元组的解构"></a>3. <strong>元组的解构</strong></h3><p>C# 支持元组解构，可以将元组的元素赋值给多个变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br><span class="hljs-keyword">var</span> (x, y) = point;<br>Console.WriteLine(x); <span class="hljs-comment">// 输出: 3</span><br>Console.WriteLine(y); <span class="hljs-comment">// 输出: 4</span><br></code></pre></td></tr></table></figure><h3 id="4-元组的用途"><a href="#4-元组的用途" class="headerlink" title="4. 元组的用途"></a>4. <strong>元组的用途</strong></h3><p>元组通常用于以下场景：</p><ul><li>返回多个值：可以用元组来返回多个相关的值，而不需要创建一个新的类或结构体。</li><li>临时数据存储：在不需要定义一个完整的类的情况下，快速存储和处理小规模的数据。</li></ul><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h3><ul><li>元组的元素类型可以不同，但元组本身是不可变的，这意味着一旦创建，元组的元素值不能被改变。</li><li>对于需要更多功能和可读性的场景，建议使用自定义类或结构体。</li></ul><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><p>下面是一个完整的示例，演示了如何使用元组：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> person = (Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;person.Name&#125;</span>, Age: <span class="hljs-subst">&#123;person.Age&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 解构元组</span><br>        <span class="hljs-keyword">var</span> (name, age) = person;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;name&#125;</span>, Age: <span class="hljs-subst">&#123;age&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="33-LINQ"><a href="#33-LINQ" class="headerlink" title="33. LINQ"></a>33. LINQ</h1><p>LINQ（Language Integrated Query）是 C# 中的一种用于处理数据的查询语言。它使开发人员能够使用类似于 SQL 的语法来查询和操作数据，而不需要具体了解数据的存储方式。LINQ 可以用于多种数据源，包括数组、集合、XML、数据库等。</p><ul><li>只是简单记录，以后用到再说</li></ul><h3 id="LINQ-的主要特点"><a href="#LINQ-的主要特点" class="headerlink" title="LINQ 的主要特点"></a>LINQ 的主要特点</h3><ol><li><strong>集成查询</strong>：LINQ 提供了一种将查询逻辑直接嵌入 C# 代码中的方式。</li><li><strong>强类型</strong>：LINQ 查询是强类型的，编译时会检查类型安全。</li><li><strong>可读性</strong>：LINQ 语法简洁易读，类似于 SQL，使得代码更容易理解。</li><li><strong>延迟执行</strong>：LINQ 查询支持延迟执行，即查询直到实际需要结果时才会执行。</li></ol><h3 id="LINQ-的基本用法"><a href="#LINQ-的基本用法" class="headerlink" title="LINQ 的基本用法"></a>LINQ 的基本用法</h3><p>以下是 LINQ 的一些常见用法示例：</p><h4 id="1-LINQ-to-Objects"><a href="#1-LINQ-to-Objects" class="headerlink" title="1. LINQ to Objects"></a>1. <strong>LINQ to Objects</strong></h4><p>查询集合中的数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br><br>        <span class="hljs-comment">// 查询所有大于 3 的数字</span><br>        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> numbers<br>                     <span class="hljs-keyword">where</span> n &gt; <span class="hljs-number">3</span><br>                     <span class="hljs-keyword">select</span> n;<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>        &#123;<br>            Console.WriteLine(number); <span class="hljs-comment">// 输出: 4, 5, 6</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-LINQ-to-SQL"><a href="#2-LINQ-to-SQL" class="headerlink" title="2. LINQ to SQL"></a>2. <strong>LINQ to SQL</strong></h4><p>查询数据库中的数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> YourDataContext())<br>&#123;<br>    <span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> c <span class="hljs-keyword">in</span> context.Customers<br>                <span class="hljs-keyword">where</span> c.City == <span class="hljs-string">&quot;London&quot;</span><br>                <span class="hljs-keyword">select</span> c;<br><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> customer <span class="hljs-keyword">in</span> query)<br>    &#123;<br>        Console.WriteLine(customer.Name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-方法语法"><a href="#3-方法语法" class="headerlink" title="3. 方法语法"></a>3. <strong>方法语法</strong></h4><p>LINQ 支持两种语法：查询语法和方法语法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = numbers.Where(n =&gt; n &gt; <span class="hljs-number">3</span>); <span class="hljs-comment">// 方法语法</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出: 4, 5, 6</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-组合查询"><a href="#4-组合查询" class="headerlink" title="4. 组合查询"></a>4. <strong>组合查询</strong></h4><p>你可以将多个 LINQ 查询组合在一起。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = numbers<br>    .Where(n =&gt; n &gt; <span class="hljs-number">2</span>)<br>    .Select(n =&gt; n * <span class="hljs-number">2</span>); <span class="hljs-comment">// 先过滤，然后乘以 2</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出: 6, 8, 10, 12</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-进一步处理，不仅仅是LINQ可以用"><a href="#5-进一步处理，不仅仅是LINQ可以用" class="headerlink" title="5. 进一步处理，不仅仅是LINQ可以用"></a>5. 进一步处理，不仅仅是LINQ可以用</h4><p>除了 <code>ToList()</code>，LINQ 查询结果还可以通过其他方法进行转换或进一步处理。常用的 LINQ 转换方法包括：</p><ol><li><strong><code>ToArray()</code></strong><br> 将查询结果转换为数组。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersArray = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToArray();<br></code></pre></td></tr></table></figure></li><li><strong><code>ToDictionary()</code></strong><br> 将查询结果转换为字典，需要指定键和值的选择器。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersDictionary = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                                   .ToDictionary(n =&gt; n, n =&gt; n.ToString());<br><span class="hljs-comment">// 这里键是数字本身，值是对应的字符串表示</span><br></code></pre></td></tr></table></figure></li><li><strong><code>ToHashSet()</code></strong><br> 将查询结果转换为 <code>HashSet</code>，去除重复项。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersSet = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToHashSet();<br></code></pre></td></tr></table></figure></li><li><strong><code>First()</code> &#x2F; <code>FirstOrDefault()</code></strong><br> 返回第一个符合条件的元素，<code>FirstOrDefault()</code> 如果没有找到元素会返回类型的默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> firstEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).First();<br><span class="hljs-keyword">var</span> firstEvenOrDefault = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).FirstOrDefault();<br></code></pre></td></tr></table></figure></li><li><strong><code>Last()</code> &#x2F; <code>LastOrDefault()</code></strong><br> 返回最后一个符合条件的元素，<code>LastOrDefault()</code> 如果没有找到元素会返回类型的默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> lastEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Last();<br><span class="hljs-keyword">var</span> lastEvenOrDefault = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).LastOrDefault();<br></code></pre></td></tr></table></figure></li><li><strong><code>Single()</code> &#x2F; <code>SingleOrDefault()</code></strong><br> 返回唯一一个符合条件的元素，如果有多个或没有找到则抛出异常，<code>SingleOrDefault()</code> 在没有找到时返回默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> singleEven = numbers.Where(n =&gt; n == <span class="hljs-number">2</span>).Single();<br><span class="hljs-keyword">var</span> singleEvenOrDefault = numbers.Where(n =&gt; n == <span class="hljs-number">2</span>).SingleOrDefault();<br></code></pre></td></tr></table></figure></li><li><strong><code>Count()</code></strong><br> 计算符合条件的元素个数。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> evenCount = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Count();<br></code></pre></td></tr></table></figure></li><li><strong><code>Any()</code></strong><br> 判断是否有任何元素符合条件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> hasEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Any();<br></code></pre></td></tr></table></figure></li><li><strong><code>All()</code></strong><br> 判断是否所有元素都符合条件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> allEven = numbers.All(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><strong><code>Max()</code> &#x2F; <code>Min()</code></strong><br>查找最大或最小值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> maxEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Max();<br><span class="hljs-built_in">int</span> minEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Min();<br></code></pre></td></tr></table></figure></li><li><strong><code>Sum()</code> &#x2F; <code>Average()</code></strong><br>计算总和或平均值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> sumEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Sum();<br><span class="hljs-built_in">double</span> avgEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Average();<br><br></code></pre></td></tr></table></figure></li><li><strong><code>ToList()</code></strong><br>将查询结果转换为List。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 示例列表</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> &#125;;<br><br>        <span class="hljs-comment">// 使用 LINQ 查询筛选出所有偶数，并转换为 List&lt;int&gt;</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; evenNumbers = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToList();<br><br>        <span class="hljs-comment">// 输出结果</span><br>        Console.WriteLine(<span class="hljs-string">&quot;偶数列表:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> evenNumbers)<br>        &#123;<br>            Console.WriteLine(num);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="LINQ-的常用操作"><a href="#LINQ-的常用操作" class="headerlink" title="LINQ 的常用操作"></a>LINQ 的常用操作</h3><ul><li><strong>Where</strong>：过滤数据。</li><li><strong>Select</strong>：投影数据。</li><li><strong>OrderBy</strong> 和 <strong>OrderByDescending</strong>：排序。</li><li><strong>GroupBy</strong>：分组。</li><li><strong>Join</strong>：连接多个数据源。</li><li><strong>Count</strong>、<strong>Sum</strong>、<strong>Average</strong>、<strong>Max</strong>、<strong>Min</strong>：聚合操作。</li></ul><h1 id="34-C-中的Object，装箱和拆箱"><a href="#34-C-中的Object，装箱和拆箱" class="headerlink" title="34. C#中的Object，装箱和拆箱"></a>34. C#中的Object，装箱和拆箱</h1><p>在C#中，<strong>装箱</strong>（Boxing）和<strong>拆箱</strong>（Unboxing）是指值类型和引用类型之间的转换过程。理解这两个概念有助于掌握C#中的内存管理和类型转换。</p><h3 id="装箱（Boxing）"><a href="#装箱（Boxing）" class="headerlink" title="装箱（Boxing）"></a>装箱（Boxing）</h3><p>装箱是将一个值类型转换为对象类型（引用类型）的过程。此过程会在堆上分配内存，并将值类型的值复制到该内存位置。<br><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 值类型</span><br><span class="hljs-built_in">object</span> boxedNumber = number; <span class="hljs-comment">// 装箱</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>number</code> 是一个值类型的 <code>int</code>，当我们将它赋值给 <code>object</code> 类型的 <code>boxedNumber</code> 时，发生了装箱。<code>number</code> 的值被复制到堆上一个新的对象中。</p><h3 id="拆箱（Unboxing）"><a href="#拆箱（Unboxing）" class="headerlink" title="拆箱（Unboxing）"></a>拆箱（Unboxing）</h3><p>拆箱是将一个已装箱的对象转换回值类型的过程。此过程会将对象的值复制回值类型变量。<br><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> boxedNumber = <span class="hljs-number">42</span>; <span class="hljs-comment">// 装箱</span><br><span class="hljs-built_in">int</span> unboxedNumber = (<span class="hljs-built_in">int</span>)boxedNumber; <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>boxedNumber</code> 是一个对象，它包含了一个整型值。通过将其强制转换为 <code>int</code>，我们执行了拆箱操作。</p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>性能开销</strong>：装箱和拆箱会导致额外的性能开销，因为它们涉及内存分配和数据复制。因此，尽量避免频繁的装箱和拆箱。<br>装箱和拆箱会导致性能开销的原因主要在于它们涉及<strong>内存分配</strong>和<strong>数据复制</strong>。具体来说：</li></ol><ul><li>装箱的性能开销<br>  装箱是将一个<strong>值类型</strong>转换为<strong>引用类型</strong>（对象）的过程。这个过程涉及以下几个步骤：<ul><li><strong>在堆上分配内存</strong>：装箱时，值类型的值需要被封装到一个对象中，而这个对象是在堆上分配的。堆上的内存分配比栈上的内存分配要慢，因为它涉及到更多的管理工作（如内存分配、垃圾回收等）。</li><li><strong>复制数据</strong>：在装箱的过程中，需要将值类型的数据复制到堆上分配的对象中。这意味着需要额外的内存操作。</li></ul></li><li>拆箱的性能开销<br>  拆箱是将一个已装箱的对象转换回值类型的过程。拆箱操作也会带来一定的开销，原因如下：<ul><li><strong>类型检查</strong>：拆箱时，C#运行时会进行类型检查，以确保对象的类型与要转换的值类型匹配。如果类型不匹配，会引发 <code>InvalidCastException</code> 异常。这种类型检查会有一定的性能开销。</li><li><strong>数据复制</strong>：拆箱时，需要将对象中的数据复制回值类型变量。这也意味着会有额外的内存操作。</li></ul></li><li>垃圾回收的影响<ul><li>由于装箱会在堆上创建新的对象，这些对象可能在将来需要被垃圾回收。当堆上分配了大量装箱产生的对象时，会增加垃圾回收的频率和负担，从而进一步影响性能。</li></ul></li><li>为什么栈上的分配更快？<ul><li>栈上的内存分配只需调整栈指针即可，非常高效。而堆上的内存分配涉及复杂的内存管理，例如查找适合的内存块、记录内存使用状态、处理垃圾回收等，因此要慢得多。</li></ul></li></ul><ol start="2"><li><strong>类型安全</strong>：拆箱时，如果对象不包含相应的值类型，程序将抛出 <code>InvalidCastException</code>。</li><li><strong>值类型与引用类型</strong>：值类型（如 <code>int</code>、<code>float</code>、<code>struct</code>）直接存储在栈上，而引用类型（如 <code>object</code>、<code>string</code>）则存储在堆上。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>理解装箱和拆箱是C#中的一个重要概念，特别是在处理集合或需要多态时。尽量减少不必要的装箱和拆箱可以提高程序性能。</p><h1 id="35-值类型和引用类型的内存分配"><a href="#35-值类型和引用类型的内存分配" class="headerlink" title="35. 值类型和引用类型的内存分配"></a>35. 值类型和引用类型的内存分配</h1><p>在C#中，<strong>值类型</strong>和<strong>引用类型</strong>的内存分配方式有所不同：</p><h3 id="值类型的内存分配"><a href="#值类型的内存分配" class="headerlink" title="值类型的内存分配"></a>值类型的内存分配</h3><ul><li><strong>值类型</strong>（如 <code>int</code>、<code>float</code>、<code>struct</code> 等）通常分配在<strong>栈</strong>上。这意味着它们的内存是在方法调用时分配，并在方法返回时释放。</li><li>栈上的内存分配非常快，因为它按照顺序管理，只需调整栈指针即可。</li><li>值类型直接包含其数据，这意味着访问值类型时没有间接性。</li><li><strong>例外情况</strong>：如果值类型是某个对象的一部分（例如，作为类的字段），那么这个值类型的实例将存储在堆上，因为包含它的对象位于堆上。</li></ul><h3 id="引用类型的内存分配"><a href="#引用类型的内存分配" class="headerlink" title="引用类型的内存分配"></a>引用类型的内存分配</h3><ul><li><strong>引用类型</strong>（如 <code>class</code>、<code>array</code>、<code>string</code> 等）通常分配在<strong>堆</strong>上。堆内存适用于动态分配，内存分配和回收由垃圾收集器管理。</li><li>引用类型的变量实际上是一个指向堆上对象的<strong>引用</strong>，它本身存储在栈上。引用指向的对象实际存储在堆中。</li><li>当引用类型的对象不再被引用时，垃圾收集器会回收它所占用的堆内存。</li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 值类型，分配在栈上</span><br><br>MyClass obj = <span class="hljs-keyword">new</span> MyClass(); <span class="hljs-comment">// 引用类型，obj的引用存储在栈上，对象本身分配在堆上</span><br><br><span class="hljs-keyword">struct</span> MyStruct<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> y;<br>    <span class="hljs-keyword">public</span> MyStruct myStruct; <span class="hljs-comment">// myStruct存储在堆上，因为它是对象的一部分</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>a</code> 是一个值类型变量，分配在栈上。<code>obj</code> 是一个引用类型变量，指向堆上分配的 <code>MyClass</code> 实例。<code>MyClass</code> 的实例包含 <code>MyStruct</code> 类型的字段 <code>myStruct</code>，由于它是对象的一部分，因此也存储在堆上。</p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>值类型直接包含数据，存储在栈上（或在某些情况下存储在堆上，比如作为类的字段）。常见的值类型包括：</p><ol><li><strong>基本数据类型</strong>：<ul><li><code>int</code></li><li><code>float</code></li><li><code>double</code></li><li><code>char</code></li><li><code>bool</code></li><li><code>byte</code>, <code>sbyte</code></li><li><code>short</code>, <code>ushort</code></li><li><code>long</code>, <code>ulong</code></li><li><code>decimal</code></li></ul></li><li><strong>结构体</strong>（<code>struct</code>）：C#中的结构体是值类型。<ul><li>自定义的<code>struct</code></li><li>预定义的结构体，如 <code>DateTime</code>, <code>TimeSpan</code>, <code>Guid</code></li></ul></li><li><strong>枚举</strong>（<code>enum</code>）：在C#中，枚举也是值类型。</li></ol><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型的变量存储在栈上，但它们指向存储在堆上的实际数据。常见的引用类型包括：</p><ol><li><strong>类</strong>（<code>class</code>）<ul><li>自定义的类</li><li>预定义的类，如 <code>string</code>, <code>ArrayList</code>, <code>List&lt;T&gt;</code></li></ul></li><li><strong>接口</strong>（<code>interface</code>）：实现接口的类型也是引用类型。</li><li><strong>数组</strong>：无论是 <code>int[]</code>, <code>string[]</code>，还是自定义类型的数组，都是引用类型。</li><li><strong>委托</strong>（<code>delegate</code>）：委托类型也是引用类型。</li><li><strong>字符串</strong>（<code>string</code>）：尽管字符串表现得像值类型（不可变），但它是引用类型。</li></ol><h4 id="值类型与引用类型的主要区别"><a href="#值类型与引用类型的主要区别" class="headerlink" title="值类型与引用类型的主要区别"></a>值类型与引用类型的主要区别</h4><ul><li><strong>内存分配</strong>：值类型通常在栈上分配，而引用类型在堆上分配。</li><li><strong>赋值操作</strong>：值类型赋值时会复制值，引用类型赋值时会复制引用（地址）。</li><li><strong>默认值</strong>：值类型的默认值是类型本身的默认值（如 <code>int</code> 的默认值为 <code>0</code>），而引用类型的默认值是 <code>null</code>。</li></ul><h1 id="36-类型转换"><a href="#36-类型转换" class="headerlink" title="36. 类型转换"></a>36. 类型转换</h1><p>在C#中，<strong>类型转换</strong>是将一个数据类型的值转换为另一个数据类型的过程。根据转换的方式和适用的场景，类型转换可以分为几种类型：<strong>隐式转换</strong>、<strong>显式转换</strong>、<strong>装箱和拆箱</strong>、以及<strong>类型转换方法</strong>。</p><h3 id="1-隐式转换"><a href="#1-隐式转换" class="headerlink" title="1. 隐式转换"></a>1. 隐式转换</h3><ul><li>隐式转换是一种<strong>自动进行</strong>的转换，不需要显式地使用类型转换运算符。</li><li>这种转换通常在<strong>不会丢失数据</strong>的情况下进行，例如从较小范围的数值类型转换为较大范围的数值类型。</li><li>常见的隐式转换示例：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">double</span> b = a; <span class="hljs-comment">// int 隐式转换为 double</span><br>```   <br>在上述示例中，`<span class="hljs-built_in">int</span>` 转换为 `<span class="hljs-built_in">double</span>` 是安全的，因为 `<span class="hljs-built_in">double</span>` 的范围比 `<span class="hljs-built_in">int</span>` 大，不会丢失精度。<br><span class="hljs-meta">### 2. 显式转换（强制转换）</span><br>- 显式转换要求使用**强制转换运算符**，即 `(目标类型)`，因为这种转换可能会**丢失数据**或导致异常。<br>- 这种转换用于从大范围的数值类型转换为小范围的数值类型，或者从一种兼容的类型转换为另一种。<br>- 示例：<br>```csharp<br><span class="hljs-built_in">double</span> a = <span class="hljs-number">9.78</span>;<br><span class="hljs-built_in">int</span> b = (<span class="hljs-built_in">int</span>)a; <span class="hljs-comment">// 显式转换，结果为 9</span><br></code></pre></td></tr></table></figure>在这个例子中，将 <code>double</code> 显式转换为 <code>int</code> 会导致小数部分丢失。</li></ul><h3 id="3-装箱和拆箱"><a href="#3-装箱和拆箱" class="headerlink" title="3. 装箱和拆箱"></a>3. 装箱和拆箱</h3><ul><li><strong>装箱（Boxing）</strong>：将<strong>值类型</strong>转换为<strong>引用类型</strong>（对象）的过程。会在堆上分配一个新的对象来存储该值类型的值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">object</span> obj = num; <span class="hljs-comment">// 装箱</span><br></code></pre></td></tr></table></figure></li><li><strong>拆箱（Unboxing）</strong>：将已装箱的<strong>对象</strong>转换回<strong>值类型</strong>的过程。这需要显式地进行转换。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">int</span> num = (<span class="hljs-built_in">int</span>)obj; <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-使用类型转换方法"><a href="#4-使用类型转换方法" class="headerlink" title="4. 使用类型转换方法"></a>4. 使用类型转换方法</h3><p>C#提供了一些用于类型转换的内置方法和类，如 <code>Convert</code> 类、<code>Parse</code> 方法和 <code>TryParse</code> 方法。</p><ul><li><strong>Convert类</strong>：可用于将基本数据类型之间进行转换。如果转换失败会抛出异常。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-built_in">int</span> num = Convert.ToInt32(str); <span class="hljs-comment">// 将字符串转换为整数</span><br></code></pre></td></tr></table></figure></li><li><strong>Parse方法</strong>：用于将字符串转换为对应的数值类型。如果转换失败会抛出异常。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-built_in">double</span> num = <span class="hljs-built_in">double</span>.Parse(str); <span class="hljs-comment">// 将字符串转换为 double</span><br></code></pre></td></tr></table></figure></li><li><strong>TryParse方法</strong>：与 <code>Parse</code> 类似，但在转换失败时不会抛出异常，而是返回 <code>false</code>。</li><li>为什么 <code>TryParse</code> 使用 <code>out</code><br>  <code>TryParse</code> 方法的设计初衷是尝试将字符串解析为数值类型（例如 <code>double</code>、<code>int</code> 等），并返回一个布尔值，表示转换是否成功。<code>out</code> 参数用于接收解析后的数值。<ul><li><strong>如果解析成功</strong>：<code>TryParse</code> 返回 <code>true</code>，并且通过 <code>out</code> 参数将解析后的结果赋值给调用者定义的变量。</li><li><strong>如果解析失败</strong>：<code>TryParse</code> 返回 <code>false</code>，<code>out</code> 参数的值不会被赋给任何有效的数值（可能是类型的默认值，如 <code>0.0</code>）。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">double</span>.TryParse(str, <span class="hljs-keyword">out</span> <span class="hljs-built_in">double</span> result))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;转换成功，值为 <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;转换失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-类型转换的注意事项"><a href="#5-类型转换的注意事项" class="headerlink" title="5. 类型转换的注意事项"></a>5. 类型转换的注意事项</h3><ul><li><strong>兼容性</strong>：转换前要确保类型兼容，不兼容的类型转换会导致编译错误或运行时异常。</li><li><strong>数据丢失</strong>：从大范围类型转换为小范围类型可能会丢失数据（例如，浮点数转换为整数会丢失小数部分）。</li><li><strong>异常处理</strong>：使用显式转换时，建议进行异常处理以防止转换失败导致程序崩溃。</li></ul><h3 id="as呢"><a href="#as呢" class="headerlink" title="as呢"></a>as呢</h3><p><code>as</code> 关键字在C#中也用于类型转换，但它的用法和普通的显式类型转换有一些区别。虽然它也可以实现类型转换的功能，但它的工作方式与传统的强制转换有所不同。</p><h4 id="as-关键字的特点"><a href="#as-关键字的特点" class="headerlink" title="as 关键字的特点"></a><code>as</code> 关键字的特点</h4><ol><li><strong>用于引用类型和可空类型的转换</strong>：<code>as</code> 关键字只能用于将一个<strong>引用类型</strong>或<strong>可空类型</strong>转换为另一种引用类型或可空类型。对于值类型的转换，不能使用 <code>as</code>。</li><li><strong>安全的类型转换</strong>：<code>as</code> 是一种<strong>安全的类型转换</strong>方法，如果转换失败，它会返回 <code>null</code>，而不是抛出异常。传统的强制转换在转换失败时会抛出 <code>InvalidCastException</code> 异常。</li><li><strong>转换失败返回 null</strong>：当类型转换无法进行时，<code>as</code> 会返回 <code>null</code>，这意味着你可以通过检查转换结果是否为 <code>null</code> 来判断转换是否成功。</li></ol><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> str = obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 成功转换，str 现在是 &quot;Hello, World!&quot;</span><br><br><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str2 = num <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 转换失败，str2 为 null</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>obj</code> 是一个字符串，因此可以使用 <code>as</code> 转换为 <code>string</code> 类型。而 <code>num</code> 是一个整数，不能转换为 <code>string</code>，所以 <code>as</code> 返回 <code>null</code>。</p><h4 id="与强制转换的对比"><a href="#与强制转换的对比" class="headerlink" title="与强制转换的对比"></a>与强制转换的对比</h4><ul><li><strong>强制转换</strong>（<code>(目标类型)obj</code>）在转换失败时会抛出异常：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str = (<span class="hljs-built_in">string</span>)num; <span class="hljs-comment">// 运行时会抛出 InvalidCastException</span><br></code></pre></td></tr></table></figure></li><li><strong><code>as</code> 转换</strong>则会返回 <code>null</code>，而不会抛出异常：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str = num <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 转换失败，str 为 null</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>当你不确定转换是否会成功时，使用 <code>as</code> 可以避免异常，并通过 <code>null</code> 检查来判断转换的结果。</li><li><code>as</code> 只能用于引用类型的转换，如果需要对值类型进行安全转换，可以结合 <code>Nullable&lt;T&gt;</code> 或使用其他方法（如 <code>TryParse</code>）。</li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><code>as</code> 可以看作是一种特殊的类型转换方式，主要用于引用类型的安全转换。它的主要特点是在转换失败时返回 <code>null</code> 而不是抛出异常，因此适合在不确定转换是否能成功的情况下使用。</p><h1 id="37-密封类（sealed-class）"><a href="#37-密封类（sealed-class）" class="headerlink" title="37. 密封类（sealed class）"></a>37. 密封类（sealed class）</h1><p>在C#中，<strong>密封类</strong>（<code>sealed class</code>）是一种不允许被继承的类。通过使用 <code>sealed</code> 关键字修饰类，可以防止其他类从该类派生。这样做的目的是增强安全性、提高性能或限制类的使用方式。</p><h3 id="密封类的特点"><a href="#密封类的特点" class="headerlink" title="密封类的特点"></a>密封类的特点</h3><ol><li><strong>不能被继承</strong>：密封类禁止其他类从它派生。这意味着你无法创建该类的子类。</li><li><strong>可以实例化</strong>：虽然密封类不能被继承，但它仍然可以像普通类一样被实例化并使用。</li><li><strong>提高性能</strong>：对于某些虚方法，JIT编译器可以针对密封类进行优化，因为它知道该方法不会被重写，从而减少方法调用的开销。</li></ol><h3 id="密封类的定义示例"><a href="#密封类的定义示例" class="headerlink" title="密封类的定义示例"></a>密封类的定义示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySealedClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is a sealed class.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 下面的代码会导致编译错误，因为 MySealedClass 是密封的，不能被继承</span><br><span class="hljs-comment">// class DerivedClass : MySealedClass</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MySealedClass</code> 是一个密封类，禁止其他类从它派生。如果尝试继承这个类，会导致编译错误。</p><h3 id="使用密封类的场景"><a href="#使用密封类的场景" class="headerlink" title="使用密封类的场景"></a>使用密封类的场景</h3><ol><li><strong>安全性需求</strong>：当你希望某个类的功能不被扩展或修改时，可以将其声明为密封类。这样可以确保类的行为在使用时不会被子类改变。</li><li><strong>性能优化</strong>：密封类在某些情况下可以提高性能，因为编译器可以针对它们进行优化，特别是方法调用。</li><li><strong>设计限制</strong>：有时，设计一个不可扩展的类是必要的，例如一些工具类或帮助类，这些类的行为应该是固定的。</li></ol><h3 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h3><p>除了密封类，C#还允许在继承类中将<strong>方法</strong>标记为密封。密封方法使用 <code>sealed</code> 关键字，并且必须是<strong>重写</strong>的（即继承自父类的虚方法或抽象方法）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Base class display method.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Derived class sealed display method.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不能进一步重写 Display 方法</span><br><span class="hljs-comment">// class AnotherDerivedClass : DerivedClass</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// 如果关键字override变成new或者删除override，不会编译报错，这个是会隐藏DerivedClass的Display()方法</span><br><span class="hljs-comment">//     public override void Display() // 这会导致编译错误</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         Console.WriteLine(&quot;Another derived class display method.&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>DerivedClass</code> 重写了 <code>BaseClass</code> 的 <code>Display</code> 方法并将其密封，防止进一步的重写。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>密封类</strong>：通过 <code>sealed</code> 关键字修饰的类，不能被继承，用于提高安全性和性能。</li><li><strong>密封方法</strong>：用 <code>sealed</code> 修饰的重写方法，防止其在子类中被进一步重写。</li><li>使用密封类和方法有助于控制类层次结构和优化性能。</li></ul><h1 id="38-多态"><a href="#38-多态" class="headerlink" title="38. 多态"></a>38. 多态</h1><p><strong>多态</strong>（Polymorphism）是面向对象编程中的一个重要概念，它指的是<strong>同一个方法或属性在不同的对象中可以有不同的实现</strong>。多态性允许程序在不同的类中定义相同的接口或方法名称，并根据具体对象的类型来调用适当的方法。这种特性增强了代码的灵活性和可维护性。</p><h3 id="多态的类型"><a href="#多态的类型" class="headerlink" title="多态的类型"></a>多态的类型</h3><p>在C#中，多态可以通过<strong>编译时多态（静态多态）</strong> 和<strong>运行时多态（动态多态）</strong> 来实现。</p><h4 id="1-编译时多态（静态多态）"><a href="#1-编译时多态（静态多态）" class="headerlink" title="1. 编译时多态（静态多态）"></a>1. 编译时多态（静态多态）</h4><p>编译时多态通常通过<strong>方法重载</strong>和<strong>运算符重载</strong>来实现。</p><ul><li><strong>方法重载（Method Overloading）</strong>：同一个类中可以定义多个具有相同名称但参数不同的方法。这些方法会根据传入的参数来决定调用哪个具体的实现。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MathOperations</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> a, <span class="hljs-built_in">double</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>MathOperations math = <span class="hljs-keyword">new</span> MathOperations();<br>Console.WriteLine(math.Add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));       <span class="hljs-comment">// 调用 Add(int, int)</span><br>Console.WriteLine(math.Add(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>));   <span class="hljs-comment">// 调用 Add(double, double)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-运行时多态（动态多态）"><a href="#2-运行时多态（动态多态）" class="headerlink" title="2. 运行时多态（动态多态）"></a>2. 运行时多态（动态多态）</h4><p>运行时多态通过<strong>继承</strong>和<strong>虚方法</strong>、<strong>抽象类</strong>或<strong>接口</strong>来实现。最常见的实现方式是<strong>方法重写（Method Overriding）</strong>。</p><ul><li><p><strong>虚方法和重写</strong>：在基类中定义一个方法为 <code>virtual</code>，然后在派生类中使用 <code>override</code> 关键字重写这个方法。调用时根据对象的实际类型来决定执行哪个版本的方法。</p></li><li><p>当然，virtual虚函数也可以不重写，这样调用的就是父类的虚函数了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Some generic animal sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Bark&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span><br>&#123;<br><span class="hljs-comment">// 不重写父类的MakeSound()虚函数</span><br>    <span class="hljs-comment">//public override void MakeSound()</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    Console.WriteLine(&quot;Meow&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        Animal myAnimal;<br>        myAnimal = <span class="hljs-keyword">new</span> Dog();<br>        myAnimal.MakeSound(); <span class="hljs-comment">// 输出 &quot;Bark&quot;</span><br><br>        myAnimal = <span class="hljs-keyword">new</span> Cat();<br>        myAnimal.MakeSound(); <span class="hljs-comment">// 输出 &quot;Some generic animal sound&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MakeSound</code> 方法在基类 <code>Animal</code> 中是虚方法，允许派生类 <code>Dog</code>  重写它。当我们调用 <code>MakeSound</code> 时，实际执行的是对象所属类型（<code>Dog</code>）的具体实现。</p></li><li><p><strong>接口</strong>与重写：在C#中，<strong>接口</strong>（Interface）是一种定义类和结构应遵循的契约。接口可以包含方法、属性、事件和索引器，但不能包含字段或实现。任何实现接口的类或结构都必须提供接口中定义的所有成员的实现。</p></li><li><p>接口不包含成员变量</p></li><li><p>接口包含的成员不能被实现</p></li><li><p>接口包含的成员访问修饰符可以不写，默认是public，但是不能写成私有</p></li><li><p>接口不能继承类，但是可以继承另一个接口</p></li><li><p>接口不能被实例化，但是可以作为容器存储对象</p></li><li><p>继承了接口，必须是public方式实现</p></li><li><p>接口也遵循历史转换原则</p><ul><li>接口的基本定义  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span>;      <span class="hljs-comment">// 定义一个方法，计算面积</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;       <span class="hljs-comment">// 定义一个方法，绘制形状</span><br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，我们定义了一个名为 <code>IShape</code> 的接口，它包含两个方法：<code>Area</code> 和 <code>Draw</code>。继承结构的类，必须实现这两个方法，否则报错</li><li>实现接口的类<br>  多个类可以实现同一个接口，并提供各自的实现。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius; <span class="hljs-comment">// 圆的面积公式</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Circle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>    &#123;<br>        Width = width;<br>        Height = height;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Width * Height; <span class="hljs-comment">// 矩形的面积公式</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Rectangle&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，<code>Circle</code> 和 <code>Rectangle</code> 类实现了 <code>IShape</code> 接口。它们都提供了 <code>Area</code> 和 <code>Draw</code> 方法的具体实现。</li><li>使用接口的示例<br>  通过接口类型，可以编写更灵活的代码，处理不同的实现。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        IShape circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        IShape rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>); <span class="hljs-comment">// 调用圆的面积方法</span><br>        circle.Draw(); <span class="hljs-comment">// 绘制圆</span><br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>); <span class="hljs-comment">// 调用矩形的面积方法</span><br>        rectangle.Draw(); <span class="hljs-comment">// 绘制矩形</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>输出结果  <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Circle</span> <span class="hljs-built_in">Area</span><span class="hljs-operator">:</span> <span class="hljs-number">78.53981633974483</span><br><span class="hljs-variable">Drawing</span> <span class="hljs-variable">a</span> <span class="hljs-built_in">Circle</span><br><span class="hljs-built_in">Rectangle</span> <span class="hljs-built_in">Area</span><span class="hljs-operator">:</span> <span class="hljs-number">24</span><br><span class="hljs-variable">Drawing</span> <span class="hljs-variable">a</span> <span class="hljs-built_in">Rectangle</span><br></code></pre></td></tr></table></figure></li><li>其他示例  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义接口 IShape</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-comment">// 方法声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br><br>    <span class="hljs-comment">// 属性声明</span><br>    <span class="hljs-built_in">double</span> Area &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-comment">// 事件声明</span><br>    <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器声明</span><br>    <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Circle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Draw 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Drawing a circle with radius: <span class="hljs-subst">&#123;Radius&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Area 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Area =&gt; Math.PI * Radius * Radius;<br><br>    <span class="hljs-comment">// 事件的实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Radius;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                Radius = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 触发 ShapeChanged 事件的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShapeChanged</span>()</span><br>    &#123;<br>        ShapeChanged?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Rectangle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>    &#123;<br>        Width = width;<br>        Height = height;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Draw 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Drawing a rectangle with width: <span class="hljs-subst">&#123;Width&#125;</span> and height: <span class="hljs-subst">&#123;Height&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Area 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Area =&gt; Width * Height;<br><br>    <span class="hljs-comment">// 事件的实现 </span><br>    <span class="hljs-comment">// EventHandler是自带的事件</span><br>    <span class="hljs-comment">// public delegate void EventHandler(object? sender, EventArgs e);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Width;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Height;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                Width = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>)<br>            &#123;<br>                Height = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 触发 ShapeChanged 事件的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShapeChanged</span>()</span><br>    &#123;<br>        ShapeChanged?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        IShape circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        circle.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a circle with radius: 5&quot;</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出圆的面积</span><br><br>        IShape rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        rectangle.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a rectangle with width: 4 and height: 6&quot;</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出矩形的面积</span><br><br>        <span class="hljs-comment">// 使用索引器</span><br>        circle[<span class="hljs-number">0</span>] = <span class="hljs-number">7</span>; <span class="hljs-comment">// 修改半径</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Updated Circle Area: <span class="hljs-subst">&#123;circle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出更新后的面积</span><br><br>        <span class="hljs-comment">// 订阅事件</span><br>        rectangle.ShapeChanged += (sender, e) =&gt; Console.WriteLine(<span class="hljs-string">&quot;Rectangle shape changed!&quot;</span>);<br>        rectangle[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>; <span class="hljs-comment">// 修改宽度，触发事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果两个接口中存在同名方法时，需要显式实现接口</li><li>显式实现接口时，不能写访问修饰符  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义接口 IShape</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>; <span class="hljs-comment">// 方法声明</span><br>&#125;<br><br><span class="hljs-comment">// 定义接口 IFigure</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFigure</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>; <span class="hljs-comment">// 方法声明</span><br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Circle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span>, <span class="hljs-title">IFigure</span><br>&#123;<br>    <span class="hljs-comment">// 显式实现 IShape 的 Draw 方法</span><br>    <span class="hljs-keyword">void</span> IShape.Draw()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a shape as IShape.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 显式实现 IFigure 的 Draw 方法</span><br>    <span class="hljs-keyword">void</span> IFigure.Draw()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a shape as IFigure.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 Circle 的实例</span><br>        Circle circle = <span class="hljs-keyword">new</span> Circle();<br><br>        <span class="hljs-comment">// 使用 IShape 接口调用 Draw 方法</span><br>        IShape shape = circle;<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a shape as IShape.&quot;</span><br><br>        <span class="hljs-comment">// 使用 IFigure 接口调用 Draw 方法</span><br>        IFigure figure = circle;<br>        figure.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a shape as IFigure.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>接口的优点<ol><li><strong>松耦合</strong>：接口允许类之间松散耦合，方便替换和扩展。你可以在不修改现有代码的情况下，引入新的实现。</li><li><strong>多态</strong>：通过接口可以实现多态性，允许不同的对象以相同的方式进行处理。</li><li><strong>强制实现</strong>：接口强制实现类遵循特定的协议，从而确保一致性。</li></ol></li><li>继承多个接口<br>  C#允许一个类实现多个接口，从而支持多重继承的特性。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDrawable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IColorable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Color</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ColoredCircle</span> : <span class="hljs-title">IShape</span>, <span class="hljs-title">IDrawable</span>, <span class="hljs-title">IColorable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColoredCircle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Colored Circle&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Color</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Coloring the circle with <span class="hljs-subst">&#123;color&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>抽象类和抽象方法</strong>：如果一个类中有抽象方法（没有方法体的方法），该类必须被声明为抽象类，不能被直接实例化，必须由派生类实现抽象方法。</p></li><li><p>抽象类不可以被实例化，但是遵循里氏转换原则，可以作为父类接受子类</p></li><li><p>抽象类需要用abstract关键字声明，放在class前面</p></li><li><p>抽象类可以没有抽象方法，但是抽象方法必须在抽象类里面</p></li><li><p>抽象方法不能是私有的，不然无法继承后重写。抽象方法一定是没有函数体的。且必须在抽象类中</p></li><li><p>如果继承了抽象类，子类不是抽象类，则必须实现抽象类，否则可以不实现</p></li><li><p>如果某个子类，继承的父类已经实现了抽象函数，那么可以直接继承，不继续实现。如果实现，用的是override，和普通的实现抽象函数一样，多态。如果使用的是new，则是和普通的重载规则一样，具体下面注释写了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape2</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Shape2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果不实现抽象类Shape中的Draw方法，也必须声明为abstract类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a rectangle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果这里继承实现了Draw，使用new关键字，下面是用Shape接受，那么会使用Rectangle的方法，输出&quot;Drawing a rectangle&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle2</span> : <span class="hljs-title">Rectangle</span><br>&#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle3</span> : <span class="hljs-title">Shape2</span><br>&#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        Shape shape;<br>        shape = <span class="hljs-keyword">new</span> Circle();<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a circle&quot;</span><br><br>        shape = <span class="hljs-keyword">new</span> Rectangle2();<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a rectangle&quot;</span><br><br>        Shape2 shape2;<br>        shape2 = <span class="hljs-keyword">new</span> Rectangle3();<br>        shape2.Draw(); <span class="hljs-comment">//输出 &quot;Shape2&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ol><li><strong>代码可维护性高</strong>：多态可以让程序在不修改现有代码的情况下，方便地扩展新的功能。例如，新增一种 <code>Shape</code> 类型的子类只需实现 <code>Draw</code> 方法，不影响其他代码。</li><li><strong>提高代码的灵活性和可扩展性</strong>：通过接口或基类编程，可以编写通用的代码，这些代码可以应用于各种具体的对象。</li><li><strong>面向接口编程</strong>：多态性鼓励面向接口编程，而不是面向实现编程，从而提高系统的可扩展性。</li></ol><h3 id="多态的实现注意事项"><a href="#多态的实现注意事项" class="headerlink" title="多态的实现注意事项"></a>多态的实现注意事项</h3><ul><li>当使用虚方法或抽象方法时，子类应使用 <code>override</code> 关键字重写基类方法。</li><li>接口方法在实现时也类似于虚方法，可以实现多态。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p>抽象类和接口在面向对象编程中用于定义抽象的类型成员，帮助实现多态性，但它们有不同的特点和使用场景。以下是抽象类和接口之间的主要区别：</p><h4 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1. 定义方式"></a>1. <strong>定义方式</strong></h4><ul><li><strong>抽象类</strong>：使用 <code>abstract</code> 关键字定义，允许包含抽象方法（没有实现）和非抽象方法（有实现）。</li><li><strong>接口</strong>：使用 <code>interface</code> 关键字定义，不能包含任何方法的实现（从 C# 8.0 开始，接口可以包含默认实现）。<ul><li>如果接口是类的唯一父类，如果用这个父类接收，可以调用其中原有的方法</li><li>接口中的方法，只能是public，不能是private，protected的话不可以在类外使用，也不可以用virtual  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">Itest</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;interface Itest 的默认实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> : <span class="hljs-title">Itest</span><br>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-comment">//test.show();// 报错</span><br><br>        <span class="hljs-comment">// 通过接口引用来调用默认实现的方法</span><br>        Itest itest = test;<br>        itest.show(); <span class="hljs-comment">// 输出: interface Itest 的默认实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-继承关系"><a href="#2-继承关系" class="headerlink" title="2. 继承关系"></a>2. <strong>继承关系</strong></h4><ul><li><strong>抽象类</strong>：支持单继承，即一个类只能继承一个抽象类。</li><li><strong>接口</strong>：支持多继承，一个类可以实现多个接口。</li><li>如果是抽象类和接口都继承，也就是一个类继承了单个类和多个接口，那么其中的父类，只能调用自己相关的方法，而不能调用其他接口或者类的方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BaseMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method from BaseClass&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IInterface1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InterfaceMethod</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IInterface1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InterfaceMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method from IInterface1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        DerivedClass derivedClass = <span class="hljs-keyword">new</span> DerivedClass();<br>        derivedClass.BaseMethod();        <span class="hljs-comment">// 输出: Method from BaseClass</span><br>        derivedClass.InterfaceMethod();   <span class="hljs-comment">// 输出: Method from IInterface1</span><br><br><br>        BaseClass derivedClass2 = <span class="hljs-keyword">new</span> DerivedClass();<br>        derivedClass2.BaseMethod();        <span class="hljs-comment">// 输出: Method from BaseClass</span><br>        <span class="hljs-comment">// derivedClass2.InterfaceMethod();   // 报错</span><br><br>        IInterface1 derivedClass3 = <span class="hljs-keyword">new</span> DerivedClass();<br>        <span class="hljs-comment">// derivedClass3.BaseMethod();        // 报错</span><br>        derivedClass3.InterfaceMethod();   <span class="hljs-comment">// 输出: Method from IInterface1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-成员类型"><a href="#3-成员类型" class="headerlink" title="3. 成员类型"></a>3. <strong>成员类型</strong></h4><ul><li><strong>抽象类</strong>：可以包含字段、属性、方法、构造函数、事件等成员，可以有访问修饰符（如 <code>public</code>、<code>protected</code>）。</li><li><strong>接口</strong>：不能包含字段或构造函数，成员默认是 <code>public</code>，且只能包含方法、属性、事件和索引器的声明（在 C# 8.0 之前）。从 C# 8.0 开始，接口可以包含静态方法、默认实现、属性和事件。(这个8.0之前和之后的属性和事件没区别，只是允许有默认实现了)</li></ul><h4 id="4-实现方式"><a href="#4-实现方式" class="headerlink" title="4. 实现方式"></a>4. <strong>实现方式</strong></h4><ul><li><strong>抽象类</strong>：子类继承抽象类并实现其抽象方法，可以使用 <code>override</code> 关键字来实现父类的抽象方法。</li><li><strong>接口</strong>：实现接口的类必须实现接口中定义的所有成员，不能使用 <code>override</code> 关键字。</li></ul><h4 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5. 构造函数"></a>5. <strong>构造函数</strong></h4><ul><li><strong>抽象类</strong>：可以有构造函数，用于初始化抽象类的字段。不能创建抽象类的实例。</li><li><strong>接口</strong>：不能有构造函数，不能创建接口的实例。</li></ul><h4 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. <strong>使用场景</strong></h4><ul><li><strong>抽象类</strong>：适用于描述具有相似属性和行为的类，并且需要在基类中提供一些默认实现时。</li><li><strong>接口</strong>：适用于定义一组不相关类的行为约定，或者需要多重继承时。</li></ul><h4 id="7-字段支持"><a href="#7-字段支持" class="headerlink" title="7. 字段支持"></a>7. <strong>字段支持</strong></h4><ul><li><strong>抽象类</strong>：可以定义字段。</li><li><strong>接口</strong>：不能定义字段，接口的成员只能是方法、属性、事件或索引器的签名。</li></ul><h4 id="8-访问修饰符"><a href="#8-访问修饰符" class="headerlink" title="8. 访问修饰符"></a>8. <strong>访问修饰符</strong></h4><ul><li><strong>抽象类</strong>：可以为成员指定不同的访问修饰符（<code>public</code>、<code>protected</code>、<code>private</code>）。</li><li><strong>接口</strong>：接口成员默认是 <code>public</code>，不能使用其他访问修饰符。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>; <span class="hljs-comment">// 抽象方法，没有实现</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>() <span class="hljs-comment">// 非抽象方法，有实现</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>() <span class="hljs-comment">// 必须实现抽象方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Woof!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMovable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>()</span>; <span class="hljs-comment">// 接口成员没有实现</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISpeakable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Robot</span> : <span class="hljs-title">IMovable</span>, <span class="hljs-title">ISpeakable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>() <span class="hljs-comment">// 实现接口方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Robot is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>() <span class="hljs-comment">// 实现接口方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Beep beep!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li>抽象类适合有默认行为的基类，而接口适合定义无关类的契约。</li><li>使用抽象类可以提供部分实现，而接口更注重行为规范的定义和多继承的支持。</li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>多态是面向对象编程的核心概念之一，它可以通过方法重载、方法重写、抽象类和接口等多种方式实现。编译时多态主要通过方法重载和运算符重载实现，而运行时多态通过继承、虚方法、抽象类和接口实现。它使得代码更加灵活、易于扩展和维护。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/zh-cn/">MS-Learning</a><br><a href="https://blog.csdn.net/zjzzjzzjzzjzzjz/article/details/8984057">解决方案、项目、程序集、命名空间之间的联系与区别</a> </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>知识点一_inline, const, static</title>
    <link href="/2024/10/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80_inline,%20const,%20static/"/>
    <url>/2024/10/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80_inline,%20const,%20static/</url>
    
    <content type="html"><![CDATA[<h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><p>C++将内联函数的代码组合到程序中，可以提高程序运行的速度。<br>语法：在函数声明和定义前加上关键字 inline。<br><code>通常的做法是将函数声明和定义都写在头文件（当然都写在源文件也行）。目的是为了避免函数重定义的问题</code></p><h3 id="正确的-inline-例子"><a href="#正确的-inline-例子" class="headerlink" title="正确的 inline 例子"></a>正确的 inline 例子</h3><ul><li><p>文件结构如图所示<br><a href="https://imgse.com/i/pAwMuMq"><img src="https://s21.ax1x.com/2024/10/24/pAwMuMq.png" alt="pAwMuMq.png"></a></p></li><li><p>代码示例<br>my_inline.h</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from version 1!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">sayHello</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>my_inline.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空的</span><br></code></pre></td></tr></table></figure><h3 id="错误的-inline-例子"><a href="#错误的-inline-例子" class="headerlink" title="错误的 inline 例子"></a>错误的 inline 例子</h3><blockquote><p>内联函数就是编译器将函数体（{…}之间的内容）在函数调用处展开，其实可以类比于#define 宏定义那种替换，来免去函数调用的开销。如果普通函数定义在头文件中，所有 include 该头文件的编译单元都可以正确找到函数定义。然而，如果内联函数 fun()定义在某个编译单元 A 中，那么其他编译单元中调用 fun()的地方将无法解析该符号，因为在编译单元 A 生成目标文件 A.obj 后，内联函数 fun()已经被替换掉，A.obj 中不再有 fun 这个符号，链接器自然无法解析。<br>上面的意思我的理解为是，下面的 sayHello 在 my_inline.cpp 中编译后，就不叫 sayHello()了，而 main 函数中仍然需要链接这个 sayHello()函数体，找不到，所以报错。具体不管，反正意思就是不能分开写</p></blockquote><p>代码示例<br>my_inline.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">sayHello</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>my_inline.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from version 1!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译期间报错<br><a href="https://imgse.com/i/pAwMKs0"><img src="https://s21.ax1x.com/2024/10/24/pAwMKs0.png" alt="pAwMKs0.png"></a></p><h3 id="正确的普通函数例子"><a href="#正确的普通函数例子" class="headerlink" title="正确的普通函数例子"></a>正确的普通函数例子</h3><ul><li>代码示例<br>my_inline.h</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">sayHello</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>my_inline.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from version 1!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>内联函数节省时间，但消耗内存。</li><li>如果函数过大，编译器可能不将其作为内联函数。</li><li>内联函数不能递归。我试了可以写递归，估计被优化成普通函数了</li></ul><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h3 id="1-修饰普通变量"><a href="#1-修饰普通变量" class="headerlink" title="1. 修饰普通变量"></a>1. <strong>修饰普通变量</strong></h3><ul><li>当<code>const</code>修饰一个变量时，该变量在声明时需要初始化，并且在之后的程序执行过程中，其值不能被改变。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxValue = <span class="hljs-number">100</span>;<br><span class="hljs-comment">// maxValue = 200; // 错误，无法修改const变量的值</span><br></code></pre></td></tr></table></figure><ul><li>使用<code>const</code>修饰变量可以增强代码的安全性，防止在无意中修改不应该更改的值。</li></ul><h3 id="2-修饰指针"><a href="#2-修饰指针" class="headerlink" title="2. 修饰指针"></a>2. <strong>修饰指针</strong></h3><p><code>const</code>在指针声明中可以有多种组合方式，分别用于不同的用途：</p><ul><li><strong>指向常量的指针</strong>（<code>const T*</code> 或 <code>T const*</code>）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* ptr = &amp;maxValue; <span class="hljs-comment">// 或 int const* ptr = &amp;maxValue;</span><br><span class="hljs-comment">// *ptr = 10; // 错误，无法通过ptr修改指向的值</span><br>ptr = &amp;anotherValue; <span class="hljs-comment">// 可以修改指针本身，指向不同地址</span><br></code></pre></td></tr></table></figure><ul><li><strong>常量指针</strong>（<code>T* const</code>）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;value;<br>*ptr = <span class="hljs-number">20</span>; <span class="hljs-comment">// 可以修改指向的值</span><br><span class="hljs-comment">// ptr = &amp;anotherValue; // 错误，不能修改指针本身</span><br></code></pre></td></tr></table></figure><ul><li><strong>指向常量的常量指针</strong>（<code>const T* const</code> 或 <code>T const* const</code>）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;maxValue;<br><span class="hljs-comment">// *ptr = 20; // 错误，无法修改指向的值</span><br><span class="hljs-comment">// ptr = &amp;anotherValue; // 错误，无法修改指针本身</span><br></code></pre></td></tr></table></figure><h3 id="3-修饰函数参数"><a href="#3-修饰函数参数" class="headerlink" title="3. 修饰函数参数"></a>3. <strong>修饰函数参数</strong></h3><ul><li>当函数参数是一个指针或引用时，<code>const</code>可以保证在函数内部不修改该参数的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; value)</span> </span>&#123;<br>    <span class="hljs-comment">// value = 10; // 错误，无法修改值</span><br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-修饰函数返回值"><a href="#4-修饰函数返回值" class="headerlink" title="4. 修饰函数返回值"></a>4. <strong>修饰函数返回值</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回一个可修改的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">getConstValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回一个不可修改的引用</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>MyClass obj;<br>obj.<span class="hljs-built_in">getValue</span>() = <span class="hljs-number">20</span>;       <span class="hljs-comment">// 允许，修改了value</span><br>cout &lt;&lt; obj.<span class="hljs-built_in">getValue</span>() &lt;&lt; endl;<br><span class="hljs-comment">//obj.getConstValue() = 30;  // 错误，返回的引用是const，无法修改</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-修饰类的成员函数"><a href="#5-修饰类的成员函数" class="headerlink" title="5. 修饰类的成员函数"></a>5. <strong>修饰类的成员函数</strong></h3><ul><li>当<code>const</code>修饰成员函数时，表示该函数不会修改类的成员变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">// value = 190; // 报错，不允许修改，const去掉可以修改</span><br><span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>MyClass obj;<br><span class="hljs-comment">// obj.getValue() = 20;       // 错误，const去掉可以修改，同时需要将上面的int getValue()函数改为int&amp; getValue()</span><br>cout &lt;&lt; obj.<span class="hljs-built_in">getValue</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如果引用的数据对象类型不匹配，当引用为-const-时，C-将创建临时变量，让引用指向临时变量"><a href="#6-如果引用的数据对象类型不匹配，当引用为-const-时，C-将创建临时变量，让引用指向临时变量" class="headerlink" title="6. 如果引用的数据对象类型不匹配，当引用为 const 时，C++将创建临时变量，让引用指向临时变量"></a>6. 如果引用的数据对象类型不匹配，当引用为 const 时，C++将创建临时变量，让引用指向临时变量</h3><ul><li>先看最下面的例子</li><li><code>int&amp;</code>定义一个变量 ra，赋值为 8。但是报错。这是因为引用(reference，表现就是&amp;表示引用)必须绑定到一个有效的变量（左值），而不能绑定到右值上。</li><li>在 C++中，引用是一种<strong>别名</strong>，它需要指向一个<strong>已存在的变量</strong>（左值），而不是一个<strong>临时的或字面值的常量</strong>（右值）。像<code>8</code>这样的字面值属于右值，没有实际的内存地址，因此不能为其创建引用【引用本质还就是指针】</li><li>正确的做法<br>引用应该绑定到一个变量，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>&amp; ra = x; <span class="hljs-comment">// 正确，引用ra绑定到变量x</span><br></code></pre></td></tr></table></figure>这样，<code>ra</code>成为<code>x</code>的别名，通过<code>ra</code>可以读取或修改<code>x</code>的值。</li><li>特例：<code>const</code>引用<br>如果需要引用一个字面值（右值），可以使用<code>const</code>引用，因为 C++允许<code>const</code>引用绑定到右值。这样做是安全的，因为<code>const</code>引用不能修改右值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = <span class="hljs-number">8</span>; <span class="hljs-comment">// 正确，const引用可以绑定到字面值</span><br></code></pre></td></tr></table></figure>在这种情况下，编译器会创建一个临时对象来存储字面值<code>8</code>，然后<code>const</code>引用<code>ra</code>绑定到这个临时对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// int&amp; ra = 8;// 报错</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = <span class="hljs-number">8</span>; <span class="hljs-comment">// 正常</span><br><span class="hljs-comment">// 等价于下面两行</span><br><span class="hljs-type">int</span> tmp = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = tmp;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>来，升级一下</li><li>原理和上面一样，不过变成了函数的参数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; no)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;no:&quot;</span> &lt;&lt; no &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; no)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;no:&quot;</span> &lt;&lt; no &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// func2(1); 报错</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下 word 中的三句话<br>什么时候将创建临时变量呢？</p><ul><li><ol><li>引用是 const<br>就是上面的例子，不再解释啦</li></ol></li><li><ol start="2"><li>数据对象的类型是正确的，但不是左值。<br>就是上面的例子，不再解释啦<br>解释一下什么叫正确的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// int&amp; ra = 8;// 报错</span><br><span class="hljs-comment">// const int&amp; ra = &quot;123&quot;; // const char* 类型不能够给const int&amp;赋值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = <span class="hljs-number">1</span>;<span class="hljs-comment">// 可以</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><ol start="3"><li>数据对象的类型不正确，但可以转换为正确的类型</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = <span class="hljs-string">&#x27;X&#x27;</span>; <span class="hljs-comment">// char可以转换为int类型，char可以理解为无符号的1字节整数</span><br>cout &lt;&lt; ra &lt;&lt; endl;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">int</span> temp = <span class="hljs-string">&#x27;X&#x27;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> rs = temp;<br>cout &lt;&lt; rs &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li>只解释下面两句话，其他的看 word 吧<ul><li>在静态成员函数中，只能访问静态成员，不能访问非静态成员</li><li>静态成员函数中没有 this 指针</li></ul></li></ul><blockquote><p>在 C++中，静态成员函数只能访问静态成员，不能直接访问非静态成员。这是因为静态成员函数属于类本身，而不是类的某个对象。静态成员函数没有 <code>this</code> 指针，因此无法访问特定对象的成员变量或调用非静态成员函数。</p></blockquote><h3 id="解释原因："><a href="#解释原因：" class="headerlink" title="解释原因："></a>解释原因：</h3><ol><li><strong>静态成员函数与类关联，而非对象关联</strong>：<ul><li>静态成员函数是属于类本身的，不需要创建类的对象就可以调用。因为它不属于任何对象实例，所以在静态成员函数中无法访问与对象实例相关的非静态成员。</li></ul></li><li><strong>没有 <code>this</code> 指针</strong>：<ul><li>非静态成员函数隐式地包含了一个指向调用对象的 <code>this</code> 指针，可以用来访问该对象的成员。而静态成员函数没有 <code>this</code> 指针，因为它与具体的对象实例无关，无法获取或操作非静态成员。</li></ul></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nonStaticMember; <span class="hljs-comment">// 非静态成员变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> staticMember; <span class="hljs-comment">// 静态成员变量</span><br><br><span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">nonStaticMember</span>(val) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticFunction</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// std::cout &lt;&lt; nonStaticMember; // 错误：无法访问非静态成员</span><br><span class="hljs-comment">// this只能用于非静态成员函数内部</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Static member: &quot;</span> &lt;&lt; staticMember &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nonStaticFunction</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 可以访问静态和非静态成员</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Non-static member: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;nonStaticMember &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Static member: &quot;</span> &lt;&lt; staticMember &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员变量</span><br><span class="hljs-type">int</span> MyClass::staticMember = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>MyClass::<span class="hljs-built_in">staticFunction</span>(); <span class="hljs-comment">// 调用静态成员函数</span><br>obj.<span class="hljs-built_in">nonStaticFunction</span>();   <span class="hljs-comment">// 调用非静态成员函数</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Static</span> <span class="hljs-keyword">member</span>: <span class="hljs-number">10</span><br>Non<span class="hljs-operator">-</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">member</span>: <span class="hljs-number">5</span><br><span class="hljs-keyword">Static</span> <span class="hljs-keyword">member</span>: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>在 <code>staticFunction</code> 中，尝试访问 <code>nonStaticMember</code> 会导致编译错误，因为它是非静态成员。</li><li>在 <code>nonStaticFunction</code> 中，可以同时访问静态成员和非静态成员，因为此函数属于某个对象实例，有 <code>this</code> 指针。<br>静态成员函数的主要用途是与类相关的操作，而非对象的具体状态</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="1-宏定义的位置"><a href="#1-宏定义的位置" class="headerlink" title="1. 宏定义的位置"></a>1. 宏定义的位置</h3><blockquote><p>宏定义建议写在头文件，源文件也没事，和普通函数一样</p></blockquote><h3 id="2-如何调用不同的重载，const-和非-const"><a href="#2-如何调用不同的重载，const-和非-const" class="headerlink" title="2. 如何调用不同的重载，const 和非 const"></a>2. 如何调用不同的重载，const 和非 const</h3><p>有下面的类，如何调用不同的重载呢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>        <span class="hljs-keyword">return</span> data[index]; <span class="hljs-comment">// 返回可修改的引用</span><br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> data[index]; <span class="hljs-comment">// 返回只读引用</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">10</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><p><strong>调用第一个版本（返回可修改引用）</strong>：</p><ul><li>当对象是<strong>非<code>const</code>类型</strong>时，将调用第一个<code>operator[]</code>，即返回一个可修改的引用。</li><li>这种情况下，调用者可以通过返回的引用来修改数组中的元素。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Array arr;<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// 非const对象，调用第一个operator[]，可以修改元素</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>调用第二个版本（返回只读引用）</strong>：</p><ul><li>当对象是**<code>const</code>类型**时，将调用第二个<code>operator[]</code>，即返回一个只读的引用。</li><li>在这种情况下，调用者只能读取数组中的元素，而不能对其进行修改。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Array arr;<br><span class="hljs-type">int</span> value = arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// const对象，调用第二个operator[]，只能读取元素</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">20</span>;        <span class="hljs-comment">// 错误，无法修改const对象的元素</span><br></code></pre></td></tr></table></figure><h4 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h4><ul><li><strong>编译器根据对象的类型（是否为<code>const</code>）自动选择合适的<code>operator[]</code>重载</strong>：<ul><li>如果对象是<code>const</code>，则只能调用<code>const</code>成员函数，因此会选择<code>const int&amp; operator[](size_t index) const</code>。</li><li>如果对象是非<code>const</code>，则会优先选择<code>int&amp; operator[](size_t index)</code>，因为它允许修改数据。</li></ul></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>下面是完整的示例代码来展示这两种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>        <span class="hljs-keyword">return</span> data[index]; <span class="hljs-comment">// 返回可修改的引用</span><br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> data[index]; <span class="hljs-comment">// 返回只读引用</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Array arr;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>; <span class="hljs-comment">// 非const对象，调用第一个operator[]，可以修改元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;arr[0] = &quot;</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 输出：arr[0] = 42</span><br><br>    <span class="hljs-type">const</span> Array constArr;<br>    <span class="hljs-type">int</span> value = constArr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// const对象，调用第二个operator[]，只能读取元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;constArr[0] = &quot;</span> &lt;&lt; value &lt;&lt; std::endl; <span class="hljs-comment">// 输出：constArr[0] = 0</span><br><br>    <span class="hljs-comment">// constArr[0] = 100; // 错误，无法修改const对象的元素</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>arr[0] = 42</code>修改了非<code>const</code>对象的元素，而<code>constArr[0]</code>只读取了<code>const</code>对象的元素。</p><h3 id="3-左值和右值"><a href="#3-左值和右值" class="headerlink" title="3. 左值和右值"></a>3. 左值和右值</h3><p>左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针。也就是可以出现在等于号左边，或者可以用&amp;取地址</p><p>非左值(右值)包括字面常量（用双引号包含的字符串除外）和包含多项的表达式。也就是不可以出现在等于号左边，或者不可以用&amp;取地址</p><p><code>字符串常量</code>（例如 <code>&quot;Hello, world!&quot;</code>）在 C++中是一个<strong>右值</strong>。它是存储在只读内存中的字符数组的地址，表示一个不可修改的字符序列。</p><h3 id="4-为什么字符串常量是右值？"><a href="#4-为什么字符串常量是右值？" class="headerlink" title="4. 为什么字符串常量是右值？"></a>4. 为什么<code>字符串常量</code>是右值？</h3><ul><li><strong>右值</strong>通常是指无法在程序中获取其内存地址的值或者在求值过程中生成的临时值，而字符串常量就是这样。它是一个临时的、不可修改的对象，其类型是 <code>const char[N]</code>，其中 <code>N</code> 是字符串的长度加上终止符 <code>\0</code>。</li><li>字符串常量本质上存储在只读内存区域，因此不能被修改，这是右值的典型特征。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>这里，字符串常量 <code>&quot;Hello, world!&quot;</code> 是一个右值，它的地址被赋值给了指针 <code>str</code>。虽然可以通过 <code>str</code> 访问字符串数据，但字符串本身是不可修改的。</p><h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h4><p>在某些情况下，字符串常量可以被视为<strong>左值</strong>，例如，当它被作为数组来使用时，字符串常量可以退化为指针（指向它的第一个字符），从而在一些表达式中可以像左值一样使用。但本质上，它仍然是只读的。</p><h5 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h5><p>字符串常量在某些表达式中可以表现得像左值，这是因为它会<strong>退化为指针</strong>，指向字符串的第一个字符。尽管如此，字符串常量本身仍然是不可修改的（即指针指向的内容是只读的）。下面是一些可以表现得像左值的例子：</p><h6 id="示例-1：作为数组的首地址使用"><a href="#示例-1：作为数组的首地址使用" class="headerlink" title="示例 1：作为数组的首地址使用"></a>示例 1：作为数组的首地址使用</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;Hello, world!&quot;</span>; <span class="hljs-comment">// &quot;Hello, world!&quot; 退化为指针，指向字符串的首地址</span><br>    std::cout &lt;&lt; p &lt;&lt; std::endl;     <span class="hljs-comment">// 输出整个字符串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，字符串常量 <code>&quot;Hello, world!&quot;</code> 退化为指针 <code>const char*</code>，其值是字符串的首地址，因此可以像左值那样使用 <code>p</code>，但字符串的内容是不可修改的。</p><h6 id="示例-2：作为数组元素的首地址"><a href="#示例-2：作为数组元素的首地址" class="headerlink" title="示例 2：作为数组元素的首地址"></a>示例 2：作为数组元素的首地址</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>    std::cout &lt;&lt; str[<span class="hljs-number">0</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 输出 &#x27;H&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>str[0]</code> 表达式访问的是字符串常量中第一个字符 <code>&#39;H&#39;</code>，字符串常量退化为指针后表现得像一个数组的首地址，可以使用数组下标访问字符。</p><h6 id="示例-3：传递给函数"><a href="#示例-3：传递给函数" class="headerlink" title="示例 3：传递给函数"></a>示例 3：传递给函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span> </span>&#123;<br>    std::cout &lt;&lt; s &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printString</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>); <span class="hljs-comment">// 字符串常量退化为指针传递给函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，字符串常量 <code>&quot;Hello, world!&quot;</code> 退化为指针并作为参数传递给函数 <code>printString</code>，在函数内表现得像一个指针的左值。</p><h3 id="5-利用-static-的特性，实现单例-多线程需要-C-11"><a href="#5-利用-static-的特性，实现单例-多线程需要-C-11" class="headerlink" title="5. 利用 static 的特性，实现单例(多线程需要 C++11)"></a>5. 利用 static 的特性，实现单例(多线程需要 C++11)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 由于静态局部变量只会在第一次进入其所在的函数时被初始化一次，后续的函数调用会直接返回已经初始化的 `instance`，这就是为什么 `static Singleton instance` 只会执行一次。这样可以确保类始终只有一个实例，从而实现单例模式。也是延迟加载，因为只会在第一次进入其所在的函数时被初始化一次</span><br>        <span class="hljs-type">static</span> Singleton instance; <span class="hljs-comment">// 静态局部变量，只会初始化一次</span><br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Singleton instance is working!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125; <span class="hljs-comment">// 构造函数私有化，防止外部创建实例</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 删除拷贝构造函数</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 删除赋值运算符</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Singleton&amp; s1 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>    Singleton&amp; s2 = Singleton::<span class="hljs-built_in">getInstance</span>();<br><br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">showMessage</span>();<br><br>    <span class="hljs-keyword">if</span> (&amp;s1 == &amp;s2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;s1 and s2 are the same instance.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;s1 and s2 are different instances.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-11-的改进：线程安全的静态局部变量"><a href="#C-11-的改进：线程安全的静态局部变量" class="headerlink" title="C++11 的改进：线程安全的静态局部变量"></a>C++11 的改进：线程安全的静态局部变量</h4><p>在 C++11 之前，静态局部变量的初始化在多线程环境下并不保证线程安全，这意味着在多个线程同时访问时，可能会导致静态变量被初始化多次。然而，C++11 对这一特性进行了改进，使得静态局部变量的初始化在多线程环境下变得线程安全，这样可以确保静态局部变量仅被初始化一次。<br>因此，在 C++11 及以上的版本中，<code>static</code>局部变量的单例模式实现无需额外的锁机制即可保证线程安全。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/tonywearme/article/details/7097910">inline 函数必须在头文件中定义吗？</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSharp知识整理(一)</title>
    <link href="/2024/10/19/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%80)/"/>
    <url>/2024/10/19/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h1><table><thead><tr><th>数据类型</th><th>占用字节数</th><th>数据范围</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>true 或 false</td><td>布尔类型，表示真或假</td><td>bool isActive &#x3D; true;</td></tr><tr><td>byte</td><td>1</td><td>0 到 255</td><td>无符号 8 位整数</td><td>byte age &#x3D; 25;</td></tr><tr><td>sbyte</td><td>1</td><td>-128 到 127</td><td>有符号 8 位整数</td><td>sbyte temperature &#x3D; -10;</td></tr><tr><td>char</td><td>2</td><td>‘\u0000’ (0) 到 ‘\uffff’ (65535)</td><td>Unicode 字符（16 位）</td><td>char letter &#x3D; ‘A’;</td></tr><tr><td>short</td><td>2</td><td>-32,768 到 32,767</td><td>有符号 16 位整数</td><td>short distance &#x3D; -32000;</td></tr><tr><td>ushort</td><td>2</td><td>0 到 65,535</td><td>无符号 16 位整数</td><td>ushort width &#x3D; 60000;</td></tr><tr><td>int</td><td>4</td><td>-2,147,483,648 到 2,147,483,647</td><td>有符号 32 位整数</td><td>int score &#x3D; 100;</td></tr><tr><td>uint</td><td>4</td><td>0 到 4,294,967,295</td><td>无符号 32 位整数</td><td>uint population &#x3D; 3000000000;</td></tr><tr><td>long</td><td>8</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td>有符号 64 位整数</td><td>long distanceToSun &#x3D; 150000000000L;</td></tr><tr><td>ulong</td><td>8</td><td>0 到 18,446,744,073,709,551,615</td><td>无符号 64 位整数</td><td>ulong starsInGalaxy &#x3D; 1000000000000UL;</td></tr><tr><td>float</td><td>4</td><td>±1.5 × 10^−45 到 ±3.4 × 10^38</td><td>单精度浮点数（32 位）</td><td>float price &#x3D; 19.99F;</td></tr><tr><td>double</td><td>8</td><td>±5.0 × 10^−324 到 ±1.7 × 10^308</td><td>双精度浮点数（64 位）</td><td>double pi &#x3D; 3.14159265359;</td></tr><tr><td>decimal</td><td>16</td><td>±1.0 × 10^−28 到 ±7.9228 × 10^28</td><td>高精度小数（128 位）</td><td>decimal balance &#x3D; 1000.75M;</td></tr><tr><td>string</td><td>不固定</td><td>根据字符数量变化</td><td>一组 Unicode 字符（文本）</td><td>string name &#x3D; “John Doe”;</td></tr></tbody></table><h2 id="char是2字节"><a href="#char是2字节" class="headerlink" title="char是2字节"></a>char是2字节</h2><p>在 C# 中，<code>char</code> 数据类型使用 2 字节（16 位）是因为它表示一个 Unicode 字符。Unicode 字符集比传统的 ASCII 字符集要大得多，能够表示全球范围内的各种字符和符号。为了支持这一广泛的字符集，C# 采用了 UTF-16 编码格式，其中每个 <code>char</code> 类型的字符占用 2 字节。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br><br>        <span class="hljs-built_in">char</span> c = <span class="hljs-string">&#x27;中&#x27;</span>;<br>        Console.WriteLine(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-原始字面量的使用"><a href="#2-原始字面量的使用" class="headerlink" title="2. 原始字面量的使用 @"></a>2. 原始字面量的使用 @</h1><p>在 C# 中，原始字面量的表示方式使用的是 <code>@</code> 符号，而不是 C++ 中的 <code>R</code>。这种方式主要用于字符串字面量，使得字符串中的反斜杠 <code>\</code> 和双引号 <code>&quot;</code> 不会被转义。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br><br>        <span class="hljs-built_in">string</span> path = <span class="hljs-string">@&quot;C:\Program Files\MyApp\config.json&quot;</span>;<br>        Console.WriteLine(path);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-枚举"><a href="#3-枚举" class="headerlink" title="3. 枚举"></a>3. 枚举</h1><ul><li>声明位置<ul><li>namespace语句块中(常用)</li><li>class语句块中，struct语句块中</li><li>但不能生命在声明语句块中（Main函数也不行）</li></ul></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-built_in">enum</span> E_number<br>    &#123;<br>        one = <span class="hljs-number">1</span>,<span class="hljs-comment">//默认从0开始</span><br>        two = <span class="hljs-number">2</span>,<br>        three,<br>        four,<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br><br>        E_number one = E_number.one;<br>        <span class="hljs-comment">// 枚举-&gt;int</span><br>        <span class="hljs-built_in">int</span> oneNum = (<span class="hljs-built_in">int</span>)one;<br>        Console.WriteLine(oneNum);<br>        <span class="hljs-comment">// int-&gt;枚举</span><br>        E_number two = (E_number)(<span class="hljs-number">2</span>);<br>        Console.WriteLine(two);<br>        <span class="hljs-comment">// 枚举-&gt;string</span><br>        <span class="hljs-built_in">string</span> oneStr = one.ToString();<br>        Console.WriteLine(oneStr);<br>        <span class="hljs-comment">// string-&gt;枚举</span><br>        one = (E_number)Enum.Parse(<span class="hljs-keyword">typeof</span>(E_number), oneStr);<br>        Console.WriteLine(one);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="4-string"><a href="#4-string" class="headerlink" title="4. string"></a>4. string</h1><p>在 C# 中，<code>string</code> 是一个用于表示文本的基本数据类型，属于引用类型。它是 .NET 中的 <code>System.String</code> 类的别名，并且是不可变（immutable）的。这意味着一旦创建了字符串对象，其内容就不能再修改。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>不可变性</strong>：每当对字符串进行操作（如拼接、替换、截取等），都会生成一个新的字符串对象，而不是修改原有的字符串。</li><li><strong>引用类型</strong>：<code>string</code> 是一个引用类型，虽然它在使用上像值类型一样简单。</li><li><strong>支持字符串插值和格式化</strong>：C# 支持字符串插值（<code>$</code>）和格式化操作。</li><li>**可以为 <code>null</code>**：<code>string</code> 可以被赋值为 <code>null</code>，表示没有任何文本。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 定义字符串</span><br>        <span class="hljs-built_in">string</span> greeting = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>        <br>        <span class="hljs-comment">// 字符串拼接</span><br>        <span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>        <span class="hljs-built_in">string</span> message = greeting + <span class="hljs-string">&quot; My name is &quot;</span> + name + <span class="hljs-string">&quot;.&quot;</span>;<br>        Console.WriteLine(message);<br>        <br>        <span class="hljs-comment">// 使用字符串插值</span><br>        <span class="hljs-built_in">string</span> interpolatedMessage = <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;greeting&#125;</span> My name is <span class="hljs-subst">&#123;name&#125;</span>.&quot;</span>;<br>        Console.WriteLine(interpolatedMessage);<br>        <br>        <span class="hljs-comment">// 字符串长度</span><br>        <span class="hljs-built_in">int</span> length = greeting.Length;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Length of greeting: <span class="hljs-subst">&#123;length&#125;</span>&quot;</span>);<br>        <br>        <span class="hljs-comment">// 字符串替换</span><br>        <span class="hljs-built_in">string</span> newGreeting = greeting.Replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;C#&quot;</span>);<br>        Console.WriteLine(newGreeting);<br>        <br>        <span class="hljs-comment">// 空字符串和 null</span><br>        <span class="hljs-built_in">string</span> emptyString = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">string</span>? nullString = <span class="hljs-literal">null</span>;<span class="hljs-comment">//表示可以是null的string类型</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Is empty string empty? <span class="hljs-subst">&#123;<span class="hljs-built_in">string</span>.IsNullOrEmpty(emptyString)&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Is null string null? <span class="hljs-subst">&#123;nullString == <span class="hljs-literal">null</span>&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><strong>定义字符串</strong>：可以使用双引号定义字符串，如 <code>&quot;Hello, World!&quot;</code>。</li><li><strong>拼接字符串</strong>：使用 <code>+</code> 运算符或字符串插值（<code>$</code>）来拼接字符串。</li><li><strong>字符串长度</strong>：通过 <code>Length</code> 属性可以获取字符串的字符数。</li><li><strong>字符串替换</strong>：使用 <code>Replace</code> 方法替换字符串中的某些内容。</li><li>**空字符串和 <code>null</code>**：C# 提供了 <code>string.IsNullOrEmpty</code> 方法来检查字符串是否为空或 <code>null</code>。</li></ul><h3 id="不可变性示例"><a href="#不可变性示例" class="headerlink" title="不可变性示例"></a>不可变性示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> original = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">string</span> modified = original.Replace(<span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>);<br><br>Console.WriteLine(original); <span class="hljs-comment">// 输出: Hello</span><br>Console.WriteLine(modified); <span class="hljs-comment">// 输出: Jello</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Replace</code> 方法不会修改 <code>original</code>，而是创建一个新的字符串 <code>modified</code>。</p><h1 id="5-StringBuilder"><a href="#5-StringBuilder" class="headerlink" title="5. StringBuilder"></a>5. StringBuilder</h1><p><code>StringBuilder</code> 是 C# 中用于处理可变字符串的类。与 <code>string</code> 不同，<code>StringBuilder</code> 允许在不创建新对象的情况下修改字符串内容，从而在频繁拼接、追加或插入操作时提高性能。</p><h3 id="为什么使用-StringBuilder"><a href="#为什么使用-StringBuilder" class="headerlink" title="为什么使用 StringBuilder"></a>为什么使用 <code>StringBuilder</code></h3><p>由于 <code>string</code> 是不可变的，每次修改字符串都会创建一个新的 <code>string</code> 对象。在大量拼接操作时，这种重复的创建和销毁会导致性能下降和内存浪费。而 <code>StringBuilder</code> 可以动态地修改字符串内容，不会创建多个字符串对象，能够显著提升性能。</p><ul><li>using System.Text;</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 StringBuilder 对象</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        <br>        <span class="hljs-comment">// 追加字符串</span><br>        sb.Append(<span class="hljs-string">&quot;, World!&quot;</span>);<br>        Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出: Hello, World!</span><br><br>        <span class="hljs-comment">// 插入字符串</span><br>        sb.Insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot; C#&quot;</span>);<br>        Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出: Hello C#, World!</span><br><br>        <span class="hljs-comment">// 替换字符串</span><br>        sb.Replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;StringBuilder&quot;</span>);<br>        Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出: Hello C#, StringBuilder!</span><br><br>        <span class="hljs-comment">// 删除字符串</span><br>        sb.Remove(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 删除从索引5开始的3个字符</span><br>        Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出: Hello, StringBuilder!</span><br><br>        <span class="hljs-comment">// 清空 StringBuilder</span><br>        sb.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;Length after clearing: <span class="hljs-subst">&#123;sb.Length&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Length after clearing: 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>StringBuilder</code> 是 C# 中用于高效构建和修改字符串的类，因为它能避免频繁创建新的字符串实例。以下是 <code>StringBuilder</code> 常用的方法：</p><h4 id="1-Append"><a href="#1-Append" class="headerlink" title="1. Append"></a>1. <strong>Append</strong></h4><ul><li>将指定的字符串或对象附加到当前 <code>StringBuilder</code> 实例的末尾。</li><li>支持多种重载，可以附加字符串、字符、对象、数字等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.Append(<span class="hljs-string">&quot;, World!&quot;</span>);<br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-AppendLine"><a href="#2-AppendLine" class="headerlink" title="2. AppendLine"></a>2. <strong>AppendLine</strong></h4><ul><li>在当前 <code>StringBuilder</code> 实例的末尾追加一个字符串，并添加一个换行符。</li><li>可用于追加多行文本。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.AppendLine(<span class="hljs-string">&quot;This is the first line.&quot;</span>);<br>sb.AppendLine(<span class="hljs-string">&quot;This is the second line.&quot;</span>);<br>Console.WriteLine(sb);<br><span class="hljs-comment">// 输出:</span><br><span class="hljs-comment">// Hello, World!</span><br><span class="hljs-comment">// This is the first line.</span><br><span class="hljs-comment">// This is the second line.</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-Insert"><a href="#3-Insert" class="headerlink" title="3. Insert"></a>3. <strong>Insert</strong></h4><ul><li>在指定位置插入一个字符串或字符。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.Insert(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;Beautiful &quot;</span>);<br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, Beautiful World!</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-Remove"><a href="#4-Remove" class="headerlink" title="4. Remove"></a>4. <strong>Remove</strong></h4><ul><li>从 <code>StringBuilder</code> 中删除指定索引处的字符，指定要删除的字符数。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.Remove(<span class="hljs-number">7</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 从索引 7 开始删除 10 个字符</span><br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="5-Replace"><a href="#5-Replace" class="headerlink" title="5. Replace"></a>5. <strong>Replace</strong></h4><ul><li>将 <code>StringBuilder</code> 实例中的所有匹配的字符串或字符替换为指定的值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<span class="hljs-comment">//也可以直接单个字符改</span><br>sb.Replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;C#&quot;</span>);<br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, C#!</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="6-Clear"><a href="#6-Clear" class="headerlink" title="6. Clear"></a>6. <strong>Clear</strong></h4><ul><li>清空 <code>StringBuilder</code> 实例中的所有内容。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.Clear();<br>Console.WriteLine(sb.Length); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="7-ToString"><a href="#7-ToString" class="headerlink" title="7. ToString"></a>7. <strong>ToString</strong></h4><ul><li>将 <code>StringBuilder</code> 实例转换为 <code>string</code>。</li><li>可以指定一个索引和长度，从而将特定范围内的字符转换为字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.Append(<span class="hljs-string">&quot;Hello, C#!&quot;</span>);<br><span class="hljs-built_in">string</span> str = sb.ToString();<br>Console.WriteLine(str); <span class="hljs-comment">// 输出: Hello, C#!</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="8-Length"><a href="#8-Length" class="headerlink" title="8. Length"></a>8. <strong>Length</strong></h4><ul><li>获取或设置 <code>StringBuilder</code> 实例中的字符数。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(sb.Length); <span class="hljs-comment">// 输出: 10</span><br>sb.Length = <span class="hljs-number">5</span>; <span class="hljs-comment">// 将长度设为 5，多余的字符将被截断</span><br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="9-Capacity"><a href="#9-Capacity" class="headerlink" title="9. Capacity"></a>9. <strong>Capacity</strong></h4><ul><li>获取或设置当前实例能够容纳的字符数。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> capacity = sb.Capacity;<br>sb.Capacity = <span class="hljs-number">50</span>; <span class="hljs-comment">// 设置容量</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="10-EnsureCapacity"><a href="#10-EnsureCapacity" class="headerlink" title="10. EnsureCapacity"></a>10. <strong>EnsureCapacity</strong></h4><ul><li>确保 <code>StringBuilder</code> 的容量至少为指定的值，如果小于该值，则会增加容量。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.EnsureCapacity(<span class="hljs-number">100</span>); <span class="hljs-comment">// 确保容量至少为 100</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="11-AppendFormat"><a href="#11-AppendFormat" class="headerlink" title="11. AppendFormat"></a>11. <strong>AppendFormat</strong></h4><ul><li>该方法用于将格式化字符串追加到 <code>StringBuilder</code> 实例的末尾，类似于 <code>string.Format</code> 的功能。</li><li>适用于需要将格式化的内容插入到字符串中的情况。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>sb.AppendFormat(<span class="hljs-string">&quot;Name: &#123;0&#125;, Age: &#123;1&#125;&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Name: Alice, Age: 25</span><br></code></pre></td></tr></table></figure></li><li><code>AppendFormat</code> 支持标准格式化和自定义格式化，因此非常适合在文本拼接时插入动态数据。</li></ul><h4 id="12-Equals"><a href="#12-Equals" class="headerlink" title="12. Equals"></a>12. <strong>Equals</strong></h4><ul><li><code>StringBuilder</code> 的 <code>Equals</code> 方法用于比较当前实例和另一个 <code>StringBuilder</code> 实例是否相等。</li><li>相等的条件是：两个实例的字符内容和长度必须相同。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">StringBuilder sb1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br>StringBuilder sb2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br>StringBuilder sb3 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;World&quot;</span>);<br><br>Console.WriteLine(sb1.Equals(sb2)); <span class="hljs-comment">// 输出: True，因为内容相同</span><br>Console.WriteLine(sb1.Equals(sb3)); <span class="hljs-comment">// 输出: False，因为内容不同</span><br></code></pre></td></tr></table></figure></li><li><code>Equals</code> 方法对 <code>StringBuilder</code> 实例进行引用相等性比较时，效果与默认的引用类型比较不同，<code>StringBuilder</code> 的 <code>Equals</code> 会检查字符内容。</li></ul><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><ul><li><strong><code>string</code> 拼接</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> result = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>    result += <span class="hljs-string">&quot;Hello &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>每次循环都会创建一个新的 <code>string</code>，性能较差。</li><li><strong>使用 <code>StringBuilder</code></strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>    sb.Append(<span class="hljs-string">&quot;Hello &quot;</span>);<br>&#125;<br><span class="hljs-built_in">string</span> result = sb.ToString();<br></code></pre></td></tr></table></figure>这种方式性能更好，因为 <code>StringBuilder</code> 可以动态地扩展内存，减少不必要的对象创建。</li></ul><h3 id="初始化容量"><a href="#初始化容量" class="headerlink" title="初始化容量"></a>初始化容量</h3><p>可以通过指定初始容量来提高性能：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">100</span>); <span class="hljs-comment">// 预分配100个字符的空间</span><br></code></pre></td></tr></table></figure><h1 id="6-ref和out的使用"><a href="#6-ref和out的使用" class="headerlink" title="6. ref和out的使用"></a>6. ref和out的使用</h1><p>在 C# 中，<code>ref</code> 和 <code>out</code> 是两种用于参数传递的关键字，它们允许方法通过引用传递参数，而不是通过值传递。虽然这两者的作用相似，但在使用和语义上有一些重要的区别。</p><h3 id="1-ref-关键字"><a href="#1-ref-关键字" class="headerlink" title="1. ref 关键字"></a>1. <code>ref</code> 关键字</h3><ul><li><strong>定义</strong>: <code>ref</code> 关键字用于将参数作为引用传递给方法。这样在方法内对参数的任何修改都会影响到原始变量。</li><li><strong>要求</strong>: 在调用方法之前，必须先为参数赋值。</li><li><strong>用法</strong>:<ul><li>在方法定义中需要加上 <code>ref</code>。</li><li>在调用方法时也需要加上 <code>ref</code>。</li></ul></li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ModifyValue</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> number</span>)</span><br>    &#123;<br>        number += <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改原始变量</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> myNumber = <span class="hljs-number">5</span>;<br>        ModifyValue(<span class="hljs-keyword">ref</span> myNumber);<br>        Console.WriteLine(myNumber); <span class="hljs-comment">// 输出 15</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-out-关键字"><a href="#2-out-关键字" class="headerlink" title="2. out 关键字"></a>2. <code>out</code> 关键字</h3><ul><li><strong>定义</strong>: <code>out</code> 关键字也用于将参数作为引用传递，但在方法内部，<code>out</code> 参数必须在方法返回之前进行赋值。</li><li><strong>要求</strong>: 在调用方法之前，无需为参数赋值（即使未赋值，也能正常工作）。但在方法内部，<code>out</code> 参数必须在方法返回之前进行赋值</li><li><strong>用法</strong>:<ul><li>在方法定义中需要加上 <code>out</code>。</li><li>在调用方法时也需要加上 <code>out</code>。</li></ul></li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetValues</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> number</span>)</span><br>    &#123;<br>        number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 必须在返回之前赋值</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> myNumber; <span class="hljs-comment">// 无需初始化</span><br>        GetValues(<span class="hljs-keyword">out</span> myNumber);<br>        Console.WriteLine(myNumber); <span class="hljs-comment">// 输出 42</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><table><thead><tr><th>特性</th><th><code>ref</code></th><th><code>out</code></th></tr></thead><tbody><tr><td>初始值要求</td><td>需要在调用前初始化</td><td>不需要初始化</td></tr><tr><td>赋值要求</td><td>可以在方法内修改，也可以不修改</td><td>必须在方法内赋值</td></tr><tr><td>语义</td><td>表示方法可能修改参数值</td><td>表示方法将输出一个值</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>使用 <code>ref</code> 可以在方法中修改传入的参数，并且调用方法之前需要初始化。</li><li>使用 <code>out</code> 适合用于返回多个值的场景，调用前不需要初始化，但必须在方法中赋值。</li><li>ref和out可以作为重载的条件，但是两个不能同时用  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br>cclass Program<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用带有 params 参数的方法</span><br>        <span class="hljs-built_in">float</span> f = <span class="hljs-number">1.0f</span>;<br>        CalcSum(<span class="hljs-keyword">ref</span> f, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CalcSum</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">float</span> f, <span class="hljs-built_in">int</span> a</span>)</span><br>    &#123;<br>        Console.WriteLine(f + a);<br>        <span class="hljs-comment">// 确保显示一位小数</span><br>        Console.WriteLine((f + a).ToString(<span class="hljs-string">&quot;F1&quot;</span>));<span class="hljs-comment">//3.0</span><br><br>    &#125;<br><br>    <span class="hljs-comment">// 两者ref和out不可以同时出现</span><br>    <span class="hljs-comment">//static void CalcSum(out float f, int a)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    Console.WriteLine(f + a);</span><br><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>C++中&amp;可以作为重载的标准，const int&amp; 指的是常数，int 和int&amp;都可以指变量，用的时候会报错</li></ul><p><code>ref</code> 和 <code>out</code> 是两个英文单词的缩写，具体含义如下：</p><ol><li>**<code>ref</code>**：是 <strong>“reference”</strong> 的缩写，表示引用。在参数传递中，<code>ref</code> 表示该参数是通过引用传递的，这意味着方法内部对参数的修改会影响到原始变量。</li><li>**<code>out</code>**：是 <strong>“output”</strong> 的缩写，表示输出。<code>out</code> 参数用于方法输出结果，表示该参数用于返回值，方法内部必须对其进行赋值。</li></ol><h1 id="7-params"><a href="#7-params" class="headerlink" title="7. params"></a>7. params</h1><p>在 C# 中，<code>params</code> 关键字用于允许方法接受可变数量的参数。这使得可以将多个参数作为数组传递给方法，而无需明确地创建一个数组。这在需要处理不确定数量的参数时非常方便。</p><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>以下是一个使用 <code>params</code> 的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用带有 params 参数的方法</span><br>        PrintNumbers(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        PrintNumbers(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        PrintNumbers(); <span class="hljs-comment">// 也可以传入零个参数</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] numbers</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Numbers received:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li>在这个示例中，<code>PrintNumbers</code> 方法可以接受任意数量的整数作为参数。</li><li><code>params</code> 参数必须是方法参数列表中的最后一个参数。</li><li>你可以在调用 <code>PrintNumbers</code> 方法时传入任意数量的整数，包括零个。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 <code>params</code> 时，方法可以接收一个数组作为参数，或者可以接收单个值而不需要手动创建数组。</li><li>方法内部会将所有传入的参数封装为一个数组。</li><li>可变参数可以作为重载的条件</li></ul><h1 id="8-C-的结构体和C-结构体区别"><a href="#8-C-的结构体和C-结构体区别" class="headerlink" title="8. C++的结构体和C#结构体区别"></a>8. C++的结构体和C#结构体区别</h1><p>C++ 中的结构体和 C# 中的结构体有许多相似之处，但也有一些重要的区别。以下是对这两种语言中结构体的比较，涵盖定义、特性、构造函数、继承、访问控制等方面。</p><h3 id="C-中的结构体"><a href="#C-中的结构体" class="headerlink" title="C++ 中的结构体"></a>C++ 中的结构体</h3><ol><li><strong>定义</strong>：<ul><li>使用 <code>struct</code> 关键字定义结构体，可以包含成员变量和成员函数。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Point(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>访问控制</strong>：<ul><li>默认情况下，C++ 中结构体的成员是 <code>public</code>，可以从外部访问。</li></ul></li><li><strong>构造函数和析构函数</strong>：<ul><li>C++ 结构体可以有构造函数和析构函数，用于初始化和清理资源。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xCoord, <span class="hljs-type">int</span> yCoord) : <span class="hljs-built_in">x</span>(xCoord), <span class="hljs-built_in">y</span>(yCoord) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">Point</span>() &#123;&#125; <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>继承和多态</strong>：<ul><li>C++ 中的结构体支持继承和多态，结构体可以继承自其他结构体或类。</li></ul></li><li><strong>存储方式</strong>：<ul><li>C++ 中的结构体通常在栈上分配，但也可以通过指针在堆上动态分配。</li></ul></li><li>其他<ul><li>变量的定义不能是自己的结构体</li></ul></li></ol><h3 id="C-中的结构体-1"><a href="#C-中的结构体-1" class="headerlink" title="C# 中的结构体"></a>C# 中的结构体</h3><ul><li>结构体可以继承接口interface</li></ul><ol><li><p><strong>定义</strong>：</p><ul><li>使用 <code>struct</code> 关键字定义结构体。结构体是值类型，不能继承自其他结构体或类，但可以实现接口。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> xCoord, <span class="hljs-built_in">int</span> yCoord</span>) <span class="hljs-comment">// 可以有参数化构造函数</span></span><br>    &#123;<br>        x = xCoord;<br>        y = yCoord;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Point(<span class="hljs-subst">&#123;x&#125;</span>, <span class="hljs-subst">&#123;y&#125;</span>)&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问控制</strong>：</p><ul><li>C# 中结构体的成员默认是 <code>private</code>，需要显式声明为 <code>public</code> 才能从外部访问。</li></ul></li><li><p><strong>构造函数</strong>：</p><ul><li>C# 结构体可以有参数化构造函数，但不能有无参数的构造函数。</li></ul></li><li><p><strong>继承</strong>：</p><ul><li>C# 中的结构体不能继承其他结构体或类，但可以实现接口。</li></ul></li><li><p><strong>存储方式</strong>：</p><ul><li>C# 中的结构体是值类型，存储在栈上，而引用类型（如类）则存储在堆上。</li></ul></li><li><p>其他</p><ul><li>变量的定义不能是自己的结构体</li><li>结构体中的变量不能直接初始化，否则初始化后，调用默认构造函数还是没用</li></ul></li></ol><h3 id="主要区别总结"><a href="#主要区别总结" class="headerlink" title="主要区别总结"></a>主要区别总结</h3><table><thead><tr><th>特性</th><th>C++ 结构体</th><th>C# 结构体</th></tr></thead><tbody><tr><td>定义</td><td>使用 <code>struct</code> 关键字</td><td>使用 <code>struct</code> 关键字</td></tr><tr><td>默认访问修饰符</td><td><code>public</code></td><td><code>private</code></td></tr><tr><td>构造函数</td><td>可以有参数化和无参数构造函数</td><td>可以有参数化构造函数，不能有无参数构造函数</td></tr><tr><td>继承</td><td>支持继承和多态</td><td>不支持继承，但可以实现接口</td></tr><tr><td>存储方式</td><td>通常在栈上，支持动态分配</td><td>是值类型，通常在栈上</td></tr><tr><td>成员函数</td><td>可以有成员函数</td><td>可以有方法</td></tr><tr><td>其他</td><td>变量的定义不能是自己的结构体，最后有一个分号</td><td>变量的定义不能是自己的结构体，结构体中的变量不能直接初始化</td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="C-结构体示例"><a href="#C-结构体示例" class="headerlink" title="C++ 结构体示例"></a>C++ 结构体示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xCoord, <span class="hljs-type">int</span> yCoord) : <span class="hljs-built_in">x</span>(xCoord), <span class="hljs-built_in">y</span>(yCoord) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Point(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// 创建结构体实例</span><br>    p.<span class="hljs-built_in">display</span>();   <span class="hljs-comment">// 输出: Point(1, 2)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-结构体示例-1"><a href="#C-结构体示例-1" class="headerlink" title="C# 结构体示例"></a>C# 结构体示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> xCoord, <span class="hljs-built_in">int</span> yCoord</span>) <span class="hljs-comment">// 构造函数</span></span><br>    &#123;<br>        x = xCoord;<br>        y = yCoord;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Point(<span class="hljs-subst">&#123;x&#125;</span>, <span class="hljs-subst">&#123;y&#125;</span>)&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Point p = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 创建结构体实例</span><br>        p.Display(); <span class="hljs-comment">// 输出: Point(1, 2)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-默认值"><a href="#9-默认值" class="headerlink" title="9. 默认值"></a>9. 默认值</h1><ul><li>数字类型<ul><li>默认值为0</li></ul></li><li>bool<ul><li>默认值为false</li></ul></li><li>引用类型<ul><li>默认值为null</li></ul></li><li>查看默认值<ul><li>default(数据类型)</li><li>default(int)</li></ul></li></ul><h1 id="10-class"><a href="#10-class" class="headerlink" title="10. class"></a>10. class</h1><p>在 C# 中，类（<code>class</code>）是用于创建对象的模板，它封装了数据和行为。类可以包含字段（成员变量）、属性、方法和事件。以下是对 C# 中类的基本概念、特性和示例的详细介绍：</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>定义</strong>：类是自定义数据类型的蓝图，可以包含状态（字段）和行为（方法）。</li><li><strong>实例化</strong>：通过类创建对象实例，每个实例都可以独立地持有状态。</li></ul><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>封装</strong>：<ul><li>类可以将数据和方法组合在一起，通过访问修饰符（如 <code>public</code>、<code>private</code>、<code>protected</code>）来控制对类成员的访问。</li></ul></li><li><strong>继承</strong>：<ul><li>类可以通过继承从其他类派生，复用代码并创建层次结构。</li><li>子类可以重写父类的方法，实现多态性。</li></ul></li><li><strong>多态性</strong>：<ul><li>通过虚方法（<code>virtual</code>）和重写方法（<code>override</code>），可以实现不同类对同一方法的不同实现。</li></ul></li><li><strong>抽象</strong>：<ul><li>抽象类（<code>abstract class</code>）可以定义一组方法，但不能直接实例化。</li></ul></li><li><strong>接口</strong>：<ul><li>接口（<code>interface</code>）定义了一组方法，但不实现它们。类可以实现多个接口。</li></ul></li></ol><ul><li>不能够将方法的声明和定义分离，必须放在一起。当然，抽象类和接口可以单独声明函数，然后继承的时候再重写</li></ul><h3 id="类的定义和使用示例"><a href="#类的定义和使用示例" class="headerlink" title="类的定义和使用示例"></a>类的定义和使用示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义一个简单的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><br>&#123;<br>    <span class="hljs-comment">// 字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> make;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> model;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> year;<br><br>    <span class="hljs-comment">// 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Make<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> make; &#125;<br>        <span class="hljs-keyword">set</span> &#123; make = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Model<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> model; &#125;<br>        <span class="hljs-keyword">set</span> &#123; model = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Year<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> year; &#125;<br>        <span class="hljs-keyword">set</span> &#123; year = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> make, <span class="hljs-built_in">string</span> model, <span class="hljs-built_in">int</span> year</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.make = make;<br>        <span class="hljs-keyword">this</span>.model = model;<br>        <span class="hljs-keyword">this</span>.year = year;<br>    &#125;<br><br>    <span class="hljs-comment">// 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayInfo</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Car Info: <span class="hljs-subst">&#123;Year&#125;</span> <span class="hljs-subst">&#123;Make&#125;</span> <span class="hljs-subst">&#123;Model&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 Car 类的实例</span><br>        Car myCar = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">&quot;Toyota&quot;</span>, <span class="hljs-string">&quot;Camry&quot;</span>, <span class="hljs-number">2021</span>);<br>        myCar.DisplayInfo(); <span class="hljs-comment">// 输出: Car Info: 2021 Toyota Camry</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重要概念说明"><a href="#重要概念说明" class="headerlink" title="重要概念说明"></a>重要概念说明</h3><ul><li><strong>构造函数</strong>：<ul><li>特殊方法，在创建对象时被调用。可以用于初始化对象的状态。</li></ul></li><li><strong>析构函数</strong>：<ul><li>用于清理资源，类在不再需要时被销毁时调用（在 C# 中，通常使用 <code>IDisposable</code> 接口和 <code>using</code> 语句进行资源管理）。</li></ul></li><li><strong>静态成员</strong>：<ul><li>使用 <code>static</code> 修饰符定义的成员属于类本身，而不是类的实例。</li></ul></li></ul><h3 id="静态成员示例"><a href="#静态成员示例" class="headerlink" title="静态成员示例"></a>静态成员示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathUtility</span><br>&#123;<br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用静态方法</span><br>        <span class="hljs-built_in">int</span> result = MathUtility.Add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Result: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Result: 15</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数，析构函数示例"><a href="#构造函数，析构函数示例" class="headerlink" title="构造函数，析构函数示例"></a>构造函数，析构函数示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-comment">// 字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-comment">// 无参构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>        name = <span class="hljs-string">&quot;Default Name&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;无参构造函数被调用: &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> newName</span>)</span><br>    &#123;<br>        name = newName;<br>        Console.WriteLine(<span class="hljs-string">&quot;带参数的构造函数被调用: &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~MyClass()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;析构函数被调用，清理资源...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用无参构造函数创建对象</span><br>        MyClass obj1 = <span class="hljs-keyword">new</span> MyClass();<br>        <br>        <span class="hljs-comment">// 使用带参数的构造函数创建对象</span><br>        MyClass obj2 = <span class="hljs-keyword">new</span> MyClass(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br>        <span class="hljs-comment">// 程序结束时，析构函数会自动被调用</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 无参构造函数被调用: Default Name </span><br><span class="hljs-comment">// 带参数的构造函数被调用: Hello, World! </span><br><span class="hljs-comment">// 析构函数被调用，清理资源... </span><br><span class="hljs-comment">// 析构函数被调用，清理资源...</span><br></code></pre></td></tr></table></figure><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><table><thead><tr><th>访问修饰符</th><th>访问范围</th></tr></thead><tbody><tr><td><code>public</code></td><td>可以在任何地方访问</td></tr><tr><td><code>private</code></td><td>只能在定义它的类内部访问(默认)</td></tr><tr><td><code>protected</code></td><td>可以在定义它的类及其派生类中访问</td></tr><tr><td><code>internal</code></td><td>可以在同一程序集内访问</td></tr><tr><td><code>protected internal</code></td><td>可以在同一程序集或派生类中访问</td></tr></tbody></table><h3 id="C-构造函数特殊写法，通过this重用构造函数代码"><a href="#C-构造函数特殊写法，通过this重用构造函数代码" class="headerlink" title="C#构造函数特殊写法，通过this重用构造函数代码"></a>C#构造函数特殊写法，通过this重用构造函数代码</h3><p>在 C# 中，可以通过使用 <code>this</code> 关键字在一个构造函数内部调用另一个构造函数，以重用构造函数的代码。这种写法被称为构造函数重载或构造函数链。它允许你在不同的构造函数中共享初始化逻辑，从而减少代码重复。</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>以下是一个示例，展示了如何通过 <code>this</code> 关键字在 C# 中重用构造函数代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 主构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 另一个构造函数，通过 this 关键字调用主构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">this</span>(<span class="hljs-params">name, <span class="hljs-number">0</span></span>) <span class="hljs-comment">// 默认年龄设为 0</span></span><br>    &#123;<br>        <span class="hljs-comment">// 这里可以添加其他初始化逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 另一个构造函数，通过 this 关键字调用主构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>() : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-string">&quot;Unknown&quot;</span>, <span class="hljs-number">0</span></span>) <span class="hljs-comment">// 默认姓名设为 &quot;Unknown&quot;，年龄为 0</span></span><br>    &#123;<br>        <span class="hljs-comment">// 这里可以添加其他初始化逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p1.Name&#125;</span>, <span class="hljs-subst">&#123;p1.Age&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Alice, 30</span><br><br>        Person p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p2.Name&#125;</span>, <span class="hljs-subst">&#123;p2.Age&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Bob, 0</span><br><br>        Person p3 = <span class="hljs-keyword">new</span> Person();<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p3.Name&#125;</span>, <span class="hljs-subst">&#123;p3.Age&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Unknown, 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><p><strong>主构造函数</strong>：<code>Person(string name, int age)</code> 是主要的构造函数，用于初始化 <code>Name</code> 和 <code>Age</code> 属性。</p></li><li><p><strong>重载构造函数</strong>：</p><ul><li><code>Person(string name)</code> 通过 <code>: this(name, 0)</code> 调用主构造函数，设定默认的 <code>Age</code> 为 <code>0</code>。</li><li><code>Person()</code> 通过 <code>: this(&quot;Unknown&quot;, 0)</code> 调用主构造函数，设定默认的 <code>Name</code> 为 <code>&quot;Unknown&quot;</code>，<code>Age</code> 为 <code>0</code>。</li></ul></li><li><p><strong>使用</strong>：在 <code>Main</code> 方法中创建了不同的 <code>Person</code> 对象，展示了如何使用不同的构造函数。</p></li></ol><h1 id="11-类与结构体区别（C-）"><a href="#11-类与结构体区别（C-）" class="headerlink" title="11. 类与结构体区别（C#）"></a>11. 类与结构体区别（C#）</h1><p>在 C# 中，类（<code>class</code>）和结构体（<code>struct</code>）都是用于封装数据和行为的复合数据类型，但它们在多个方面存在显著的区别。以下是它们的主要区别：</p><h3 id="主要区别-1"><a href="#主要区别-1" class="headerlink" title="主要区别"></a>主要区别</h3><table><thead><tr><th>特性</th><th>类 (Class)</th><th>结构体 (Struct)</th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>引用类型</td><td>值类型</td></tr><tr><td><strong>存储方式</strong></td><td>存储在堆上</td><td>存储在栈上</td></tr><tr><td><strong>继承</strong></td><td>支持继承</td><td>不支持继承</td></tr><tr><td><strong>构造函数</strong></td><td>可以有无参数和有参数构造函数</td><td>只能有参数构造函数，不能有无参数构造函数</td></tr><tr><td><strong>默认构造函数</strong></td><td>有默认构造函数</td><td>没有默认构造函数，编译器自动提供一个隐式的默认构造函数，该构造函数会将结构体的所有字段初始化为其类型的默认值（如 <code>0</code>、<code>false</code>、<code>null</code> 等）</td></tr><tr><td><strong>访问修饰符</strong></td><td>默认是 <code>private</code></td><td>默认是 <code>private</code></td></tr><tr><td><strong>接口实现</strong></td><td>可以实现接口</td><td>可以实现接口</td></tr><tr><td><strong>实例化</strong></td><td>通过 <code>new</code> 创建</td><td>通过 <code>new</code> 创建</td></tr><tr><td><strong>赋值行为</strong></td><td>赋值时复制引用</td><td>赋值时复制值</td></tr><tr><td><strong>内存管理</strong></td><td>垃圾回收（GC）管理</td><td>垃圾回收（GC）管理</td></tr><tr><td><strong>性能</strong></td><td>对于小对象，性能开销较大</td><td>对于小对象，性能开销较小</td></tr></tbody></table><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ol><li><strong>类型</strong>：<ul><li><strong>类</strong>是引用类型，意味着它们的实例在内存中是通过引用来访问的。</li><li><strong>结构体</strong>是值类型，意味着它们的实例直接包含数据。</li></ul></li><li><strong>存储方式</strong>：<ul><li>类的对象存储在堆上，结构体的实例通常存储在栈上（如果是局部变量），因此结构体在内存分配和释放上更加高效。</li></ul></li><li><strong>继承</strong>：<ul><li>类支持继承，可以派生出子类。结构体不支持继承，因此不能从其他结构体或类继承。</li></ul></li><li><strong>构造函数</strong>：<ul><li>类可以有无参数构造函数和有参数构造函数，而结构体只能有有参数构造函数，不能有无参数构造函数。结构体会自动提供一个默认构造函数，该构造函数将所有字段设置为其默认值。</li><li>类如果声明了有参构造函数，默认的无参构造函数会消失；结构体声明有参构造函数后，无参构造仍然存在</li></ul></li><li><strong>赋值行为</strong>：<ul><li>当类的对象被赋值给另一个变量时，实际上是复制了引用，而不是对象本身。因此，修改一个对象会影响所有引用它的变量。</li><li>结构体的赋值操作会复制整个数据，因此修改一个结构体不会影响另一个结构体的值。</li></ul></li><li>访问修饰符:<ul><li>结构体成员不可以用protected访问修饰符，类可以</li></ul></li><li>初始值<ul><li>结构体成员变量不能指定初始值，类可以</li><li>但结构体需要在构造函数中初始化所有成员变量，类随意</li></ul></li><li>析构函数<ul><li>结构体不能声明析构函数，类可以</li></ul></li><li>static修饰<ul><li>结构体不能够被静态static修饰（不存在静态结构体），类可以</li></ul></li><li>嵌套包含<ul><li>结构体不能在自己内部声明和自己一样的结构体变量，类可以</li></ul></li></ol><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="类的示例"><a href="#类的示例" class="headerlink" title="类的示例"></a>类的示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>) <span class="hljs-comment">// 构造函数</span></span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        Person person2 = person1; <span class="hljs-comment">// 复制引用</span><br>        person2.Name = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 修改 person2 的 Name</span><br><br>        Console.WriteLine(person1.Name); <span class="hljs-comment">// 输出: Bob</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结构体的示例"><a href="#结构体的示例" class="headerlink" title="结构体的示例"></a>结构体的示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>) <span class="hljs-comment">// 构造函数</span></span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        Person person2 = person1; <span class="hljs-comment">// 复制引用</span><br>        person2.Name = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 修改 person2 的 Name</span><br><br>        Console.WriteLine(person1.Name); <span class="hljs-comment">// 输出: Bob</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何选择结构体和类"><a href="#如何选择结构体和类" class="headerlink" title="如何选择结构体和类"></a>如何选择结构体和类</h3><ul><li>想要用继承和多态时，选择类，比如玩家，怪物等</li><li>对象是数据集合时，优先考虑结构体，比如位置，坐标等</li><li>从值类型和引用类型赋值时区别上考虑，如果经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着改变时，使用结构体，比如坐标，向量，旋转等</li></ul><h1 id="12-C-垃圾回收机制"><a href="#12-C-垃圾回收机制" class="headerlink" title="12. C#垃圾回收机制"></a>12. C#垃圾回收机制</h1><p>   C#的垃圾回收机制（Garbage Collection，简称GC）是一种自动内存管理机制，用于释放不再使用的对象和回收内存资源，从而避免手动管理内存。它在.NET框架中由CLR（Common Language Runtime）负责执行，确保应用程序在运行期间高效地使用内存。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li><strong>自动内存管理</strong>：不需要开发人员手动释放对象的内存，GC会自动检测并释放不再使用的对象。</li><li><strong>内存压缩</strong>：GC不仅会回收无用的对象，还会对内存进行压缩，把存活的对象移动到内存的开头，减少碎片。</li><li><strong>分代回收</strong>：采用分代（Generational）回收机制，根据对象的生命周期将内存划分为不同的代。</li></ol><h3 id="分代回收机制"><a href="#分代回收机制" class="headerlink" title="分代回收机制"></a>分代回收机制</h3><p>GC将托管堆中的对象分为三代：</p><ul><li><strong>第0代（Gen 0）</strong>：短期对象，如临时变量。GC最频繁地回收这部分对象。</li><li><strong>第1代（Gen 1）</strong>：较长时间的对象或从Gen 0晋升的对象。适用于中等寿命的对象。</li><li><strong>第2代（Gen 2）</strong>：长期对象或从Gen 1晋升的对象，如全局静态变量。GC最不频繁地回收这部分对象。</li></ul><p>在进行垃圾回收时，GC会优先处理Gen 0，如果清理不够再继续回收Gen 1和Gen 2。这样可以减少不必要的回收操作，提升性能。</p><h3 id="晋升的规则"><a href="#晋升的规则" class="headerlink" title="晋升的规则"></a>晋升的规则</h3><p>对象的晋升主要发生在垃圾回收的过程中，规则如下：</p><ol><li><p><strong>第0代（Gen 0）到第1代（Gen 1）的晋升</strong>：</p><ul><li>当第0代进行垃圾回收时，如果某个对象存活（即仍被引用），则这个对象将晋升到第1代。</li><li>如果一个对象在Gen 0的垃圾回收后依然存活，它通常被认为是一个较为持久的对象，因此被晋升到Gen 1，减少它在以后的垃圾回收中被频繁扫描的次数。</li></ul></li><li><p><strong>第1代（Gen 1）到第2代（Gen 2）的晋升</strong>：</p><ul><li>当第1代进行垃圾回收时，仍然存活的Gen 1对象将被晋升到Gen 2。</li><li>Gen 2被认为是“老年代”，也就是说，这些对象的生命周期较长，可能会存活很长时间。因此，GC会对Gen 2对象进行更少的回收操作，以减少垃圾回收的开销。</li></ul></li><li><p><strong>第2代（Gen 2）对象的处理</strong>：</p><ul><li>Gen 2的对象在垃圾回收后仍然存活，不会再晋升，因为Gen 2已经是最高代。</li></ul></li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><strong>标记阶段</strong>：GC扫描所有的对象，标记出哪些是存活的，哪些是不再使用的。</li><li><strong>回收阶段</strong>：对不再使用的对象进行回收，释放它们的内存。</li><li><strong>压缩阶段</strong>：把存活的对象移动到内存的开头，减少内存碎片，并更新对象引用。</li></ol><h3 id="什么时候进行垃圾回收？"><a href="#什么时候进行垃圾回收？" class="headerlink" title="什么时候进行垃圾回收？"></a>什么时候进行垃圾回收？</h3><ul><li>内存不足时。</li><li>分配了大量对象，Gen 0空间不足。</li><li>显式调用<code>GC.Collect()</code>方法（不建议频繁使用）。</li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建大量对象，强制触发GC</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1000</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 手动调用GC（不推荐）</span><br>        GC.Collect();<br>        Console.WriteLine(<span class="hljs-string">&quot;手动垃圾回收完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h3><ol><li><strong>GC.Collect()的使用</strong>：尽量避免手动调用GC，因为GC会自动管理内存。手动调用会导致性能下降。</li><li><strong>非托管资源的清理</strong>：对于非托管资源（如文件句柄、数据库连接等），需要实现<code>IDisposable</code>接口，并在<code>Dispose</code>方法中释放资源。</li><li><strong>Finalize和Dispose</strong>：实现<code>Dispose</code>方法或使用<code>using</code>语句来清理资源，避免依赖GC进行非托管资源的回收。</li></ol><h3 id="实现IDisposable接口来清理非托管资源的示例"><a href="#实现IDisposable接口来清理非托管资源的示例" class="headerlink" title="实现IDisposable接口来清理非托管资源的示例"></a>实现<code>IDisposable</code>接口来清理非托管资源的示例</h3><p>示例将展示如何使用<code>Dispose</code>方法和析构函数（<code>Finalize</code>）来处理非托管资源的清理</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceHolder</span> : <span class="hljs-title">IDisposable</span><br>&#123;<br>    <span class="hljs-comment">// 模拟的非托管资源</span><br>    <span class="hljs-keyword">private</span> IntPtr unmanagedResource;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> disposed = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 用来跟踪对象是否已被释放</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ResourceHolder</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 分配非托管资源</span><br>        unmanagedResource = <span class="hljs-keyword">new</span> IntPtr(<span class="hljs-number">123</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;ResourceHolder: 非托管资源已分配.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现IDisposable接口的Dispose方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>    &#123;<br>        Dispose(<span class="hljs-literal">true</span>);<br>        GC.SuppressFinalize(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 防止析构函数重复释放资源</span><br>    &#125;<br><br>    <span class="hljs-comment">// 受保护的Dispose方法，真正的资源释放逻辑在这里执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> disposing</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (!disposed)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (disposing)<br>            &#123;<br>                <span class="hljs-comment">// 释放托管资源（如果有）</span><br>                Console.WriteLine(<span class="hljs-string">&quot;ResourceHolder: 释放托管资源.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// 释放非托管资源</span><br>            <span class="hljs-keyword">if</span> (unmanagedResource != IntPtr.Zero)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;ResourceHolder: 释放非托管资源.&quot;</span>);<br>                unmanagedResource = IntPtr.Zero;<br>            &#125;<br><br>            disposed = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数（Finalize），在Dispose没有被调用时释放资源</span><br>    ~ResourceHolder()<br>    &#123;<br>        Dispose(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">using</span> (ResourceHolder resource = <span class="hljs-keyword">new</span> ResourceHolder())<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;使用ResourceHolder对象.&quot;</span>);<br>        &#125; <span class="hljs-comment">// using语句结束后自动调用Dispose方法</span><br><br>        Console.WriteLine(<span class="hljs-string">&quot;程序结束.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ResourceHolder: 非托管资源已分配.</span><br><span class="hljs-comment">// 使用ResourceHolder对象.</span><br><span class="hljs-comment">// ResourceHolder: 释放托管资源.</span><br><span class="hljs-comment">// ResourceHolder: 释放非托管资源.</span><br><span class="hljs-comment">// 程序结束.</span><br></code></pre></td></tr></table></figure><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><ol><li><strong><code>IDisposable</code>接口</strong>：<code>ResourceHolder</code>类实现了<code>IDisposable</code>接口，提供<code>Dispose</code>方法来释放资源。</li><li><strong><code>Dispose</code>方法</strong>：实现<code>Dispose</code>方法，用于释放托管和非托管资源。调用<code>GC.SuppressFinalize(this)</code>避免在垃圾回收时调用析构函数。</li><li><strong>析构函数（<code>Finalize</code>）</strong>：析构函数用于在<code>Dispose</code>方法未被显式调用时释放非托管资源。</li><li><strong><code>using</code>语句</strong>：<code>using</code>语句会在代码块结束时自动调用<code>Dispose</code>方法，确保资源被及时释放。</li></ol><h1 id="13-代码解析using-ResourceHolder-resource-new-ResourceHolder-Console-WriteLine-“使用ResourceHolder对象-”"><a href="#13-代码解析using-ResourceHolder-resource-new-ResourceHolder-Console-WriteLine-“使用ResourceHolder对象-”" class="headerlink" title="13. 代码解析using (ResourceHolder resource &#x3D; new ResourceHolder()) { Console.WriteLine(“使用ResourceHolder对象.”); }"></a>13. 代码解析using (ResourceHolder resource &#x3D; new ResourceHolder()) { Console.WriteLine(“使用ResourceHolder对象.”); }</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> (ResourceHolder resource = <span class="hljs-keyword">new</span> ResourceHolder())<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;使用ResourceHolder对象.&quot;</span>);<br>&#125; <span class="hljs-comment">// using语句结束后自动调用Dispose方法</span><br></code></pre></td></tr></table></figure><h4 id="1-ResourceHolder-类"><a href="#1-ResourceHolder-类" class="headerlink" title="1. ResourceHolder 类"></a>1. <code>ResourceHolder</code> 类</h4><p>假设 <code>ResourceHolder</code> 是一个实现了 <code>IDisposable</code> 接口的类。<code>IDisposable</code> 接口定义了一个 <code>Dispose</code> 方法，用于显式地释放非托管资源。实现 <code>IDisposable</code> 是处理非托管资源或需要手动释放的资源（如文件句柄、数据库连接等）的一种常见做法。</p><h4 id="2-using-语句的作用"><a href="#2-using-语句的作用" class="headerlink" title="2. using 语句的作用"></a>2. <code>using</code> 语句的作用</h4><ul><li><code>using</code> 语句可以自动管理实现了 <code>IDisposable</code> 接口的对象的生命周期。</li><li>在进入 <code>using</code> 块时，会创建一个 <code>ResourceHolder</code> 对象并将其分配给 <code>resource</code> 变量。</li><li>当 <code>using</code> 语句结束时，无论是否发生异常，都会自动调用 <code>resource.Dispose()</code> 方法，以确保资源被正确释放。</li></ul><h4 id="3-代码的执行流程"><a href="#3-代码的执行流程" class="headerlink" title="3. 代码的执行流程"></a>3. 代码的执行流程</h4><ul><li>创建 <code>ResourceHolder</code> 对象，并分配给 <code>resource</code>。</li><li>执行 <code>using</code> 块内的代码，输出 “使用ResourceHolder对象.”</li><li>当 <code>using</code> 块结束时，<code>Dispose</code> 方法被自动调用，释放资源。</li></ul><p>等价于下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ResourceHolder resource = <span class="hljs-keyword">new</span> ResourceHolder();<br><span class="hljs-keyword">try</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;使用ResourceHolder对象.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span><br>&#123;<br>    <span class="hljs-comment">// 确保 Dispose 方法在 using 块结束时被调用</span><br>    <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>)<br>    &#123;<br>        resource.Dispose();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IDisposable-接口和-Dispose-方法的作用"><a href="#IDisposable-接口和-Dispose-方法的作用" class="headerlink" title="IDisposable 接口和 Dispose 方法的作用"></a><code>IDisposable</code> 接口和 <code>Dispose</code> 方法的作用</h3><p><code>IDisposable</code> 接口定义了一个 <code>Dispose</code> 方法，用于释放资源。典型的实现方式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ResourceHolder</span> : <span class="hljs-title">IDisposable</span><br>&#123;<br>    <span class="hljs-comment">// 实现 Dispose 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 释放资源的代码，如关闭文件句柄或断开数据库连接</span><br>        Console.WriteLine(<span class="hljs-string">&quot;ResourceHolder 的 Dispose 方法被调用.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Dispose</code> 方法释放资源，而 <code>using</code> 语句确保在使用完对象后自动调用 <code>Dispose</code>。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><code>using</code> 语句用于自动管理实现了 <code>IDisposable</code> 接口的对象的生命周期，确保资源在使用后被正确释放。</li><li>在 <code>using</code> 块结束时，会自动调用 <code>Dispose</code> 方法，释放资源，避免内存泄漏或资源占用。</li></ul><h1 id="14-IntPtr解释"><a href="#14-IntPtr解释" class="headerlink" title="14. IntPtr解释"></a>14. IntPtr解释</h1><p><code>IntPtr</code> 是 C# 中表示指针或句柄的平台相关类型。它的主要用途是处理非托管资源、与操作系统交互时的指针或句柄、以及在托管代码和非托管代码之间传递指针。以下是 <code>IntPtr</code> 的几个关键点：</p><ol><li><p><strong>平台相关大小</strong>：<code>IntPtr</code> 的大小取决于当前运行的平台。在 32 位平台上，<code>IntPtr</code> 是 4 字节（32 位），而在 64 位平台上，它是 8 字节（64 位）。这使得它非常适合用来表示指针或句柄的大小。</p></li><li><p><strong>表示指针或句柄</strong>：<code>IntPtr</code> 通常用于存储指针（如内存地址）或操作系统资源的句柄（如窗口句柄、文件句柄）。它可以存储一个整数值，表示内存地址或某种非托管资源的标识符。</p></li><li><p><strong>用于非托管代码交互</strong>：在与非托管代码交互时（例如，通过 P&#x2F;Invoke 调用 Win32 API），<code>IntPtr</code> 常被用来表示指针参数。它可以与 C&#x2F;C++ 中的 <code>void*</code> 类型类似，适合用来传递内存地址。</p></li><li><p><strong>转换和比较</strong>：<code>IntPtr</code> 支持从整数类型（<code>int</code> 或 <code>long</code>）进行隐式或显式转换，也可以与整数进行比较或相互赋值。</p></li></ol><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><p>下面是一个使用 <code>IntPtr</code> 来表示一个非托管资源句柄的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 模拟一个非托管资源的句柄（假设资源的句柄值为123）</span><br>        IntPtr unmanagedResource = <span class="hljs-keyword">new</span> IntPtr(<span class="hljs-number">123</span>);<br><br>        <span class="hljs-comment">// 打印 IntPtr 的值</span><br>        Console.WriteLine(<span class="hljs-string">&quot;非托管资源句柄: &quot;</span> + unmanagedResource);<br><br>        <span class="hljs-comment">// 检查 IntPtr 是否为零</span><br>        <span class="hljs-keyword">if</span> (unmanagedResource != IntPtr.Zero)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;资源已分配.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;资源未分配.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 将 IntPtr 转换为 long 类型</span><br>        <span class="hljs-built_in">long</span> handleValue = unmanagedResource.ToInt64();<br>        Console.WriteLine(<span class="hljs-string">&quot;句柄的长整型值: &quot;</span> + handleValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">非托管资源句柄: 123</span><br>资源已分配.<br><span class="hljs-section">句柄的长整型值: 123</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>IntPtr</code> 被用来模拟表示一个非托管资源的句柄值，并可以进行检查和转换。通过使用 <code>IntPtr</code>，代码可以适应不同的平台（32 位或 64 位），确保指针或句柄的大小能够正确匹配。</p><h3 id="IntPtr-Zero的解释"><a href="#IntPtr-Zero的解释" class="headerlink" title="IntPtr.Zero的解释"></a>IntPtr.Zero的解释</h3><p><code>IntPtr.Zero</code> 是 .NET 中 <code>IntPtr</code> 结构的一个静态只读字段，表示一个空指针或指针值为零的情况。它的作用类似于 C&#x2F;C++ 中的 <code>NULL</code> 或 <code>nullptr</code>，用于表示一个未分配的指针或句柄。<code>IntPtr</code> 是一种平台相关的类型，用于存储指针或句柄的值。</p><h3 id="IntPtr-结构"><a href="#IntPtr-结构" class="headerlink" title="IntPtr 结构"></a><code>IntPtr</code> 结构</h3><ul><li><code>IntPtr</code> 是一个可以存储内存地址（指针）或操作系统句柄的平台无关类型。</li><li>它的大小是平台相关的：在 32 位系统上是 4 字节，在 64 位系统上是 8 字节。</li></ul><h3 id="IntPtr-Zero-的用途"><a href="#IntPtr-Zero-的用途" class="headerlink" title="IntPtr.Zero 的用途"></a><code>IntPtr.Zero</code> 的用途</h3><ul><li><code>IntPtr.Zero</code> 可以用来检查指针或句柄是否为空，例如在调用非托管代码或处理操作系统资源时，判断一个指针是否已经被分配。</li><li>作为默认值，表示未初始化的指针或句柄。</li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>在使用 P&#x2F;Invoke 或与非托管代码交互时，可以用 <code>IntPtr.Zero</code> 来表示空指针：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">IntPtr handle = IntPtr.Zero; <span class="hljs-comment">// 初始化为一个空指针</span><br><br><span class="hljs-comment">// 检查指针是否为空</span><br><span class="hljs-keyword">if</span> (handle == IntPtr.Zero)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Handle 未被初始化.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Handle 已初始化.&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>IntPtr.Zero</code> 用来判断 <code>handle</code> 是否为未分配的空指针。</p><h3 id="句柄的解释"><a href="#句柄的解释" class="headerlink" title="句柄的解释"></a>句柄的解释</h3><p>在计算机编程中，<strong>句柄</strong>（Handle）是用于引用系统资源的一个抽象标识符。它可以看作是一个间接指向资源的指针，通过句柄可以对资源进行操作，而不需要直接访问资源的内存地址。句柄通常用于操作系统提供的资源管理，例如文件、内存、窗口、线程、数据库连接等。</p><h3 id="句柄的作用"><a href="#句柄的作用" class="headerlink" title="句柄的作用"></a>句柄的作用</h3><ul><li><strong>间接引用</strong>：句柄为资源提供了一个间接的访问方式，使得程序不需要知道资源的具体内存地址，只需使用句柄进行操作。</li><li><strong>资源管理</strong>：操作系统或库使用句柄来管理资源的分配和释放。句柄由操作系统分配，当资源不再需要时，程序员可以释放句柄来回收资源。</li><li><strong>类型安全</strong>：通过句柄访问资源可以防止程序直接操作资源的内存地址，提高了系统的安全性和稳定性。</li></ul><h3 id="常见的句柄类型"><a href="#常见的句柄类型" class="headerlink" title="常见的句柄类型"></a>常见的句柄类型</h3><ul><li><strong>文件句柄</strong>：用于打开和操作文件，如读取或写入文件数据。</li><li><strong>窗口句柄（HWND）</strong>：在图形用户界面编程中，用于标识窗口。</li><li><strong>进程或线程句柄</strong>：用于操作系统中标识进程或线程的标识符。</li><li><strong>数据库句柄</strong>：用于连接到数据库或执行查询。</li></ul><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><p>在 C# 中，使用句柄来操作系统资源，如文件句柄：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> (FileStream fileStream = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;example.txt&quot;</span>, FileMode.Open))<br>&#123;<br>    <span class="hljs-comment">// fileStream.SafeFileHandle 是一个文件句柄</span><br>    <span class="hljs-keyword">if</span> (!fileStream.SafeFileHandle.IsInvalid)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;文件句柄有效.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>fileStream.SafeFileHandle</code> 是文件句柄，用于管理文件资源。句柄让操作系统跟踪文件的状态，并在使用完毕后释放资源。</p><h1 id="15-类中的属性"><a href="#15-类中的属性" class="headerlink" title="15. 类中的属性"></a>15. 类中的属性</h1><p>在 C# 中，类的属性是用于封装字段（成员变量）并提供对这些字段的访问的机制。属性使得对类内部数据的访问更加安全和灵活，可以控制对字段的读取和写入。</p><h3 id="属性的基本定义"><a href="#属性的基本定义" class="headerlink" title="属性的基本定义"></a>属性的基本定义</h3><p>属性通常由两个部分组成：</p><ol><li><strong>get 访问器</strong>：用于获取属性的值。get必须有返回值</li><li><strong>set 访问器</strong>：用于设置属性的值。set可以不设置赋值</li></ol><p>以下是一个简单的示例，展示了如何在类中定义属性：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// 私有字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br><br>    <span class="hljs-comment">// 公共属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;   <span class="hljs-comment">// 获取name字段的值</span><br>        <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;  <span class="hljs-comment">// 设置name字段的值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> age; &#125;    <span class="hljs-comment">// 获取age字段的值</span><br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-comment">// 可以添加逻辑，例如确保年龄不能为负数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;年龄不能为负数&quot;</span>);<br>            &#125;<br>            age = <span class="hljs-keyword">value</span>;         <span class="hljs-comment">// 设置age字段的值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用属性"><a href="#使用属性" class="headerlink" title="使用属性"></a>使用属性</h3><p>可以通过实例化类并直接访问属性来使用它们：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        person.Name = <span class="hljs-string">&quot;Alice&quot;</span>; <span class="hljs-comment">// 设置属性值</span><br>        person.Age = <span class="hljs-number">30</span>;       <span class="hljs-comment">// 设置属性值</span><br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;person.Name&#125;</span>, Age: <span class="hljs-subst">&#123;person.Age&#125;</span>&quot;</span>); <span class="hljs-comment">// 获取属性值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h3><p>C# 还提供了自动属性的功能，可以简化属性的定义，编译器会为这些属性创建一个私有的匿名字段。我们只需要使用Name或者Age获取或者修改值即可。下面是一个使用自动属性的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-comment">// 自动属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只读和只写属性"><a href="#只读和只写属性" class="headerlink" title="只读和只写属性"></a>只读和只写属性</h3><p>属性也可以设置为只读或只写：</p><ul><li><strong>只读属性</strong>：只有 <code>get</code> 访问器，没有 <code>set</code> 访问器，不能直接修改。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyPerson</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadOnlyPerson</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125; <span class="hljs-comment">// 只读属性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>只写属性</strong>：只有 <code>set</code> 访问器，没有 <code>get</code> 访问器，不能直接读取。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WriteOnlyPerson</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>    &#123;<br>        <span class="hljs-keyword">set</span> &#123; age = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 只写属性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="get，set的访问修饰符的规定"><a href="#get，set的访问修饰符的规定" class="headerlink" title="get，set的访问修饰符的规定"></a>get，set的访问修饰符的规定</h3><p>在 C# 中，属性的 <code>get</code> 和 <code>set</code> 访问修饰符可以单独定义，允许你对属性的读取和写入操作分别控制访问权限。这种灵活性使得你能够根据需要来限制对类成员的访问。</p><h3 id="访问修饰符-1"><a href="#访问修饰符-1" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>C# 提供了以下几种常用的访问修饰符：</p><ol><li><strong>public</strong>：可以被任何其他代码访问。</li><li><strong>private</strong>：只能在定义该成员的类内部访问。</li><li><strong>protected</strong>：只能在定义该成员的类及其子类中访问。</li><li><strong>internal</strong>：只能在同一程序集（项目）中访问。</li><li><strong>protected internal</strong>：可以在同一程序集或从其子类中访问。</li></ol><h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><p>以下是一些示例，展示了如何为 <code>get</code> 和 <code>set</code> 分别指定不同的访问修饰符：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name; <span class="hljs-comment">// 私有字段</span><br><br>    <span class="hljs-comment">// 只读属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;  <span class="hljs-comment">// 公开的get方法</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;  <span class="hljs-comment">// 仅在类内部可设置</span><br>    &#125;<br><br>    <span class="hljs-comment">// 只写属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> age; &#125; <span class="hljs-comment">// 仅在类内部可读取</span><br>        <span class="hljs-keyword">set</span> &#123; age = <span class="hljs-keyword">value</span>; &#125;  <span class="hljs-comment">// 公开的set方法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span><br>    &#123;<br>        Name = name;  <span class="hljs-comment">// 通过公共set方法设置</span><br>        Age = age;    <span class="hljs-comment">// 通过公共set方法设置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        <br>        <span class="hljs-comment">// 访问Name属性</span><br>        Console.WriteLine(person.Name); <span class="hljs-comment">// 公开的get方法可以访问</span><br><br>        <span class="hljs-comment">// 不能直接设置Name属性，因为set是私有的</span><br>        <span class="hljs-comment">// person.Name = &quot;Bob&quot;; // 这行代码会产生编译错误</span><br><br>        <span class="hljs-comment">// 访问和修改Age属性</span><br>        <span class="hljs-comment">// Console.WriteLine(person.Age); // 编译错误，因为get是私有的</span><br>        person.Age = <span class="hljs-number">35</span>; <span class="hljs-comment">// 公开的set方法可以访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问修饰符的规则"><a href="#访问修饰符的规则" class="headerlink" title="访问修饰符的规则"></a>访问修饰符的规则</h3><ul><li><p><strong>访问修饰符可以单独定义</strong>：<code>get</code> 和 <code>set</code> 访问修饰符可以不同。例如，<code>get</code> 可以是 <code>public</code>，而 <code>set</code> 可以是 <code>private</code>。</p></li><li><p><strong>当未指定访问修饰符时</strong>：如果没有明确指定 <code>get</code> 和 <code>set</code> 的访问修饰符，则默认情况下：</p><ul><li><code>get</code> 默认为 属性声明时的访问权限。</li><li><code>set</code> 默认为  属性声明时的访问权限（如果是自动属性，或类内部没有定义）。</li></ul></li><li><p><strong>构造函数和方法</strong>：构造函数和其他方法可以访问私有属性的 <code>set</code> 访问器，从而在对象创建时初始化值。</p></li><li><p>仅当属性或索引器同时具有 <code>set</code> 和 <code>get</code> 访问器时，才能使用访问器修饰符。 这种情况下，只允许对其中一个访问器使用修饰符。</p></li><li><p>访问器的可访问性级别必须比属性或索引器本身的可访问性级别具有更严格的限制。如果属性本身就是private，get和set均不可以使用访问修饰符。如果是public的属性，不可以对get或者set使用public，只能更严格</p></li></ul><h1 id="16-索引器"><a href="#16-索引器" class="headerlink" title="16. 索引器"></a>16. 索引器</h1><p>C#中的索引器是一种特殊的属性，允许对象像数组一样通过索引访问其元素。索引器使得类的实例能够使用“[]”语法来访问其内部数据，使得代码更加简洁和直观。索引器的定义通常涉及到 <code>this</code> 关键字，后面跟随一个或多个参数。</p><ul><li>索引器可以重载，中括号里面的参数不一样就可以</li><li>结构体也支持索引器</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>索引器的基本语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 内部数组</span><br><br>    <span class="hljs-comment">// 定义索引器</span><br>    <span class="hljs-comment">// 访问修饰符 返回值 this[参数类型 参数名, 参数类型 参数名, ...]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>    <span class="hljs-comment">// 内部书写和属性相同</span><br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[index]; &#125; <span class="hljs-comment">// 获取元素</span><br>        <span class="hljs-keyword">set</span> &#123; data[index] = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 设置元素</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass myClass = <span class="hljs-keyword">new</span> MyClass();<br>        <br>        <span class="hljs-comment">// 使用索引器设置元素</span><br>        myClass[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>        myClass[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br><br>        <span class="hljs-comment">// 使用索引器获取元素</span><br>        Console.WriteLine(myClass[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出: 10</span><br>        Console.WriteLine(myClass[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出: 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><p>以下是一个使用索引器的完整示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 内部数组</span><br><br>    <span class="hljs-comment">// 定义索引器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[index]; &#125; <span class="hljs-comment">// 获取元素</span><br>        <span class="hljs-keyword">set</span> &#123; data[index] = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 设置元素</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass myClass = <span class="hljs-keyword">new</span> MyClass();<br>        <br>        <span class="hljs-comment">// 使用索引器设置元素</span><br>        myClass[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>        myClass[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br><br>        <span class="hljs-comment">// 使用索引器获取元素</span><br>        Console.WriteLine(myClass[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出: 10</span><br>        Console.WriteLine(myClass[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出: 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>简洁性</strong>：索引器提供了一种方便的方式来访问对象的内部数据，语法类似于数组的访问方式。</li><li><strong>可以重载</strong>：索引器可以有多个重载形式，以支持不同类型和数量的参数。</li><li><strong>访问修饰符</strong>：索引器的 <code>get</code> 和 <code>set</code> 访问修饰符可以独立设置，可以是 <code>public</code>、<code>private</code>、<code>protected</code> 等。</li><li><strong>类型安全</strong>：索引器可以返回任何类型，而不仅限于基本数据类型。</li></ol><h3 id="访问修饰符示例"><a href="#访问修饰符示例" class="headerlink" title="访问修饰符示例"></a>访问修饰符示例</h3><p>下面的示例演示了如何设置不同的访问修饰符：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-comment">// 只允许内部访问的索引器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[index]; &#125;<br>        <span class="hljs-keyword">set</span> &#123; data[index] = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 公开的索引器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">string</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[<span class="hljs-built_in">int</span>.Parse(index)]; &#125;<br>        <span class="hljs-keyword">set</span> &#123; data[<span class="hljs-built_in">int</span>.Parse(index)] = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><strong>越界检查</strong>：在 <code>get</code> 和 <code>set</code> 访问器中可以添加越界检查，以避免访问数组外的元素。</li><li><strong>性能</strong>：索引器与普通方法的性能基本相同，但使用索引器的代码通常更加简洁。</li><li><strong>适用性</strong>：索引器适用于需要通过索引访问集合或数组的场景，例如自定义集合类。</li></ul><p>索引器为C#提供了一种直观且强大的方式来操作类的内部数据，使得编写清晰易读的代码变得更加容易。</p><h1 id="17-static的使用"><a href="#17-static的使用" class="headerlink" title="17. static的使用"></a>17. static的使用</h1><p>在C#中，<code>static</code>关键字用于定义静态成员或静态类。静态成员属于类本身，而不是属于类的某个实例，因此可以在不创建类对象的情况下访问。<code>static</code>的主要用途包括定义静态字段、方法、属性、构造函数、类和操作符等。以下是C#中<code>static</code>的具体使用情况：</p><h3 id="1-静态字段（Static-Fields）"><a href="#1-静态字段（Static-Fields）" class="headerlink" title="1. 静态字段（Static Fields）"></a>1. 静态字段（Static Fields）</h3><p>静态字段在类级别定义，对于该类的所有实例共享同一个字段。可以通过类名来访问静态字段，而不需要创建对象实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态字段</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>()</span><br>    &#123;<br>        Count++; <span class="hljs-comment">// 每创建一个实例，Count加1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(Counter.Count); <span class="hljs-comment">// 输出: 0</span><br><br>        Counter c1 = <span class="hljs-keyword">new</span> Counter();<br>        Counter c2 = <span class="hljs-keyword">new</span> Counter();<br><br>        Console.WriteLine(Counter.Count); <span class="hljs-comment">// 输出: 2，因为创建了两个实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-静态方法（Static-Methods）"><a href="#2-静态方法（Static-Methods）" class="headerlink" title="2. 静态方法（Static Methods）"></a>2. 静态方法（Static Methods）</h3><ul><li>静态方法可以在没有创建对象实例的情况下被调用。静态方法中不能访问非静态成员，因为它们没有绑定到任何实例。静态方法属于类本身，而不是某个具体的实例对象。我记得C++中，还有一个角度是static是在编译阶段确定，而非static是在运行阶段确定，所以无法访问未定义的变量，C#也可以这么理解。</li><li>在 C# 中，静态方法无法访问非静态成员的原因与 C++ 类似。静态方法属于类本身，而非某个具体的对象，因此它没有 <code>this</code> 引用，因为 <code>this</code> 只在实例方法中才有意义。非静态成员需要特定的对象实例来调用，而静态方法在类的上下文中调用，无法使用 <code>this</code> 来访问非静态成员。</li><li>而非静态方法，是可以使用静态成员的</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections.Specialized;<br><span class="hljs-keyword">using</span> System.Runtime.CompilerServices;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathUtils</span><br>&#123;<br>    <span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>) <span class="hljs-comment">// 静态方法</span></span><br>    &#123;<br>        <span class="hljs-comment">// this.c // 报错</span><br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-keyword">this</span>.c);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> result = MathUtils.Add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 调用静态方法</span><br>        Console.WriteLine(result); <span class="hljs-comment">// 输出: 8</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-静态属性（Static-Properties）"><a href="#3-静态属性（Static-Properties）" class="headerlink" title="3. 静态属性（Static Properties）"></a>3. 静态属性（Static Properties）</h3><p>静态属性用于封装静态字段的访问，类似于静态字段，但通过<code>get</code>和<code>set</code>访问器来访问或修改值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Settings</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _volume = <span class="hljs-number">5</span>; <span class="hljs-comment">// 静态字段</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Volume <span class="hljs-comment">// 静态属性</span><br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _volume; &#125;<br>        <span class="hljs-keyword">set</span> &#123; _volume = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(Settings.Volume); <span class="hljs-comment">// 输出: 5</span><br>        Settings.Volume = <span class="hljs-number">10</span>;<br>        Console.WriteLine(Settings.Volume); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-静态构造函数（Static-Constructors）"><a href="#4-静态构造函数（Static-Constructors）" class="headerlink" title="4. 静态构造函数（Static Constructors）"></a>4. 静态构造函数（Static Constructors）</h3><p>静态构造函数用于初始化静态字段或执行只需要运行一次的操作。它在类的第一次使用之前自动调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> LogFilePath;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Logger</span>() <span class="hljs-comment">// 静态构造函数，C++不允许静态构造函数，会报错</span></span><br>    &#123;<br>        LogFilePath = <span class="hljs-string">&quot;log.txt&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;静态构造函数被调用&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(Logger.LogFilePath); <span class="hljs-comment">// 输出: log.txt</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态构造函数的主要作用是在类的第一次使用之前自动执行一次，无论是否创建了该类的实例。它通常用于初始化静态字段或执行只需运行一次的操作。</p><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol><li><strong>只执行一次</strong>：静态构造函数只会在第一次访问类时自动调用一次，无论你创建了多少个实例。</li><li><strong>自动调用</strong>：你不需要显式调用静态构造函数。它会在类的静态成员或方法首次被访问时自动执行。</li><li><strong>实例化无关</strong>：即使没有实例化类，静态构造函数也会在类的静态成员被访问时调用。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>以下是一个 C# 中静态构造函数的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> StaticValue;<br><br>    <span class="hljs-comment">// 静态构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        StaticValue = <span class="hljs-number">42</span>; <span class="hljs-comment">// 初始化静态字段，但只会被调用一次</span><br>        Console.WriteLine(<span class="hljs-string">&quot;静态构造函数被调用。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;实例构造函数被调用。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;访问静态成员之前。&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;StaticValue: &quot;</span> + Example.StaticValue); <span class="hljs-comment">// 触发静态构造函数</span><br>        Console.WriteLine(<span class="hljs-string">&quot;StaticValue: &quot;</span> + Example.StaticValue); <span class="hljs-comment">// 触发静态构造函数</span><br>        Console.WriteLine(<span class="hljs-string">&quot;访问静态成员之后。&quot;</span>);<br><br>        Example obj = <span class="hljs-keyword">new</span> Example(); <span class="hljs-comment">// 触发实例构造函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">访问静态成员之前。<br>静态构造函数被调用。<br><span class="hljs-section">StaticValue: 42</span><br><span class="hljs-section">StaticValue: 42</span><br>访问静态成员之后。<br>实例构造函数被调用。<br></code></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>在这个例子中，静态构造函数在访问 <code>StaticValue</code> 之前自动调用，而实例构造函数在创建 <code>Example</code> 类的实例时调用。这表明静态构造函数确实在类的实例化之前运行，即使没有创建实例。</p><h3 id="5-静态类（Static-Classes）"><a href="#5-静态类（Static-Classes）" class="headerlink" title="5. 静态类（Static Classes）"></a>5. 静态类（Static Classes）</h3><p>静态类只能包含静态成员，不能创建实例，也就是不能被new。它适用于只包含工具方法的类（如数学运算类）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utility</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Utility.PrintMessage(<span class="hljs-string">&quot;Hello, world!&quot;</span>); <span class="hljs-comment">// 调用静态类的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-静态操作符（Static-Operators）"><a href="#6-静态操作符（Static-Operators）" class="headerlink" title="6. 静态操作符（Static Operators）"></a>6. 静态操作符（Static Operators）</h3><p>可以定义静态操作符重载，如重载<code>+</code>、<code>-</code>等操作符。它们也是类级别的操作，不需要类实例。其实和static没关系，就是需要这样用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector <span class="hljs-keyword">operator</span> +(Vector a, Vector b) <span class="hljs-comment">// 静态操作符</span><br>    <span class="hljs-comment">// 运算符重载必须是静态方法，因为运算符通常在两个操作数之间操作，不依赖于单个实例的状态</span><br>    <span class="hljs-comment">// 并且必须是public的</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector &#123; X = a.X + b.X, Y = a.Y + b.Y &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Vector v1 = <span class="hljs-keyword">new</span> Vector &#123; X = <span class="hljs-number">1</span>, Y = <span class="hljs-number">2</span> &#125;;<br>        Vector v2 = <span class="hljs-keyword">new</span> Vector &#123; X = <span class="hljs-number">3</span>, Y = <span class="hljs-number">4</span> &#125;;<br>        Vector result = v1 + v2;<br>        Console.WriteLine(<span class="hljs-string">$&quot;X: <span class="hljs-subst">&#123;result.X&#125;</span>, Y: <span class="hljs-subst">&#123;result.Y&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: X: 4, Y: 6</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-静态成员的特点"><a href="#7-静态成员的特点" class="headerlink" title="7. 静态成员的特点"></a>7. 静态成员的特点</h3><ul><li>静态成员只能通过类名访问，不能通过对象实例访问。</li><li>静态方法和字段在程序的整个生命周期中只会存在一个实例。</li><li>静态构造函数没有访问修饰符，不能有参数，只能定义一个。</li></ul><h1 id="18-C-中const和static的区别"><a href="#18-C-中const和static的区别" class="headerlink" title="18. C#中const和static的区别"></a>18. C#中const和static的区别</h1><p>在 C# 中，<code>const</code> 和 <code>static</code> 都与类的成员有关，但它们有不同的用途和特点。以下是它们的主要区别：</p><h3 id="1-定义与初始化"><a href="#1-定义与初始化" class="headerlink" title="1. 定义与初始化"></a>1. 定义与初始化</h3><ul><li><strong>const</strong>:<ul><li>用于定义常量，值在编译时确定，并且不可更改。（C++const也是编译期间确定）</li><li>必须在声明时初始化。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MaxValue = <span class="hljs-number">100</span>; <span class="hljs-comment">// 必须初始化</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>static</strong>:<ul><li>用于定义静态成员，属于类本身而不是类的实例。</li><li>可以在定义时或在类的静态构造函数中初始化。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Count; <span class="hljs-comment">// 可以在其他地方初始化</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        Count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态构造函数中初始化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-值的可变性"><a href="#2-值的可变性" class="headerlink" title="2. 值的可变性"></a>2. 值的可变性</h3><ul><li><strong>const</strong>:<ul><li>一旦定义，值无法改变。</li></ul></li><li><strong>static</strong>:<ul><li>可以在程序运行期间修改静态字段的值。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-comment">// 定义静态字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 增加计数的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Increment</span>()</span><br>    &#123;<br>        Count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 输出初始值</span><br>        Console.WriteLine(<span class="hljs-string">&quot;初始计数: &quot;</span> + Counter.Count); <span class="hljs-comment">// 输出：0</span><br><br>        <span class="hljs-comment">// 调用静态方法增加计数</span><br>        Counter.Increment();<br>        Counter.Increment();<br><br>        <span class="hljs-comment">// 输出修改后的值</span><br>        Console.WriteLine(<span class="hljs-string">&quot;修改后的计数: &quot;</span> + Counter.Count); <span class="hljs-comment">// 输出：2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h3><ul><li><p><strong>const</strong>:</p><ul><li>常量可以是类级别的（static）或实例级别的，通常与类一起使用时，会被视为静态成员。但是C++还是static方法不能访问const常量  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathConstants</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个静态常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> Pi = <span class="hljs-number">3.14159</span>;<br><br>    <span class="hljs-comment">// 定义一个实例常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> E = <span class="hljs-number">2.71828</span>;<br><br>    <span class="hljs-comment">// 静态方法访问静态常量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayConstants</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Pi: &quot;</span> + Pi); <span class="hljs-comment">// 访问静态常量</span><br>    &#125;<br><br>    <span class="hljs-comment">// 实例方法访问实例常量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayE</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;E: &quot;</span> + E); <span class="hljs-comment">// 访问实例常量</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用静态方法</span><br>        MathConstants.DisplayConstants();<br>        Console.WriteLine(<span class="hljs-string">&quot;MathConstants.E: &quot;</span> + MathConstants.E); <span class="hljs-comment">// 访问实例常量</span><br><br><br>        <span class="hljs-comment">// 创建实例并调用实例方法</span><br>        MathConstants mathConstants = <span class="hljs-keyword">new</span> MathConstants();<br>        mathConstants.DisplayE();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathConstants</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 定义静态常量</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi;<br><span class="hljs-comment">// 定义实例常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> E;<br><br><span class="hljs-comment">// 构造函数初始化实例常量</span><br><span class="hljs-built_in">MathConstants</span>() : <span class="hljs-built_in">E</span>(<span class="hljs-number">2.71828</span>) &#123;&#125;<br><br><span class="hljs-comment">// 静态方法访问静态常量</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DisplayConstants</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Pi: &quot;</span> &lt;&lt; Pi &lt;&lt; std::endl; <span class="hljs-comment">// 访问静态常量</span><br><span class="hljs-comment">// std::cout &lt;&lt; &quot;E: &quot; &lt;&lt; E &lt;&lt; std::endl; // 报错，无法访问实例常量</span><br>&#125;<br><br><span class="hljs-comment">// 实例方法访问实例常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayE</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;E: &quot;</span> &lt;&lt; E &lt;&lt; std::endl; <span class="hljs-comment">// 访问实例常量</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 静态常量的定义</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> MathConstants::Pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 调用静态方法</span><br>MathConstants::<span class="hljs-built_in">DisplayConstants</span>();<br><br><span class="hljs-comment">// 创建实例并调用实例方法</span><br>MathConstants mathConstants;<br>mathConstants.<span class="hljs-built_in">DisplayE</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>static</strong>:</p><ul><li>仅与类相关，所有实例共享同一份数据。</li></ul></li></ul><h3 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h3><ul><li><strong>const</strong>:<ul><li>编译时常量，直接替换为其值，因此在性能上通常更高效。</li></ul></li><li><strong>static</strong>:<ul><li>访问静态成员需要查找类的静态表，相比之下可能稍慢。</li></ul></li></ul><h3 id="5-书写顺序"><a href="#5-书写顺序" class="headerlink" title="5. 书写顺序"></a>5. 书写顺序</h3><ul><li><strong>const</strong>:<ul><li>public const</li></ul></li><li><strong>static</strong>:<ul><li>public static</li><li>static public</li></ul></li></ul><h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> Pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> InstanceCount; <span class="hljs-comment">// 静态字段</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        InstanceCount++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(Example.Pi); <span class="hljs-comment">// 输出：3.14</span><br>        Console.WriteLine(Example.InstanceCount); <span class="hljs-comment">// 输出：0</span><br><br>        Example ex1 = <span class="hljs-keyword">new</span> Example();<br>        Example ex2 = <span class="hljs-keyword">new</span> Example();<br>        <br>        Console.WriteLine(Example.InstanceCount); <span class="hljs-comment">// 输出：2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>const</strong> 用于定义不可更改的常量。</li><li><strong>static</strong> 用于定义与类相关的共享成员，值可以在运行时改变。</li></ul><h1 id="19-拓展方法"><a href="#19-拓展方法" class="headerlink" title="19. 拓展方法"></a>19. 拓展方法</h1><blockquote><p>扩展方法（Extension Method）是C#中的一种功能，允许为现有类型（<code>非静态</code>）添加新的方法，而无需修改类型本身的源代码或创建子类。扩展方法是通过定义<code>一个静态类</code>，其中包含<code>静态方法</code>，并在方法的第一个参数前加上 <code>this</code> 关键字来实现的。这个第一个参数指定了要扩展的类型。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringExtensions</span><br>&#123;<br>    <span class="hljs-comment">// 扩展方法: 为string类型添加一个ToWordCount方法，统计单词数量</span><br>    <span class="hljs-comment">// 访问修饰符 static 返回值 函数名(this 扩展类名 参数名, 参数类型 参数名, 参数类型 参数名...)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ToWordCount</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> str</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.IsNullOrEmpty(str))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span> &#125;, StringSplitOptions.RemoveEmptyEntries).Length;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;Hello, how many words are in this sentence?&quot;</span>;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        <span class="hljs-built_in">int</span> wordCount = sentence.ToWordCount();<br>        Console.WriteLine(<span class="hljs-string">$&quot;The sentence has <span class="hljs-subst">&#123;wordCount&#125;</span> words.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>ToWordCount</code> 方法被定义为 <code>string</code> 类型的扩展方法，能够像调用实例方法一样使用扩展方法。扩展方法通常用于增强第三方库或框架中的类，或者在不修改原始类型的情况下添加辅助功能。</p><p>扩展方法可以为以下类型添加新方法：</p><ol><li><strong>普通类和结构体</strong>：可以为任何已存在的类或结构体（包括 .NET 框架中的类型或自定义的类型）添加扩展方法。例如，为 <code>string</code>、<code>int</code>、<code>List&lt;T&gt;</code> 等常见类型添加扩展方法。类只可以是非静态。</li><li><strong>接口</strong>：可以为接口添加扩展方法，这样接口的所有实现类都可以使用该扩展方法。例如，为 <code>IEnumerable&lt;T&gt;</code> 添加扩展方法来简化 LINQ 查询。</li><li><strong>泛型类型</strong>：可以为泛型类型添加扩展方法。例如，为 <code>List&lt;T&gt;</code> 或 <code>Dictionary&lt;TKey, TValue&gt;</code> 添加方法来处理泛型数据。</li><li><strong>枚举</strong>：可以为枚举类型添加扩展方法，以提供一些便捷的功能，如转换或格式化枚举值。<br><strong>注意</strong>：</li></ol><ul><li>扩展方法必须定义在一个静态类中。</li><li>扩展方法不能为静态类添加方法</li><li>扩展方法本质上是静态方法，但可以像实例方法一样调用。</li><li>在C#中，如果扩展方法的名字和已有的方法名字一样，原有方法会优先被调用。这是因为扩展方法的解析规则优先级较低，只有当编译器找不到匹配的实例方法时，才会尝试使用扩展方法。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ExtensionMethodDemo</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个普通类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是原始类中的方法&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个扩展类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClassExtensions</span><br>    &#123;<br>        <span class="hljs-comment">// 定义一个扩展方法，与原有方法同名</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> MyClass myClass</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是扩展方法&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            MyClass myClass = <span class="hljs-keyword">new</span> MyClass();<br>            myClass.PrintMessage(); <span class="hljs-comment">// 调用原有方法</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，<code>MyClass</code>的实例方法<code>PrintMessage</code>优先于扩展方法，因此会输出“这是原始类中的方法”。如果要调用扩展方法，就需要给扩展方法取一个不同的名字，或者避免在类中定义相同名称的方法。<ul><li>解决方法<ol><li><strong>使用不同的名字</strong>：避免扩展方法与原有方法同名。</li><li><strong>显式调用扩展方法</strong>：如果确实需要调用扩展方法，可以通过反射或直接使用静态方法调用的方式：  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MyClassExtensions.PrintMessage(myClass);<br></code></pre></td></tr></table></figure>  这样可以绕过实例方法的优先级限制，直接调用扩展方法。</li></ol></li></ul></li></ul><h3 id="扩展方法的第一个参数干嘛的，后面的是参数，那第一个干嘛的"><a href="#扩展方法的第一个参数干嘛的，后面的是参数，那第一个干嘛的" class="headerlink" title="扩展方法的第一个参数干嘛的，后面的是参数，那第一个干嘛的"></a>扩展方法的第一个参数干嘛的，后面的是参数，那第一个干嘛的</h3><p>扩展方法的</p><p>第一个参数通过<code>this</code>关键字来指定要扩展的类型。它定义了该扩展方法应用于哪个类型的对象，<code>this</code>后面跟着类型名称，表示这个方法可以像该类型的实例方法一样被调用。</p><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><ul><li>第一个参数使用<code>this</code>关键字来表示该方法是一个扩展方法，<code>this</code>后面的类型是被扩展的类型。</li><li>扩展方法的第一个参数（<code>this</code>后面的参数）是指向被扩展对象的引用。在调用扩展方法时，这个对象将作为参数传递给方法。</li><li>后面的参数是该方法的其他输入参数，类似于普通方法的参数。</li></ul><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringExtensions</span><br>&#123;<br>    <span class="hljs-comment">// 扩展方法，第一个参数是要扩展的类型（string），表示这个方法可以用于string类型的对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">WordCount</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> str</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展的字符串对象</span><br>        <span class="hljs-keyword">return</span> str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span> &#125;, StringSplitOptions.RemoveEmptyEntries).Length;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用扩展方法</span><br><span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;Hello world, this is an extension method example.&quot;</span>;<br><span class="hljs-built_in">int</span> count = sentence.WordCount();  <span class="hljs-comment">// 相当于 StringExtensions.WordCount(sentence)</span><br>Console.WriteLine(count);  <span class="hljs-comment">// 输出: 7</span><br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li><code>WordCount</code>方法的第一个参数是<code>this string str</code>，表示这个方法是用来扩展<code>string</code>类型的对象的。</li><li>当<code>sentence.WordCount()</code>被调用时，<code>sentence</code>对象被传递给<code>str</code>参数，相当于执行了<code>StringExtensions.WordCount(sentence)</code>。</li></ol><p>因此，扩展方法的第一个参数<code>this</code>后面的类型就是要扩展的类型，指定了这个方法适用于哪些对象，并使其能够像实例方法一样调用。而str则表示什么样的对象调用了这个方法，可以对调用的对象进行操作</p><h3 id="为普通类和结构体、接口、泛型类型、枚举类型编写扩展方法的示例"><a href="#为普通类和结构体、接口、泛型类型、枚举类型编写扩展方法的示例" class="headerlink" title="为普通类和结构体、接口、泛型类型、枚举类型编写扩展方法的示例"></a>为普通类和结构体、接口、泛型类型、枚举类型编写扩展方法的示例</h3><h3 id="1-普通类和结构体的扩展方法"><a href="#1-普通类和结构体的扩展方法" class="headerlink" title="1. 普通类和结构体的扩展方法"></a>1. 普通类和结构体的扩展方法</h3><h4 id="扩展普通类"><a href="#扩展普通类" class="headerlink" title="扩展普通类"></a>扩展普通类</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 普通类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 扩展方法类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PersonExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Greet</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Person person</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Hello, <span class="hljs-subst">&#123;person.Name&#125;</span>!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        person.Greet();  <span class="hljs-comment">// 输出: Hello, Alice!</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="扩展结构体"><a href="#扩展结构体" class="headerlink" title="扩展结构体"></a>扩展结构体</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 结构体</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 扩展方法类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PointExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">DistanceToOrigin</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Point point</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.Sqrt(point.X * point.X + point.Y * point.Y);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">new</span> Point &#123; X = <span class="hljs-number">3</span>, Y = <span class="hljs-number">4</span> &#125;;<br>        Console.WriteLine(point.DistanceToOrigin());  <span class="hljs-comment">// 输出: 5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-接口的扩展方法"><a href="#2-接口的扩展方法" class="headerlink" title="2. 接口的扩展方法"></a>2. 接口的扩展方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span>;<br>&#125;<br><br><span class="hljs-comment">// 扩展方法类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShapeExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintArea</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IShape shape</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;The area is <span class="hljs-subst">&#123;shape.GetArea()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类，这里扩展方法可以不用重写了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        IShape circle = <span class="hljs-keyword">new</span> Circle &#123; Radius = <span class="hljs-number">5</span> &#125;;<br>        circle.PrintArea();  <span class="hljs-comment">// 输出: The area is 78.5398163397448</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-泛型类型的扩展方法"><a href="#3-泛型类型的扩展方法" class="headerlink" title="3. 泛型类型的扩展方法"></a>3. 泛型类型的扩展方法</h3><ul><li>感觉这个泛型很好用了啊<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 泛型类型的扩展方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GenericExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintTypeName</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> T obj</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;The type of the object is <span class="hljs-subst">&#123;<span class="hljs-keyword">typeof</span>(T).Name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        <span class="hljs-built_in">int</span> number = <span class="hljs-number">42</span>;<br>        number.PrintTypeName();  <span class="hljs-comment">// 输出: The type of the object is Int32</span><br><br>        <span class="hljs-built_in">string</span> text = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        text.PrintTypeName();    <span class="hljs-comment">// 输出: The type of the object is String</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-枚举的扩展方法"><a href="#4-枚举的扩展方法" class="headerlink" title="4. 枚举的扩展方法"></a>4. 枚举的扩展方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 枚举</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> DayOfWeek<br>&#123;<br>    Monday,<br>    Tuesday,<br>    Wednesday,<br>    Thursday,<br>    Friday,<br>    Saturday,<br>    Sunday<br>&#125;<br><br><span class="hljs-comment">// 扩展方法类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DayOfWeekExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsWeekend</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> DayOfWeek day</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> day == DayOfWeek.Saturday || day == DayOfWeek.Sunday;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        DayOfWeek today = DayOfWeek.Saturday;<br>        Console.WriteLine(today.IsWeekend());  <span class="hljs-comment">// 输出: True</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些示例展示了如何为普通类、结构体、接口、泛型类型和枚举编写扩展方法。每种类型的扩展方法通过<code>this</code>关键字为目标类型增加新功能，方便开发和代码的可读性。</p><h1 id="20-C-的泛型和C-的模板有什么区别呢"><a href="#20-C-的泛型和C-的模板有什么区别呢" class="headerlink" title="20. C#的泛型和C++的模板有什么区别呢"></a>20. C#的泛型和C++的模板有什么区别呢</h1><p>C#的泛型和C++的模板虽然看起来有些相似，但它们的工作方式和设计初衷存在一些关键区别。</p><h3 id="1-编译机制"><a href="#1-编译机制" class="headerlink" title="1. 编译机制"></a>1. <strong>编译机制</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>C++的模板是在编译期间进行代码的生成，称为模板实例化。模板是基于文本替换的宏机制，编译器会根据使用模板时传递的类型生成特定类型的代码。这种方式导致代码膨胀（代码冗余）。</li><li>模板允许类型参数进行特殊化（模板特化），可以为某些特定类型实现不同的模板行为。</li></ul></li><li><strong>C# 泛型</strong><ul><li>C#的泛型在编译期间会被编译成中间语言（IL），并在运行时通过JIT（即时编译器）生成类型安全的代码。编译生成的泛型代码只需要一份，所有的具体类型共享相同的代码，这样可以减少代码的膨胀。</li><li>C# 泛型没有模板特化的概念。泛型的类型参数只能在运行时提供，所有类型参数在使用时都必须满足编译时的类型约束。</li></ul></li></ul><h3 id="2-类型安全"><a href="#2-类型安全" class="headerlink" title="2. 类型安全"></a>2. <strong>类型安全</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>由于C++模板是基于代码替换的宏机制，编译器会根据模板的具体使用来生成代码，在编译期间进行类型检查。因此，如果模板代码不符合类型要求，会在模板实例化时出现编译错误。</li></ul></li><li><strong>C# 泛型</strong><ul><li>C#的泛型提供类型安全的机制，允许在定义泛型时指定类型约束（如<code>where T : class</code>）。编译器在编译期间会检查这些约束，确保类型的安全性。</li></ul></li></ul><h3 id="3-运行时与编译时的行为"><a href="#3-运行时与编译时的行为" class="headerlink" title="3. 运行时与编译时的行为"></a>3. <strong>运行时与编译时的行为</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>模板实例化是在编译时完成的。编译器为每种使用的模板参数生成独立的代码，因此没有额外的运行时开销。</li><li>模板的元编程能力强大，可以实现复杂的编译时计算和类型变换。</li></ul></li><li><strong>C# 泛型</strong><ul><li>C#的泛型是在运行时通过JIT进行类型参数化，允许在运行时决定使用的类型。</li><li>泛型无法在编译时进行元编程计算，只能使用运行时的反射等方式来进行类似的操作。</li></ul></li></ul><h3 id="4-模板特化与泛型约束"><a href="#4-模板特化与泛型约束" class="headerlink" title="4. 模板特化与泛型约束"></a>4. <strong>模板特化与泛型约束</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>支持模板特化，可以为某些特定类型定义不同的实现。</li><li>模板特化分为全特化和偏特化，灵活性更高。</li></ul></li><li><strong>C# 泛型</strong><ul><li>不支持模板特化，但支持泛型约束，可以用<code>where</code>关键字为类型参数指定一定的约束条件，如必须实现某接口或继承某基类。</li></ul></li></ul><h3 id="5-编译器错误信息"><a href="#5-编译器错误信息" class="headerlink" title="5. 编译器错误信息"></a>5. <strong>编译器错误信息</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>由于模板的复杂性和模板元编程的灵活性，模板相关的编译器错误通常非常冗长且难以理解。</li></ul></li><li><strong>C# 泛型</strong><ul><li>由于C#的泛型设计简单，错误信息相对直观。泛型约束的限制也使得类型安全检查更加明确。</li></ul></li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li>C++模板是基于编译期的宏替换机制，支持编译期的元编程和模板特化，灵活性高，但可能会带来代码膨胀。</li><li>C#的泛型是类型安全的运行时机制，支持类型约束，减少了代码冗余，更易于使用，但不具备C++模板的编译期元编程能力。</li></ul><p>两者的设计目的是不同的：C++模板主要为了性能和灵活性，而C#泛型更注重类型安全和代码重用性。</p><h1 id="21-什么叫元编程"><a href="#21-什么叫元编程" class="headerlink" title="21. 什么叫元编程"></a>21. 什么叫元编程</h1><p>元编程（Metaprogramming）是一种编程技术，在这种技术中，程序可以将其他程序作为数据进行操作、分析或生成。换句话说，<code>元编程的目标是编写能够生成、修改或编译代码的代码</code>。它能够提升代码的灵活性、可重用性和性能。元编程主要体现在以下几个方面：</p><h3 id="1-代码生成"><a href="#1-代码生成" class="headerlink" title="1. 代码生成"></a>1. <strong>代码生成</strong></h3><ul><li>通过编写元程序来自动生成某些重复性较强或复杂的代码，从而减少手工编写的工作量。常见的例子有代码生成器和宏。</li></ul><h3 id="2-编译期计算"><a href="#2-编译期计算" class="headerlink" title="2. 编译期计算"></a>2. <strong>编译期计算</strong></h3><ul><li>元编程允许在编译时执行计算。这使得可以利用编译器在编译阶段执行某些逻辑，从而优化程序运行时的性能。例如，C++的模板元编程可以在编译期计算出一些结果，而不是在运行时执行。</li></ul><h3 id="3-反射和动态类型"><a href="#3-反射和动态类型" class="headerlink" title="3. 反射和动态类型"></a>3. <strong>反射和动态类型</strong></h3><ul><li>一些编程语言（如Python、Java、C#）支持在运行时检查和操作类型信息，这种机制称为反射。通过反射，程序可以动态地创建和修改对象、调用方法或访问属性。</li></ul><h3 id="4-宏和预处理器"><a href="#4-宏和预处理器" class="headerlink" title="4. 宏和预处理器"></a>4. <strong>宏和预处理器</strong></h3><ul><li>在C和C++等语言中，预处理器宏是一种简单的元编程工具。它们在编译前处理源代码，用于定义常量、条件编译、代码替换等。</li></ul><h3 id="5-泛型编程"><a href="#5-泛型编程" class="headerlink" title="5. 泛型编程"></a>5. <strong>泛型编程</strong></h3><ul><li>泛型编程是一种特殊的元编程形式，允许编写适用于多种数据类型的代码。例如，C++中的模板和C#中的泛型使得函数和类可以针对任意类型编写。</li></ul><h3 id="6-模板元编程（Template-Metaprogramming）"><a href="#6-模板元编程（Template-Metaprogramming）" class="headerlink" title="6. 模板元编程（Template Metaprogramming）"></a>6. <strong>模板元编程（Template Metaprogramming）</strong></h3><ul><li>C++中广泛应用的元编程技术，允许在编译期通过模板实现复杂的逻辑推导和代码生成。例如，可以利用模板递归计算阶乘或实现编译期类型检查。</li></ul><h3 id="7-编译器插件和自定义编译器"><a href="#7-编译器插件和自定义编译器" class="headerlink" title="7. 编译器插件和自定义编译器"></a>7. <strong>编译器插件和自定义编译器</strong></h3><ul><li>一些语言和编译器允许开发者编写插件或自定义编译器来进行元编程，从而可以在编译过程中自动进行代码优化、生成和修改。</li></ul><h3 id="8-领域特定语言（DSL）"><a href="#8-领域特定语言（DSL）" class="headerlink" title="8. 领域特定语言（DSL）"></a>8. <strong>领域特定语言（DSL）</strong></h3><ul><li>元编程有时还用于创建领域特定语言，这些语言是针对某个特定领域设计的，可以通过扩展已有的语言或创建新的语法来简化编程。</li></ul><h3 id="元编程的优缺点"><a href="#元编程的优缺点" class="headerlink" title="元编程的优缺点"></a>元编程的优缺点</h3><p><strong>优点：</strong></p><ul><li><strong>减少代码重复性</strong>：通过生成代码或编写通用的模板，可以大大减少重复性代码。</li><li><strong>提升性能</strong>：利用编译期计算和优化，可以生成更高效的代码。</li><li><strong>增强灵活性</strong>：程序可以根据不同的条件动态生成或调整代码，增加程序的适应性。<br><strong>缺点：</strong></li><li><strong>复杂性</strong>：元编程的代码往往较为复杂，难以理解和维护。</li><li><strong>编译时间</strong>：编译期元编程可能会显著增加编译时间，尤其是在复杂的模板元编程中。</li><li><strong>调试困难</strong>：由于元编程代码是在编译期生成的，调试错误会更加困难。</li></ul><h3 id="举例：C-模板元编程示例"><a href="#举例：C-模板元编程示例" class="headerlink" title="举例：C++模板元编程示例"></a>举例：C++模板元编程示例</h3><p>在C++中，可以使用模板元编程来计算编译期的阶乘：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 模板结构体，用于计算阶乘</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N - <span class="hljs-number">1</span>&gt;::value; <span class="hljs-comment">// 递归计算阶乘</span><br>&#125;;<br><br><span class="hljs-comment">// 模板特化，用于终止递归</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>; <span class="hljs-comment">// 0! = 1</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 输出5的阶乘</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Factorial of 5: &quot;</span> &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Factorial&lt;5&gt;::value</code>在编译期被计算为120，不需要运行时进行计算。</p><h4 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h4><ol><li><strong>模板递归定义</strong>：<ul><li><code>template &lt;int N&gt; struct Factorial</code> 定义了一个模板结构体，用来计算整数 <code>N</code> 的阶乘。</li><li><code>static const int value = N * Factorial&lt;N - 1&gt;::value;</code> 这一行表示 <code>Factorial&lt;N&gt;::value</code> 等于 <code>N</code> 乘以 <code>Factorial&lt;N - 1&gt;::value</code>。这是一种递归定义，类似于数学上的阶乘定义：<code>N! = N * (N-1)!</code>。</li></ul></li><li><strong>模板特化</strong>：<ul><li><code>template &lt;&gt; struct Factorial&lt;0&gt;</code> 是一个模板特化，用来终止递归计算。它指定当 <code>N</code> 为 0 时，<code>Factorial&lt;0&gt;::value</code> 等于 1。</li></ul></li><li><strong>使用 <code>Factorial&lt;5&gt;::value</code> 进行取值</strong>：<ul><li><code>Factorial&lt;5&gt;::value</code> 的含义是通过模板递归计算 5 的阶乘，即 <code>5 * 4 * 3 * 2 * 1 = 120</code>。</li><li><code>::value</code> 是用来访问 <code>Factorial</code> 结构体中的 <code>value</code> 成员，它保存了计算结果。</li></ul></li></ol><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>输出为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Factorial</span> <span class="hljs-variable">of</span> <span class="hljs-number">5</span><span class="hljs-operator">:</span> <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>这段代码使用模板元编程在编译时计算阶乘，<code>Factorial&lt;5&gt;::value</code> 中的 <code>::value</code> 是访问结构体 <code>Factorial</code> 的静态成员变量，用于获取计算结果。</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>元编程可以提高代码的灵活性和效率，通过编写“生成代码的代码”，解决某些问题变得更加优雅和高效。然而，由于它增加了程序的复杂性，使用时需要权衡和谨慎。</p><p><a href="https://learn.microsoft.com/zh-cn/">MS-Learning</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【算法】约瑟夫环问题</title>
    <link href="/2024/09/12/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/"/>
    <url>/2024/09/12/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="占坑，后面再进行填充"><a href="#占坑，后面再进行填充" class="headerlink" title="占坑，后面再进行填充"></a>占坑，后面再进行填充</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-游戏（二）</title>
    <link href="/2024/09/10/%E6%9D%82%E8%B0%88-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/09/10/%E6%9D%82%E8%B0%88-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>往电脑游戏上靠吧，尽量还是自己能够慢慢玩的游戏，不是类似每几个月就更新的游戏<br>自己确实没时间玩<br>多分析，可以写攻略啥的，至少比第一篇详细</p></blockquote><h3 id="游戏杂谈"><a href="#游戏杂谈" class="headerlink" title="游戏杂谈"></a>游戏杂谈</h3><h4 id="大江湖之苍龙与白鸟"><a href="#大江湖之苍龙与白鸟" class="headerlink" title="大江湖之苍龙与白鸟"></a>大江湖之苍龙与白鸟</h4><!-- ![双人成行.png](https://s2.loli.net/2022/07/20/dxheYjZ9R7vU5iw.png) --><p>占坑</p><h4 id="骰子浪游者"><a href="#骰子浪游者" class="headerlink" title="骰子浪游者"></a>骰子浪游者</h4><p>占坑</p><h4 id="深岩银河"><a href="#深岩银河" class="headerlink" title="深岩银河"></a>深岩银河</h4><p>占坑</p><h4 id="土豆兄弟"><a href="#土豆兄弟" class="headerlink" title="土豆兄弟"></a>土豆兄弟</h4><p>占坑</p><h4 id="学生时代"><a href="#学生时代" class="headerlink" title="学生时代"></a>学生时代</h4><p>占坑</p><h4 id="墨境"><a href="#墨境" class="headerlink" title="墨境"></a>墨境</h4><p>占坑</p><h4 id="暖雪"><a href="#暖雪" class="headerlink" title="暖雪"></a>暖雪</h4><p>占坑</p><h4 id="沉默的蟋蟀"><a href="#沉默的蟋蟀" class="headerlink" title="沉默的蟋蟀"></a>沉默的蟋蟀</h4><p>占坑</p><h4 id="太吾绘卷"><a href="#太吾绘卷" class="headerlink" title="太吾绘卷"></a>太吾绘卷</h4><p>占坑</p><h4 id="孤星猎人"><a href="#孤星猎人" class="headerlink" title="孤星猎人"></a>孤星猎人</h4><p>占坑</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode基本使用和Emmet语法</title>
    <link href="/2024/09/10/VSCode%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8CEmmet%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/09/10/VSCode%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8CEmmet%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="VSCode基本使用和Emmet语法"><a href="#VSCode基本使用和Emmet语法" class="headerlink" title="VSCode基本使用和Emmet语法"></a>VSCode基本使用和Emmet语法</h3><h4 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h4><blockquote><p>Emmet用于加快HTML和CSS代码的编写速度。</p><p>能够通过简短的表达式就可以生成HTML或CSS代码片段。</p><p>截至2022年，主流的编辑器工具如Visual Studio Code、WebStorm都已经继承了<code>Emmet</code>工具，无需手动安装即可使用</p><p>文档地址：<a href="https://docs.emmet.io/cheat-sheet/">https://docs.emmet.io/cheat-sheet/</a></p></blockquote><p>test.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 单个标签 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- p --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 父子关系标签 --&gt;</span><br>  <span class="hljs-comment">&lt;!--   div&gt;ul&gt;li --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 生成多个标签 --&gt;</span><br>  <span class="hljs-comment">&lt;!--   div&gt;ul&gt;li*5 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 兄弟关系标签 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- div+p --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dic</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dic</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 属性 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- #box --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- p#box --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- dic.cls .cls --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 同时生成id和类 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- div.title.#header --&gt;</span><br>  <span class="hljs-comment">&lt;!-- div.title#header --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 自动生成内容 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- p&#123;Hello你好！&#125; --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--   p&#123;Hello你好$&#125;*5 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好4<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好5<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- a[href=&quot;https//www.baidu.com&quot;] --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https//www.baidu.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- input[data-content=&#x27;AAAA&#x27;] --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">data-content</span>=<span class="hljs-string">&quot;AAAA&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- div&gt;p*2+ul&gt;li*2 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- p&gt;span.cls$*6 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls6&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="快捷键以及其他命令"><a href="#快捷键以及其他命令" class="headerlink" title="快捷键以及其他命令"></a>快捷键以及其他命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">code #在windows中的命令行输入code会打开vscode软件<br>CRTL + / #单行注释或取消<br>ALT + UP/DOWN # 移动行<br>SHIFT + ALT + UP/DOWN # 复制当前行<br>CTRL + &#x27;+或-&#x27; # 设置IDE整体字体大小<br>CTRL + ALT + UP/DOWN # 多行编辑<br>SHIFT + CTRL + K # 删除当前行<br></code></pre></td></tr></table></figure><h4 id="VSCode插件推荐"><a href="#VSCode插件推荐" class="headerlink" title="VSCode插件推荐"></a>VSCode插件推荐</h4><ul><li><p>Auto Rename Tag</p><blockquote><p>自动将标签全部修改</p><p></p> 修改其中的p，另一个p也会修改</blockquote></li><li><p>Code Runner</p><blockquote><p>运行多种语言的代码段或代码文件,实际上还要安装其他插件，不知道是不是自带的</p></blockquote></li><li><p>Code Translate</p><blockquote><p>能翻译代码中的英文</p></blockquote></li><li><p>ESLint</p><blockquote><p>vue代码格式化</p></blockquote></li><li><p>JavaScript(ES6) code snippets</p><blockquote><p>js语法报错提示</p></blockquote></li><li><p>Live Server</p><blockquote><p>使用服务器（本地）运行html文件</p></blockquote></li><li><p>Material Icon Theme</p><blockquote><p>修改文件目录的图标</p></blockquote></li><li><p>open in browser</p><blockquote><p>使用浏览器打开html文件</p></blockquote></li><li><p>Prettier Code formatter</p><blockquote><p>代码格式化</p><p>参考<a href="https://huaweicloud.csdn.net/638ee1f6dacf622b8df8d8c0.html">https://huaweicloud.csdn.net/638ee1f6dacf622b8df8d8c0.html</a></p></blockquote></li><li><p>Vetur </p><blockquote><p>Vue代码格式化</p></blockquote></li><li><p>Vue Language Feature(Volur)</p><blockquote><p>Vue代码格式化</p></blockquote></li></ul><p><a href="https://imgse.com/i/pSjl7RI"><img src="https://s1.ax1x.com/2023/02/21/pSjl7RI.png" alt="pSjl7RI.png"></a></p><p><a href="https://imgse.com/i/pSjlOL8"><img src="https://s1.ax1x.com/2023/02/21/pSjlOL8.png" alt="pSjlOL8.png"></a></p><h4 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h4><p>左下角齿轮-&gt;setting</p><p>过一段时间自动保存</p><p><a href="https://imgse.com/i/pSjlxoQ"><img src="https://s1.ax1x.com/2023/02/21/pSjlxoQ.png" alt="pSjlxoQ.png"></a></p><p>去除右上角的迷你窗口</p><p><a href="https://imgse.com/i/pSj1pJs"><img src="https://s1.ax1x.com/2023/02/21/pSj1pJs.png" alt="pSj1pJs.png"></a></p><p>增加Ctrl+鼠标滑轮缩放代码字体大小</p><p><a href="https://imgse.com/i/pSj19Wn"><img src="https://s1.ax1x.com/2023/02/21/pSj19Wn.png" alt="pSj19Wn.png"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>本地双人塔防游戏Demo</title>
    <link href="/2024/09/10/%E6%9C%AC%E5%9C%B0%E5%8F%8C%E4%BA%BA%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8FDemo/"/>
    <url>/2024/09/10/%E6%9C%AC%E5%9C%B0%E5%8F%8C%E4%BA%BA%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8FDemo/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本 Demo 来自 B 站课程学习的改进</p><p>作为自己的整理和找工作的项目 Demo</p><p>添加了自己的想法，记录在做这个 Demo 过程中比较重要的内容，可能会贴出部分源码</p></blockquote><h1 id="导入-SDL-相关的包"><a href="#导入-SDL-相关的包" class="headerlink" title="导入 SDL 相关的包"></a>导入 SDL 相关的包</h1><p><a href="https://wiki.libsdl.org/SDL2/CategoryAPI">SDL2 API 文档总览</a></p><p><a href="https://github.com/DaveGamble/cJSON">cJSON 仓库链接</a><br><a href="https://github.com/libsdl-org/SDL">SDL2 仓库链接</a><br><a href="https://github.com/libsdl-org/SDL_ttf">SDL_ttf 仓库链接</a><br><a href="https://github.com/libsdl-org/SDL_mixer">SDL_mixer 仓库链接</a><br><a href="https://github.com/libsdl-org/SDL_image">SDL_image 仓库链接</a><br><a href="https://www.ferzkopp.net/wordpress/2016/01/02/sdl_gfx-sdl2_gfx/">SDL2_gfx 官网链接</a></p><h2 id="下载-SDL2-的时候的-release-版本的信息解读"><a href="#下载-SDL2-的时候的-release-版本的信息解读" class="headerlink" title="下载 SDL2 的时候的 release 版本的信息解读"></a>下载 SDL2 的时候的 release 版本的信息解读</h2><p><img src="/BlogImg/image-20240909230926905.png" alt="image-20240909230926905"></p><p>文件名 <code>SDL2-devel-2.30.7-VC.zip</code> 中的各个部分通常遵循一定的命名规则，以下是对其命名含义的解释：</p><ol><li><p><strong><code>SDL2</code></strong>:</p><ul><li>代表 Simple DirectMedia Layer 2.0，即 SDL2，这是一个跨平台的多媒体开发库，广泛用于游戏开发、图形渲染和音频处理等领域。</li></ul></li><li><p><strong><code>devel</code></strong>:</p><ul><li><code>devel</code> 是 <code>development</code> 的缩写，表示这是一个开发版本的文件包，通常包含开发库、头文件和相关的工具，用于软件开发而不是仅仅用于运行时。这意味着你可以使用它来编译和开发依赖于 SDL2 的应用程序。</li></ul></li><li><p><strong><code>2.30.2</code></strong>:</p><ul><li><p>这是 SDL2 的版本号，表示这是 2.30.7 版本。版本号通常以</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">主版本号.次版本号.修订号<br></code></pre></td></tr></table></figure><p>的形式表示，例如在此例中：</p><ul><li><code>2</code> 是主版本号，表示这是 SDL2 的第二个大版本。</li><li><code>30</code> 是次版本号，表示自主版本 2 以来进行了 30 次功能更新或改进。</li><li><code>7</code> 是修订号，表示这个版本在 <code>2.30</code> 基础上进行了七次小的修复或改进。</li></ul></li></ul></li><li><p><strong><code>VC</code></strong>:</p><ul><li><code>VC</code> 代表 Visual C++，表示这个文件包是为 Microsoft Visual C++ 编译器和开发环境准备的。这通常意味着它包含了适用于 Visual Studio 的动态链接库（DLLs）、静态库（LIBs）、头文件（headers）等。</li></ul></li><li><p><strong><code>.zip</code></strong>:</p><ul><li>这是文件的扩展名，表示该文件是一个压缩包，使用 ZIP 压缩格式。你需要解压缩它以访问其中的内容。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文件名 <code>SDL2-devel-2.30.2-VC.zip</code> 可以理解为：</p><ul><li>这是 SDL2 库的开发版（包含开发所需的文件），</li><li>版本号是 2.30.2，</li><li>专门为 Visual C++ 编译器准备，</li><li>文件被打包为 ZIP 格式的压缩包。</li></ul><h2 id="VS-Studio-的一些设置"><a href="#VS-Studio-的一些设置" class="headerlink" title="VS Studio 的一些设置"></a>VS Studio 的一些设置</h2><h3 id="运行库设置"><a href="#运行库设置" class="headerlink" title="运行库设置"></a>运行库设置</h3><p><img src="/BlogImg/image-20240909233156816.png" alt="属性页操作"></p><p><img src="/BlogImg/image-20240909233309479.png" alt="右键项目最下面能看到属性"></p><p><img src="/BlogImg/image-20240909233333704.png" alt="找到属性中的运行库"></p><h3 id="不同选项的解释，来自-chatgpt-4o"><a href="#不同选项的解释，来自-chatgpt-4o" class="headerlink" title="不同选项的解释，来自 chatgpt-4o"></a>不同选项的解释，来自 chatgpt-4o</h3><p>在 Visual Studio 中，当你编译一个 C&#x2F;C++ 程序时，可以选择不同的运行库（Runtime Library）选项。每个选项都有不同的特性，主要影响程序在运行时如何链接到 C&#x2F;C++ 标准库以及线程安全性。以下是常见的运行库选项及其区别：</p><h3 id="1-多线程-单线程"><a href="#1-多线程-单线程" class="headerlink" title="1. 多线程&#x2F;单线程"></a>1. <strong>多线程&#x2F;单线程</strong></h3><ul><li><strong>&#x2F;MT</strong> (Multithreaded): 编译器使用多线程的、静态链接的运行库。这意味着标准库的代码将被编译进生成的二进制文件中，不依赖外部的 DLL 文件。此选项适用于编译需要多线程支持的独立可执行文件。</li><li><strong>&#x2F;MTd</strong> (Multithreaded Debug): 和 <code>/MT</code> 类似，但用于调试版本，包含调试信息。</li><li><strong>&#x2F;MD</strong> (Multithreaded DLL): 编译器使用多线程的、动态链接的运行库。这意味着标准库的代码不会被编译进生成的二进制文件中，而是依赖外部的 <code>msvcrt.dll</code>（或调试版本的 <code>msvcrtd.dll</code>）。这是默认的运行库选项，适用于需要分发较小的可执行文件并且使用了动态链接库的项目。</li><li><strong>&#x2F;MDd</strong> (Multithreaded DLL Debug): 和 <code>/MD</code> 类似，但用于调试版本，包含调试信息。</li></ul><h3 id="2-静态链接-vs-动态链接"><a href="#2-静态链接-vs-动态链接" class="headerlink" title="2. 静态链接 vs 动态链接"></a>2. <strong>静态链接 vs 动态链接</strong></h3><ul><li><strong>静态链接</strong> (<code>/MT</code>, <code>/MTd</code>):<ul><li>所有的运行时库代码都被嵌入到最终的可执行文件或库文件中。</li><li>不依赖任何外部 DLL 文件。</li><li>生成的文件较大，但在部署时不需要依赖额外的库文件。</li></ul></li><li><strong>动态链接</strong> (<code>/MD</code>, <code>/MDd</code>):<ul><li>运行时库代码保存在外部的 DLL 文件中，最终的可执行文件中只包含对这些 DLL 的引用。</li><li>生成的可执行文件较小，但在运行时必须确保相关的 DLL 文件可用。</li><li>如果不同的模块使用不同的运行时库（比如一个模块用 <code>/MD</code>，另一个用 <code>/MT</code>），可能会导致内存管理问题（如内存分配与释放的不一致）。</li></ul></li></ul><h3 id="3-调试版-vs-发布版"><a href="#3-调试版-vs-发布版" class="headerlink" title="3. 调试版 vs 发布版"></a>3. <strong>调试版 vs 发布版</strong></h3><ul><li><strong>调试版</strong> (<code>/MTd</code>, <code>/MDd</code>):<ul><li>包含调试信息，便于在调试器中运行程序。</li><li>使用了调试版本的运行库，运行时性能可能较低，但提供了更多的错误检查机制。</li></ul></li><li><strong>发布版</strong> (<code>/MT</code>, <code>/MD</code>):<ul><li>不包含调试信息，优化后的代码适用于发布版本。</li><li>使用了非调试版本的运行库，运行时性能更好。</li></ul></li></ul><h3 id="选择哪个运行库？"><a href="#选择哪个运行库？" class="headerlink" title="选择哪个运行库？"></a>选择哪个运行库？</h3><ul><li><strong>单独的可执行文件</strong>: <font color="red">如果你需要一个不依赖外部 DLL 的独立可执行文件，可以选择 <code>/MT</code> 或 <code>/MTd</code>。</font></li><li><strong>使用动态链接库</strong>: 如果你希望通过动态链接库减小可执行文件的大小并共享库代码，使用 <code>/MD</code> 或 <code>/MDd</code> 是更好的选择。</li><li><strong>调试 vs 发布</strong>: 在开发和调试阶段，选择调试版运行库（如 <code>/MDd</code>），在发布时切换到发布版运行库（如 <code>/MD</code>）。</li></ul><h2 id="第三方库的导入"><a href="#第三方库的导入" class="headerlink" title="第三方库的导入"></a>第三方库的导入</h2><ul><li>导入头文件(include 文件夹)和静态(lib)或者动态链接库(dll)</li></ul><p><img src="/BlogImg/image-20240909233954841.png" alt="导入头文件和库文件"></p><ul><li>导入头文件(include 文件夹)和源文件</li></ul><p><img src="/BlogImg/image-20240909234021144.png" alt="导入头文件和源文件"></p><h2 id="头文件目录设置"><a href="#头文件目录设置" class="headerlink" title="头文件目录设置"></a>头文件目录设置</h2><p><img src="/BlogImg/image-20240909234813783.png" alt="附加包含目录"></p><p>在 Visual Studio 中，“附加包含目录”（Additional Include Directories）是一个项目属性设置项，用于指定编译器在编译项目时需要查找的头文件目录。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>当你在代码中使用 <code>#include</code> 指令引用头文件时，编译器需要知道这些头文件的位置。编译器默认会在以下地方查找头文件：</p><ol><li><strong>当前源文件所在的目录</strong>。</li><li><strong>系统默认的包含目录</strong>（如 C++ 标准库的头文件目录）。</li></ol><p>如果你的项目中使用了自定义的头文件，或者你依赖于外部库的头文件，这些头文件可能位于编译器默认查找路径之外。此时，你需要通过“附加包含目录”将这些头文件所在的路径告诉编译器。</p><h3 id="如何设置"><a href="#如何设置" class="headerlink" title="如何设置"></a>如何设置</h3><p>在 Visual Studio 中，你可以通过以下步骤设置“附加包含目录”：</p><ol><li>右键点击你的项目，选择“属性”（Properties）。</li><li>在项目属性窗口中，导航到“配置属性”（Configuration Properties） -&gt; “C&#x2F;C++” -&gt; “常规”（General）。</li><li>在右侧的“附加包含目录”一栏中，添加需要包含的头文件目录路径。可以手动输入路径，或点击旁边的按钮选择目录。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设你正在编译一个 C++ 项目，并且你使用了一个外部库 <code>MyLibrary</code>，它的头文件存放在 <code>C:\Libraries\MyLibrary\include</code> 目录下。在你的代码中，你可能会有这样的包含语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;MyLibrary.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>为了让编译器找到 <code>MyLibrary.h</code> 文件，你需要将 <code>C:\Libraries\MyLibrary\include</code> 路径添加到“附加包含目录”中。</p><h2 id="库文件目录设置"><a href="#库文件目录设置" class="headerlink" title="库文件目录设置"></a>库文件目录设置</h2><p><img src="/BlogImg/image-20240909235154768.png" alt="库文件目录设置"></p><p>在 Visual Studio 中，“附加库目录”（Additional Library Directories）是项目属性设置中的一项，用于指定链接器在链接阶段需要查找库文件（如 <code>.lib</code> 文件）的目录。</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>当你编写的程序需要链接到外部库（如第三方库或自己编写的库）时，链接器需要知道这些库文件的位置。库文件通常包含了程序中使用的函数、类等的预编译代码，而链接器的任务就是将这些库与您的代码结合，生成最终的可执行文件。</p><p>默认情况下，链接器会在以下地方查找库文件：</p><ol><li><strong>系统默认的库目录</strong>（例如，Windows SDK 中的库目录）。</li><li><strong>项目文件所在的目录</strong>。</li></ol><p>如果你的项目使用的库文件不在这些默认目录中，你就需要通过“附加库目录”告诉链接器这些库文件所在的位置。</p><h3 id="如何设置-1"><a href="#如何设置-1" class="headerlink" title="如何设置"></a>如何设置</h3><p>在 Visual Studio 中，你可以通过以下步骤设置“附加库目录”：</p><ol><li>右键点击你的项目，选择“属性”（Properties）。</li><li>在项目属性窗口中，导航到“配置属性”（Configuration Properties） -&gt; “链接器”（Linker） -&gt; “常规”（General）。</li><li>在右侧的“附加库目录”一栏中，添加需要包含的库文件目录路径。你可以手动输入路径，也可以点击旁边的按钮来选择目录。</li></ol><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>假设你正在编译一个 C++ 项目，并且使用了一个外部库 <code>MyLibrary</code>，其库文件存放在 <code>C:\Libraries\MyLibrary\lib</code> 目录下。在你的代码中，你可能需要链接到这个库的 <code>.lib</code> 文件。</p><p>为了让链接器找到这些库文件，你需要将 <code>C:\Libraries\MyLibrary\lib</code> 路径添加到“附加库目录”中。</p><h3 id="关联设置：附加依赖项"><a href="#关联设置：附加依赖项" class="headerlink" title="关联设置：附加依赖项"></a>关联设置：附加依赖项</h3><p>在设置了“附加库目录”后，你还需要在“附加依赖项”（Additional Dependencies）中指定要链接的具体库文件名（如 <code>MyLibrary.lib</code>），这个选项也位于链接器的属性设置中。设置路径后，链接器会在指定的“附加库目录”中查找这些库文件。</p><h3 id="lib-和-dll-的区别"><a href="#lib-和-dll-的区别" class="headerlink" title="lib 和 dll 的区别"></a>lib 和 dll 的区别</h3><h4 id="1-lib-文件"><a href="#1-lib-文件" class="headerlink" title="1. lib 文件"></a>1. <strong><code>lib</code> 文件</strong></h4><p><code>lib</code> 文件通常有两种形式，分别用于不同的目的：</p><ul><li><strong>静态库（Static Library）</strong>:<ul><li><strong>作用</strong>: 在编译时将库代码直接嵌入到可执行文件中。</li><li><strong>链接</strong>: 编译器将静态库中的代码与应用程序的代码结合，生成一个包含所有必要代码的独立可执行文件。</li><li><strong>部署</strong>: 生成的可执行文件不依赖外部库，体积会比较大，但运行时不需要额外的库文件。</li><li><strong>扩展名</strong>: <code>.lib</code></li></ul></li><li><strong>导入库（Import Library）</strong>:<ul><li><strong>作用</strong>: 为动态链接库（DLL）提供链接信息。</li><li><strong>链接</strong>: 导入库不包含实际的代码，只包含 DLL 中函数和变量的符号信息。在编译时使用导入库，告诉链接器将来需要使用特定的 DLL 文件。</li><li><strong>部署</strong>: 可执行文件在运行时依赖 DLL 文件，导入库仅在编译和链接阶段使用。</li><li><strong>扩展名</strong>: <code>.lib</code></li></ul></li></ul><h4 id="2-dll-文件"><a href="#2-dll-文件" class="headerlink" title="2. dll 文件"></a>2. <strong><code>dll</code> 文件</strong></h4><ul><li><p>动态链接库（Dynamic Link Library）:</p><ul><li><strong>作用</strong>: 提供可在运行时加载并使用的库函数和数据。DLL 文件可以被多个程序同时使用，从而节省内存和减少重复代码。</li><li><strong>链接</strong>: 在运行时加载 DLL 文件，应用程序通过动态链接来调用其中的函数。编译时，程序通过导入库（<code>.lib</code> 文件）或使用 <code>LoadLibrary</code> 等 API 函数来引用 DLL 中的函数。</li><li><strong>部署</strong>: DLL 文件需要与可执行文件一起部署。当应用程序运行时，系统会在特定目录中查找并加载 DLL 文件。</li><li><strong>扩展名</strong>: <code>.dll</code></li></ul></li></ul><h4 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. <strong>主要区别</strong></h4><ul><li><strong>链接方式</strong>:<ul><li><strong>静态库</strong>: 在编译时链接，生成的可执行文件不需要依赖外部库。</li><li><strong>动态库</strong>: 在运行时链接，可执行文件在运行时需要加载对应的 DLL。</li></ul></li><li><strong>文件扩展名</strong>:<ul><li><strong>静态库&#x2F;导入库</strong>: <code>.lib</code></li><li><strong>动态库</strong>: <code>.dll</code></li></ul></li><li><strong>内存占用</strong>:<ul><li><strong>静态库</strong>: 由于库代码被嵌入到可执行文件中，多个应用程序会各自占用内存。</li><li><strong>动态库</strong>: DLL 可以被多个程序同时加载，节省内存。</li></ul></li><li><strong>更新与维护</strong>:<ul><li><strong>静态库</strong>: 如果库代码需要更新，必须重新编译所有使用该库的程序。</li><li><strong>动态库</strong>: 更新 DLL 文件后，所有使用该 DLL 的程序都能立即受益于更新，无需重新编译。</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><strong>静态库（.lib）</strong>: 编译时链接，库代码直接嵌入到可执行文件中。</li><li><strong>动态链接库（.dll）</strong>: 运行时链接，可执行文件依赖于外部的 DLL 文件。</li><li><strong>导入库（.lib）</strong>: 用于编译时链接到 DLL，提供符号信息，但不包含实际代码。</li></ul><h2 id="链接库文件"><a href="#链接库文件" class="headerlink" title="链接库文件"></a>链接库文件</h2><p><img src="/BlogImg/image-20240909235827283.png" alt="链接库文件"></p><p>在 Visual Studio 中，“附加依赖项”（Additional Dependencies）是一个链接器设置项，用于指定在编译和链接过程中，程序需要链接的库文件（通常是 <code>.lib</code> 文件）。</p><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>“附加依赖项”告诉链接器，除了默认的系统库外，还需要链接哪些特定的库文件。库文件包含预编译的代码或数据，程序在编译和链接时将这些库中的内容整合到最终生成的可执行文件或动态链接库中。</p><h3 id="如何设置-2"><a href="#如何设置-2" class="headerlink" title="如何设置"></a>如何设置</h3><p>你可以通过以下步骤在 Visual Studio 中设置“附加依赖项”：</p><ol><li>右键点击你的项目，选择“属性”（Properties）。</li><li>在项目属性窗口中，导航到“配置属性”（Configuration Properties） -&gt; “链接器”（Linker） -&gt; “输入”（Input）。</li><li>在右侧的“附加依赖项”一栏中，输入需要链接的库文件名，文件名之间用分号隔开。例如：<code>MyLibrary.lib;AnotherLibrary.lib</code>。</li></ol><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>假设你正在编译一个项目，该项目依赖于两个外部库 <code>MyLibrary.lib</code> 和 <code>AnotherLibrary.lib</code>。你需要将这两个库的名称添加到“附加依赖项”中，如下所示：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">MyLibrary.<span class="hljs-keyword">lib</span>;AnotherLibrary.<span class="hljs-keyword">lib</span><br></code></pre></td></tr></table></figure><h3 id="与“附加库目录”的关系"><a href="#与“附加库目录”的关系" class="headerlink" title="与“附加库目录”的关系"></a>与“附加库目录”的关系</h3><p>“附加依赖项”指定了需要链接的库文件名，而“附加库目录”指定了这些库文件所在的路径。链接器会在“附加库目录”中查找“附加依赖项”中列出的库文件。如果库文件不在默认路径中，你需要在“附加库目录”中指定正确的路径，否则链接器将无法找到并链接这些库文件。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>附加依赖项</strong>: 指定在链接阶段需要链接的库文件名（通常是 <code>.lib</code> 文件）。</li><li><strong>附加库目录</strong>: 指定这些库文件所在的路径。</li></ul><h2 id="DLL-的文件设置"><a href="#DLL-的文件设置" class="headerlink" title="DLL 的文件设置"></a>DLL 的文件设置</h2><blockquote><p>就放在 main.cpp 同级目录下，具体怎么加载还不知道</p></blockquote><p><img src="/BlogImg/image-20240910000249147.png" alt="dll文件缩放位置的参考"></p><h2 id="其他源文件的导入"><a href="#其他源文件的导入" class="headerlink" title="其他源文件的导入"></a>其他源文件的导入</h2><p><img src="/BlogImg/image-20240910000425931.png" alt="新建筛选器"></p><ul><li>源文件拖拽到新建筛选器下方，导入的时候会自己找到这个源文件的，不是复制</li></ul><p><img src="/BlogImg/image-20240910000502340.png" alt="源文件拖拽到新建筛选器下方"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>各种功能测试</title>
    <link href="/2024/09/10/%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/09/10/%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h4 id="LaTex-公式"><a href="#LaTex-公式" class="headerlink" title="LaTex 公式"></a>LaTex 公式</h4><p>$$<br>J_r^{-1}(e_{ij})\approx I +\frac { 1 } { 2 }<br>\begin{bmatrix}<br>\phi_e^ { \wedge } &amp; \rho_e^ { \wedge } \<br>0 &amp; \phi_e^{\wedge} \<br>\end{bmatrix}<br>$$</p><p>$$<br>E&#x3D;mc^2<br>$$</p><h4 id="提交并更新博客"><a href="#提交并更新博客" class="headerlink" title="提交并更新博客"></a>提交并更新博客</h4><ul><li>提交仓库并更新</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo c &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ul><li>本地更新</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo c &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis的基本使用</title>
    <link href="/2024/09/10/Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/09/10/Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="基本命令-包含centos命令和redis的命令"><a href="#基本命令-包含centos命令和redis的命令" class="headerlink" title="基本命令(包含centos命令和redis的命令)"></a>基本命令(包含centos命令和redis的命令)</h4><p>后面的是redis的命令</p><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>redis-server</td><td>前台启动redis服务</td></tr><tr><td>redis-server redis.conf目录</td><td>后台启动redis服务</td></tr><tr><td>redis-server &#x2F;etc&#x2F;redis.conf</td><td>后台启动redis服务</td></tr><tr><td>&gt;ping</td><td>返回PONG表示redis连接成功</td></tr><tr><td>ps -ef | grep redis</td><td>显示redis的所有进程</td></tr><tr><td>kill -9 ID</td><td>杀死 ID的进程</td></tr><tr><td>redis-cli -p 6379</td><td>用6379端口启动redis,默认使用6379端口可以不用写-p 6379</td></tr><tr><td>redis-cli shutdown</td><td>单实例redis关闭</td></tr><tr><td>&gt;shutdown</td><td>关闭进入的redis实例</td></tr><tr><td>redis-cli -p 6379 shutdown</td><td>多redis实例关闭，指定端口关闭</td></tr></tbody></table><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>set key value</td><td>添加键值对</td></tr><tr><td>get key</td><td>查询对应的键值</td></tr><tr><td>append key value</td><td>将给定的value 追加到原值的末尾</td></tr><tr><td>strlen key</td><td>获得值的长度</td></tr><tr><td>setnx key value</td><td>只有在key不存在时，设置key的值</td></tr><tr><td>incr key</td><td>将key中存储的数字值增加1，只能对数字值操作，如果为空，值设置为1</td></tr><tr><td>decr key</td><td>将key中存储的数字值减少1，只能对数字值操作，如果为空，值设置为-1</td></tr><tr><td>incrby&#x2F;decrby key&gt; 步长</td><td>将 key 中储存的数字值增减步长值，步长可以为负数</td></tr><tr><td>mset key1 value1 key2 value2 …</td><td>同时设置一个或多个key-value对</td></tr><tr><td>mget key2 value2 key2 value2</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx key1 value1 key2 value2</td><td>同时设置一个或多个key-value对，当且仅当所有给定key都不存在</td></tr><tr><td>getrange key 起始位置 结束位置</td><td>获得值的范围，类似java中的substring，前包，后包</td></tr><tr><td>setrange key 起始位置 value</td><td>用value 覆写key所存储的字符串值，从起始位置开始(索引从0开始)</td></tr><tr><td>set key 过期时间 value</td><td>设置键值的同时，设置过期时间，单位秒</td></tr><tr><td>getset key value</td><td>依旧换新，设置新值同时输出旧值</td></tr></tbody></table><p>Redis列表(List)</p><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>lpush&#x2F;rpush  key1 value1 key2 value2  …</td><td>从左边&#x2F;右边插入一个或多个值</td></tr><tr><td>lpop&#x2F;rpop key</td><td>从左边&#x2F;右边吐出一个值。值在键在，值光键亡</td></tr><tr><td>rpop&#x2F;lpush key1 key2</td><td>从key1列表右边吐出一个值，插到key2列表左边</td></tr><tr><td>lrange key start stop</td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>lrange mylist 0 -1</td><td>0左边第一个，-1右边第一个<br />改命令表示获得所有</td></tr><tr><td>lindex key index</td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>llen key</td><td>获得列表长度</td></tr><tr><td>linsert key before value newvalue</td><td>在value前面插入newvalue</td></tr><tr><td>lrem key n value</td><td>从左边删除n个value(从左到右)</td></tr><tr><td>lset key index value</td><td>将列表key下标为index的值替换成value</td></tr></tbody></table><p>Redis集合(set)</p><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>sadd key value1 value2</td><td>将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略</td></tr><tr><td>smembers key</td><td>取出该集合的所有值</td></tr><tr><td>sismember key value</td><td>判断集合key是否为含有该value值，有1，没有0</td></tr><tr><td>scard key</td><td>返回该集合的元素个数</td></tr><tr><td>srem key value1 value2 …</td><td>删除集合中的某个元素</td></tr><tr><td>spop key</td><td>随机从该集合中吐出一个值</td></tr><tr><td>srandmember key n</td><td>随机从该集合中取出n个值，不会从集合中删除</td></tr><tr><td>smove source destination value</td><td>把集合中一个值从一个集合移动到另一个集合</td></tr><tr><td>sinnter key1 key2</td><td>返回两个集合的交集元素</td></tr><tr><td>sunion key1 key2</td><td>返回两个集合的并集元素</td></tr><tr><td>sdiff key1 key2</td><td>返回两个集合的差集元素(key1中的，不包含key2中的)</td></tr></tbody></table><h4 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>hset key field value</td><td>给key集合中的field键赋值value</td></tr><tr><td>hget key1 field</td><td>从key1集合field取出value</td></tr><tr><td>hmset key1 field1 value1 field2 value2…</td><td>批量设置hash的值</td></tr><tr><td>hexists &lt;key1 field</td><td>查看哈希表key中，给定域field是否存在</td></tr><tr><td>hkeys key</td><td>列出该hash集合的所有field</td></tr><tr><td>hvals key</td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby key field increment</td><td>为哈希表key中的域field的值加上增量increment</td></tr><tr><td>hsetnx key field value</td><td>将哈希表key中的域field的值设置为value，当且仅当域field不存在</td></tr></tbody></table><h4 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h4><p>主要是根据score来排序</p><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>zadd key score1 value1 score2 value2 …</td><td>将一个或多个member元素及其score值加入到有序key当中</td></tr><tr><td>zrange key start stop [WITHSCORES]</td><td>返回有序集key中，下标在start stop 之间的元素<br />带WITHSCORES可以让分数一起和值返回到结果集</td></tr><tr><td>zrangebyscore key minmax [withscores] [limit offset count]</td><td>返回有序集key中，所有score值介于min和max之间(包括等于min或max)的成员，有序集成员按score值递增(从小到大)次序排列</td></tr><tr><td>zrevrangebyscore</td><td>同上，改为从大到小排列</td></tr><tr><td>zincrby key increment value</td><td>为元素的score加上增量</td></tr><tr><td>zrem key value</td><td>删除该集合下指定值的元素</td></tr><tr><td>zcount key min max</td><td>统计该集合，分数区间内的元素个数</td></tr><tr><td>zrank key value</td><td>返回该值在集合中的排名，从0开始</td></tr></tbody></table><h4 id="Redis的一些相关配置"><a href="#Redis的一些相关配置" class="headerlink" title="Redis的一些相关配置"></a>Redis的一些相关配置</h4><p>配置只有保存后，并重启查看进程才能生效</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&gt; <span class="hljs-keyword">shutdown</span><br>redis-server <span class="hljs-string">/redis.conf</span>的路径<br></code></pre></td></tr></table></figure><p>注释掉bind 127.0.0.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">bind</span> 127.0.0.1</span><br></code></pre></td></tr></table></figure><p>将本机的访问保护模式设置no</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">protected-<span class="hljs-keyword">mode</span> <span class="hljs-keyword">no</span><br></code></pre></td></tr></table></figure><p>端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>设置为后台进程</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">requirepass</span> foobared <span class="hljs-comment">#将foobared改为自己的密码，去掉注释就行</span><br><span class="hljs-comment"># 之后使用redis-cli登录redis后使用命令：auth 你的密码</span><br><span class="hljs-comment"># 这样就可以密码登录了 或者redis-cli -a 你的密码</span><br></code></pre></td></tr></table></figure><h4 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>subscribe channel1</td><td>需要先进入redis，订阅channel1</td></tr><tr><td>publish channel1 hello</td><td>给channel1频道发信息</td></tr></tbody></table><h4 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h4><h5 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h5><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>setbit key offset value</td><td>设置Bitmaps中某个偏移量的值（0或1）</td></tr><tr><td>getbit key offset</td><td>获取Bitmaps中某个偏移量的值</td></tr><tr><td>bitcount key [start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td></tr><tr><td>bitop and(or&#x2F;not&#x2F;xor) destkey [key]</td><td>bitop是一个符合操作，他可以做多个Bitmaps的and(交集)、or(并集)、not(非)、xor(异或)操作并将结果保存在destkey中</td></tr></tbody></table><h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>pfadd key element [element …]</td><td>添加指定元素到HyperLogLog中</td></tr><tr><td>pfcount key [key…]</td><td>计算key的近似基数</td></tr><tr><td>pfmerge destkey sourcekey [sourcekey…]</td><td>将一个或多个key合并后的结果存在另一个key中，比如每月活跃用户可以使用每天的活跃用户来合并计算得到</td></tr></tbody></table><h5 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h5><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>geoadd key logitude latitude member [longitude latitude member …]</td><td>添加地理位置(经度，纬度，名称)</td></tr><tr><td>geopos key member [member…]</td><td>获得指定地区的坐标值</td></tr><tr><td>geodis key member1 member2 [m|km|ft|mi]</td><td>获取两个位置之间的直线距离<br />(m:米(默认值),km:千米,mi:英里,ft英尺)</td></tr><tr><td>georadius key longitude latitude radius m|km|ft|mi</td><td>以给定的经纬度为中心， 找出某一半径内的元素（经度 纬度 距离 单位）</td></tr></tbody></table><h4 id="Java连接Redis"><a href="#Java连接Redis" class="headerlink" title="Java连接Redis"></a>Java连接Redis</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.137.3&quot;</span>,<span class="hljs-number">6379</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">pong</span> <span class="hljs-operator">=</span> jedis.ping();<br>System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span>+pong);<br>jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis_事务"></a>Redis_事务</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>multi</td><td>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行。</td></tr><tr><td>exec</td><td>同上</td></tr><tr><td>discard</td><td>组队的过程中可以通过 discard 来放弃组队</td></tr></tbody></table><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>后面还有持久化-RDB和AOF，用的时候查一下“尚硅谷的笔记”或者百度吧，暂时没练过，不知道记录啥，本人还是主要想去学一下C#和unity，要不是大数据作业，估计不会看这个[-_-||]</p><p>主从复制</p><p>lua脚本</p><p>集群</p><ul><li>缓存穿透</li><li>缓存击穿</li><li>缓存雪崩</li></ul><h4 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h4><p><a href="https://www.bilibili.com/video/BV1Rv41177Af" title="B站尚硅谷Redis学习视频">参考B站视频</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB的简单使用</title>
    <link href="/2024/09/10/MongoDB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/09/10/MongoDB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>show databases</td><td>显示当前数据库</td></tr><tr><td>show dbs</td><td>显示当前数据库</td></tr><tr><td>use 数据库名</td><td>进入指定数据库</td></tr><tr><td>db</td><td>显示当前所处数据库</td></tr><tr><td>show collections</td><td>显示数据库中所有的集合</td></tr></tbody></table><h4 id="CRUD操作（create-read-update-delete）"><a href="#CRUD操作（create-read-update-delete）" class="headerlink" title="CRUD操作（create read update delete）"></a>CRUD操作（create read update delete）</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>db.&lt;collection&gt;.insert(doc)</td><td>向集合中插入一个文档</td></tr><tr><td>db.stus.insert({name:”孙悟空”,age:18,gender:”男”})</td><td>向当前的数据库中的stus集合中插入一个学生对象{name:”孙悟空”,age:18,gender:”男”}</td></tr><tr><td>db.stus.insert([{name:”孙悟空”,age:18,gender:”男”},{name:”沙和尚”,age:22,gender:”男”},{name:”猪八戒”,age:24,gender:”男”}])</td><td>一次性插入多个</td></tr><tr><td>db.stus.insert([{_id:”hello”,name:”孙悟空”,age:18,gender:”男”},])</td><td>会自定义id</td></tr><tr><td>db.stus.insertOne({name:”孙悟空”,age:18,gender:”男”},)<br />db.stus.insertMany([{name:”孙悟空”,age:18,gender:”男”},{name:”孙悟空”,age:18,gender:”男”}])</td><td>insertOne()和insertMany()分别是用来插入一个和多个数据</td></tr><tr><td>db.&lt;collection&gt;.find()<br />-find()用来查看集合中所有符合条件的文档<br />-find()可以接收一个对象作为条件参数<br />{}表示查询集合中所有的文档<br />{属性：值}查询属性是指定值的文档</td><td>查询当前集合中的所有文档</td></tr><tr><td>db.stus.find({_id:”hello”})<br />db.stus.find({age:28,name:”白骨精”})</td><td>查询id为hello的文档<br />查询年龄为28，name为白骨精的文档</td></tr><tr><td>db.stus.find()<br />db.stus.find()[0]<br />db.stus.find()[0].name<br />db.stus.find({}).count()<br />db.stus.find().length()</td><td>查询stus中所有文档<br />查询第一个文档<br />查询第一个文档的name属性<br />查询stus集合中文档的数量，find()中有{}效果是一样的<br />作用同count()</td></tr><tr><td>db.&lt;collectioin&gt;.findOne()<br />db.&lt;collection&gt;.findOne().name</td><td>用来查询集合中符合条件的第一个<br />查询集合中第一个的name属性</td></tr><tr><td>db.&lt;collection&gt;.findOne()</td><td>查询集合中符合条件的第一个文档</td></tr></tbody></table><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>db.collection.update(查询条件，新对象)</td><td>修改查询到的对象为新对象<br />update()默认情况下会使用新对象替换旧的对象，默认替换修改一个符合条件的</td></tr><tr><td>db.stus.update({“_id”:”hello”},{$set:{name:”沙和尚”}})<br />db.stus.update({“_id”:”hello”},{$set:{gender:”女”,address:”流沙河”}})</td><td>$set: 用来修改文档中的指定属性<br />修改_id为hello的对象中name为沙和尚<br />修改_id为hello的对象中的gender为女，添加address属性</td></tr><tr><td>db.stus.update({“name”:”孙悟空”},{$set:{address:”花果山2”}},{multi:true})</td><td>添加一个{multi:true}</td></tr><tr><td>db.stus.update({“_id”:”hello”},{$unset:{address:{}}})</td><td>$unset:用来删除文档中的指定属性<br />删除_id为hello的对象中address属性，删除是根据属性删除，属性后面的值不管，可以用{}或””或者随便什么值（1也可以，简单就行）代替</td></tr><tr><td>db.&lt;collection&gt;.updateMany()</td><td>同时修改多个符合条件的文档</td></tr><tr><td>db.stus.updateMany({“name”:”孙悟空”},{$set:{address:”花果山”}})</td><td>同时将name属性为孙悟空的对象中添加一个address属性</td></tr><tr><td>db.&lt;collection&gt;.updateOne()</td><td>修改一个符合条件的文档</td></tr><tr><td>db.&lt;collection&gt;.replaceOne()</td><td>替换一个文档</td></tr></tbody></table><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>db.&lt;collection&gt;.remove()</td><td>可以根据条件来删除文档，传递的条件和find()一样，默认情况下删除符合条件的所有文档</td></tr><tr><td>db.stus.remove({age:28},true)</td><td>可以根据条件来删除stus集合中的文档,只删除一个</td></tr><tr><td>db.stus.remove({})</td><td>删除stus中的所有文档（性能略差），stus集合还在</td></tr><tr><td>db.stus.drop()</td><td>删除stus集合,如果stus集合是数据库中的最后一个，那么数据库也会被删除</td></tr><tr><td>db.dropDatabase()</td><td>删除所在的数据库</td></tr><tr><td>db.&lt;collection&gt;.deleteOne()</td><td>删除集合中的一个对象</td></tr><tr><td>db.&lt;collection&gt;.deleteMany()</td><td>删除集合中的多个对象</td></tr></tbody></table><ul><li><p>文档之间的关系</p><ul><li><p>一对一(one to one)</p><ul><li><p>夫妻（一个丈夫 对应 一个妻子）</p></li><li><p>在MongoDB可以通过内嵌文档的形式来体现出一对一的关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">use wifeAndHusband;<br>db.wifeAndHusband.insert([<br>&#123;<br>name:&quot;黄蓉&quot;,<br>husband:<br>&#123;<br>name:&quot;郭靖&quot;,<br>&#125;<br>&#125;,<br>&#123;<br>name:&quot;&quot;,<br>husband:<br>&#123;<br>name:&quot;武大郎&quot;,<br>&#125;<br>&#125;<br>]);<br><br>db.wifeAndHusband.find();<br></code></pre></td></tr></table></figure></li></ul></li><li><p>一对多(one to many)&#x2F;多对一(many to one)</p><ul><li><p>也可以通过内嵌文档来映射一对多的关系</p></li><li><p>父母 – 孩子</p></li><li><p>用户 – 订单</p></li><li><p>文章 – 评论</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.users.insert(<br>[<br>&#123;<br>username:&quot;swk&quot;,<br>&#125;,<br>&#123;<br>username:&quot;zbj&quot;,<br>&#125;<br><br>]<br>);<br>db.users.find();<br><br>db.order.insert(<br>&#123;<br>list:[&quot;苹果&quot;,&quot;香蕉&quot;,&quot;大鸭梨&quot;],<br>user_id:ObjectId(&quot;6352bdd40a470000750024d8&quot;),<br>&#125;<br><br>);<br>db.order.find();<br><br>db.order.insert(<br>&#123;<br>list:[&quot;西瓜&quot;,&quot;葡萄&quot;,&quot;桃子&quot;],<br>user_id:ObjectId(&quot;6352bdd40a470000750024d9&quot;),<br>&#125;<br><br>);<br>db.order.find();<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查找用户swk的订单<br>var user_id <span class="hljs-operator">=</span> db.users.findOne(&#123;username:&quot;swk&quot;&#125;)._id;<br>db.order.find(&#123;user_id:user_id&#125;);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>多对多(many to many)</p><ul><li><p>分类 – 商品</p></li><li><p>老师 – 学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>多对多<br>db.teachers.insert(<br>[<br>&#123;name:&quot;洪七公&quot;&#125;,<br>&#123;name:&quot;黄药师&quot;&#125;,<br>&#123;name:&quot;龟仙人&quot;&#125;,<br>]<br><br>);<br>db.teachers.find()<br><br><br>db.stus.insert(<br>[<br>&#123;<br>name:&quot;郭靖&quot;,<br>tech_isd:<br>[<br>ObjectId(&quot;6352c0260a470000750024dc&quot;),<br>ObjectId(&quot;6352c0260a470000750024dd&quot;),<br>]<br>&#125;,<br>&#123;<br>name:&quot;孙悟空&quot;,<br>tech_isd:<br>[<br>ObjectId(&quot;6352c0260a470000750024dc&quot;),<br>ObjectId(&quot;6352c0260a470000750024dd&quot;),<br>ObjectId(&quot;6352c0260a470000750024de&quot;),<br>]<br>&#125;,<br>]<br>);<br>db.stus.find()<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="排序和投影"><a href="#排序和投影" class="headerlink" title="排序和投影"></a>排序和投影</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>db.&lt;collection&gt;.find({}).sort([属性:1&#x2F;-1])</td><td>对集合中的数据进行排序<br />1表示升序，-1表示降序</td></tr><tr><td>db.stus.find({}).sort({age:1,name:-1})</td><td>对stus集合中所有的数据按照年龄升序，name降序进行排序</td></tr><tr><td>db.&lt;collection&gt;.find({},{属性:1&#x2F;0})</td><td>对集合中的数据字段进行筛选<br />1表示显示，0表示不显示</td></tr><tr><td>db.stus.find({},{name:1,_id:0,gender:1});</td><td>对stus集合中的数据，显示name和gender字段，不显示_id字段，默认显示_id字段</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询文档时，默认情况是按照创建的时间进行排序（升序），视频上说是按照_id，实际上我测试不是的，是根据创建时间进行排序<br>db.stus.find(&#123;&#125;);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>sort()可以用来指定文档的排序规则，sort()需要传递一个对象来指定排序规则，<span class="hljs-number">1</span>表示升序，<span class="hljs-number">-1</span>表示降序<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>limit <span class="hljs-keyword">skip</span> sort 可以以任意的顺序进行调用<br>db.stus.find(&#123;&#125;).sort(&#123;age:<span class="hljs-number">1</span>,name:<span class="hljs-number">-1</span>&#125;)<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>在查询时，可以在第二个参数的位置来设置查询结果的投影，<span class="hljs-number">1</span>表示显示，<span class="hljs-number">0</span>表示不显示<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>显示name，不显示_id,显示gender<br>db.stus.find(&#123;&#125;,&#123;name:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>,gender:<span class="hljs-number">1</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="mongoose的使用"><a href="#mongoose的使用" class="headerlink" title="mongoose的使用"></a>mongoose的使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.安装Mongoose</span><br><span class="hljs-comment">准备：</span><br><span class="hljs-comment">切换为淘宝镜像命令</span><br><span class="hljs-comment">npm config set registry https://registry.npm.taobao.org</span><br><span class="hljs-comment">查看当前使用的镜像地址命令</span><br><span class="hljs-comment">npm config get registry</span><br><span class="hljs-comment">如果返回 https://registry.npm.taobao.org，说明镜像配置成功。</span><br><span class="hljs-comment">切换回原镜像（安装一些package不容易报错）</span><br><span class="hljs-comment">npm config set registry https://registry.npmjs.org</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正式安装：</span><br><span class="hljs-comment">    cnpm i mongoose --save</span><br><span class="hljs-comment">2. 在项目中引入mongoose</span><br><span class="hljs-comment">    var mongoose = require(&quot;mongoose&quot;);</span><br><span class="hljs-comment">3. 连接MongoDB数据库</span><br><span class="hljs-comment">    mongoose.connect(&#x27;mongodb://数据库Ip地址:端口号/数据库名称&#x27;,&#123;useMongoClient:true&#125;);</span><br><span class="hljs-comment">    - 如果端口号是默认端口号(27017)则可以省略不写</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4. 断开数据库连接(一般不需要调用)</span><br><span class="hljs-comment">    - MongoDB数据库，一般情况下，只需要连接一次，连接一次后，除非项目停止，服务器关闭，否则连接一般不会断开</span><br><span class="hljs-comment">    mongoose.disconnect()</span><br><span class="hljs-comment">    - 监听MongoDB数据库的连接状态</span><br><span class="hljs-comment">        - 在Mongoose对象中，有一个属性叫做connection,该对象表示的就是数据库连接</span><br><span class="hljs-comment">            通过监视该对象的状态，可以来监听数据库的连接与断开</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        数据库连接成功的事件</span><br><span class="hljs-comment">            mongoose.connection.once(&quot;open&quot;,function()&#123;&#125;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        数据库断开的事件</span><br><span class="hljs-comment">            mongoose.connection.once(&quot;close&quot;,function()&#123;&#125;);</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br><br><br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;);<br><br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;close&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接已经断开&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">//断开数据库连接</span><br>mongoose.<span class="hljs-title function_">disconnect</span>();<br></code></pre></td></tr></table></figure><h5 id="Schema和Model"><a href="#Schema和Model" class="headerlink" title="Schema和Model"></a>Schema和Model</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//import mongoose from &#x27;mongoose&#x27;;</span><br><br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;)<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Schema</span> &#125; = mongoose;<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> stuSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-attr">title</span>:  <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">gender</span>:&#123;<br>        <span class="hljs-comment">//gender是个对象，类型是String,默认值是female</span><br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&quot;female&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">address</span>:<span class="hljs-title class_">String</span>,<br>&#125;);<br><br><span class="hljs-comment">//通过Schema来创建Model</span><br><span class="hljs-comment">//Model代表的是数据库中的集合，通过Model才能鬼数据库进行操作</span><br><span class="hljs-comment">//mongoose.model(modelName, schema)</span><br><span class="hljs-comment">//modelName:就是要映射的集合名,实际映射的是students集合，mongoose会自动将集合名称变为负数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;student&#x27;</span>, stuSchema);<br><br><span class="hljs-comment">//向数据库中插入一个文档</span><br><span class="hljs-comment">//stuModel.create(doc,function(err)&#123;&#125;);</span><br><span class="hljs-comment">//doc:要插入的文档  function(err)&#123;&#125;:回调函数</span><br><span class="hljs-comment">// StuModel.create(&#123;</span><br><span class="hljs-comment">//     name:&quot;孙悟空&quot;,</span><br><span class="hljs-comment">//     age:18,</span><br><span class="hljs-comment">//     gender:&quot;male&quot;,</span><br><span class="hljs-comment">//     address:&quot;花果山&quot;,</span><br><span class="hljs-comment">// &#125;,function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;插入成功~~~&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">//会自动将属性gender设置为female</span><br><span class="hljs-title class_">StuModel</span>.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;白骨精&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">16</span>,<br>    <span class="hljs-attr">address</span>:<span class="hljs-string">&quot;白骨洞&quot;</span>,<br>&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!err)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;插入成功~~~&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="Model的方法"><a href="#Model的方法" class="headerlink" title="Model的方法"></a>Model的方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;)<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Schema</span> &#125; = mongoose;<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> stuSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-comment">//原本这里是title:String,自己怎么插入name都无法插入，改成name就能够插入了</span><br>    <span class="hljs-attr">name</span>:  <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">gender</span>:&#123;<br>        <span class="hljs-comment">//gender是个对象，类型是String,默认值是female</span><br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&quot;female&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">address</span>:<span class="hljs-title class_">String</span>,<br>&#125;);<br><br><span class="hljs-comment">//通过Schema来创建Model</span><br><span class="hljs-comment">//Model代表的是数据库中的集合，通过Model才能鬼数据库进行操作</span><br><span class="hljs-comment">//mongoose.model(modelName, schema)</span><br><span class="hljs-comment">//modelName:就是要映射的集合名,实际映射的是students集合，mongoose会自动将集合名称变为负数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;students&#x27;</span>, stuSchema);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * - 有了Model，我们就可以来对数据库进行增删改查的操作</span><br><span class="hljs-comment"> *  添加</span><br><span class="hljs-comment"> *  Model.create(docs,[options],[callback])</span><br><span class="hljs-comment"> *  用来创建一个文档并添加到数据库中</span><br><span class="hljs-comment"> *  参数：</span><br><span class="hljs-comment"> *  docs:可以是一个文档对象，也可以是一个文档对象的数组</span><br><span class="hljs-comment"> *  callback:当操作完成以后调用的回调函数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  查找</span><br><span class="hljs-comment"> *  Model.find(filter,[projection],[options],[callback])</span><br><span class="hljs-comment"> *      查询所有符合条件的文档,总会返回一个数组(即便是空数组)</span><br><span class="hljs-comment"> *      filter:查询的条件</span><br><span class="hljs-comment"> *      project:投影 需要获取到的字段</span><br><span class="hljs-comment"> *          - 两种方式</span><br><span class="hljs-comment"> *              &#123;name:1,_id:0&#125;</span><br><span class="hljs-comment"> *              &quot;name -_id&quot;</span><br><span class="hljs-comment"> *      options:查询选项(skip limit)</span><br><span class="hljs-comment"> *          跳过前三个，只显示后面的一个</span><br><span class="hljs-comment"> *          &#123;skip:3,limit:1&#125;</span><br><span class="hljs-comment"> *      callback:回调函数,查询结果会通过回调函数返回，回调函数必须传，如果不传回调函数,根本不会查询</span><br><span class="hljs-comment"> *  Model.findById(id,[projection],[options],[callback])</span><br><span class="hljs-comment"> *      根据文档的id属性查询文档 总会返回一个具体的文档对象</span><br><span class="hljs-comment"> *  Model.findOne([conditioins],[projection],[options],[callback])</span><br><span class="hljs-comment"> *      查询符合条件的第一个文档 总会返回一个具体的文档对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  修改</span><br><span class="hljs-comment"> *  Model.update(filter,update,[options],[callback])</span><br><span class="hljs-comment"> *  Model.updateMany(filter,update,[options],[callback])</span><br><span class="hljs-comment"> *  Model.updateOne(filter,update,[options],[callback])</span><br><span class="hljs-comment"> *      - 用来修改一个或多个文档</span><br><span class="hljs-comment"> *      - 参数</span><br><span class="hljs-comment"> *          filter 查询条件</span><br><span class="hljs-comment"> *          update 修改后的对象</span><br><span class="hljs-comment"> *          options 配置参数</span><br><span class="hljs-comment"> *          callback 回调函数</span><br><span class="hljs-comment"> *  Model.replaceOne(filter,doc,[options],[callback])</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  删除</span><br><span class="hljs-comment"> *  Model.remove([options],[fn])</span><br><span class="hljs-comment"> *  Model.deleteOne(conditions,[options],[callback])</span><br><span class="hljs-comment"> *  Model.deleteMany(conditions,[options],[callback])</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  统计文档的数量</span><br><span class="hljs-comment"> *  Model.count(filter,[callback])</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// StuModel.create([</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         name:&quot;猪八戒&quot;,</span><br><span class="hljs-comment">//         age:28,</span><br><span class="hljs-comment">//         gender:&quot;male&quot;,</span><br><span class="hljs-comment">//         address:&quot;高老庄&quot;,</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//     &#125;,</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         name:&quot;唐僧&quot;,</span><br><span class="hljs-comment">//         age:16,</span><br><span class="hljs-comment">//         gender:&quot;male&quot;,</span><br><span class="hljs-comment">//         address:&quot;女儿国&quot;,</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//     &#125;,</span><br><span class="hljs-comment">// ],function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;插入成功~~~&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">// StuModel.create([</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         name:&quot;沙僧&quot;,</span><br><span class="hljs-comment">//         age:36,</span><br><span class="hljs-comment">//         gender:&quot;male&quot;,</span><br><span class="hljs-comment">//         address:&quot;流沙河&quot;,</span><br><span class="hljs-comment">//     &#125;,</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ],function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(arguments);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">// 运行后的输出结果</span><br><span class="hljs-comment">// 0:应该就是err参数</span><br><span class="hljs-comment">// 1:就是我们插入的文档</span><br><span class="hljs-comment">// [Arguments] &#123;</span><br><span class="hljs-comment">//     &#x27;0&#x27;: null,</span><br><span class="hljs-comment">//         &#x27;1&#x27;: [</span><br><span class="hljs-comment">//         &#123;</span><br><span class="hljs-comment">//             age: 36,</span><br><span class="hljs-comment">//             gender: &#x27;male&#x27;,</span><br><span class="hljs-comment">//             address: &#x27;流沙河&#x27;,</span><br><span class="hljs-comment">//             _id: new ObjectId(&quot;6353a555d75ad742ba9e5e3d&quot;),</span><br><span class="hljs-comment">//             __v: 0</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     ]</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 只要name属性，不要_id属性</span><br><span class="hljs-comment">// StuModel.find(&#123;name:&quot;唐僧&quot;&#125;,&#123;name:1,_id:0&#125;,function (err,docs) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(docs);</span><br><span class="hljs-comment">//         console.log(docs[0].name);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">//-_id指不要_id</span><br><span class="hljs-comment">// skip:1 指跳过第一个，显示后面的</span><br><span class="hljs-comment">// limit:1 指只显示一个</span><br><span class="hljs-comment">// StuModel.find(&#123;&#125;,&#x27;name age -_id&#x27;,&#123;skip:1,limit:1&#125;,function (err,docs) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(docs);</span><br><span class="hljs-comment">//         console.log(docs[0].name);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">//返回的是具体的对象</span><br><span class="hljs-comment">// StuModel.findOne(&#123;&#125;,function (err,doc) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(doc);</span><br><span class="hljs-comment">//         console.log(doc.name);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">//返回的是具体的对象</span><br><span class="hljs-comment">// StuModel.findById(&quot;6353ad5d5bd5fcedc0b7658b&quot;,function (err,doc) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         // console.log(doc);</span><br><span class="hljs-comment">//         // 通过find()查询的结果，返回的对象就是Document,文档对象</span><br><span class="hljs-comment">//         // Document对象是Model的实例，就是集合（StuModel）的实例</span><br><span class="hljs-comment">//         // 返回true，表示doc是StuModel的实例</span><br><span class="hljs-comment">//         console.log(doc instanceof StuModel)</span><br><span class="hljs-comment">//         // console.log(doc.name);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">// 修改唐僧的年龄为20</span><br><span class="hljs-comment">// StuModel.updateOne(&#123;name:&quot;唐僧&quot;&#125;,&#123;$set:&#123;age:20&#125;&#125;,function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;修改成功&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">// collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.</span><br><span class="hljs-comment">// StuModel.remove(&#123;name:&quot;唐僧&quot;&#125;,function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;删除成功&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br>统计集合中的文档数量<br><span class="hljs-title class_">StuModel</span>.<span class="hljs-title function_">count</span>(&#123;&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err,count</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!err)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="Document的方法"><a href="#Document的方法" class="headerlink" title="Document的方法"></a>Document的方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;)<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Schema</span> &#125; = mongoose;<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> stuSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-attr">name</span>:  <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">gender</span>:&#123;<br>        <span class="hljs-comment">//gender是个对象，类型是String,默认值是female</span><br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&quot;female&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">address</span>:<span class="hljs-title class_">String</span>,<br>&#125;);<br><br><span class="hljs-comment">//通过Schema来创建Model</span><br><span class="hljs-comment">//Model代表的是数据库中的集合，通过Model才能鬼数据库进行操作</span><br><span class="hljs-comment">//mongoose.model(modelName, schema)</span><br><span class="hljs-comment">//modelName:就是要映射的集合名,实际映射的是students集合，mongoose会自动将集合名称变为负数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;student&#x27;</span>, stuSchema);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Document 和集合中的文档一一对应，Document是Model的实例</span><br><span class="hljs-comment"> * 通过Model查询到的结果都是Document</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * document的方法</span><br><span class="hljs-comment"> *  Model#save(&#123;options&#125;,[fn])</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StuModel</span>(&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;奔波霸&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">48</span>,<br>    <span class="hljs-attr">gender</span>:<span class="hljs-string">&quot;male&quot;</span>,<br>    <span class="hljs-attr">address</span>:<span class="hljs-string">&quot;碧波谭&quot;</span>,<br>&#125;);<br><br><span class="hljs-comment">//会将文档中的信息进行保存</span><br><span class="hljs-comment">// stu.save(function(err)&#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;保存成功&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-title class_">StuModel</span>.<span class="hljs-title function_">findOne</span>(&#123;&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err,doc</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!err)&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * update(update,[options],[callback])</span><br><span class="hljs-comment">         *  - 修改对象</span><br><span class="hljs-comment">         * remove([callback])</span><br><span class="hljs-comment">         *  - 删除对象</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// console.log(doc);</span><br>        <span class="hljs-comment">//这个doc就是指findOne()找到的那个对象，直接修改该对象</span><br>        <span class="hljs-comment">// doc.update(&#123;$set:&#123;age:38&#125;&#125;,function (err) &#123;</span><br>        <span class="hljs-comment">//     if(!err)&#123;</span><br>        <span class="hljs-comment">//         console.log(&quot;修改成功&quot;);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// &#125;);</span><br>        <span class="hljs-comment">//也可以直接修改findOne()获得的对象</span><br>        <span class="hljs-comment">// doc.age = 18;</span><br>        <span class="hljs-comment">// doc.save();</span><br>        <span class="hljs-comment">//直接删除findOne()获得的对象</span><br>        <span class="hljs-comment">// doc.remove(function (err) &#123;</span><br>        <span class="hljs-comment">//     if(!err)&#123;</span><br>        <span class="hljs-comment">//         console.log(&quot;二师兄再见&quot;);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// &#125;);</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * get(name)</span><br><span class="hljs-comment">         *  - 直接获取文档中指定属性值</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *  set(name,value)</span><br><span class="hljs-comment">         *  - 设置文档的指定的属性值</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *  id</span><br><span class="hljs-comment">         *      获取文档的_id属性值</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *  toObject()</span><br><span class="hljs-comment">         *      - 将Document对象转换为一个普通的js对象</span><br><span class="hljs-comment">         *          转换为普通的js对象以后，注意所有的Document对象的方法或属性都不能使用</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 下面两个的效果相同</span><br>        <span class="hljs-comment">// console.log(doc.get(&quot;name&quot;));</span><br>        <span class="hljs-comment">// console.log(doc.name);</span><br><br>        <span class="hljs-comment">// doc.set(&quot;name&quot;,&quot;猪小小&quot;);</span><br>        <span class="hljs-comment">// doc.name = &quot;猪小小&quot;;</span><br>        <span class="hljs-comment">// console.log(doc);</span><br><br>        <span class="hljs-comment">// console.log(doc._id);</span><br>        <span class="hljs-comment">// new ObjectId(&quot;6353ee24148021db079f47db&quot;)</span><br><br>        <span class="hljs-comment">// console.log(doc.id);</span><br>        <span class="hljs-comment">// 6353ee24148021db079f47db</span><br><br>        <span class="hljs-comment">//转换为一个普通的对象</span><br>        <span class="hljs-comment">// var o = doc.toObject();</span><br>        <span class="hljs-comment">// console.log(o);</span><br><br>        <span class="hljs-comment">//转换为普通的Object后能够删除其中的address,否则不能使用delete删除数据</span><br>        doc = doc.<span class="hljs-title function_">toObject</span>();<br>        <span class="hljs-keyword">delete</span> doc.<span class="hljs-property">address</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doc);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doc.<span class="hljs-property">id</span>);<br>        <span class="hljs-comment">//undefined</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doc.<span class="hljs-property">_id</span>);<br>        <span class="hljs-comment">// new ObjectId(&quot;6353ee24148021db079f47db&quot;)</span><br>    &#125;<br><br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="mongoose的模块化"><a href="#mongoose的模块化" class="headerlink" title="mongoose的模块化"></a>mongoose的模块化</h5><p>可以在models包中创建模型，后面可以直接使用该模型，如index.js中的使用，tools包中主要是放连接mongoDB的代码，可以不用每次都重复写</p><p><a href="https://imgse.com/i/xguig1"><img src="https://s1.ax1x.com/2022/10/22/xguig1.png" alt="xguig1.png"></a></p><p>conn_mongo.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个模块，用来连接MongoDB数据库</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>student.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来定义Student的模型</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;)<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Schema</span> &#125; = mongoose;<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> stuSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-comment">//原本这里是title:String,自己怎么插入name都无法插入，改成name就能够插入了</span><br>    <span class="hljs-attr">name</span>:  <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">gender</span>:&#123;<br>        <span class="hljs-comment">//gender是个对象，类型是String,默认值是female</span><br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&quot;female&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">address</span>:<span class="hljs-title class_">String</span>,<br>&#125;);<br><br><span class="hljs-comment">//定义模型</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;students&#x27;</span>, stuSchema);<br><br><span class="hljs-comment">// exports.model = StuModel;</span><br><span class="hljs-comment">//使用该语句在index.js中就不需要.model了</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">StuModel</span>;<br></code></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入会直接执行该模块</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./tools/conn_mongo&quot;</span>);<br><span class="hljs-comment">// const Student = require(&quot;./models/student&quot;).model;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Student</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./models/student&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Student</span>);<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-title function_">find</span>(&#123;&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err,docs</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!err)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(docs);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="https://blog.csdn.net/weixin_45182409/article/details/117981169" title="csdn博客npm相关使用">npm相关配置</a></p><h4 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h4><p><a href="https://www.bilibili.com/video/BV18s411E78K" title="尚硅谷MongoDB学习视频">参考B站视频</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex表示数学符号</title>
    <link href="/2024/09/10/LaTex%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"/>
    <url>/2024/09/10/LaTex%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h4 id="长期更新-慢慢添加"><a href="#长期更新-慢慢添加" class="headerlink" title="长期更新,慢慢添加"></a>长期更新,慢慢添加</h4><ul><li>因为自己有时候会学一些数学相关的东西,会用公式表示,用 LaTex 的好看啊</li><li>目录在右边,可以导航用</li></ul><h4 id="上标-下标"><a href="#上标-下标" class="headerlink" title="上标,下标"></a>上标,下标</h4><p>$$<br>a^b<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a^b<br></code></pre></td></tr></table></figure><p>$$<br>a_b<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a_b<br></code></pre></td></tr></table></figure><p>$$<br>a^{ab}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a^&#123;ab&#125;<br></code></pre></td></tr></table></figure><p>$$<br>a_{ab}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a_&#123;ab&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\overset{B}{\rightarrow}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">\overset&#123;B&#125;&#123;\rightarrow&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\underset{B}{\rightarrow}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">\underset&#123;B&#125;&#123;\rightarrow&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/10/hello-world/"/>
    <url>/2024/09/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hello World</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用记录</title>
    <link href="/2024/09/10/git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/09/10/git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="Git-干嘛的"><a href="#Git-干嘛的" class="headerlink" title="Git 干嘛的"></a>Git 干嘛的</h4><ul><li>分布式版本控制系统</li></ul><h4 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h4><h5 id="查看-git-版本"><a href="#查看-git-版本" class="headerlink" title="查看 git 版本"></a>查看 git 版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git -v<br></code></pre></td></tr></table></figure><h5 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置用户名</span><br>git config --global user.name &quot;wing2791&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上述的用户名可以省略双引号,如果用户名有空格，则无法省略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略(<span class="hljs-built_in">local</span>):本地配置,只对本地仓库有效</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--global: 全局配置,所有仓库生效</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--system: 系统配置,对所有用户生效</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置邮箱</span><br>git config --global user.email wing2791@163.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存用户名和密码，这样就不用每次都输入了</span><br>git config --global credential.helper store<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看配置信息</span><br>git config --global --list<br></code></pre></td></tr></table></figure><h5 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir learn-git<br>cd learn-git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化空仓库,会以learn-git为仓库</span><br>git init<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会在learn-git文件夹下创建一个my-repo文件夹,以my-repo文件夹为仓库</span><br>git init my-repo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加仓库地址，克隆仓库到本地</span><br>git clone https//....git<br></code></pre></td></tr></table></figure><h5 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span><br>git status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态的简略模式,??表示为跟踪，M表示修改</span><br>git status -s<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件添加到暂存区</span><br>git add filename.suffix<br><span class="hljs-meta prompt_"># </span><span class="language-bash">git add 支持使用通配符,只添加.txt结尾的文件</span><br>git add *.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以提交文件夹，提交当前文件夹</span><br>git add .<br><span class="hljs-meta prompt_"># </span><span class="language-bash">提交文件,-m表示提交时对文件信息的描述,只提交暂存区中的文件</span><br>git commit -m &quot;the first commit&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看提交记录</span><br>git log<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看简洁信息</span><br>git log --oneline<br></code></pre></td></tr></table></figure><h5 id="git-reset-回退版本"><a href="#git-reset-回退版本" class="headerlink" title="git reset 回退版本"></a>git reset 回退版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --soft # 回退到某个版本,并且保留工作区和暂存区中的所有修改内容<br>git reset --hard # 回退到某个版本,并且丢弃工作区和暂存区的所有修改内容<br>git reset --mixed # 回退到某个版本,并且只保留工作区的修改内容，而丢弃暂存区中的内容（reset默认参数）<br>git reset --soft ID # 需要添加回退版本ID,这个需要用git log查看<br>git ls-files # 查看暂存区内容<br>git reset HEAD^ # 使用--mixed模式，HEAD^指当前 HEAD 的前一个提交<br>git reflog # 查看操作历史记录，可以查看操作的ID号，用于回退<br></code></pre></td></tr></table></figure><h5 id="git-diff-查看差异"><a href="#git-diff-查看差异" class="headerlink" title="git diff 查看差异"></a>git diff 查看差异</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff # 可以查看修改的内容具体是什么，默认比较工作区和暂存区的区别<br>git diff HEAD # 查看工作区和版本库的区别,HEAD指的是最新提交节点<br>git diff --cached # 查看暂存库和版本库的区别<br>git diff ID1 ID2 # 比较两个特定版本库的差异，HEAD~表示上一个版本，HEAD~2表示之前的两个版本<br>git diff ID1 ID2 file1.txt # 只查看file1.txt的修改内容<br></code></pre></td></tr></table></figure><h5 id="版本库中删除文件"><a href="#版本库中删除文件" class="headerlink" title="版本库中删除文件"></a>版本库中删除文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm file1.txt # 删除工作区中文件file1.txt<br>git add . # 更新暂存区，删除暂存区中的file1.txt<br>git rm file2.txt # 会在工作区和暂存区中都删除file2.txt<br>git commit -m &quot;information&quot;<br></code></pre></td></tr></table></figure><h5 id="gitignore-忽略文件"><a href="#gitignore-忽略文件" class="headerlink" title=".gitignore 忽略文件"></a>.gitignore 忽略文件</h5><ul><li>.gitignore 中的内容就是指所有忽略的文件名，也可以是文件夹名，文件夹名是相对于 <code>.gitignore</code> ,例如<code>temp/</code></li><li>如果文件夹是空文件夹，不会被版本管理</li><li><a href="https://git-scm.com/docs/gitignore">git 官网匹配规则</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">*.log # 就是忽略所有的.log文件<br>!a.log # 表示在*.log忽略的规则下，不忽略a.log文件<br>/TODO # 表示只忽略当前目录下的TODO文件，不忽略subdir/TODO<br>build/ # 忽略任何目录下名为build的文件夹<br>doc/*.txt # 只忽略doc文件夹下的所有.txt文件,但是不忽略doc/subdir/*.txt的文件，即不忽略子文件夹下的文件<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果某个文件已经被添加到仓库中,如忽略*.<span class="hljs-built_in">log</span>，但是仓库中有other.log，更新other.log文件的时候，也会一起更新other.log文件</span><br>doc/**/*.pdf # 葫芦doc/目录及其所有子目录下的.pdf文件<br>git rm --cached other.log # 从暂存区中移除文件 other.log<br></code></pre></td></tr></table></figure><h5 id="github-的使用和远程仓库操作"><a href="#github-的使用和远程仓库操作" class="headerlink" title="github 的使用和远程仓库操作"></a>github 的使用和远程仓库操作</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">git@github.com:wing2791/wing2791.github.io.git</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git开头的仓库使用的是SSH协议,在push的时候不需要验证用户名和密码,但是需要在github上添加ssh公钥的配置，添加密钥的时候如果修改了名称，需要额外配置，这里不赘述</span><br>git push &lt;remote&gt; &lt;branch&gt; # 本地仓库的指定分支推送到远程仓库，这里配置好一般直接git push，配置在后面<br>git pull &lt;remote&gt; # 远程仓库拉取到本地<br></code></pre></td></tr></table></figure><h5 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add &lt;shortname&gt; &lt;url&gt; # 关联一个远程仓库<br><span class="hljs-meta prompt_"># </span><span class="language-bash">git remote add roigin git@....git</span><br>git remote -v # 查看当前仓库对应的远程仓库的别名和地址<br>git branch -M main # 指定分支名为main<br>git push -u origin main:main # u是upstream的缩写,把本地仓库和别名为origin仓库的远程仓库关联起来，把本地仓库的main分支推送给远程仓库的main分支，如果本地分支和远程仓库分支名称一样,可以main:main改为main，第一个main本地分支,第二个main远程分支<br><br>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; # 拉去远程仓库修改内容，起其中仓库名和分支名都可以省略，默认为拉取仓库别名为orgin的main分支<br>git fetch # 只会获取远程仓库的修改，但是并不合并到本地仓库中，需要手动合并<br></code></pre></td></tr></table></figure><h5 id="分支的使用"><a href="#分支的使用" class="headerlink" title="分支的使用"></a>分支的使用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch 分支名 # 创建一个新的分支<br>git checkout 分支1 # 切换到分支1，checkout也可以用来恢复文件，会产生歧义，故换一个切换分支的命令切换到分支1<br>git switch 分支1 # 切换到分支1<br>git merge 分支1 # 假如现在处在main分支，运行该命令可以将分支1中的内容合并到main中<br>git log --graph --oneline --decorate --all # 查看分支图<br>git branch -d branch-name # 当branch-name被合并后，可以用-d进行删除<br>git branch -D branch-name # 强制删除分支branch-name<br></code></pre></td></tr></table></figure><h5 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -a -m &quot;commit content&quot; # -a参数会直接添加到暂存区，然后提交到仓库，完成两个步骤，这个只对已经添加过的文件生效，新文件无法使用，-a -m 可以写成-am<br>git status # 可以查看冲突文件的列表<br>git diff # 可以查看冲突的具体内容<br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后直接查看原文件，可以手动修改冲突内容，重新添加，提交即可</span><br>git add .<br>git commit -m &quot;commit cotent&quot;<br>git merge --abort # 中止合并<br></code></pre></td></tr></table></figure><h5 id="回退和-rebase"><a href="#回退和-rebase" class="headerlink" title="回退和 rebase"></a>回退和 rebase</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase branch-name<br>git checkout -b dev ID # 恢复到dev分支的ID的时刻，看来checkout很多功能啊<br>alias graph=&quot;git log --graph --oneline --decorate --all&quot; # 可以把查看图形化的提交记录命令改为graph<br></code></pre></td></tr></table></figure><p>merge</p><ul><li>优点<ul><li>不会破坏原分支的提交历史，方便回溯和查看</li></ul></li><li>缺点<ul><li>会产生额外的提交节点，分支图比较复杂</li></ul></li></ul><p>rebase</p><ul><li>优点<ul><li>不会新增额外的提交记录，形成线性历史，比较直观和干净</li></ul></li><li>缺点<ul><li>会改变提交历史，改变了当前分支 branch out 的节点，避免在共享分支使用</li></ul></li></ul><h5 id="分支管理和工作流模型"><a href="#分支管理和工作流模型" class="headerlink" title="分支管理和工作流模型"></a>分支管理和工作流模型</h5><p><img src="https://s21.ax1x.com/2024/09/10/pAm8EYd.png" alt="202408070024207"></p><p><img src="https://s21.ax1x.com/2024/09/10/pAm8n6P.png" alt="202408070026443"></p><p><img src="https://s21.ax1x.com/2024/09/10/pAm8mlt.png" alt="202408070026771"></p><h4 id="其他待补充"><a href="#其他待补充" class="headerlink" title="其他待补充"></a>其他待补充</h4><ul><li>git 的权限管理</li><li>在不同编辑器上的使用</li><li>可视化 git 管理工具</li><li>实际使用的例子</li></ul><h4 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h4><p><a href="https://www.bilibili.com/video/BV1HM411377j">【GeekHour】一小时 Git 教程</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>github部署个人博客</title>
    <link href="/2024/09/10/github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/09/10/github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/clearloe/article/details/139879493">Hexo 博客搭建并部署到 GitHub Pages(2024 最新详细版)</a></p><h4 id="安装-VsCode"><a href="#安装-VsCode" class="headerlink" title="安装 VsCode"></a>安装 VsCode</h4><p><a href="https://blog.csdn.net/msdcp/article/details/127033151">VSCode 安装配置使用教程（最新版超详细保姆级含插件）一文就够了</a></p><p><a href="https://code.visualstudio.com/Download">VsCode 下载链接</a></p><ul><li>如果无法下载，可以选择在电脑的应用商城里面下载，我记得是要挂梯子才能官网下载</li><li>安装就是正常安装，建议别 C 盘</li></ul><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><p><a href="https://blog.csdn.net/qq_45730223/article/details/131693287">Git 安装详解（写吐了，看完不后悔）</a></p><ul><li>很常用的软件，程序员必装，按照教程装就好了，不过有时候验证有问题，也要梯子</li></ul><h4 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h4><p><a href="https://blog.csdn.net/weixin_44893902/article/details/121788104">node.js 安装及环境配置超详细教程【Windows 系统安装包方式】</a></p><blockquote><p>搬运上述链接评论<br>Node.js Express 安装报错总结<br>express 4.x 版本之前 全局安装 express 命令是 npm install express -g<br>express 4.x 版本之后 全局安装 express 命令是 npm install -g express-generator</p></blockquote><h4 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h4><p><a href="https://www.cnblogs.com/zhujingxiu/articles/7462025.html" title="发布于 2017-09-01 10:34">Win10 任意目录下默认快速以管理员身份运行 CMD</a><br><a href="https://blog.csdn.net/clearloe/article/details/139879493">安装 hexo 参考博客链接</a><br><a href="https://blog.csdn.net/qq_42786011/article/details/123895927">运行 npm install 不动时</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">//  配置nmp代理来提高速度，如设置淘宝镜像<br>npm config set registry  https://registry.npmmirror.com/<br><br>// 查看配置是否成功<br>npm config get registry<br><br>// 成功后重新npm install安装<br>// npm install 。。。<br></code></pre></td></tr></table></figure><h4 id="更新文章"><a href="#更新文章" class="headerlink" title="更新文章"></a>更新文章</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo c &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo c &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h4 id="遇上的错误，解决方法供参考"><a href="#遇上的错误，解决方法供参考" class="headerlink" title="遇上的错误，解决方法供参考"></a>遇上的错误，解决方法供参考</h4><h5 id="fatal-detected-dubious-ownership-in-repository"><a href="#fatal-detected-dubious-ownership-in-repository" class="headerlink" title="fatal: detected dubious ownership in repository"></a>fatal: detected dubious ownership in repository</h5><p><a href="https://stackoverflow.com/questions/73408170/git-fatal-detected-dubious-ownership">参考博客</a></p><p><img src="https://s21.ax1x.com/2024/09/10/pAm8py6.png" alt="202407281829173"></p><ul><li>解决方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global --add safe.directory *<br></code></pre></td></tr></table></figure><h5 id="安装-Pandoc，运行-Pandoc-有误，说找不到命令"><a href="#安装-Pandoc，运行-Pandoc-有误，说找不到命令" class="headerlink" title="安装 Pandoc，运行 Pandoc 有误，说找不到命令"></a>安装 Pandoc，运行 Pandoc 有误，说找不到命令</h5><blockquote><p>主要问题是我的 360 会自动删除 pandoc.exe,我在 360 软件管家中的隔离区恢复了就行</p></blockquote><p><a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md">pandoc 安装地址</a></p><p>正常安装是有下面的四个文件，如果少了 exe 需要按照上面的进行恢复</p><p><img src="https://s21.ax1x.com/2024/09/10/pAm8iwD.png" alt="202407281832443"></p><h5 id="Hexo-使用-markdown-插入图片无法显示解决方法（废弃，直接找网络图床，https-的）"><a href="#Hexo-使用-markdown-插入图片无法显示解决方法（废弃，直接找网络图床，https-的）" class="headerlink" title="Hexo 使用 markdown 插入图片无法显示解决方法（废弃，直接找网络图床，https 的）"></a>Hexo 使用 markdown 插入图片无法显示解决方法（废弃，直接找网络图床，https 的）</h5><blockquote><p>免费图床：<a href="https://imgse.com/">https://imgse.com/</a><br>每天八张</p></blockquote><p><a href="https://www.jianshu.com/p/04814a816caf">参考博客</a></p><ul><li><p>安装插件</p><ul><li><p>先进入自己 blog 的目录<br><img src="https://s21.ax1x.com/2024/09/10/pAm8PeO.png" alt="image-20240728203701626"></p></li><li><p>用命令安装（如果第二次使用还是失效，重新运行下列命令，会重新安装一遍，再弄就是可以了，具体的解决方案没找到）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># npm install https://github.com/7ym0n/hexo-asset-image --save # 已经失效，换一个</span><br>npm install hexo-asset-img --save<br></code></pre></td></tr></table></figure></li><li><p>运行下列命令，提交本地查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s # 本地查看<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d # 上传到github<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改 hexo 根目录下的_config.yml 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">post_asset_folder: <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br>url: http://yourname.github.io<br></code></pre></td></tr></table></figure></li><li><p>插入图片</p><ul><li>我用的是 typora，直接设置如下，然后复制图片，直接到文件中即可</li></ul><p><img src="https://s21.ax1x.com/2024/09/10/pAm8FTe.png" alt="image-20240728204034558"></p><p><img src="https://s21.ax1x.com/2024/09/10/pAm8AFH.png" alt="image-20240728204107912"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">![xx](xx/xx.png)<br></code></pre></td></tr></table></figure></li></ul><h4 id="其他可能用得上的网址"><a href="#其他可能用得上的网址" class="headerlink" title="其他可能用得上的网址"></a>其他可能用得上的网址</h4><p><a href="https://hexo.io/zh-cn/docs">Hexo 官方中文文档</a><br><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-游戏(一)</title>
    <link href="/2024/09/10/%E6%9D%82%E8%B0%88-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/09/10/%E6%9D%82%E8%B0%88-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="游戏杂谈"><a href="#游戏杂谈" class="headerlink" title="游戏杂谈"></a>游戏杂谈</h3><h4 id="双人成行"><a href="#双人成行" class="headerlink" title="双人成行"></a>双人成行</h4><p><img src="https://s2.loli.net/2022/07/20/dxheYjZ9R7vU5iw.png" alt="双人成行.png"></p><p>游玩：本人也是正经的玩过全流程的，和 Z 同学一点点摸索着玩，但是由于 origin 平台实在是连接困难，加上网络不好，在线游玩属实是体验不好，总是会掉线，玩着玩着就开始卡顿，掉线，每次重新连接大概五分钟，挺折磨人的耐心。</p><p>另外关于游玩方面，Z 同学和我都不是高玩，玩起来其实也挺痛苦的，某些关卡对我们来说还挺需要操作和反应速度的，比如有的关卡自己需要在几秒内就跑到指定的位置，错了就要重来，但好在只要成功一次就能够过关，后面会自动保存。有些 Boss 打起来也挺费时间的，例如有个黄蜂的 Boss，那个需要科迪先喷糖浆，小梅后面才能够攻击，而 Boss 还有一些小兵蜜蜂保护，这是一个需要跨过去的坎，游玩过程自己的鼠标都快费了，虽然是自动瞄准，但也是有判定范围的，最后鼠标都移动困难了。</p><p>关卡在设计方面非常有新意，是我玩过的游戏中不可多得的必玩游戏，可惜需要有一个朋友，配置要求极高。前期的关卡设计挺多，也有剧情，不过都 Q 掉了，后面几大章节明显不如前几关，而且神庙逃亡太多了，颜色也过于鲜艳，属于虎头蛇尾了，但是质量还是高于大多数同类游戏。音乐方面不评价，没咋注意，游戏难度听说是动态的，在某一关待久了听说会降低难度，方便手残玩家，但耗时间，适合平时时间长放松可以试一下，没时间不适合玩，比如累死晚上十点回家，这个游戏建议别试着玩了。</p><h4 id="影之诗"><a href="#影之诗" class="headerlink" title="影之诗"></a>影之诗</h4><p><img src="https://s2.loli.net/2022/07/20/jKwHk72dgOFYVmi.jpg" alt="影之诗.jpg"></p><p>游玩：算是老玩家了，在起焉之光版本入坑，大概一两周后碧蓝骑士版本（在国服，当时国际服应该早就碧蓝骑士版本了），中间退坑过一年的时间，大概就是疫情那段时间，去玩昆特牌了，没碰影之诗，拿过三个版本 GM，优点是无聊，缺点也是无聊。国服的福利极好，随便肝一下每日任务就行，基本上每个版本的所有卡都能拿到，还会有剩余的资源。但是为什么退坑，就是太无聊了，稍微娱乐一点点的卡组就不能玩，而且渐渐的很多东西都脱离实际了，很多职业特色都没有了，像暗夜伯爵原本非常好的一张鬼妈（8 费用，4 攻击，4 生命，虹卡，荣耀再临版本），原来效果是从卡堆里抽到手上时消失，直接无条件复仇，俗称点灯，后来削过后就没意思了，主战者生命上限直接少了一半，对手稍微打一下就输了，而且国服版本特别难玩，稍微有一点不顺就会输，任务有时候打三四个小时都做不好，而且后面设计的卡越来越膨胀，膨胀就算了，还膨胀的特别快，官方削弱卡牌一削弱就不能用，会不会削弱啊，卡牌不会设计就算了，削弱也是一刀切。我最关心的其实是双人模式，可惜一直没出，出不出都不会去玩了，毕竟是二次元游戏，我反而重视游戏性，玩 steam 挺好。</p><h4 id="洛克王国"><a href="#洛克王国" class="headerlink" title="洛克王国"></a>洛克王国</h4><p><img src="https://s2.loli.net/2022/07/20/lRL6wrIn75jkmyX.png" alt="洛克王国.png"></p><p>游玩：也算是个老玩家，基本前期游玩的样子都知道，疫情的时候也是玩到了高级训练师，系别排位也是圣魔导师。前期洛克王国感觉更像是经营类的游戏，战斗没有任何技巧可言，就是想办法控制对面（催眠粉，以及后面的瓦斯叮当的生命火焰，或者雪影娃娃的冰晶结界和冰龙王的嗜血寒冰冰冻），找一个 C 位进行强化进行推队，简单得很，看运气。但是现在的战斗很有趣，基本都是会玩的能够碾压不会玩的，已经不是以前的过家家了，从前期的收集、逛街重点倾向于战斗了，我玩过，很有趣，但是也无聊，每场战斗少则二十分钟，多则上小时，每天十把，累死人，而且网络极度不稳定，极度极度不稳定，退坑原因一方面就是这个，战斗我觉得比王者啥的好多了，操作运营一点不输王者那些游戏，另一方面是 flash 游戏，已经淘汰的技术，网页大多数不支持且有广告。另外前期洛克王国剧情极好，后期就是现在的剧情完全就是白开水，只会玩梗，一点感情没有，看其他大佬分析，游戏封面也敷衍起来了，以前是剧情为主，每周任务也很好，至少挺人性化，现在随便放几个花盆宠，而且每周任务特别恶心人，费时费力，不用辅助手刷我是时间多了没事干啊，游戏已经到了末期了，另外论坛也是很让人头疼的地方。最后提一嘴，氪金吗？也挺氪金的，不过比不上王者一套皮肤的钱，不氪金可以玩，也是大佬，要肝一肝的。最近洛克王国手游也被大众关注，我不看好，不为什么，就是不看好，洛克王国页游都不行，手游也大概率不行，都是刷刷刷的，剧情和所寄托的文化没有，算不上好游戏。原神也火出去了啊？我不玩原神，但那个是手游和 PC 端互通啊，手机方便，但其性能现在远远弱于电脑。</p><h4 id="觅长生"><a href="#觅长生" class="headerlink" title="觅长生"></a>觅长生</h4><p><img src="https://s2.loli.net/2022/07/20/fHcmsZepbixJzMv.png" alt="觅长生.png"></p><p>游玩：依然是 steam 游戏，我很早就在 B 站上看见了，当时还没 ea 版本呢，可惜当时不看好，卡牌？？金木水火土的牌能做出来什么战斗呢，就没管，最近改成灵气球了，无所谓，玩多了都可以。后来鬼谷八荒火了，当时也不知道怎么回事，对修仙游戏极度渴望，找到了觅长生，当时鬼谷八荒还没出事，就是 bug 多，更新慢，饼很多。当时看了飞羽仙狂的游玩，会了打劫流，渐渐熟悉了，制作组诚意很足，每周都更新，还有了 B 站的 wiki，体系完善，就等制作组继续更新了，不过好慢啊，都好多年了，还在 ea 阶段，游戏最近的创意工坊也出来了，玩家实力大大增加，难度降低很多，不过觅长生我更喜欢看看剧情了，飞不飞升要等正式版了（虽然我也化神了），喜欢修仙游戏的可以尝试，至少没有坑，也没有饼，缺点就像 steam 里面说的，可以玩的修仙小说，看剧情和装大佬才是王道啦。另外有一款了不起的修仙模拟器（玩法是修仙门派模拟器）也很好，但学习成本高。有额外资金且对修仙感兴趣可以尝试这两款游戏（觅长生和了不起的休闲模拟器，鬼谷八荒有大坑，别去）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
