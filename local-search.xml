<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cpp知识整理(一)</title>
    <link href="/2025/01/07/Cpp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%80)/"/>
    <url>/2025/01/07/Cpp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><blockquote><p>和C++没有任何关系啦<br>本科遇见ww，虽然联系甚少了，但感谢ww最后一路的支持，不会忘记，所以遇见yf后，更加珍惜了<br>很开心遇见了yf，或许有一天总会分道扬镳，但是从我逐渐学习Cpp或者CSharp的时候，都认识了yf，是好朋友，有困难会两肋插刀<br>如果哪天你们看到了，希望你两个能知道，不仅仅是，做兄弟在心中，也会付出行动</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式(Cpp)</title>
    <link href="/2024/12/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(Cpp)/"/>
    <url>/2024/12/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(Cpp)/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>知识点四_如何标记废弃方法</title>
    <link href="/2024/12/03/%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B_%E5%A6%82%E4%BD%95%E6%A0%87%E8%AE%B0%E5%BA%9F%E5%BC%83%E6%96%B9%E6%B3%95/"/>
    <url>/2024/12/03/%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B_%E5%A6%82%E4%BD%95%E6%A0%87%E8%AE%B0%E5%BA%9F%E5%BC%83%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="如何标记废弃方法"><a href="#如何标记废弃方法" class="headerlink" title="如何标记废弃方法"></a>如何标记废弃方法</h1><h2 id="Cpp"><a href="#Cpp" class="headerlink" title="Cpp"></a>Cpp</h2><p>在C++中，如果要标记某个方法已经废弃，可以使用 <code>[[deprecated]]</code> 属性（attribute）。这是一种现代、清晰的方法，用于提醒开发者某些函数或方法不推荐使用。编译器会在调用这些标记为废弃的方法时生成警告信息。</p><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><ol><li><p><strong>简单标记废弃</strong></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[[deprecated]]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oldFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Implementation of old function</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>带有自定义消息</strong>  </p><ul><li>如果需要说明废弃的原因或建议替代方案，可以加上自定义的警告信息： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;This function is deprecated, use newFunction() instead.&quot;</span>)]]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oldFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Implementation of old function</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>适用于类或变量</strong>  </p><ul><li><code>[[deprecated]]</code> 也可以用于类或变量： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;This class is deprecated, use NewClass instead.&quot;</span>)]]<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OldClass</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br>[[deprecated]]<br><span class="hljs-type">int</span> oldVariable;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> [[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;Use NewClass instead.&quot;</span>)]] OldClass &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;OldClass method&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br>[[<span class="hljs-built_in">deprecated</span>(<span class="hljs-string">&quot;Use newFunction instead.&quot;</span>)]]<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">oldFunction</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;This is an old function&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    OldClass obj;         <span class="hljs-comment">// 编译器会发出警告</span><br>    obj.<span class="hljs-built_in">display</span>();        <span class="hljs-comment">// 编译器会发出警告</span><br><br>    <span class="hljs-built_in">oldFunction</span>();        <span class="hljs-comment">// 编译器会发出警告</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li>需要使用支持 C++14 或更高版本的编译器。</li><li>不同编译器对 <code>[[deprecated]]</code> 的支持和警告信息的详细程度可能会有所不同。<ul><li>Vstudio 2022在编译阶级就报错</li></ul></li></ul><h2 id="Csharp"><a href="#Csharp" class="headerlink" title="Csharp"></a>Csharp</h2><p>在C#中，可以通过使用 <code>Obsolete</code> 特性来标记方法、属性、类等为已废弃。这种方式不仅可以提醒开发者，还可以在使用时生成编译警告或错误。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><strong>简单标记为废弃：</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Obsolete</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OldMethod</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;This method is deprecated.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><strong>效果：</strong> 调用 <code>OldMethod</code> 时，编译器会发出警告。</li><li><strong>提供自定义消息：</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;This method is deprecated. Use NewMethod instead.&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OldMethod</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;This method is deprecated.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><strong>效果：</strong> 调用 <code>OldMethod</code> 时，警告信息会显示提供的自定义消息。</li><li><strong>强制阻止使用（将警告升级为错误）：</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;This method is deprecated. Use NewMethod instead.&quot;</span>, true)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OldMethod</span>()</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;This method is deprecated.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><strong>效果：</strong> 调用 <code>OldMethod</code> 时，编译器会报错，而不是仅仅发出警告。</li><li><strong>应用于类或属性：</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;This class is deprecated. Use NewClass instead.&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OldClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Old class method.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    [<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;Use NewMethod instead.&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OldMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Old method called.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NewMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;New method called.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        OldMethod(); <span class="hljs-comment">// 会触发警告</span><br>        NewMethod(); <span class="hljs-comment">// 正常调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>Obsolete</code> 特性主要用于提醒开发者，实际的逻辑仍然会执行。</li><li>将 <code>Obsolete</code> 特性与 <code>true</code> 参数结合使用时，会阻止编译通过，从而强制开发者迁移到新的实现。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unity知识整理(四_XML)</title>
    <link href="/2024/12/03/Unity%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E5%9B%9B_XML)/"/>
    <url>/2024/12/03/Unity%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E5%9B%9B_XML)/</url>
    
    <content type="html"><![CDATA[<h1 id="XML基本语法"><a href="#XML基本语法" class="headerlink" title="XML基本语法"></a>XML基本语法</h1><ul><li><p>XML格式是一种树形结构<br><img src="https://s2.loli.net/2024/12/05/PwWTGlbLso1axRt.png" alt="Pasted image 20241203201539.png"></p></li><li><p>基本规则</p></li></ul><ol><li>每个元素都必须有关闭标签</li><li>元素命名规则基本遵照C#中变量名命名规则</li><li>XML标签对大小写敏感，name和Name不一样</li><li>XML文档必须有根元素</li><li>特殊的符号应该用实体引用<br> &amp;lt        &lt; 小于<br> &amp;gt       &gt;大于<br> &amp;amp   &amp;和号<br> &amp;apos  ‘单引号<br> &amp;quot  “双引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注释 --&gt;</span><br><span class="hljs-comment">&lt;!-- 固定内容代表xml的版本，使用的编码--&gt;</span><br><span class="hljs-comment">&lt;!-- 所谓的编码格式就是读取文件时,解析字符串使用的编码是什么编码格式,不同的字符在内存中的二进制是不一样的,每一个字符对应一个数字,不同的编码格式字符对应的二进制是不一样的 --&gt;</span><br><span class="hljs-comment">&lt;!-- 乱码出现的情况就是因为用了不一样的编码格式去解析文本内容由于字符和对应的二进制不匹配就会出现乱码 --&gt;</span><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!-- 一定要有一个根节点 --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;节点名&gt;可以填写数据，或者在其中包裹其他的节点&lt;/节点名&gt; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">PlayerInfo</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>wing2791<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">atk</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">atk</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ItemList</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">num</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">num</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Item</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">num</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">num</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Item</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">num</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">num</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Item</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ItemList</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">PlayerInfo</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="XML属性知识点"><a href="#XML属性知识点" class="headerlink" title="XML属性知识点"></a>XML属性知识点</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!-- 一定要有一个根节点 --&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;节点名&gt;可以填写数据，或者在其中包裹其他的节点&lt;/节点名&gt; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 属性就是在元素标签后面空格 添加的内容 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注意：属性必须用引号包裹单引号双引号都可以 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Friend</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;小明&quot;</span>&gt;</span>我的朋友<span class="hljs-tag">&lt;/<span class="hljs-name">Friend</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 如果使用属性记录信息，不想使用元素记录，可以下面这样写 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 属性和元素节点只是写法上的区别而已 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Father</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;父亲&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;50&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>网址检查语法错误<br><a href="https://www.runoob.com/xml/xml-validator.html">https://www.runoob.com/xml/xml-validator.html</a></li></ul><h1 id="Csharp读取存储XML"><a href="#Csharp读取存储XML" class="headerlink" title="Csharp读取存储XML"></a>Csharp读取存储XML</h1><h2 id="XML文件存放位置"><a href="#XML文件存放位置" class="headerlink" title="XML文件存放位置"></a>XML文件存放位置</h2><ul><li><p>TestXML.xml</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;Root&gt;<br>&lt;name&gt;唐老狮&lt;/name&gt;<br>&lt;age&gt;<span class="hljs-number">18</span>&lt;/age&gt;<br>&lt;Item id=<span class="hljs-string">&quot;1&quot;</span> num=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br>&lt;Friend&gt;<br>&lt;name&gt;小明&lt;/name&gt;<br>&lt;age&gt;<span class="hljs-number">8</span>&lt;/age&gt;<br>&lt;/Friend&gt;<br>&lt;Friend&gt;<br>&lt;name&gt;小红&lt;/name&gt;<br>&lt;age&gt;<span class="hljs-number">10</span>&lt;/age&gt;<br>&lt;/Friend&gt;<br>&lt;/Root&gt;<br></code></pre></td></tr></table></figure></li><li><p>只读不写的XML文件</p><ul><li>可以放在Resources或者StreamingAssets文件夹下<ul><li>Resources.Load&lt;TextAsset&gt;(“文件名”);<ul><li>加载的是.txt文件</li></ul></li><li>Application.streamingAssetsPath</li></ul></li></ul></li><li><p>动态存储的XML文件</p><ul><li>放在Application.persistentDataPath路径下<br><img src="https://s2.loli.net/2024/12/05/LIxafOAU3KSXy1k.png" alt="Pasted image 20241203231939.png"></li></ul></li></ul><h2 id="Csharp读取XML文件知识点"><a href="#Csharp读取XML文件知识点" class="headerlink" title="Csharp读取XML文件知识点"></a>Csharp读取XML文件知识点</h2><ul><li><p>加载的文件是TestXML.xml</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;Root&gt;<br>&lt;name&gt;唐老狮&lt;/name&gt;<br>&lt;age&gt;<span class="hljs-number">18</span>&lt;/age&gt;<br>&lt;Item id=<span class="hljs-string">&quot;1&quot;</span> num=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br>&lt;Friend&gt;<br>&lt;name&gt;小明&lt;/name&gt;<br>&lt;age&gt;<span class="hljs-number">8</span>&lt;/age&gt;<br>&lt;/Friend&gt;<br>&lt;Friend&gt;<br>&lt;name&gt;小红&lt;/name&gt;<br>&lt;age&gt;<span class="hljs-number">10</span>&lt;/age&gt;<br>&lt;/Friend&gt;<br>&lt;/Root&gt;<br></code></pre></td></tr></table></figure></li><li><p>LoadXml.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Xml;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadXml</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//C#读取XML的方法有几种</span><br>        <span class="hljs-comment">//1.XmlDocument    (把数据加载到内存中，方便读取)</span><br>        <span class="hljs-comment">//2.XmlTextReader  (以流形式加载，内存占用更少，但是是单向只读，使用不是特别方便，除非有特殊需求，否则不会使用)</span><br>        <span class="hljs-comment">//3.Linq           (以后专门讲Linq的时候讲)</span><br><br>        <span class="hljs-comment">//使用XmlDocument类读取是较方便最容易理解和操作的方法</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 读取xml文件信息</span><br>        <span class="hljs-comment">// using System.Xml;</span><br>        XmlDocument xml = <span class="hljs-keyword">new</span> XmlDocument();<br>        <span class="hljs-comment">//通过XmlDocument读取xml文件 有两个API</span><br>        <span class="hljs-comment">//1.直接根据xml字符串内容 来加载xml文件</span><br>        <span class="hljs-comment">//存放在Resorces文件夹下的xml文件加载处理</span><br>        TextAsset asset = Resources.Load&lt;TextAsset&gt;(<span class="hljs-string">&quot;TestXml&quot;</span>);<br>        print(asset.text);<br>        <span class="hljs-comment">//通过这个方法 就能够翻译字符串为xml对象</span><br>        xml.LoadXml(asset.text);<br><br>        <span class="hljs-comment">//2.是通过xml文件的路径去进行加载</span><br>        xml.Load(Application.streamingAssetsPath + <span class="hljs-string">&quot;/TestXml.xml&quot;</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 读取元素和属性信息</span><br>        <span class="hljs-comment">//节点信息类</span><br>        <span class="hljs-comment">//XmlNode 单个节点信息类</span><br>        <span class="hljs-comment">//节点列表信息</span><br>        <span class="hljs-comment">//XmlNodeList 多个节点信息类</span><br><br>        <span class="hljs-comment">//获取xml当中的根节点</span><br>        XmlNode root = xml.SelectSingleNode(<span class="hljs-string">&quot;Root&quot;</span>);<br>        <span class="hljs-comment">//再通过根节点 去获取下面的子节点</span><br>        XmlNode nodeName = root.SelectSingleNode(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-comment">//如果想要获取节点包裹的元素信息 直接 .InnerText</span><br>        print(nodeName.InnerText);<br><br>        <span class="hljs-comment">// 如果有age同名节点，只会获取到第一个节点</span><br>        XmlNode nodeAge = root.SelectSingleNode(<span class="hljs-string">&quot;age&quot;</span>);<br>        print(nodeAge.InnerText);<br><br>        XmlNode nodeItem = root.SelectSingleNode(<span class="hljs-string">&quot;Item&quot;</span>);<br>        <span class="hljs-comment">//第一种方式 直接 中括号获取信息</span><br>        print(nodeItem.Attributes[<span class="hljs-string">&quot;id&quot;</span>].Value);<br>        print(nodeItem.Attributes[<span class="hljs-string">&quot;num&quot;</span>].Value);<br>        <span class="hljs-comment">//第二种方式</span><br>        print(nodeItem.Attributes.GetNamedItem(<span class="hljs-string">&quot;id&quot;</span>).Value);<br>        print(nodeItem.Attributes.GetNamedItem(<span class="hljs-string">&quot;num&quot;</span>).Value);<br><br>        <span class="hljs-comment">//这里是获取 一个节点下的同名节点的方法</span><br>        XmlNodeList friendList = root.SelectNodes(<span class="hljs-string">&quot;Friend&quot;</span>);<br><br>        <span class="hljs-comment">//遍历方式一：迭代器遍历</span><br>        <span class="hljs-comment">//foreach (XmlNode item in friendList)</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    print(item.SelectSingleNode(&quot;name&quot;).InnerText);</span><br>        <span class="hljs-comment">//    print(item.SelectSingleNode(&quot;age&quot;).InnerText);</span><br>        <span class="hljs-comment">//&#125;</span><br>        <span class="hljs-comment">//遍历方式二：通过for循环遍历</span><br>        <span class="hljs-comment">//通过XmlNodeList中的 成员变量 Count可以得到 节点数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; friendList.Count; i++)<br>        &#123;<br>            print(friendList[i].SelectSingleNode(<span class="hljs-string">&quot;name&quot;</span>).InnerText);<br>            print(friendList[i].SelectSingleNode(<span class="hljs-string">&quot;age&quot;</span>).InnerText);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//1.读取XML文件</span><br>        <span class="hljs-comment">//XmlDocument xml = new XmlDocument();</span><br>        <span class="hljs-comment">//读取文本方式1-xml.LoadXml(传入xml文本字符串)</span><br>        <span class="hljs-comment">//读取文本方式2-xml.Load(传入路径)</span><br><br>        <span class="hljs-comment">//2.读取元素和属性</span><br>        <span class="hljs-comment">//获取单个节点 : XmlNode node = xml.SelectSingleNode(节点名)</span><br>        <span class="hljs-comment">//获取多个节点 : XmlNodeList nodeList = xml.SelectNodes(节点名)</span><br><br>        <span class="hljs-comment">//获取节点元素内容：node.InnerText</span><br>        <span class="hljs-comment">//获取节点元素属性：</span><br>        <span class="hljs-comment">//1.item.Attributes[&quot;属性名&quot;].Value</span><br>        <span class="hljs-comment">//2.item.Attributes.GetNamedItem(&quot;属性名&quot;).Value</span><br><br>        <span class="hljs-comment">//通过迭代器遍历或者循环遍历XmlNodeList对象 可以获取到各单个元素节点</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Csharp存储XML文件知识点"><a href="#Csharp存储XML文件知识点" class="headerlink" title="Csharp存储XML文件知识点"></a>Csharp存储XML文件知识点</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Xml;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SaveXml</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 决定存储在哪个文件夹下</span><br>        <span class="hljs-comment">//注意：存储xml文件 在Unity中一定是使用各平台都可读可写可找到的路径</span><br>        <span class="hljs-comment">// 1.Resources 可读 不可写 打包后找不到  ×</span><br>        <span class="hljs-comment">// 2.Application.streamingAssetsPath 可读，PC端可写,ios和安卓端不可写，找得到  ×</span><br>        <span class="hljs-comment">// 3.Application.dataPath 打包后找不到，只在测试的时候使用  ×</span><br>        <span class="hljs-comment">// 4.Application.persistentDataPath 可读可写找得到   √</span><br><br>        <span class="hljs-built_in">string</span> path = Application.persistentDataPath + <span class="hljs-string">&quot;/PlayerInfo2.xml&quot;</span>;<br>        print(Application.persistentDataPath);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 存储xml文件</span><br>        <span class="hljs-comment">//关键类 XmlDocument 用于创建节点 存储文件</span><br>        <span class="hljs-comment">//关键类 XmlDeclaration 用于添加版本信息</span><br>        <span class="hljs-comment">//关键类 XmlElement 节点类</span><br><br>        <span class="hljs-comment">//存储有5步</span><br>        <span class="hljs-comment">//1.创建文本对象</span><br>        XmlDocument xml = <span class="hljs-keyword">new</span> XmlDocument();<br><br>        <span class="hljs-comment">//2.添加固定版本信息</span><br>        <span class="hljs-comment">//这一句代码 相当于就是创建&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;这句内容</span><br>        XmlDeclaration xmlDec = xml.CreateXmlDeclaration(<span class="hljs-string">&quot;1.0&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//创建完成过后 要添加进入 文本对象中</span><br>        xml.AppendChild(xmlDec);<br><br>        <span class="hljs-comment">//3.添加根节点</span><br>        XmlElement root = xml.CreateElement(<span class="hljs-string">&quot;Root&quot;</span>);<br>        xml.AppendChild(root);<br><br>        <span class="hljs-comment">//4.为根节点添加子节点</span><br>        <span class="hljs-comment">//加了一个 name子节点</span><br>        XmlElement name = xml.CreateElement(<span class="hljs-string">&quot;name&quot;</span>);<br>        name.InnerText = <span class="hljs-string">&quot;唐老狮&quot;</span>;<br>        root.AppendChild(name);<br><br>        XmlElement atk = xml.CreateElement(<span class="hljs-string">&quot;atk&quot;</span>);<br>        <span class="hljs-comment">// 无论是int还是float，都需要转成string</span><br>        atk.InnerText = <span class="hljs-string">&quot;10&quot;</span>;<br>        root.AppendChild(atk);<br><br>        XmlElement listInt = xml.CreateElement(<span class="hljs-string">&quot;listInt&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>        &#123;<br>            XmlElement childNode = xml.CreateElement(<span class="hljs-string">&quot;int&quot;</span>);<br>            childNode.InnerText = i.ToString();<br>            listInt.AppendChild(childNode);<br>        &#125;<br>        root.AppendChild(listInt);<br><br>        XmlElement itemList = xml.CreateElement(<span class="hljs-string">&quot;itemList&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++)<br>        &#123;<br>            XmlElement childNode = xml.CreateElement(<span class="hljs-string">&quot;Item&quot;</span>);<br>            <span class="hljs-comment">//添加属性</span><br>            childNode.SetAttribute(<span class="hljs-string">&quot;id&quot;</span>, i.ToString());<br>            childNode.SetAttribute(<span class="hljs-string">&quot;num&quot;</span>, (i * <span class="hljs-number">10</span>).ToString());<br>            itemList.AppendChild(childNode);<br>        &#125;<br>        root.AppendChild(itemList);<br><br>        <span class="hljs-comment">//5.保存</span><br>        xml.Save(path);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 修改xml文件</span><br>        <span class="hljs-comment">//1.先判断是否存在文件</span><br>        <span class="hljs-comment">// File需要引入这个命名空间</span><br>        <span class="hljs-comment">// using System.IO;</span><br>        <span class="hljs-keyword">if</span> (File.Exists(path))<br>        &#123;<br>            <span class="hljs-comment">//2.加载后 直接添加节点 移除节点即可</span><br>            XmlDocument newXml = <span class="hljs-keyword">new</span> XmlDocument();<br>            newXml.Load(path);<br><br>            <span class="hljs-comment">//修改就是在原有文件基础上 去移除 或者添加</span><br>            <span class="hljs-comment">//移除</span><br>            XmlNode node; <span class="hljs-comment">// = newXml.SelectSingleNode(&quot;Root&quot;).SelectSingleNode(&quot;atk&quot;);</span><br>            <span class="hljs-comment">//这种是一种简便写法 通过/来区分父子关系</span><br>            node = newXml.SelectSingleNode(<span class="hljs-string">&quot;Root/atk&quot;</span>);<br>            <span class="hljs-comment">//得到自己的父节点</span><br>            XmlNode root2 = newXml.SelectSingleNode(<span class="hljs-string">&quot;Root&quot;</span>);<br>            <span class="hljs-comment">//移除子节点方法</span><br>            root2.RemoveChild(node);<br><br>            <span class="hljs-comment">//添加节点</span><br>            XmlElement speed = newXml.CreateElement(<span class="hljs-string">&quot;moveSpeed&quot;</span>);<br>            speed.InnerText = <span class="hljs-string">&quot;20&quot;</span>;<br>            root2.AppendChild(speed);<br><br>            <span class="hljs-comment">//改了记得存</span><br>            newXml.Save(path);<br>        &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//1.路径选取</span><br>        <span class="hljs-comment">//在运行过程中存储 只能往可写且能找到的文件夹存储</span><br>        <span class="hljs-comment">//故 选择了Application.persistentDataPath</span><br><br>        <span class="hljs-comment">//2.存储xml关键类</span><br>        <span class="hljs-comment">//XmlDocument  文件</span><br>        <span class="hljs-comment">//   创建节点 CreateElement</span><br>        <span class="hljs-comment">//   创建固定内容方法 CreateXmlDeclaration</span><br>        <span class="hljs-comment">//   添加节点 AppendChild</span><br>        <span class="hljs-comment">//   保存 Save</span><br>        <span class="hljs-comment">//XmlDeclaration 版本</span><br>        <span class="hljs-comment">//XmlElement 元素节点</span><br>        <span class="hljs-comment">//   设置属性方法SetAttribute</span><br><br>        <span class="hljs-comment">//3.修改</span><br>        <span class="hljs-comment">//RemoveChild移除节点</span><br>        <span class="hljs-comment">//可以通过 /的形式 来表示 子节点的子节点</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/05/LTPDNz4f1M7GhxY.png" alt="Pasted image 20241203235048.png"></p><h1 id="XML序列化知识点"><a href="#XML序列化知识点" class="headerlink" title="XML序列化知识点"></a>XML序列化知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Xml.Serialization;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson1Test</span><br>&#123;<br>    [<span class="hljs-meta">XmlElement(<span class="hljs-string">&quot;testPublic123123&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> testPublic; <span class="hljs-comment">//&lt;testPublic123123&gt;0&lt;/testPublic123123&gt;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> testPrivate;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> testProtected;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-built_in">int</span> testInternal;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> testPUblicStr;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> testPro &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-keyword">public</span> Lesson1Test2 testClass = <span class="hljs-keyword">new</span> Lesson1Test2();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] arrayInt;<br><br>    [<span class="hljs-meta">XmlArray(<span class="hljs-string">&quot;IntList&quot;</span>)</span>]<br>    [<span class="hljs-meta">XmlArrayItem(<span class="hljs-string">&quot;Int32&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">int</span>&gt; listInt; <span class="hljs-comment">// &lt;IntList&gt; &lt;Int32&gt;&lt;/Int32&gt; &lt;/IntList&gt;</span><br>    <span class="hljs-keyword">public</span> List&lt;Lesson1Test2&gt; listItem;<br><br>    <span class="hljs-comment">//不支持字典</span><br>    <span class="hljs-comment">//public Dictionary&lt;int, string&gt; testDic = new Dictionary&lt;int, string&gt;() &#123; &#123; 1, &quot;123&quot; &#125; &#125;;</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson1Test2</span><br>&#123;<br>    <span class="hljs-comment">//&lt;Lesson1Test2 Test1=&quot;1&quot; test2=&quot;1.1&quot; test3=&quot;true&quot; /&gt;</span><br>    [<span class="hljs-meta">XmlAttribute(<span class="hljs-string">&quot;Test1&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> test1 = <span class="hljs-number">1</span>;<br><br>    [<span class="hljs-meta">XmlAttribute()</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> test2 = <span class="hljs-number">1.1f</span>;<br><br>    [<span class="hljs-meta">XmlAttribute()</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> test3 = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson1</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 什么是序列化和反序列化</span><br>        <span class="hljs-comment">//序列化：把对象转化为可传输的字节序列过程称为序列化</span><br>        <span class="hljs-comment">//反序列化：把字节序列还原为对象的过程称为反序列化</span><br><br>        <span class="hljs-comment">//说人话：</span><br>        <span class="hljs-comment">//序列化就是把想要存储的内容转换为字节序列用于存储或传递</span><br>        <span class="hljs-comment">//反序列化就是把存储或收到的字节序列信息解析读取出来使用</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 xml序列化</span><br>        <span class="hljs-comment">//1.第一步准备一个数据结构类</span><br>        Lesson1Test lt = <span class="hljs-keyword">new</span> Lesson1Test();<br>        <span class="hljs-comment">//2.进行序列化</span><br>        <span class="hljs-comment">//  关键知识点</span><br>        <span class="hljs-comment">//  XmlSerializer 用于序列化对象为xml的关键类</span><br>        <span class="hljs-comment">//  StreamWriter 用于存储文件</span><br>        <span class="hljs-comment">//  using 用于方便流对象释放和销毁</span><br><br>        <span class="hljs-comment">//第一步：确定存储路径</span><br>        <span class="hljs-built_in">string</span> path = Application.persistentDataPath + <span class="hljs-string">&quot;/Lesson1Test.xml&quot;</span>;<br>        print(Application.persistentDataPath);<br>        <span class="hljs-comment">//第二步：结合 using知识点 和 StreamWriter这个流对象 来写入文件</span><br>        <span class="hljs-comment">// 括号内的代码：写入一个文件流 如果有该文件 直接打开并修改 如果没有该文件 直接新建一个文件</span><br>        <span class="hljs-comment">// using 的新用法 括号当中包裹的声明的对象 会在 大括号语句块结束后 自动释放掉</span><br>        <span class="hljs-comment">// 当语句块结束 会自动帮助我们调用 对象的 Dispose这个方法 让其进行销毁</span><br>        <span class="hljs-comment">// using一般都是配合 内存占用比较大 或者 有读写操作时  进行使用的</span><br>        <span class="hljs-keyword">using</span> (StreamWriter stream = <span class="hljs-keyword">new</span> StreamWriter(path))<br>        &#123;<br>            <span class="hljs-comment">//第三步：进行xml文件序列化</span><br>            <span class="hljs-comment">//Lesson1Test lt = new Lesson1Test();</span><br><br>            XmlSerializer s = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(Lesson1Test));<br>            <span class="hljs-comment">//XmlSerializer s = new XmlSerializer(lt.GetType());</span><br>            <span class="hljs-comment">//这句代码的含义 就是通过序列化对象 对我们类对象进行翻译 将其翻译成我们的xml文件 写入到对应的文件中</span><br>            <span class="hljs-comment">//第一个参数 ： 文件流对象</span><br>            <span class="hljs-comment">//第二个参数: 想要备翻译 的对象</span><br>            <span class="hljs-comment">//注意 ：翻译机器的类型s 一定要和传入的对象lt 是一致的 不然会报错</span><br>            s.Serialize(stream, lt);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 自定义节点名 或 设置属性</span><br>        <span class="hljs-comment">//可以通过特性 设置节点或者设置属性 并且修改名字</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//序列化流程</span><br>        <span class="hljs-comment">//1.有一个想要保存的类对象</span><br>        <span class="hljs-comment">//2.使用XmlSerializer 序列化该对象</span><br>        <span class="hljs-comment">//3.通过StreamWriter 配合 using将数据存储 写入文件</span><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//1.只能序列化公共成员</span><br>        <span class="hljs-comment">//2.不支持字典序列化</span><br>        <span class="hljs-comment">//3.可以通过特性修改节点信息 或者设置属性信息</span><br>        <span class="hljs-comment">//4.Stream相关要配合using使用</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="XML反序列化"><a href="#XML反序列化" class="headerlink" title="XML反序列化"></a>XML反序列化</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Xml.Serialization;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson2</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识回顾</span><br>        <span class="hljs-comment">// 序列化 就是把类对象 转换为可存储和传输的数据</span><br>        <span class="hljs-comment">// 反序列化 就是把存储或收到的数据 转换为 类对象</span><br><br>        <span class="hljs-comment">// xml序列化关键知识</span><br>        <span class="hljs-comment">// 1.using 和 StreamWriter</span><br>        <span class="hljs-comment">// 2.XmlSerializer 的 Serialize序列化方法</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 判断文件是否存在</span><br>        <span class="hljs-built_in">string</span> path = Application.persistentDataPath + <span class="hljs-string">&quot;/Lesson1Test.xml&quot;</span>;<br>        <span class="hljs-keyword">if</span> (File.Exists(path))<br>        &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 反序列化</span><br>            <span class="hljs-comment">//关键知识</span><br>            <span class="hljs-comment">// 1.using 和 StreamReader</span><br>            <span class="hljs-comment">// 2.XmlSerializer 的 Deserialize反序列化方法</span><br><br>            <span class="hljs-comment">//读取文件</span><br>            <span class="hljs-keyword">using</span> (StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(path))<br>            &#123;<br>                <span class="hljs-comment">//产生了一个 序列化反序列化的翻译机器</span><br>                XmlSerializer s = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(Lesson1Test));<br>                <span class="hljs-comment">// 这里有个坑，如果是List，会根据Lesson1Test里面的具体情况进行初始化</span><br>                <span class="hljs-comment">// 然后再根据xml文件来对List进行Add，建议Lesson1Test里面不要初始化</span><br>                Lesson1Test lt = s.Deserialize(reader) <span class="hljs-keyword">as</span> Lesson1Test;<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//1.判断文件是否存在 File.Exists</span><br>        <span class="hljs-comment">//2.文件流获取 StreamReader reader = new StreamReader(path)</span><br>        <span class="hljs-comment">//3.根据文件流 XmlSerializer通过Deserialize反序列化 出对象</span><br><br>        <span class="hljs-comment">//注意：List对象 如果有默认值 反序列化时 不会清空 会往后面添加</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="IXmlSerializable接口知识点"><a href="#IXmlSerializable接口知识点" class="headerlink" title="IXmlSerializable接口知识点"></a>IXmlSerializable接口知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Xml;<br><span class="hljs-keyword">using</span> System.Xml.Schema;<br><span class="hljs-keyword">using</span> System.Xml.Serialization;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestLesson3</span> : <span class="hljs-title">IXmlSerializable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> test1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> test2 = <span class="hljs-number">99</span>;<br><br>    <span class="hljs-comment">// 这个方法暂时不用管，返回null就可以了</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> XmlSchema <span class="hljs-title">GetSchema</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 反序列化时会自动调用的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadXml</span>(<span class="hljs-params">XmlReader reader</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 自定义反序列化规则</span><br>        <span class="hljs-comment">//读属性</span><br>        <span class="hljs-comment">// reader[&quot;Test1&quot;] 意思是读取根节点的Test1的属性，读取出来是String类型</span><br>        <span class="hljs-comment">//test1 = int.Parse(reader[&quot;Test1&quot;]);</span><br>        <span class="hljs-comment">//test2 = int.Parse(reader[&quot;Test2&quot;]);</span><br><br>        <span class="hljs-comment">//读节点</span><br>        <span class="hljs-comment">//方式一</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * &lt;TestLesson3&gt;</span><br><span class="hljs-comment">         *&lt;test1&gt;0&lt;/test1&gt;</span><br><span class="hljs-comment">         *&lt;test2&gt;123&lt;/test2&gt;</span><br><span class="hljs-comment">         * &lt;/TestLesson3&gt;</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-comment">//reader.Read();//这时读到的是节点&lt;test1&gt;</span><br>        <span class="hljs-comment">//reader.Read();//这时读到的才是值0</span><br>        <span class="hljs-comment">//test1 = int.Parse(reader.Value);//得到值内容，解析这个值</span><br>        <span class="hljs-comment">//reader.Read();//得到节点尾部配对&lt;/test1&gt;</span><br>        <span class="hljs-comment">//reader.Read();//读到节点开头&lt;test2&gt;</span><br>        <span class="hljs-comment">//reader.Read();//读到值123</span><br>        <span class="hljs-comment">//test2 = int.Parse(reader.Value);//获取值内容</span><br>        <span class="hljs-comment">//方式二</span><br>        <span class="hljs-comment">//while (reader.Read())</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    if(reader.NodeType == XmlNodeType.Element)</span><br>        <span class="hljs-comment">//    &#123;</span><br>        <span class="hljs-comment">//        switch (reader.Name)</span><br>        <span class="hljs-comment">//        &#123;</span><br>        <span class="hljs-comment">//            case &quot;Test1&quot;:</span><br>        <span class="hljs-comment">//                reader.Read();</span><br>        <span class="hljs-comment">//                test1 = int.Parse(reader.Value) ;</span><br>        <span class="hljs-comment">//                break;</span><br>        <span class="hljs-comment">//            case &quot;Test2&quot;:</span><br>        <span class="hljs-comment">//                reader.Read();</span><br>        <span class="hljs-comment">//                test2 = int.Parse(reader.Value);</span><br>        <span class="hljs-comment">//                break;</span><br>        <span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-comment">//    &#125;</span><br>        <span class="hljs-comment">//&#125;</span><br><br>        <span class="hljs-comment">//读包裹点</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * &lt;TestLesson3&gt;</span><br><span class="hljs-comment">         *&lt;test1&gt;0&lt;/test1&gt;</span><br><span class="hljs-comment">         *&lt;test2&gt;123&lt;/test2&gt;</span><br><span class="hljs-comment">         * &lt;/TestLesson3&gt;</span><br><span class="hljs-comment">         * */</span><br>        XmlSerializer s = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>));<br>        reader.Read();<br>        <span class="hljs-comment">// 检查当前节点是否是 &lt;Test1&gt; 元素的起始标签，并将光标移到标签内容（即 0）的位置</span><br>        reader.ReadStartElement(<span class="hljs-string">&quot;Test1&quot;</span>);<br>        <span class="hljs-comment">// 使用 XmlSerializer 将当前节点的内容反序列化为 int 类型，并赋值给变量 test1</span><br>        <span class="hljs-comment">// 此时，reader 光标移动到&lt;Test1&gt; 元素结束标签的位置</span><br>        test1 = (<span class="hljs-built_in">int</span>)s.Deserialize(reader);<br>        <span class="hljs-comment">// 检查并读取 &lt;Test1&gt; 元素的结束标签，确保匹配了对应的 &lt;Test1&gt; 开始标签</span><br>        reader.ReadEndElement();<br>        reader.ReadStartElement(<span class="hljs-string">&quot;Test2&quot;</span>);<br>        test1 = (<span class="hljs-built_in">int</span>)s.Deserialize(reader);<br>        reader.ReadEndElement();<br>    &#125;<br><br>    <span class="hljs-comment">// 序列化时，会自动调用的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteXml</span>(<span class="hljs-params">XmlWriter writer</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 自定义序列化规则</span><br>        <span class="hljs-comment">//写属性，可以改为this.test1.ToString()</span><br>        <span class="hljs-comment">// 则会个test1就是这个TestLesson3的里面的属性</span><br>        <span class="hljs-comment">//writer.WriteAttributeString(&quot;Test1&quot;, test1.ToString());</span><br>        <span class="hljs-comment">//writer.WriteAttributeString(&quot;Test2&quot;, test2.ToString());</span><br><br>        <span class="hljs-comment">//写节点</span><br>        <span class="hljs-comment">//writer.WriteElementString(&quot;Test1&quot;, test1.ToString());</span><br>        <span class="hljs-comment">//writer.WriteElementString(&quot;Test2&quot;, test2.ToString());</span><br><br>        <span class="hljs-comment">//写包裹节点</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * &lt;TestLesson3&gt;</span><br><span class="hljs-comment">         *&lt;test1&gt;</span><br><span class="hljs-comment">         *&lt;int&gt;0&lt;/int&gt;</span><br><span class="hljs-comment">         *&lt;/test1&gt;</span><br><span class="hljs-comment">         *&lt;test2&gt;</span><br><span class="hljs-comment">         *&lt;string&gt;123&lt;/string&gt;</span><br><span class="hljs-comment">         *&lt;/test2&gt;</span><br><span class="hljs-comment">         *&lt;/TestLesson3&gt;</span><br><span class="hljs-comment">         */</span><br>        XmlSerializer s = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>));<br>        writer.WriteStartElement(<span class="hljs-string">&quot;Test1&quot;</span>);<br>        s.Serialize(writer, test1);<br>        writer.WriteEndElement();<br><br>        writer.WriteStartElement(<span class="hljs-string">&quot;Test2&quot;</span>);<br>        s.Serialize(writer, test2);<br>        writer.WriteEndElement();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson3</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 IXmlSerializable是什么</span><br>        <span class="hljs-comment">//C# 的XmlSerializer 提供了可拓展内容</span><br>        <span class="hljs-comment">//可以让一些不能被序列化和反序列化的特殊类能被处理</span><br>        <span class="hljs-comment">//让特殊类继承 IXmlSerializable 接口 实现其中的方法即可</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 自定义类实践</span><br>        TestLesson3 t = <span class="hljs-keyword">new</span> TestLesson3();<br>        <span class="hljs-keyword">using</span> (StreamWriter writer = <span class="hljs-keyword">new</span> StreamWriter(Application.persistentDataPath + <span class="hljs-string">&quot;/test.xml&quot;</span>))<br>        &#123;<br>            <span class="hljs-comment">// 序列化的“翻译机器”</span><br>            XmlSerializer s = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(TestLesson3));<br>            <span class="hljs-comment">// 在序列化时，如果对象中的引用成员为空，那么xml里面时看不到该字段的</span><br>            <span class="hljs-comment">// 例如TestLesson3中，如果test2没有用等于号赋值，那么形成xml文件的时候，就不会有这个标签</span><br>            s.Serialize(writer, t);<br>        &#125;<br><br>        <span class="hljs-comment">// 反序列化</span><br>        <span class="hljs-keyword">using</span> (StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(Application.persistentDataPath + <span class="hljs-string">&quot;/test.xml&quot;</span>))<br>        &#123;<br>            <span class="hljs-comment">// 序列化的“翻译机器”</span><br>            XmlSerializer s = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(TestLesson3));<br>            t = s.Deserialize(reader) <span class="hljs-keyword">as</span> TestLesson3;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="让Dictionary支持序列化，反序列化"><a href="#让Dictionary支持序列化，反序列化" class="headerlink" title="让Dictionary支持序列化，反序列化"></a>让Dictionary支持序列化，反序列化</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Xml;<br><span class="hljs-keyword">using</span> System.Xml.Schema;<br><span class="hljs-keyword">using</span> System.Xml.Serialization;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SerizlizerDictionary</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt; : <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">TKey</span>, <span class="hljs-title">TValue</span>&gt;, <span class="hljs-title">IXmlSerializable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> XmlSchema <span class="hljs-title">GetSchema</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//自定义字典的 反序列化 规则</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReadXml</span>(<span class="hljs-params">XmlReader reader</span>)</span><br>    &#123;<br>        XmlSerializer keySer = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(TKey));<br>        XmlSerializer valueSer = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(TValue));<br><br>        <span class="hljs-comment">//要跳过根节点</span><br>        reader.Read();<br>        <span class="hljs-comment">//判断 当前不是元素节点 结束 就进行 反序列化</span><br>        <span class="hljs-keyword">while</span> (reader.NodeType != XmlNodeType.EndElement)<br>        &#123;<br>            <span class="hljs-comment">//反序列化键</span><br>            <span class="hljs-comment">//&lt;KeyValuePair&gt;</span><br>            <span class="hljs-comment">//&lt; Key &gt; 1 &lt;/ Key &gt;</span><br>            <span class="hljs-comment">//&lt; Value &gt; One &lt;/ Value &gt;</span><br>            <span class="hljs-comment">//&lt;/ KeyValuePair &gt;</span><br>            <span class="hljs-comment">//当光标位于&lt;Key&gt; 节点时</span><br>            <span class="hljs-comment">//XmlReader 的光标指向&lt;Key&gt;</span><br>            <span class="hljs-comment">//Deserialize 自动解析 &lt; Key &gt; 节点中的内容</span><br>            <span class="hljs-comment">//查找&lt;Key&gt; 标签中的值 1</span><br>            <span class="hljs-comment">//转换为与 TKey 类型匹配的值（int 或 string 等）</span><br>            <span class="hljs-comment">//key 的值被赋为 1</span><br>            TKey key = (TKey)keySer.Deserialize(reader);<br>            <span class="hljs-comment">//反序列化值</span><br>            TValue <span class="hljs-keyword">value</span> = (TValue)valueSer.Deserialize(reader);<br>            <span class="hljs-comment">//存储到字典中</span><br>            <span class="hljs-keyword">this</span>.Add(key, <span class="hljs-keyword">value</span>);<br>        &#125;<br>        reader.Read();<br>    &#125;<br><br>    <span class="hljs-comment">//自定义 字典的 序列化 规则</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteXml</span>(<span class="hljs-params">XmlWriter writer</span>)</span><br>    &#123;<br>        XmlSerializer keySer = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(TKey));<br>        XmlSerializer valueSer = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(TValue));<br><br>        <span class="hljs-keyword">foreach</span> (KeyValuePair&lt;TKey, TValue&gt; kv <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>)<br>        &#123;<br>            <span class="hljs-comment">//键值对 的序列化</span><br>            keySer.Serialize(writer, kv.Key);<br>            valueSer.Serialize(writer, kv.Value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Xml存储和读取功能实现"><a href="#Xml存储和读取功能实现" class="headerlink" title="Xml存储和读取功能实现"></a>Xml存储和读取功能实现</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Xml.Serialization;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">XmlDataMgr</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> XmlDataMgr instance = <span class="hljs-keyword">new</span> XmlDataMgr();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> XmlDataMgr Instance =&gt; instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">XmlDataMgr</span>()</span> &#123; &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 保存数据到xml文件中</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;data&quot;&gt;</span>数据对象<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;fileName&quot;&gt;</span>文件名<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SaveData</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> data, <span class="hljs-built_in">string</span> fileName</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//1.得到存储路径</span><br>        <span class="hljs-built_in">string</span> path = Application.persistentDataPath + <span class="hljs-string">&quot;/&quot;</span> + fileName + <span class="hljs-string">&quot;.xml&quot;</span>;<br>        <span class="hljs-comment">//2.存储文件</span><br>        <span class="hljs-keyword">using</span> (StreamWriter writer = <span class="hljs-keyword">new</span> StreamWriter(path))<br>        &#123;<br>            <span class="hljs-comment">//3.序列化</span><br>            XmlSerializer s = <span class="hljs-keyword">new</span> XmlSerializer(data.GetType());<br>            s.Serialize(writer, data);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 从xml文件中读取内容</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;type&quot;&gt;</span>对象类型<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;fileName&quot;&gt;</span>文件名<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">LoadData</span>(<span class="hljs-params">Type type, <span class="hljs-built_in">string</span> fileName</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//1。首先要判断文件是否存在</span><br>        <span class="hljs-built_in">string</span> path = Application.persistentDataPath + <span class="hljs-string">&quot;/&quot;</span> + fileName + <span class="hljs-string">&quot;.xml&quot;</span>;<br>        <span class="hljs-keyword">if</span> (!File.Exists(path))<br>        &#123;<br>            path = Application.streamingAssetsPath + <span class="hljs-string">&quot;/&quot;</span> + fileName + <span class="hljs-string">&quot;.xml&quot;</span>;<br>            <span class="hljs-keyword">if</span> (!File.Exists(path))<br>            &#123;<br>                <span class="hljs-comment">//如果根本不存在文件 两个路径都找过了</span><br>                <span class="hljs-comment">//那么直接new 一个对象 返回给外部 无非 里面都是默认值</span><br>                <span class="hljs-keyword">return</span> Activator.CreateInstance(type);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//2.存在就读取</span><br>        <span class="hljs-keyword">using</span> (StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(path))<br>        &#123;<br>            <span class="hljs-comment">//3.反序列化 取出数据</span><br>            XmlSerializer s = <span class="hljs-keyword">new</span> XmlSerializer(type);<br>            <span class="hljs-keyword">return</span> s.Deserialize(reader);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h1><ul><li>先将想要打包的文件放在指定位置<br><img src="https://s2.loli.net/2024/12/05/HrY6qxFjaGTSWlE.png" alt="Pasted image 20241205233153.png"></li></ul><p><img src="https://s2.loli.net/2024/12/05/KXuc61nZzjYx3Ov.png" alt="Pasted image 20241205233311.png"></p><ul><li>只选中想要打包的内容<br><img src="https://s2.loli.net/2024/12/05/oVkTS26H51guyIC.png" alt="Pasted image 20241205233342.png"></li><li>后续想要使用的时候，直接拖进Assets中就可以了<br><img src="https://s2.loli.net/2024/12/05/fVJwkyqTQjmUCcg.png" alt="Pasted image 20241205233408.png"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unity知识整理(三_UGUI)</title>
    <link href="/2024/11/26/Unity%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%89_UGUI)/"/>
    <url>/2024/11/26/Unity%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%89_UGUI)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>NGUI全称下一代用户界面(Next-Gen UI)<br>它是第三方提供的Unity付费插件<br>专门用于制作Unity中游戏UI的第三方工具<br>相对于GUI它更适用于制作游戏UI功能<br>更方便使用，性能和效率更高<br>Unity插件：是一种基于Unity规范编写出来的程序，主要用于拓展功能，简单理解就是别人基于Unity写好的某种功能代码，我们可以直接用来处理特定的游戏逻辑</p></blockquote><h1 id="UGUI导入"><a href="#UGUI导入" class="headerlink" title="UGUI导入"></a>UGUI导入</h1><ul><li><p>打开资源商店<br><img src="https://s2.loli.net/2024/12/01/VjU51TOEKnqoGNH.png" alt="Pasted image 20241126164355.png"></p></li><li><p>搜索NGUI<br><img src="https://s2.loli.net/2024/12/01/QLpyRGWAPH9FKjz.png" alt="Pasted image 20241126164726.png"></p></li><li><p>找到这个NGUI<br><img src="https://s2.loli.net/2024/12/01/qiJn3wsXbrON6AS.png" alt="Pasted image 20241126164740.png"></p></li><li><p>UI创建<br><img src="https://s2.loli.net/2024/12/01/mvx8n3hNIUFWfrB.png" alt="Pasted image 20241126164950.png"></p></li><li><p>另一种方式创建UI<br><img src="https://s2.loli.net/2024/12/01/ZFAp6CjQ8rxbygt.png" alt="Pasted image 20241126165232.png"></p></li></ul><h1 id="ROOT组件"><a href="#ROOT组件" class="headerlink" title="ROOT组件"></a>ROOT组件</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson1_Root</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 必备知识——分辨率概念</span><br>        <span class="hljs-comment">//1.分辨率</span><br>        <span class="hljs-comment">//屏幕宽高两个方向的像素点</span><br>        <span class="hljs-comment">//比如1920 * 1080</span><br>        <span class="hljs-comment">//宽1920个像素</span><br>        <span class="hljs-comment">//高1080个像素</span><br><br>        <span class="hljs-comment">//2.像素</span><br>        <span class="hljs-comment">//像素</span><br>        <span class="hljs-comment">//像素即px</span><br>        <span class="hljs-comment">//是画面中最小的点(单位色块)</span><br><br>        <span class="hljs-comment">//3.屏幕尺寸</span><br>        <span class="hljs-comment">//屏幕对角线长度</span><br><br>        <span class="hljs-comment">//4.屏幕比例</span><br>        <span class="hljs-comment">//PC显示器</span><br>        <span class="hljs-comment">//1920:1080 = 16:9</span><br><br>        <span class="hljs-comment">//苹果手机</span><br>        <span class="hljs-comment">//iPhone7,8：1334 * 750 = 16:9</span><br>        <span class="hljs-comment">//iPhone 7,8 Plus：1920 * 1080 = 16:9</span><br>        <span class="hljs-comment">//iPhoneX：2436 * 1125 = 19.5:9</span><br>        <span class="hljs-comment">//iPhone12: 2532 * 1170 = 19.5:9</span><br><br>        <span class="hljs-comment">//目前市面上设备分辨率比例传统的有：</span><br>        <span class="hljs-comment">//4:3(ipad)</span><br>        <span class="hljs-comment">//16:10</span><br>        <span class="hljs-comment">//16:9(老手机 、电脑显示器)</span><br>        <span class="hljs-comment">//18:9（去掉留海屏幕）</span><br>        <span class="hljs-comment">//19.5:9（ 新款手机）</span><br>        <span class="hljs-comment">//19.9:9</span><br><br>        <span class="hljs-comment">//5.dpi</span><br>        <span class="hljs-comment">//像素密度</span><br>        <span class="hljs-comment">//单位面积上有多少个像素点</span><br>        <span class="hljs-comment">//一般指一英寸有多少个像素点</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 Root是用来干啥的</span><br>        <span class="hljs-comment">//Root是用于分辨率自适应的根对象</span><br>        <span class="hljs-comment">//可以设置基本分辨率,相当于设置UI显示区域</span><br>        <span class="hljs-comment">//并且管理所有UI控件的分辨率自适应</span><br><br>        <span class="hljs-comment">//可以简单理解 它管理一个 UI画布 所有的UI都是显示在这个画布上的</span><br>        <span class="hljs-comment">//它会管理 UI画布 和 不同屏幕分辨率的 适应关系</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 Root相关参数</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//1.Flexible 适用于可以手动拖窗口改变分辨率的设备 比如pc端</span><br><br>        <span class="hljs-comment">//2.Constrained 适用于移动设备</span><br>        <span class="hljs-comment">//  因为移动设备都是全屏应用 不会频繁改变分辨率 只用适配不同分辨率的设备</span><br>        <span class="hljs-comment">//  横屏勾选 高 fit  竖屏 勾选 宽 fit 一般就可以比较好的进行分辨率适应了</span><br>        <span class="hljs-comment">//  需要注意的是 背景图 一定要考虑 极限 宽高比来出 最大宽高比  19.9:9</span><br><br>        <span class="hljs-comment">//3.Constrained On Mobiles 是上面两者的综合体 适用于多平台发布的游戏和应用</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>创建的2D UI</p></li><li><p>UI ROOT上有Root脚本和Panel脚本</p></li><li><p>Camera上有Event Systeam(UI Camera)脚本<br><img src="https://s2.loli.net/2024/12/01/AI8OdcPezFvTVMN.png" alt="Pasted image 20241126170036.png"><br><img src="https://s2.loli.net/2024/12/01/6V9MuAfjZCNo5cL.png" alt="Pasted image 20241126170217.png"></p></li><li><p>Flexible 适用于PC端</p><ul><li>灵活模式<ul><li>在该模式下，U都是以像素为基础，100像素的物体无论在多少分辨率上都是100像素</li><li>这就意味着，100像素在分辨率低的屏幕上可能显示正常，但是在高分辨率上就会显得很小</li><li>Minimum Height 屏幕高小于该值时开始按比例缩放</li><li>Maximum Height 屏幕高大于改值时开始按比例缩放</li><li>Shrink Portrait UI  勾选时，竖屏时，按宽度来适配，就是上面的Min Height和Max Height改成了按照宽度适配</li><li>Adjust by DPI 使用dpi做适配计算建议勾选</li></ul></li></ul></li><li><p>Constrained 适用于手机端 </p><ul><li>约束模式</li><li>该模式下，屏幕按尺寸比例来适配，不管实际屏幕有多大，NGUI都会通过合适的缩放来适配屏幕。</li><li>这样在高分辨率上显示的UI就会被放大保持原有大小，但有可能会模糊，好处是各设备看到的UI和屏幕比例是一样的</li><li>Content Width<ul><li>按照该宽度值适配屏幕</li><li>制作资源时的默认分辨率宽</li></ul></li><li>Content Heigh<ul><li>按照该高度值适配屏幕</li><li>制作资源时的默认分辨率高</li></ul></li><li>Fit表示以那个值做适配<ul><li>勾选Width 屏幕比例变化时，按照宽度来适配 (宽度始终不变)<ul><li>竖屏游戏</li></ul></li><li>勾选Height 屏幕比例变化时，按照高度来适配 (高度始终不变)<ul><li>横屏游戏</li></ul></li><li>两个都勾选 <ul><li>不会被裁剪，但是有黑边</li><li>意思就是会把实际制作的图完全显示</li><li>当适配宽高比大于实际宽高比时，就会按照宽度适配，反之按照高度适配</li></ul></li><li>两个都不勾选<ul><li>始终保证屏幕被UI填充满</li><li>不会有黑边</li><li>可能会被裁剪</li></ul></li></ul></li></ul></li><li><p>Constrained On Mobiles</p><ul><li>上面两种模式的综合体</li><li>在PC和Mac等桌面设备上用Flexible模式</li><li>在移动设备上用Constrained模式</li></ul></li><li><p>选中UI Root，创建Sprite<br><img src="https://s2.loli.net/2024/12/01/J8eKsuX3qgM5nBP.png" alt="Pasted image 20241126170927.png"></p></li></ul><p><img src="https://s2.loli.net/2024/12/01/ui4xV1S9X23AtNd.png" alt="Pasted image 20241126171119.png"></p><ul><li>红色的就是屏幕大小</li><li>蓝色的是实际图片大小<br><img src="https://s2.loli.net/2024/12/01/97KiC1UoGWgda3z.png" alt="Pasted image 20241126173125.png"></li></ul><p><img src="https://s2.loli.net/2024/12/01/Lhse8CGqUz5j7Iv.png" alt="缩放模式设置.png"></p><h1 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson1_Panel</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Panel用来干啥</span><br>        <span class="hljs-comment">//1.管理一个UI面板的渲染顺序</span><br>        <span class="hljs-comment">//2.管理一个UI面板上的所有子控件</span><br>        <span class="hljs-comment">// 如果某个Sprite对象的父对象上没有Panel脚本，则Sprite精灵图则无法被渲染</span><br>        <span class="hljs-comment">// 所以必须要有一个Panel脚本，默认UI Root上有一个Panel脚本</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 Panel参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//1.没有Panel父对象 UI控件看不到</span><br>        <span class="hljs-comment">//2.Panel一般用于管理面板 控制层级</span><br>        <span class="hljs-comment">//3.Panel可以有多个 一般一个Panel管理一个面板</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Alpha<ul><li>控制所有子UI元素的透明度</li></ul></li><li>Depth<ul><li>控制该Panel的层级</li><li>层级高的后渲染会把层级低的先渲染的遮挡住</li></ul></li><li>Clipping 裁剪<ul><li>None 不处理<ul><li>正常</li></ul></li><li>Texture Mask 根据图片信息进行遮罩<ul><li>比如人物头像</li></ul></li><li>Soft Clip 自己定范围裁剪 <ul><li>比如拖动框</li></ul></li><li>Constrain But Dont Clip 约束但不剪裁<ul><li>不裁剪画面</li><li>只限制响应范围</li></ul></li><li>Sorting Layer 排序层</li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/OchYZAvETXzbiNr.png" alt="重要参数.png"></p><ul><li><p>Advanced Options 渲染相关高级选项</p><ul><li>Render Q 渲染队列</li><li>Sort Order 排序</li><li>Normals 是否需要灯光着色器</li><li>UV2 是否用于自定义着色器效果</li><li>Shadow Mode 阴影模式<ul><li>3DUI得时候用，2DUI不用</li></ul></li><li>Cull 元素组件拖动时提出</li><li>Visible 检查元素组件是否离开屏幕</li><li>Padding 边界内容</li><li>Offset 抵消偏移位置</li><li>Static 检查子元素是否会移动</li><li>Panel Tool 是否显示面板工具</li></ul></li><li><p>Anchors  锚点设置</p><ul><li>用于分辨率自适应设置大小</li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/MQI9gUeFqYXTrLk.png" alt="次要参数.png"></p><h1 id="EventSystem组件（UIGamera）"><a href="#EventSystem组件（UIGamera）" class="headerlink" title="EventSystem组件（UIGamera）"></a>EventSystem组件（UIGamera）</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson1_EventSystem</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 EventSystem是用来干啥的</span><br>        <span class="hljs-comment">//主要作用是让摄像机渲染出来的物体</span><br>        <span class="hljs-comment">//能够接收到NGUI的输入事件</span><br>        <span class="hljs-comment">//大部分设置不需要我们去修改</span><br><br>        <span class="hljs-comment">//有了它我们通过鼠标 触碰 键盘 控制器 操作UI 响应玩家的输入</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 相关参数</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//1.EventSystem很重要，如果没有它，我们没有办法监听玩家输入</span><br>        <span class="hljs-comment">//2.创建UI时的 2DUI 和3DUI 主要就是摄像机的模式不一样</span><br>        <span class="hljs-comment">//  EventSystem的2D和3D主要是 采用2D碰撞器 还是3D碰撞器 不能直接改变摄像机模式</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Event Type 事件类型<ul><li>决定了脚本如何对鼠标和触屏事件进行响应</li><li>UI模式，那么他们处理事件的方式是根据组件的深度,UI组件里面有脚本Sprite-Widget-Depth，这个Depth越大，表示深度越高，点击得时候处理Depth大的UI的事件</li><li>world模式，那么则会根据距离离主摄像机的远近来进行响应排序，处理离摄像机近的的UI</li><li>2D和3D的区别是，碰撞器是用3D碰撞器还是2D碰撞器2DUI</li></ul></li><li>Events go to<ul><li>事件通过刚体还是碰撞盒传递</li></ul></li><li>Process Events In<ul><li>事件更新进度在Update中还是LateUpdate中</li><li>一般不改，默认在Update中</li></ul></li><li>Event Mask<ul><li>决定哪个游戏对象层级将会接受事件</li></ul></li><li>Debug<ul><li>是否开启调试模式</li><li>如果开启，可以帮助你在点击时</li><li>判断当前和鼠标事件交互的是什么对象</li><li>能在Scene窗口看到信息</li></ul></li><li>Command Click<ul><li>苹果电脑上是否用Command按键模拟右键操作</li></ul></li><li>Allow Multi Touch<ul><li>是否支持多点触碰</li></ul></li><li>Auto Hide Cursor<ul><li>当游戏有控制器或者其他输入设备时</li><li>是否自动隐藏光标</li></ul></li><li>Sticky Tooltip<ul><li>是否使用tooltip</li></ul></li><li>Long Press Tooltip<ul><li>是否长按出提示</li></ul></li><li>Tooltip Delay<ul><li>停留多久出现tip</li></ul></li><li>Raycast Range<ul><li>射线长度，一般不修改</li></ul></li><li>EventSources 接收的事件来源<ul><li>Mouse 鼠标</li><li>Touch 触摸</li><li>Keyboard 键盘</li><li>Controller 控制器</li></ul></li><li>Thresholds 调整鼠标事件的点击、拖、轻拍等行为<ul><li>Mouse Drag</li><li>Mouse Click</li><li>Touch Drag</li><li>Touch Tap</li></ul></li><li>Axes and keys<ul><li>热键关系</li><li>一般不修改</li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/dkX2Twsb7pKyWEJ.png" alt="Pasted image 20241127105755.png"></p><p><img src="https://s2.loli.net/2024/12/01/u6xYagU1Avc5psD.png" alt="Pasted image 20241127110751.png"><br><img src="https://s2.loli.net/2024/12/01/MRFHAI1JPoBUuDE.png" alt="参数1.png"></p><p><img src="https://s2.loli.net/2024/12/01/zO1489ZoIsXrmVN.png" alt="参数2.png"></p><h1 id="图集制作"><a href="#图集制作" class="headerlink" title="图集制作"></a>图集制作</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson2</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 图集用来干啥</span><br>        <span class="hljs-comment">//NGUI中的最小图片控件Sprite要使用图集中的图片进行显示</span><br>        <span class="hljs-comment">//图集 就是把很多单独的小图 合并为 一张大图 合并后的大图就是图集</span><br>        <span class="hljs-comment">//目的：提高渲染性能</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 打开图集制作工具</span><br>        <span class="hljs-comment">//方法一：Project右键打开</span><br>        <span class="hljs-comment">//方法二：上方工具栏NGUI——Open——Atlas Maker</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 新建图集</span><br>        <span class="hljs-comment">//在图集工具中创建</span><br><br>        <span class="hljs-comment">//图集关键文件有3</span><br>        <span class="hljs-comment">//1.图集文件</span><br>        <span class="hljs-comment">//2.图集材质</span><br>        <span class="hljs-comment">//3.图集图片</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 修改删除图集元素</span><br>        <span class="hljs-comment">//在图集工具中操作</span><br>        <span class="hljs-comment">//增删改</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/01/BgzUijdC2kH5cSA.png" alt="Pasted image 20241127114002.png"><br><img src="https://s2.loli.net/2024/12/01/IjToOCir9YQ31VN.png" alt="Pasted image 20241127114054.png"><br><img src="https://s2.loli.net/2024/12/01/3KRMLVtnUJFdefl.png" alt="Pasted image 20241127114020.png"></p><ul><li>创建图集<br><img src="https://s2.loli.net/2024/12/01/VeJp4mKQjSOIzwZ.png" alt="Pasted image 20241127114306.png"></li></ul><p><img src="https://s2.loli.net/2024/12/01/35vFa1Q4YcewAUL.png" alt="Pasted image 20241127114549.png"></p><ul><li><p>可以指定当前编辑的是哪个图集<br><img src="https://s2.loli.net/2024/12/01/8pxksJZHGwiVWOC.png" alt="Pasted image 20241127153648.png"></p></li><li><p>Material 可以快速选中当前图集对应的材质球</p></li><li><p>Texture 可以快速选中当前图集对应的图片<br><img src="https://s2.loli.net/2024/12/01/EDepYzNaHr92k85.png" alt="Pasted image 20241127153810.png"></p></li><li><p>Padding 图片间像素间隔</p><ul><li>也就是图集中图片之间的间隔</li></ul></li><li><p>Trim Alpha 移除图片多余空白空间</p><ul><li>如果一个图片是png，有透明背景，会将透明背景剔除，不管透明背景</li></ul></li><li><p>PMA Shader 预乘透明通道</p></li><li><p>Unity Packer 自定义打包器</p></li><li><p>Truecolor 强制ARGB32纹理</p><ul><li>A 透明度</li><li>R 红色</li><li>G 绿色</li><li>B 蓝色</li></ul></li><li><p>Auto-upgrade 自动更新，用精灵替换纹理</p></li><li><p>Force Square 如果启用，将强制方形图集纹理长宽都为2的n次方</p><ul><li>也就是图集的大小，为方形</li><li>并且像素值为2的n次方</li></ul></li><li><p>Pre-processor 预处理器</p></li><li><p>View Sprites</p><ul><li>更详细的查看图集中一个个的图片<br><img src="https://s2.loli.net/2024/12/01/demlM3NwcTiGYqQ.png" alt="Pasted image 20241127155932.png"></li></ul></li><li><p>选中图片的时候会出现下面的情况</p></li><li><p>Update 表示图片名称一样，进行更新</p></li><li><p>Add 新图片，新添加</p></li><li><p>上方的Add &#x2F;Update就可以重新更新选中的图集了</p></li><li><p>添加完之后会有x，如上一张图片，就可以删除图集中添加的图片了<br><img src="https://s2.loli.net/2024/12/01/UiDxuLdM7beIJSK.png" alt="Pasted image 20241127160116.png"></p></li></ul><p><img src="https://s2.loli.net/2024/12/01/aiFM7G26XIWsbK3.png" alt="图集工具参数.png"></p><h1 id="Sprite精灵图片"><a href="#Sprite精灵图片" class="headerlink" title="Sprite精灵图片"></a>Sprite精灵图片</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson3</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br><br><span class="hljs-comment">// NGUI需要用UISprite</span><br>    <span class="hljs-keyword">public</span> UISprite sprite;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Sprite用来做啥</span><br>        <span class="hljs-comment">//NGUI中所有中小尺寸图片显示都用Sprite显示</span><br>        <span class="hljs-comment">//使用它来显示图集中的单个图片资源</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 创建Sprite</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 Sprite参数</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 代码设置图片</span><br>        <span class="hljs-comment">//sprite.width = 200;</span><br>        <span class="hljs-comment">//sprite.height = 300;</span><br>        <span class="hljs-comment">//1.改变为当前图集中选择的图片</span><br><span class="hljs-comment">// 在同一个图集中，直接改成对应图片的名字就可以了</span><br>        sprite.spriteName = <span class="hljs-string">&quot;bk&quot;</span>;<br><br>        <span class="hljs-comment">//2.改变为其它图集中的图片</span><br>        <span class="hljs-comment">//先加载图集，NGUIAtlas表示是图集，否则可能加载错误，因为还有其他同名的材质球和图片</span><br>        NGUIAtlas atlas = Resources.Load&lt;NGUIAtlas&gt;(<span class="hljs-string">&quot;Atlas/login&quot;</span>);<br>        sprite.atlas = atlas;<br>        <span class="hljs-comment">//再设置图片</span><br>        sprite.spriteName = <span class="hljs-string">&quot;ui_DL_anniuxiao_01&quot;</span>;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>创建Sprite<br><img src="https://s2.loli.net/2024/12/01/hoCbcT6sDMut318.png" alt="Pasted image 20241127165355.png"></p></li><li><p>Atlas 选择使用的图集</p></li><li><p>Sprite 选择使用图集中的精灵图片</p></li><li><p>Material 材质，一般不修改</p></li><li><p>Fixed Aspect  固定宽高比</p><ul><li>不管如何变化尺寸</li><li>适中保持宽高比</li></ul></li><li><p>Type 图片类型</p><ul><li>Simple 普通模式<ul><li>缩放会拉伸</li></ul></li><li>Sliced 切片模式<ul><li>可九宫格缩放</li></ul></li><li>Tiled 平铺模式<ul><li>图片重复绘制</li><li>Horizontal 水平</li><li>Vertical 竖直</li><li>Radial 90 90度</li><li>Radial 180 180度</li><li>Radial 360 360度</li></ul></li><li>Filed 填充模式<ul><li>可以做CD，进度条等。CD的意思就是技能那种时钟类型的等待</li></ul></li><li>Advanced 高级模式<ul><li>可以把图片分成5个部分分别设置模式</li></ul></li></ul></li><li><p>Filp 翻转模式</p><ul><li>Nothing 不翻转</li><li>Horizontally 水平翻转</li><li>Vertically 竖直翻转</li><li>Both 水平竖直都翻转</li></ul></li><li><p>Gradient 渐变色</p><ul><li>勾选后上部颜色和下部颜色自动渐变</li></ul></li><li><p>Color Tint</p><ul><li>颜色叠加</li></ul></li><li><p>Pivot</p><ul><li>控制对象中心点，决定用于对齐的中心点</li><li>Pivot左中右、上中下，每个里面选择一个</li><li>对应的就是下面第二张图片的九个位置</li><li><img src="https://s2.loli.net/2024/12/01/41ECxoSjdsvpb6Z.png" alt="Pasted image 20241128215009.png"></li><li><img src="https://s2.loli.net/2024/12/01/KUM5lWtYOuh3wnG.png" alt="Pasted image 20241128215030.png"></li></ul></li><li><p>Depth 深度层级</p><ul><li>用于决定渲染顺序，不过是用在同一个Panel中，表示的是控件之间的渲染顺序，Panel中有自己单独的Depth</li><li>值越大越后渲染，显示在前方，深度值的意思是渲染的顺序，值越小，渲染的顺序越靠前，所以值越大，就能够覆盖之前渲染的</li></ul></li><li><p>Size 尺寸</p><ul><li>Snap 原始尺寸显示，也就是图片原始是98x98的大小，把图片也调整为这么大显示在Game&#x2F;Scene中</li></ul></li><li><p>Aspect 宽高比</p><ul><li>Free 随意缩放</li><li>Based On Width  基于宽等比变化</li><li>Based On Height 基于高等比变化</li></ul></li><li><p>Sliced模式<br><img src="https://s2.loli.net/2024/12/01/yjZnpKwtbmfrxuH.png" alt="Pasted image 20241127170518.png"></p></li><li><p>下面两张图拉伸后的实例</p></li><li><p>设置Sprite Details 中的Border参数的效果</p></li><li><p>实际上就是这四个角不回被拉伸<br><img src="https://s2.loli.net/2024/12/01/QRKkvdcHTgqb4ta.png" alt="Pasted image 20241127170642.png"></p></li></ul><p><img src="https://s2.loli.net/2024/12/01/6J1kqtMfHB74lTR.png" alt="Pasted image 20241127170717.png"></p><p><img src="https://s2.loli.net/2024/12/01/mz6o4XKYF1GwnMP.png" alt="Pasted image 20241127170835.png"></p><ul><li><p>Tiled 平铺模式<br><img src="https://s2.loli.net/2024/12/01/pZXcoL6NSKy1mli.png" alt="Pasted image 20241127171039.png"></p></li><li><p>Filed</p><ul><li>Horizontal<br><img src="https://s2.loli.net/2024/12/01/XKNvHecLsA65m98.png" alt="Pasted image 20241127171239.png"></li></ul></li><li><p>Vertical<br><img src="https://s2.loli.net/2024/12/01/VrPFJvpybigO4R2.png" alt="Pasted image 20241127171301.png"></p></li><li><p>Radial 90<br><img src="https://s2.loli.net/2024/12/01/vYzILJPkxo98HfK.png" alt="Pasted image 20241127171317.png"></p></li><li><p>Radial 180<br><img src="https://s2.loli.net/2024/12/01/mCZXMDfYKGUd9tN.png" alt="Pasted image 20241127171332.png"></p></li><li><p>Radial 360<br><img src="https://s2.loli.net/2024/12/01/YNVM5bEsdXFouU4.png" alt="Pasted image 20241127171406.png"></p></li></ul><p><img src="https://s2.loli.net/2024/12/01/EvZ5sDy4jUROJAd.png" alt="Sprite参数1.png"></p><p><img src="https://s2.loli.net/2024/12/01/A47BGrZ6bMF9Hix.png" alt="Sprite参数2.png"></p><p><img src="https://s2.loli.net/2024/12/01/yXLRjnmbsVodNZ2.png" alt="Sprite参数3.png"></p><h1 id="Label-文本控件知识点"><a href="#Label-文本控件知识点" class="headerlink" title="Label 文本控件知识点"></a>Label 文本控件知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson4</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UILabel label;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Label用来干啥</span><br>        <span class="hljs-comment">//NGUI中所有文本显示都使用Label来显示</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 创建Label</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 Label参数</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 富文本</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点五 代码设置Label</span><br>        label.text = <span class="hljs-string">&quot;123123123123&quot;</span>;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Font</p><ul><li>使用Unity字体可以使用fft的字体文件（<code>C:\Windows\Fonts</code>）,可以拖到资源中，然后拖到Label脚本中</li><li>也可以使用NGUI字体图集（之后专门讲解）</li></ul></li><li><p>Material</p><ul><li>材质，一般不会修改</li></ul></li><li><p>FontSize 字体大小</p><ul><li>这个如果Label很小的话，可能显示的大小比设置的要小，需要自己调整文字框的大小。（默认Modifier 为 Shrink Content模式）</li><li>Normal 普通 </li><li>Bold 加粗</li><li>Italic 斜体</li><li>Bold And Italic 加粗并斜体</li></ul></li><li><p>Text 显示内容</p></li><li><p>Modifier 修饰方式，引强制大小写字母</p><ul><li>None 没有限制</li><li>To Uppercase 大写字母</li><li>To Lowercase 小写字母</li><li>Custom 自定义</li></ul></li><li><p>Overflow </p><ul><li>Shrink Content 收缩内容<ul><li>文字显示的大小与Label的大小自动适应</li><li>Label控件尺寸不足显示较大字体时</li><li>字体的尺寸会自动适应Label控件的尺寸</li></ul></li><li>Clamp Content 夹紧内容<ul><li>裁减掉无法显示的字体内容</li><li>字体会按照FontSize大小来显示</li><li>如果Label控件大小不足以装下字体时</li><li>对应内容被裁剪掉不会显示</li></ul></li><li>Resize Freely 自动调整大小<ul><li>Labe大小去适应字体内容的大小</li></ul></li><li>Resize Height 自动调整高<ul><li>Label控件高度无法手动调节</li><li>会随着字体内容的大小需求去适配字体内容</li><li>只能手动调节Label控件的宽度</li></ul></li></ul></li><li><p>Alignment 对齐方式</p><ul><li>Automatic 自动对齐</li><li>Left 居左</li><li>Center 中心</li><li>Right 居右</li><li>Justified 调整会自动变化</li></ul></li><li><p>Keep crispp 动态字体锐化</p><ul><li>这是一个动态字体功能，可以确保文本在收缩时清晰</li><li>Never Never</li><li>OnDesktop和Always区别不大都会开启</li></ul></li><li><p>Gradient  渐变</p></li><li><p>Effect 特效</p><ul><li>None 没有</li><li>Shadow 阴影效果</li><li>OutLine和Outline8 边缘线，计算参数不同8粗一点</li></ul></li><li><p>Float spacing 开启浮点数间隔调整</p><ul><li>默认整形，不勾选</li></ul></li><li><p>Spacing 字符间隔</p></li><li><p>Max Lines 最大行数</p><ul><li>默认0，表示可以有很多行，不限制</li></ul></li><li><p>BBCode 是否开启富文本</p></li><li><p>Color Tint 字体颜色</p></li><li><p>富文本</p><ul><li>$[ff0000]颜色[-]$</li><li>$[b]加粗[&#x2F;b]$</li><li>$[i]斜体[&#x2F;i]$</li><li>$[u]下划线[&#x2F;u]$</li><li>$[s]直线穿过文字[&#x2F;s]$</li><li>$[sub]右下角显示[&#x2F;sub]$</li><li>$[sup]右上角显示[&#x2F;sup]$</li><li>$[url&#x3D;<a href="http://www.baidu.com/][u]%E8%B6%85%E9%93%BE%E6%8E%A5[/u]/url]$">http://www.baidu.com/][u]超链接[/u]/url]$</a><ul><li>希望点击超链接能打开页面</li><li><ol><li>添加碰撞器</li></ol><ul><li><img src="https://s2.loli.net/2024/12/01/QvSOui9PwjGz6Zs.png" alt="Pasted image 20241128230831.png"></li></ul></li><li><ol start="2"><li>添加脚本OpenURLOnClick</li></ol></li></ul></li></ul></li><li><p>创建Label<br><img src="https://s2.loli.net/2024/12/01/5UV12zoAZu8S9K4.png" alt="Pasted image 20241128224814.png"><br><img src="https://s2.loli.net/2024/12/01/svQRYon7XyTDk18.png" alt="Pasted image 20241128224830.png"></p></li></ul><p><img src="https://s2.loli.net/2024/12/01/Wbo2SAkvpNLt7UH.png" alt="Pasted image 20241128225252.png"></p><p><img src="https://s2.loli.net/2024/12/01/rWnpoIhLG1yc2ax.png" alt="label_parameters1.png"><br><img src="https://s2.loli.net/2024/12/01/JMIHdwzheRtlrEa.png" alt="label_parameters2.png"><br><img src="https://s2.loli.net/2024/12/01/g9I6iR5OqdUeQHL.png" alt="rich_text.png"></p><h1 id="Texture大图控件"><a href="#Texture大图控件" class="headerlink" title="Texture大图控件"></a>Texture大图控件</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson5</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UITexture tex;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Texture用来干啥</span><br>        <span class="hljs-comment">//Sprite只能显示图集中图片 一般用于显示中小图片</span><br>        <span class="hljs-comment">//如果使用大尺寸图片 没有必要打图集</span><br>        <span class="hljs-comment">//直接使用Texture组件进行大图片显示</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 代码设置</span><br>        <span class="hljs-comment">//加载图片</span><br>        Texture texture = Resources.Load&lt;Texture&gt;(<span class="hljs-string">&quot;BK&quot;</span>);<br>        <span class="hljs-comment">//改变图片</span><br>        <span class="hljs-keyword">if</span> (texture != <span class="hljs-literal">null</span>)<br>            tex.mainTexture = texture;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Texture 图片资源</p></li><li><p>Material 材质 一般不改</p></li><li><p>Shader 着色器 一般不改</p></li><li><p>Type 图片类型 </p><ul><li>Simple 普通模式，缩放会拉伸</li><li>Sliced 切片模式，可九宫格缩放</li><li>Tiled 平铺模式<ul><li>图片重复绘制</li></ul></li><li>Filed 填充模式<ul><li>可以做CD，进度条等</li></ul></li><li>Advanced 高级模式<ul><li>可以把图片分成5个部分分别设置模式</li></ul></li></ul></li><li><p>Flip 翻转模式</p><ul><li>Nothing</li><li>Horizontally 水平翻转</li><li>Vertically 竖直翻转</li><li>Both 水平竖直都翻转</li></ul></li><li><p>Gradient 渐变色</p><ul><li>勾选后，上部颜色和下部颜色，自动渐变</li></ul></li><li><p>Color Tint 颜色叠加</p></li><li><h2 id="创建Texture"><a href="#创建Texture" class="headerlink" title="创建Texture  - "></a>创建Texture<br>  - <img src="https://s2.loli.net/2024/12/01/XEqUhoOpjVAareb.png" alt="Pasted image 20241128231430.png"></h2></li></ul><p><img src="https://s2.loli.net/2024/12/01/AFK1lW3GEs5yw6R.png" alt="Texture_parameters.png"></p><h1 id="Button按钮组件知识点"><a href="#Button按钮组件知识点" class="headerlink" title="Button按钮组件知识点"></a>Button按钮组件知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson6</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UIButton btn;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 所有组合控件的共同特点</span><br>        <span class="hljs-comment">//1.在3个基础组件对象上添加对应组件</span><br>        <span class="hljs-comment">//2.如果希望响应点击等事件 需要添加碰撞器</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 Button是用来干嘛的</span><br>        <span class="hljs-comment">//UI界面中的按钮 当点击按钮后我们可以进行一些处理</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 制作Button</span><br>        <span class="hljs-comment">//1.一个Sprite（需要文字再加一个Label子对象）</span><br>        <span class="hljs-comment">//2.为Sprite添加Button脚本</span><br>        <span class="hljs-comment">//3.添加碰撞器</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点五 监听事件的两种方式</span><br>        <span class="hljs-comment">//1.拖脚本</span><br>        <span class="hljs-comment">//2.代码获取按钮对象监听</span><br>        <span class="hljs-comment">// 这个EventDelegate是无参数，无返回值的</span><br>        <span class="hljs-comment">// 如果想要传入参数，可以封装一层</span><br>        <span class="hljs-comment">// 好像可以传入一个MonoBehaviour子类的类，然后写方法名</span><br>        btn.onClick.Add(<span class="hljs-keyword">new</span> EventDelegate(ClickDo2));<br><br>        btn.onClick.Add(<br>            <span class="hljs-keyword">new</span> EventDelegate(() =&gt;<br>            &#123;<br>                print(<span class="hljs-string">&quot;那么大表达式添加的 点击事件处理&quot;</span>);<br>            &#125;)<br>        );<br><br>        btn.onClick.Add(<span class="hljs-keyword">new</span> EventDelegate(() =&gt; ClickDo2(<span class="hljs-string">&quot;Hello, World!&quot;</span>)));<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClickDoSomthing</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;按钮点击&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClickDo2</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;按钮点击2&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ClickDo2</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Debug.Log(message);<br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>    <span class="hljs-comment">//1.button的制作流程</span><br>    <span class="hljs-comment">//  3个基础组件构成 任意一个基础组件 往上面添加Button脚本 再添加碰撞器 就可以让它变成一个按钮</span><br>    <span class="hljs-comment">//2.事件的监听</span><br>    <span class="hljs-comment">// 通过 拖曳 或者 代码的形式 可以进行按钮的 点击事件 监听</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>制作Button 步骤<ul><li>1.一个Sprite（需要文字再加一个Label子对象）<ul><li><img src="https://s2.loli.net/2024/12/01/bMndSasTrOvI9fF.png" alt="Pasted image 20241128234834.png"></li></ul></li><li>2.为Sprite添加Button脚本<ul><li><img src="https://s2.loli.net/2024/12/01/aIhb7qAlFiOZMQ2.png" alt="Pasted image 20241128235004.png"></li><li><img src="https://s2.loli.net/2024/12/01/U9rpyc1Jzihld3C.png" alt="Pasted image 20241128235029.png"></li></ul></li><li>3.添加碰撞器<ul><li><img src="https://s2.loli.net/2024/12/01/qBSMYVOpAP1DIZ5.png" alt="Pasted image 20241128235051.png"></li></ul></li></ul></li><li>Twen Target 按钮控制的目标<ul><li>一般是3个基础控件之一</li><li>会自动设置</li></ul></li><li>Drag Over<ul><li>拖动结束后做什么事件</li></ul></li><li>Transition 过渡效果持续时间</li><li>Colors 按钮各状态颜色设置<ul><li>Normal 普通</li><li>Hover 经过</li><li>Pressed 按下</li><li>Disabled 失活</li><li>Default 默认</li></ul></li><li>Sprites 按钮各状态图片设置<ul><li>Normal 普通</li><li>Hover 经过</li><li>Pressed 按下</li><li>Disabled 失活</li><li>Pixel Snap 自动设置原始大小<ul><li>勾选后，选择的图片是什么大小，按钮使用时就显示什么样大小的图片</li></ul></li></ul></li><li>OnCIick 点击按钮响应脚本<ul><li><img src="https://s2.loli.net/2024/12/01/r1lnGX7fDP98JUI.png" alt="Pasted image 20241129001126.png"><br><img src="https://s2.loli.net/2024/12/01/16Cs5EqwgKjHf3b.png" alt="Button_parameters.png"></li></ul></li></ul><h1 id="Toggle单选多选框组件知识点"><a href="#Toggle单选多选框组件知识点" class="headerlink" title="Toggle单选多选框组件知识点"></a>Toggle单选多选框组件知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson7</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UIToggle tog1;<br>    <span class="hljs-keyword">public</span> UIToggle tog2;<br>    <span class="hljs-keyword">public</span> UIToggle tog3;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Toggle用来干啥</span><br>        <span class="hljs-comment">//单选框 多选框都可以使用它来制作</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 制作Toggle</span><br>        <span class="hljs-comment">//1.2个Sprite 1父1子</span><br>        <span class="hljs-comment">//2.为父对象添加Toggle脚本</span><br>        <span class="hljs-comment">//3.添加碰撞器</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 监听事件的两种方式</span><br>        <span class="hljs-comment">//1.拖代码</span><br>        <span class="hljs-comment">//2.代码进行监听添加</span><br><br>        tog1.onChange.Add(<span class="hljs-keyword">new</span> EventDelegate(Change2));<br>        tog2.onChange.Add(<span class="hljs-keyword">new</span> EventDelegate(Change2));<br>        tog3.onChange.Add(<span class="hljs-keyword">new</span> EventDelegate(Change2));<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Change2</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;代码监听&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Change</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;Toggle变化执行的内容&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (tog1.<span class="hljs-keyword">value</span>)<br>        &#123;<br>            print(<span class="hljs-string">&quot;tog1选中&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tog2.<span class="hljs-keyword">value</span>)<br>        &#123;<br>            print(<span class="hljs-string">&quot;tog2选中&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tog3.<span class="hljs-keyword">value</span>)<br>        &#123;<br>            print(<span class="hljs-string">&quot;tog3选中&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Group</p><ul><li>多选框分组</li><li>多个多选框分为一组则变为单选框</li><li>StateofNone 单选框状态时是否允许不选中</li></ul></li><li><p>Starting State 开始默认状态，勾选Starting State为选中</p></li><li><p>Sprite 选中用图片</p></li><li><p>Invert State 反转状态</p><ul><li>如果选中不显示，不选中显示，就勾选它</li></ul></li><li><p>Animator 状态变化时播放动画（新动画系统）</p></li><li><p>Animation 状态变化时播放动画（老动画系统）</p></li><li><p>Tween 状态变化时缓动</p></li><li><p>Transition 过渡模式</p></li><li><p>OnValueChange 状态变化时响应脚本</p></li><li><p>2个Sprite 1父1子</p><ul><li><img src="https://s2.loli.net/2024/12/01/SoKmBIxYiyCWGML.png" alt="Pasted image 20241129104052.png"></li></ul></li><li><p>为父对象添加Toggle脚本</p><ul><li><img src="https://s2.loli.net/2024/12/01/SAwfZJTmuxatOQo.png" alt="Pasted image 20241129104013.png"></li></ul></li><li><p>添加碰撞器</p><ul><li><img src="https://s2.loli.net/2024/12/01/segwvyktdCrVF7f.png" alt="Pasted image 20241129104210.png"></li></ul></li><li><p>需要关联的这个对象拖到Toggle上</p></li><li><p>此时运行Unity，点击Game窗口就可以出现单选框的现象了<br><img src="https://s2.loli.net/2024/12/01/c5K7fQp1EW3NYew.png" alt="Pasted image 20241129104426.png"></p></li><li><p>如果是多选框，多个是互斥的，则把Toggle脚本上的Group变成一样的数字</p></li><li><p>数字0表示不分组，就是多选框</p></li><li><p>State of None表示勾选后是否可以多个都不选，否则至少选择一个<br><img src="https://s2.loli.net/2024/12/01/G4BOAcM7jDlf596.png" alt="Pasted image 20241129105459.png"></p></li><li><p>当指定多选框状态变化的时候，调用指定的方法<br><img src="https://s2.loli.net/2024/12/01/RUm6PeXhWVg2sB9.png" alt="Pasted image 20241129110052.png"></p></li></ul><p><img src="https://s2.loli.net/2024/12/01/ThvaPIXCuSYz5pB.png" alt="Toggle_parameters.png"></p><h1 id="Input输入框组件知识点"><a href="#Input输入框组件知识点" class="headerlink" title="Input输入框组件知识点"></a>Input输入框组件知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson8</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UIInput input;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Input是啥</span><br>        <span class="hljs-comment">//输入框</span><br>        <span class="hljs-comment">//可以用来制作账号密码聊天输入框</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 制作Input</span><br>        <span class="hljs-comment">//1.1个Sprite做背景 1个Label显示文字</span><br>        <span class="hljs-comment">//2.为Sprint添加Input脚本</span><br>        <span class="hljs-comment">//3.添加碰撞器</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 监听事件的两种方式</span><br>        <span class="hljs-comment">//1.拖曳脚本</span><br>        <span class="hljs-comment">//2.通过代码关联</span><br><br>        input.onSubmit.Add(<span class="hljs-keyword">new</span> EventDelegate(() =&gt;<br>        &#123;<br>            print(<span class="hljs-string">&quot;完成输入 通关代码添加的监听函数&quot;</span>);<br>        &#125;));<br><br>        input.onChange.Add(<span class="hljs-keyword">new</span> EventDelegate(() =&gt;<br>        &#123;<br>            print(<span class="hljs-string">&quot;输入变化 通关代码添加的监听函数&quot;</span>);<br>        &#125;));<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnSubmit</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;输入完成&quot;</span> + input.<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnChange</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;输入变化&quot;</span> + input.<span class="hljs-keyword">value</span>);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>1个Sprite做背景 1个Label显示文字</p></li><li><p>为Sprint添加Input脚本</p><ul><li><img src="https://s2.loli.net/2024/12/01/AgQnNE1rToZx3DG.png" alt="Pasted image 20241129113650.png"></li></ul></li><li><p>添加碰撞器<br>  -<img src="https://s2.loli.net/2024/12/01/hSQVE2va8xOwdpW.png" alt="Pasted image 20241129113912.png"></p></li><li><p>Label  关联的文本组件</p><ul><li>需要将Label拖给脚本的这个参数</li><li><img src="https://s2.loli.net/2024/12/01/LanmfdQZUqAyu9W.png" alt="Pasted image 20241129114454.png"></li></ul></li><li><p>Starting Value 开始默认显示的内容</p></li><li><p>Saved As  </p><ul><li>若此处填写内容，会使用PlayerPrefs将输入内容作为此处填写的key，实际的内容作为值进行存储</li><li>一般不使用</li></ul></li><li><p>ActiveTextColor 选中激活时颜色</p></li><li><p>Inactive Color 未选中失活时颜色 </p></li><li><p>Caret Color 插入光标的颜色</p></li><li><p>Selection Color 选中文字的背景颜色</p></li><li><p>InputType 输入类型</p><ul><li>Standard 默认模式</li><li>Auto Correct 自动更正</li><li>Password 密码输入 (输入内容看不到）</li></ul></li><li><p>Validation 输入限制</p><ul><li>None：无限制</li><li>Integer：只能输入整形</li><li>Float：可以输入浮点数</li><li>Alphanumeric：只能是数字和字母</li><li>Username：用户名，只能输入小写字母</li><li>Name：姓名，大小写字母+空格</li><li>Filename：文件名，只是多了一些特殊字符的输入</li></ul></li><li><p>Mobile Keyboard 手机键盘模式</p><ul><li>Default </li><li>ASCII Capable 英文</li><li>Numbers And Punctuation 数字符号</li><li>URL 链接</li><li>Number Pad 数字</li><li>Phone Pad 手机</li><li>Name Phone Pad 名字</li><li>Email Address 邮箱地址</li></ul></li><li><p>Hide Input 键盘下隐藏输入框</p><ul><li>输入的内容可以在键盘上看见，如果勾选，只能通过游戏界面看见</li><li>不勾选，键盘会自带输入内容的文本框</li></ul></li><li><p>On Return Key 完成键（回车键）做什么操作</p><ul><li>Default 默认操作，根据系统的默认情况指定</li><li>Submit 结束输入，回车键表示结束输入<ul><li>一般选择这个</li><li>如果想要调用OnSubmit方法，必须选择这个，不然可能无反应</li></ul></li><li>New Line 换行</li></ul></li><li><p>Character Limit 最大可输入字符数</p><ul><li>0表示无限制</li></ul></li><li><p>OnSubmit 输入完成时响应脚本</p><ul><li>需要On Return Key中设置Submit</li></ul></li><li><p>OnChange 输入变化时响应脚本</p></li></ul><p><img src="https://s2.loli.net/2024/12/01/vHyzYkO1Z4mX3N7.png" alt="Input_parameters1.png"><br><img src="https://s2.loli.net/2024/12/01/KDm3ybs9WOxRLoA.png" alt="Input_parameter2.png"></p><h1 id="PopupList下拉列表相关知识点"><a href="#PopupList下拉列表相关知识点" class="headerlink" title="PopupList下拉列表相关知识点"></a>PopupList下拉列表相关知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson9</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UIPopupList list;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 PopupList是啥？</span><br>        <span class="hljs-comment">//下拉列表</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 制作Popuplist</span><br>        <span class="hljs-comment">//1.一个sprite做背景 一个lable做显示内容</span><br>        <span class="hljs-comment">//2.添加PopupList脚本</span><br>        <span class="hljs-comment">//3.添加碰撞器</span><br>        <span class="hljs-comment">//4.关联lable做信息更新，选择Label中的SetCurrentSelection函数</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 监听事件的两种方式</span><br>        <span class="hljs-comment">//1.拖曳代码</span><br>        <span class="hljs-comment">//2.代码关联</span><br>        <span class="hljs-comment">// 代码添加选项</span><br>        list.items.Add(<span class="hljs-string">&quot;新加 选项4&quot;</span>);<br><br>        <span class="hljs-comment">// 代码添加监听事件</span><br>        list.onChange.Add(<br>            <span class="hljs-keyword">new</span> EventDelegate(() =&gt;<br>            &#123;<br>                print(<span class="hljs-string">&quot;代码添加的监听&quot;</span> + list.<span class="hljs-keyword">value</span>);<br>            &#125;)<br>        );<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnChange</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;选项变化&quot;</span> + list.<span class="hljs-keyword">value</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一个sprite做背景 一个label做显示内容</li><li>添加PopupList脚本<ul><li><img src="https://s2.loli.net/2024/12/01/pmWdnZ1JQNIrMO5.png" alt="Pasted image 20241129164013.png"></li></ul></li><li>添加碰撞器<ul><li><img src="https://s2.loli.net/2024/12/01/UYS1FhQdBVxIe3K.png" alt="Pasted image 20241129164034.png"></li></ul></li><li>关联Label做信息更新，选择Label中的SetCurrentSelection函数<ul><li><img src="https://s2.loli.net/2024/12/01/TZQU6YKCrGljVxR.png" alt="Pasted image 20241129170649.png"></li></ul></li><li>Options <ul><li>下拉列表显示内容（空一行表示加一个）</li><li>按照下图的设置，就能run，有一个下拉列表的情况了，但是可能还是有范围的问题</li><li><img src="https://s2.loli.net/2024/12/01/UvWxKfuwgTJhO3Y.png" alt="Pasted image 20241129164710.png"></li><li><img src="https://s2.loli.net/2024/12/01/cs3KLb4HThD69WF.png" alt="Pasted image 20241129164808.png"></li></ul></li><li>Position 下拉列表出现位置<ul><li>Auto 自动（建议自动让其自动判断）</li><li>Above 向上，如果会产生出屏幕了，会自己调整</li><li>Below 向下，如果会产生出屏幕了，会自己调整</li></ul></li><li>Selection 选中操作<ul><li>On Press 按下选中（默认选这个）<ul><li>按下的时候会触发Value的事件</li><li><img src="https://s2.loli.net/2024/12/01/C7l2cdtSITEaODk.png" alt="Pasted image 20241129165727.png"></li></ul></li><li>On Click 点击选中</li></ul></li><li>Alignment 下拉列表的对齐方式<ul><li>Automatic 自动对齐</li><li>Left 左对齐</li><li>Center 居中对齐</li><li>Right 右对齐</li><li>Justified 调整会自动变化</li></ul></li><li>Font，设置的是下拉列表上字体的选项<ul><li>Font 字体设置</li><li>Font Size 字体大小</li><li>TextColor 字体颜色</li><li>Padding 偏移位置<ul><li>X表示水平偏移，大于0表示右偏，小于0表示左偏</li><li>Y表示垂直偏移，大于0表示远离Label框，小于0表示接近Label框</li></ul></li><li>Modifier 修饰方式，强制大小写字母<ul><li>None 没有限制</li><li>To Uppercase 大写字母</li><li>To Lowercase 小写字母</li><li>Custom 自定义</li></ul></li></ul></li><li>Open on 下拉列表打开方式<ul><li>Click Or Tap 点击或者触碰</li><li>Right Click 右键</li><li>Double Click 双击</li><li>Manual 手动（相当于关闭。自己代码处理，一般不选择）</li></ul></li><li>On Top 始终显示在所有面板之前<ul><li>默认选择</li><li>不选择可能被其他的面板遮挡，导致无法选择下拉列表</li></ul></li><li>Localized  是否将对弹出列表的值进行本地化</li><li>Keep Value 始终保持有列表中的某个默认值<ul><li>勾选后，会默认显示下拉列表中的某个值，具体由initial Value设置</li></ul></li><li>initial Value<ul><li>可以选择默认初始化选择的列表显示值，需要勾选Keep Value才能生效，这个只是提供给我们一个选择的选项，实际起作用的还是Keep Value</li></ul></li><li>Atlas<ul><li>Atlas 图集</li><li>Background 下拉列表背景图</li><li>Highlight 下拉列表选中图<ul><li>也就是每个选项选中后，背景显示的图</li></ul></li><li>Background 背景颜色叠加</li><li>Highlight 选中高亮叠加家宴</li><li>Overlap 弹出窗口边框与打开它的内容重叠的数量</li><li>Animated 是否有默认的弹出动画，禁用可以节约性能</li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/mG6H7tEI3aBUYfn.png" alt="PopupList_parameters1.png"><br><img src="https://s2.loli.net/2024/12/01/OVnsUmJlCp79PQK.png" alt="PopupList_parameters2.png"><br><img src="https://s2.loli.net/2024/12/01/uwFtcRb4DoT1ixf.png" alt="PopupList_parameters3.png"></p><h1 id="Slider滑动条控件知识点"><a href="#Slider滑动条控件知识点" class="headerlink" title="Slider滑动条控件知识点"></a>Slider滑动条控件知识点</h1><blockquote><p>图片的质量很重要，要对齐，不能上面1像素空白，下面3像素空白，不然对不齐</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson10</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UISlider slider;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Slider是啥？</span><br>        <span class="hljs-comment">//滑动条控件</span><br>        <span class="hljs-comment">//主要用于设置音乐音效大小等</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 制作Slider</span><br>        <span class="hljs-comment">//1.3个sprite 1个做根对象为背景  2个子对象 1个进度 1个滑动块 </span><br>        <span class="hljs-comment">//2.设置层级</span><br>        <span class="hljs-comment">//3.为根背景添加Slider脚本</span><br>        <span class="hljs-comment">//4.添加碰撞器（父对象或者滑块）</span><br>        <span class="hljs-comment">//5.关联3个对象</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 监听事件的两种方式</span><br>        <span class="hljs-comment">//1.拖曳脚本关联</span><br>        <span class="hljs-comment">//2.通过代码关联</span><br>        <span class="hljs-comment">// 拖曳中调用</span><br>        slider.onChange.Add(<span class="hljs-keyword">new</span> EventDelegate(() =&gt; &#123;<br><br>            print(<span class="hljs-string">&quot;通过代码监听&quot;</span> + slider.<span class="hljs-keyword">value</span>);<br>        &#125;));<br><span class="hljs-comment">// 拖曳结束时调用</span><br>        slider.onDragFinished += () =&gt; &#123;<br>            print(<span class="hljs-string">&quot;拖曳结束&quot;</span> + slider.<span class="hljs-keyword">value</span>);<br>        &#125;;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnChange</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;值变化&quot;</span> + slider.<span class="hljs-keyword">value</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Value 当前值0~1</p></li><li><p>Steps 步数将1平分</p></li><li><p>Appearance 外观设置</p><ul><li>Foreground 前景 (用于缩放)</li><li>Background 背景</li><li>Thumb 拖动块</li><li>Direction 拖动方向<ul><li>Left To Right 从左到右</li><li>Right To Left 从右到左</li><li>Bottom To Top 从下到上</li><li>Top To Bottom 从上到下</li></ul></li></ul></li><li><p>OnValueChange 值变化时监听脚本</p></li><li><p>3个sprite 1个做根对象为背景  2个子对象 1个进度 1个滑动块 </p><ul><li><img src="https://s2.loli.net/2024/12/01/waJirGL4bQ7MXUf.png" alt="Pasted image 20241130114237.png"></li></ul></li><li><p>设置层级</p><ul><li>滑动块最前面 2</li><li>进度条中间 1</li><li>背景最后面 0</li><li>调整的是Sprite脚本上的Depth</li><li><img src="https://s2.loli.net/2024/12/01/PJ63qxQRcVYaleX.png" alt="Pasted image 20241130114446.png"></li></ul></li><li><p>为根背景添加Slider脚本</p><ul><li><img src="https://s2.loli.net/2024/12/01/aedbJqSOk1mxQsr.png" alt="Pasted image 20241130114552.png"></li></ul></li><li><p>添加碰撞器（父对象或者滑块）</p><ul><li><img src="https://s2.loli.net/2024/12/01/o8OpU1GlRXN4qjY.png" alt="Pasted image 20241130114646.png"></li></ul></li><li><p>关联3个对象</p><ul><li><img src="https://s2.loli.net/2024/12/01/iAWZ9JUCvkTtpGY.png" alt="Pasted image 20241130114800.png"></li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/NWXdlAj4qKmVrJp.png" alt="Slider_parameters.png"></p><h1 id="ScrollBar滚动条和ProgressBar进度条知识点"><a href="#ScrollBar滚动条和ProgressBar进度条知识点" class="headerlink" title="ScrollBar滚动条和ProgressBar进度条知识点"></a>ScrollBar滚动条和ProgressBar进度条知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson11</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 ScrollBar和ProgressBar用来干啥</span><br>        <span class="hljs-comment">//1.ScrollBar滚动条一般不单独使用 都是配合滚动视图使用 类似VS右侧的滚动条</span><br>        <span class="hljs-comment">//2.ProgressBar进度条 一般不咋使用   一般直接用Sprite的Filed填充模式即可</span><br><br>        <span class="hljs-comment">//他们的参数和之前的知识很类似</span><br>        <span class="hljs-comment">//所以这两个知识点不是重点 了解如何制作他们即可</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 制作Scrollbar</span><br>        <span class="hljs-comment">//1.两个Sprite 1个背景 1个滚动条</span><br>        <span class="hljs-comment">//2.背景父对象添加脚本</span><br>        <span class="hljs-comment">//3.添加碰撞器</span><br>        <span class="hljs-comment">//4.关联对象</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 制作ProgressBar</span><br>        <span class="hljs-comment">//1.两个Sprite 1个背景 1个进度条</span><br>        <span class="hljs-comment">//2.背景父对象添加脚本</span><br>        <span class="hljs-comment">//3.关联对象</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ScrollBar滚动条"><a href="#ScrollBar滚动条" class="headerlink" title="ScrollBar滚动条"></a>ScrollBar滚动条</h2><ul><li>两个Sprite 1个背景 1个滚动条</li><li>背景父对象添加脚本<ul><li>这里要求Scrollbar和Sprite一样长，是重叠的</li><li><img src="https://s2.loli.net/2024/12/01/c3RP7UyBZuIFdXw.png" alt="Pasted image 20241130165310.png"></li></ul></li><li>添加碰撞器<ul><li><img src="https://s2.loli.net/2024/12/01/bHGnIKW3jDUV1cm.png" alt="Pasted image 20241130165358.png"></li></ul></li><li>关联对象<ul><li><img src="https://s2.loli.net/2024/12/01/W8UcetuLTbazQfZ.png" alt="Pasted image 20241130165437.png"></li></ul></li><li>Steps<ul><li>表示按分成几步来移动<br><img src="https://s2.loli.net/2024/12/01/Lli8vGdBckJX1sh.png" alt="Pasted image 20241130165706.png"></li></ul></li></ul><h2 id="ProgressBar进度条"><a href="#ProgressBar进度条" class="headerlink" title="ProgressBar进度条"></a>ProgressBar进度条</h2><ul><li>填充如果是纯色，可以用Sprite脚本上的FIlled类型控制进度<ul><li>如果不是纯色，更加细节，则需要用ProgressBar控制进度条</li></ul></li><li>两个Sprite 1个背景 1个进度条</li><li>背景父对象添加脚本<ul><li><img src="https://s2.loli.net/2024/12/01/lsMKpuxA7XTHUjb.png" alt="Pasted image 20241130170511.png"></li></ul></li><li>不需要添加碰撞器，因为不需要手动改变进度条，是代码控制</li><li>关联对象<ul><li><img src="https://s2.loli.net/2024/12/01/ycfSoqX3uWwltZR.png" alt="Pasted image 20241130170550.png"></li></ul></li></ul><h1 id="ScrollView-滚动视图知识点"><a href="#ScrollView-滚动视图知识点" class="headerlink" title="ScrollView 滚动视图知识点"></a>ScrollView 滚动视图知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson12</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 ScrollView来干啥</span><br>        <span class="hljs-comment">//滚动视图</span><br>        <span class="hljs-comment">//我们现在用于编程的VS代码窗口就是典型的滚动视图</span><br>        <span class="hljs-comment">//游戏中主要用于 背包、商店、排行榜等等功能</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 制作ScrollView</span><br>        <span class="hljs-comment">//1.直接工具栏创建即可 NGUI——Create——ScrollView</span><br>        <span class="hljs-comment">//2.若需要ScrollBar 自行添加水平和竖直</span><br>        <span class="hljs-comment">//3.添加子对象 为子对象添加Drag Scroll View和碰撞器</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 自动对齐脚本Grid 参数相关</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        <span class="hljs-comment">// 通过sv控制滚动条更新</span><br>        <span class="hljs-keyword">public</span> UIScrollView sv;<br>    sv.UpdateScrollbars();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>直接工具栏创建即可 NGUI——Create——ScrollView</p><ul><li>ScrollView不会创建UIRoot，所以需要先创建UIRoot</li><li><img src="https://s2.loli.net/2024/12/01/Wv1xMhgjaFV6ecC.png" alt="Pasted image 20241130171629.png"></li><li><img src="https://s2.loli.net/2024/12/01/YRDlGMwdQy8S3T4.png" alt="Pasted image 20241130171416.png"></li></ul></li><li><p>若需要ScrollBar 自行添加水平和竖直</p></li><li><p>添加子对象 为子对象添加Drag Scroll View和碰撞器</p><ul><li><img src="https://s2.loli.net/2024/12/01/8pzmGqVaNdIZCBi.png" alt="Pasted image 20241130172617.png"></li><li>添加碰撞器</li><li><img src="https://s2.loli.net/2024/12/01/xZSKqFRcrDoYNVC.png" alt="Pasted image 20241130172704.png"></li></ul></li><li><p>ScrollView使用Panel管理，Clipping是SoftClip</p></li><li><p>只有左边紫色的范围内才能够看到图像，其他的需要滚动显示，多余的会被裁剪掉<br><img src="https://s2.loli.net/2024/12/01/PHdLwpjsecXWaIT.png" alt="Pasted image 20241130171846.png"></p></li><li><p>Content Origin 内容子对象对其方式</p></li><li><p>Movement 拖曳的方向，指的是Sprite那个对象，可以在哪个方向可以拖动</p><ul><li>Horizontal 水平</li><li>Vertical 垂直</li><li>Unrestricted 自由</li><li>Custom 自定义</li></ul></li><li><p>Drag Effect 拖动特效</p><ul><li>None 不使用任何效果</li><li>Momentum 动量 (惯性）效果 (差异不明显)</li><li>Momentum And Spring 动量（惯性）和弹力效果</li><li>一般选择<code>Momentum And Spring</code></li></ul></li><li><p>Scroll Wheel Factor 滚动因子</p><ul><li>如果不为0，鼠标中间滚动可以滚动它,可以通过它控制速度和方向</li><li>负数表示方向反向</li></ul></li><li><p>Momentum Amount 动量</p><ul><li>拖曳一下鼠标，动的快慢</li><li>可以理解成惯性大小</li></ul></li><li><p>Spring Strength</p><ul><li>弹力大小</li><li>移动到边缘时弹回时弹力大小</li></ul></li><li><p>Dampen Strength</p><ul><li>如果比较大，会很难拖动</li><li>阻尼强度</li><li>影响回弹效果</li></ul></li><li><p>Restrict Within Panel</p><ul><li>限制在Panel中</li><li>不勾选，不会产生弹力效果，也就是不回弹回</li></ul></li><li><p>Constrain OnDrag</p><ul><li>阻力约束，一般不修改</li></ul></li><li><p>Cancel Drag if fits</p><ul><li>若勾选，滚动视图的内容是否应该是可拖动的，取决于它们当前子对象大小是否溢出</li><li>勾选后，如果对象太小，没有占满屏幕，则不允许拖动</li></ul></li><li><p>Smooth Drag Start</p><ul><li>平滑拖动，一般不修改</li></ul></li><li><p>IOS Drag Emulation</p><ul><li>IOS阻力模拟，一般不修改</li></ul></li><li><p>ScrollBars 滚动条关联</p><ul><li>Horizontal 水平滚动条</li><li>Vertical 竖直滚动条</li><li>ShowCondition 显示时机<ul><li>Always 一直显示</li><li>Only If Needed 需要时显示</li><li>When Dragging 拖动时显示</li></ul></li></ul></li><li><p>自己手动制作一个ScrollBar</p><ul><li><img src="https://s2.loli.net/2024/12/01/RwsEy4S5nND1z3T.png" alt="Pasted image 20241130175950.png"></li></ul></li><li><p>关联到ScrollView上</p><ul><li><img src="https://s2.loli.net/2024/12/01/kUJXTzcbqIj9ipy.png" alt="Pasted image 20241130180037.png"></li></ul></li><li><p>Grid脚本</p></li><li><p><img src="https://s2.loli.net/2024/12/01/apK1vrzlUscoAZ6.png" alt="Pasted image 20241130180449.png"></p></li><li><p>Arrangement 排序对齐方式</p><ul><li>Horizontal 水平</li><li>Vertical 竖直</li><li>Cell Snap 元素大小</li></ul></li><li><p>Cell width 元素宽</p></li><li><p>Cell Height 元素高</p></li><li><p>Row Limit 元素个数（只有水平或者竖直才有）</p><ul><li>会自动换行</li><li>如果选择的是水平，表示列数Row Limit个</li><li>如果选择的是竖直，表示行数为Row Limit个</li></ul></li><li><p>Sorting 排序顺序</p><ul><li>None 没有排序</li><li>Alphabetic 按字母排序</li><li>Horizontal 水平放置顺序</li><li>Vertical 垂直放置顺序</li><li>Custom 自定义</li></ul></li><li><p>Inverted 倒转</p><ul><li>若选择了排序方式</li><li>勾选这里可以翻转排序规则</li></ul></li><li><p>Pivot 锚点位置</p><ul><li>9宫格9个位置，一般选择左上角</li></ul></li><li><p>Smooth Tween 平缓缓动动画</p><ul><li>是否会平滑地将其子对象设置为正确的位置</li></ul></li><li><p>Hide Inactive  是否隐藏不活动组件</p></li><li><p>Constrain To panel 约束面板</p><ul><li>是否将网格子对象的更改通知父容器Panel，勾选后会通知</li><li>会用于更新ScrollBar等显示信息<br><img src="https://s2.loli.net/2024/12/01/RA4TYraCbNL7vhW.png" alt="ScrollView_parameters1.png"><br><img src="https://s2.loli.net/2024/12/01/Fa56kZ1q7jNzXHK.png" alt="ScrollView_parameters2.png"></li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/uPITABFdXv4tGRc.png" alt="Grid_parameters.png"></p><h1 id="Anchor锚点组件知识点"><a href="#Anchor锚点组件知识点" class="headerlink" title="Anchor锚点组件知识点"></a>Anchor锚点组件知识点</h1><h2 id="老版本的Anchor"><a href="#老版本的Anchor" class="headerlink" title="老版本的Anchor"></a>老版本的Anchor</h2><ul><li>UICamera 关联UI摄像机</li><li>Container 控制的容器对象</li><li>Side 9宫格位置</li><li>Run Only Once<ul><li>是否只对齐一次</li><li>一般情况下，设备分辨率都定死的，横屏竖屏也是定死的，所以勾选，除非分辨率要变化才取消勾选</li></ul></li><li>Relative Offset 相对比例偏移位置（0~1）<ul><li>一般建议用这个，不同设备像素密度不同，可能有差别</li></ul></li><li>Pixel Offset 像素偏移位置</li><li>Type 尺寸对齐方式<ul><li>None 无</li><li>Unified 统一模式</li><li>Advanced 高级模式<ul><li>每条边都有一个父对象</li></ul></li></ul></li><li>Execute 什么时候执行更新 <ul><li>On Enable 激活的时候更新</li><li>On Update 每一帧更新</li><li>On Start 在Update之前的Start()更新</li></ul></li><li>Target 相对目标（默认选择的是第一个最近的含有Panel脚本的父对象，一般UI Root都有Panel脚本）<ul><li>Left Sprite左边的蓝色线</li><li>Right Sprite右边的蓝色线</li><li>Bottom  Sprite下面的蓝色线</li><li>Top 上面的蓝色线</li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/v51r2G9X7jHi6OQ.png" alt="Pasted image 20241130222925.png"></p><ul><li>如果不勾选Run Only Once，会在运行的时候重新计算分辨率变化</li><li>勾选可以解决性能<br><img src="https://s2.loli.net/2024/12/01/kBt5rx8pwb9XPDJ.png" alt="Pasted image 20241130224129.png"></li><li>Anchors中的参数</li><li>Left蓝色的线，相对于中间竖直的黑色的线的距离是左偏50px</li><li>Right蓝色的线，相对于中间竖着的黑色的线的距离是右偏50px</li><li>Bottom蓝色的线，相对于中间横着的黑色的线的距离是下偏50px</li><li>Top蓝色的线，相对于中间横着的黑色的线的距离是上偏50px</li><li>最后实际的效果是，Sprite图案按照这个下面的标准进行位置确定，缩放的话是其他参数<br><img src="https://s2.loli.net/2024/12/01/2rDFgWBSUwX9vIO.png" alt="Pasted image 20241130224923.png"></li><li>Anchors中的Left…和Target’s Center在哪里</li><li>Left指的是蓝色的四条线，Target’s指的是红色的四条线加上两条黑色的线</li><li><img src="https://s2.loli.net/2024/12/01/tCkwXEWv1fRKFil.png" alt="Pasted image 20241130225057.png"></li></ul><p><img src="https://s2.loli.net/2024/12/01/VQuXgjtapqUYPf1.png" alt="Anchor_parameters.png"></p><h1 id="EventListener和EventTrigger知识点"><a href="#EventListener和EventTrigger知识点" class="headerlink" title="EventListener和EventTrigger知识点"></a>EventListener和EventTrigger知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson14</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> UISprite A;<br>    <span class="hljs-keyword">public</span> UISprite B;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 控件自带事件的局限性</span><br>        <span class="hljs-comment">//目前复合控件只提供了一些常用的事件监听方式</span><br>        <span class="hljs-comment">//比如</span><br>        <span class="hljs-comment">//Button —— 点击</span><br>        <span class="hljs-comment">//Toggle —— 值变化</span><br>        <span class="hljs-comment">//等等</span><br>        <span class="hljs-comment">//如果想要制作 按下 抬起 长按等功能 利用现在的知识是无法完成的</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 NGUI事件 响应函数</span><br>        <span class="hljs-comment">//添加了碰撞器的对象</span><br>        <span class="hljs-comment">//NGUI提供了一些利用反射调用的函数</span><br>        <span class="hljs-comment">//经过 OnHover(bool isOver)</span><br>        <span class="hljs-comment">//按下 OnPress(bool pressed)</span><br>        <span class="hljs-comment">//点击 OnClick()</span><br>        <span class="hljs-comment">//双击 OnDoubleClick()</span><br>        <span class="hljs-comment">//拖曳开始 OnDragStart()</span><br>        <span class="hljs-comment">//拖曳中  OnDrag(Vector2 delta)</span><br>        <span class="hljs-comment">//拖曳结束 OnDragEnd()</span><br>        <span class="hljs-comment">//拖曳经过某对象 OnDragOver(GameObject go)</span><br>        <span class="hljs-comment">//拖曳离开某对象 OnDragOut(GameObject go)</span><br>        <span class="hljs-comment">//等等等等</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 更加方便的UIEventListener和UIEventTrigger</span><br>        <span class="hljs-comment">//他们帮助我们封装了所有 特殊响应函数</span><br>        <span class="hljs-comment">//可以通过它进行管理添加</span><br>        <span class="hljs-comment">//1.UIEventListener 适合代码添加</span><br>        UIEventListener listener = UIEventListener.Get(A.gameObject);<br>        listener.onPress += (obj, isPress) =&gt;<br>        &#123;<br>            print(obj.name + <span class="hljs-string">&quot;被按下或者抬起了&quot;</span> + isPress);<br>        &#125;;<br><br>        listener.onDragStart += BeginDrag;<br><br>        <span class="hljs-comment">//2.UIEventTrigger 适合Inspector面板 关联脚本添加</span><br><br><br>        <span class="hljs-comment">//UIEventListener和UIEventTrigger区别</span><br>        <span class="hljs-comment">//1.Listener更适合，代码添加监听，Trigger适合拖曳对象添加监听</span><br>        <span class="hljs-comment">//2.Listener传入的参数更具体，Trigger就不会传入参数，我们需要在函数中去判断处理逻辑</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginDrag</span>(<span class="hljs-params">GameObject obj</span>)</span><br>    &#123;<br>        print(obj.name + <span class="hljs-string">&quot;开始拖曳&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Press</span>()</span> &#123; &#125;<br><br>    <span class="hljs-comment">//void OnPress(bool pressed)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    if( pressed )</span><br>    <span class="hljs-comment">//    &#123;</span><br>    <span class="hljs-comment">//        print(&quot;按下&quot;);</span><br>    <span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-comment">//    else</span><br>    <span class="hljs-comment">//    &#123;</span><br>    <span class="hljs-comment">//        print(&quot;抬起&quot;);</span><br>    <span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//void OnHover(bool isOver)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    if( isOver )</span><br>    <span class="hljs-comment">//    &#123;</span><br>    <span class="hljs-comment">//        print(&quot;鼠标经过&quot;);</span><br>    <span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-comment">//    else</span><br>    <span class="hljs-comment">//    &#123;</span><br>    <span class="hljs-comment">//        print(&quot;鼠标离开&quot;);</span><br>    <span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//void OnClick()</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    print(&quot;点击相关&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//void OnDoubleClick()</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    print(&quot;双击相关&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//void OnDragStart()</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    print(&quot;开始拖曳&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//void OnDrag(Vector2 delta)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    print(&quot;拖曳中&quot; + delta);</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">//void OnDragEnd()</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    print(&quot;拖曳结束&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">// 这个obj记录的是拖曳的对象，不是经过的对象</span><br>    <span class="hljs-comment">//void OnDragOver(GameObject obj)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    print(&quot;拖曳经过&quot; + obj.name);</span><br>    <span class="hljs-comment">//&#125;</span><br><br>    <span class="hljs-comment">// 这个obj记录的是拖曳的对象，不是经过的对象</span><br>    <span class="hljs-comment">//void OnDragOut(GameObject obj)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    print(&quot;拖曳离开&quot; + obj.name);</span><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>UI Root中的Camera会自带Event System脚本，他检测鼠标点击到了哪些对象，找到点击的对象后，找到他身上挂载的脚本，执行其中能够符合自己要求的方法<br><img src="https://s2.loli.net/2024/12/01/7nRQfbNaBjGgSvy.png" alt="Pasted image 20241130232259.png"></li></ul><h1 id="DrawCall-知识点"><a href="#DrawCall-知识点" class="headerlink" title="DrawCall 知识点"></a>DrawCall 知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson15</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 DrawCall的概念</span><br>        <span class="hljs-comment">//字面理解DrawCall  就是 绘制呼叫的意思  表示 CPU（中央处理器）通知GPU（图形处理器-显卡）</span><br><br>        <span class="hljs-comment">//DrawCall 概念</span><br>        <span class="hljs-comment">//就是CPU(处理器)准备好渲染数据（顶点，纹理，法线，Shader等等）后</span><br>        <span class="hljs-comment">//告知GPU(图形处理器-显卡)开始渲染（将命令放入命令缓冲区）的命令</span><br><br>        <span class="hljs-comment">//简单来说：一次DrawCall就是 CPU准备好渲染数据通知 GPU渲染的这个过程</span><br><br>        <span class="hljs-comment">//如果游戏中DrawCall数量较高会影响CPU的效率</span><br>        <span class="hljs-comment">//最直接的感受就是游戏会卡顿</span><br><br>        <span class="hljs-comment">//举例说明  以拷贝文件来进行类比</span><br>        <span class="hljs-comment">//假设我们创建10000个小文件，每个文件大小为1kb，然后把这些文件拷贝到另一个文件夹中</span><br>        <span class="hljs-comment">//你会发现，即使这些文件加起来不超过10MB，但是拷贝花费的时间是很长的</span><br>        <span class="hljs-comment">//如果我们单独创建1个10MB的文件拷贝到另一个文件夹，基本可以瞬间拷贝完毕</span><br>        <span class="hljs-comment">//为什么会这样呢？</span><br>        <span class="hljs-comment">//因为每一个文件赋值动作都需要很多额外的操作，比如分配内存，创建数据等等</span><br>        <span class="hljs-comment">//这些操作就会带来一些额外的性能开销</span><br>        <span class="hljs-comment">//简单理解 文件越多额外开销就越大</span><br><br>        <span class="hljs-comment">//渲染过程和上面的例子很类似，每次DrawCall，CPU都需要准备很多数据发送给GPU</span><br>        <span class="hljs-comment">//那么如果DrawCall越多那么额外开销就越大，其实GPU的渲染效率是很强大的，往往影响渲染效率的</span><br>        <span class="hljs-comment">//都是因为CPU提交命令的速度</span><br>        <span class="hljs-comment">//如果DrawCall 太多CPU就会把大量时间花在提交DrawCall上 造成CPU过载，游戏卡顿</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 如何降低DrawCall数量</span><br>        <span class="hljs-comment">//在UI层面上</span><br>        <span class="hljs-comment">//小图合大图——&gt;即多个小DrawCall变一次大DrawCall</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 制作UI时降低DrawCall的技巧</span><br>        <span class="hljs-comment">//1.通过NGUI Panel上提供的DrawCall查看工具</span><br>        <span class="hljs-comment">//2.注意不同图集之间的层级关系</span><br>        <span class="hljs-comment">// 如果三张图片来自两个图集，Depth分别为0，1，2</span><br>        <span class="hljs-comment">// 0，2是同一个图集，1是另一个图集，DrawCall是3</span><br>        <span class="hljs-comment">// 所以不要让不同图集的Depth插入在同一个图集的Depth中</span><br>        <span class="hljs-comment">//3.注意Label的层级关系</span><br>        <span class="hljs-comment">// 字体也算是一个图集，字体会被打包在同一个图集中</span><br>        <span class="hljs-comment">// 一般把文字Depth放在最上面</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>查看DrawCall数量<br><img src="https://s2.loli.net/2024/12/01/8HYL9sPO6uTVCy2.png" alt="Pasted image 20241130235502.png"></li><li><img src="https://s2.loli.net/2024/12/01/NHgIA6tMpEChvxR.png" alt="Pasted image 20241130235644.png"></li></ul><h1 id="NGUI字体知识点"><a href="#NGUI字体知识点" class="headerlink" title="NGUI字体知识点"></a>NGUI字体知识点</h1><ul><li><p>打开NGUI字体制作<br><img src="https://s2.loli.net/2024/12/01/B2YI6sNXokiFyMZ.png" alt="Pasted image 20241201001346.png"></p></li><li><p>Generated Bitmap</p><ul><li>生成Bitmap</li></ul></li><li><p>Imported Bitmap</p><ul><li>导入Bitmap</li></ul></li><li><p>Dynamic</p><ul><li>动态字体，已经有Unity的了，不用管这个<br><img src="https://s2.loli.net/2024/12/01/lnmyW9gcYET1oSA.png" alt="Pasted image 20241201001424.png"></li></ul></li><li><p>Font Maker的设置</p></li><li><p><code>Generated Bitmap</code></p><ul><li>Create Font会保存这个字体，有用到字体的地方可以拖入生成的文件<ul><li>但是如果有文字不在图集中，就无法显示了</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/ramjKoG7BktHNSQ.png" alt="Pasted image 20241201001819.png"></p><ul><li>使用Bitmap Font生成字体软件<br><img src="https://s2.loli.net/2024/12/01/qEdlVCLvnwBMZ7g.png" alt="Pasted image 20241201002108.png"></li></ul><p><img src="https://s2.loli.net/2024/12/01/XkRvxwzbhF2dLie.png" alt="Pasted image 20241201002241.png"></p><p><img src="https://s2.loli.net/2024/12/01/eHjQ5nf46s8Ki2F.png" alt="Pasted image 20241201002256.png"></p><p><img src="https://s2.loli.net/2024/12/01/HRLaNSTQYU6wKb1.png" alt="Pasted image 20241201002358.png"></p><ul><li>选择想要导出的文字<br><img src="https://s2.loli.net/2024/12/01/tGQHxY8ZflKS2Pg.png" alt="Pasted image 20241201002507.png"></li><li>预览结果<br><img src="https://s2.loli.net/2024/12/01/ngVY5A7yDe6ZU3m.png" alt="Pasted image 20241201002438.png"></li><li>可以选择文件中出现的文字来打图集</li><li>文件必须是带有BOM的utf-8格式的txt文件<br><img src="https://s2.loli.net/2024/12/01/zD19BokjPnRaJdU.png" alt="Pasted image 20241201002552.png"></li><li>导出图集<br><img src="https://s2.loli.net/2024/12/01/uthZdGXCAsoFc6I.png" alt="Pasted image 20241201002732.png"></li></ul><p><img src="https://s2.loli.net/2024/12/01/PLbKsq9Zjk8TAGC.png" alt="Pasted image 20241201002829.png"></p><ul><li>继续Create the Font，可以产生Unity中的其他图集合并</li></ul><h2 id="自定义美术字体"><a href="#自定义美术字体" class="headerlink" title="自定义美术字体"></a>自定义美术字体</h2><ul><li>还是之前的Bitmap Font生成字体软件<br><img src="https://s2.loli.net/2024/12/01/WluQxzXq8mG9VUD.png" alt="Pasted image 20241201003020.png"></li><li>插入美术字体<br><img src="https://s2.loli.net/2024/12/01/urToBsby2lCS9Av.png" alt="Pasted image 20241201003059.png"><br><img src="https://s2.loli.net/2024/12/01/oTpHAvRYeOBPjV2.png" alt="Pasted image 20241201003138.png"></li></ul><p><img src="https://s2.loli.net/2024/12/01/R8DcvzwtUZ2g4FY.png" alt="Pasted image 20241201003302.png"></p><ul><li>删除指定的美术字体<br><img src="https://s2.loli.net/2024/12/01/lHIP8bBXd9DViS7.png" alt="Pasted image 20241201003321.png"></li></ul><h1 id="NGUI缓动知识点"><a href="#NGUI缓动知识点" class="headerlink" title="NGUI缓动知识点"></a>NGUI缓动知识点</h1><blockquote><p>该对象上也要加碰撞器</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson17</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 什么是NGUI缓动</span><br>        <span class="hljs-comment">// NGUI缓动，就是让控件交互时，进行缩放变化，透明变化，位置变化，角度变化等等行为</span><br>        <span class="hljs-comment">// NGUI自带Tween功能来实现这些缓动效果</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 使用NGUI缓动</span><br>        <span class="hljs-comment">// 1. 关键组件 Tween缓动相关组件</span><br>        <span class="hljs-comment">// 2. 关键组件，Play Tween 可以通过它让该对象和输入事件关联</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Alpha 指从某个Alpha值变成另一个Alpha值</p><ul><li>是透明度的意思<br><img src="https://s2.loli.net/2024/12/01/dwV1LpqSkWmejvo.png" alt="Pasted image 20241201005139.png"></li></ul></li><li><p>以Scale为例<br><img src="https://s2.loli.net/2024/12/01/xVuHUw9ArMbkL8G.png" alt="Pasted image 20241201005305.png"></p></li><li><p>From 开始状态</p></li><li><p>To 结束状态</p></li><li><p>PlayStyle 播放方式</p><ul><li>Once 一次</li><li>Loop 循环</li><li>Ping Pong 循环从头到尾从尾到头</li></ul></li><li><p>Animation Curve 动画曲线</p><ul><li>可以调整两个值的变化曲线</li></ul></li><li><p>Duration 持续时间</p></li><li><p>Start Delay 开始播放前的延迟时间</p></li><li><p>Delay Affects 延迟影响</p><ul><li>Forward 正向播放时才有延迟效果</li><li>Reverse  反转播放时才有延迟效果</li><li>Both 都有延迟效果<ul><li>如果时Ping Pong的话，播放只有正向会延迟，反向不会延迟</li><li>只有代码控制的时候，反转播放才会有延迟</li></ul></li></ul></li><li><p>Tween Group 分组ID</p><ul><li>用于一个对象多个动画时分组</li></ul></li><li><p>Ignore TimeScale 忽略时间暂停</p><ul><li>即使timescale变成了0，也不会停止缓动</li></ul></li><li><p>Use Fixed Update 使用物理更新更新动画</p><ul><li>一般不勾选，物理时间可能会很长</li></ul></li><li><p>On Finished</p><ul><li>只有选中Once的播放方式才调用这个，其他的播放方式不会停止<br><img src="https://s2.loli.net/2024/12/01/HzhyXdYm6uLDpM4.png" alt="Pasted image 20241201005346.png"></li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/cp9GObg6FLZ3EY5.png" alt="PlayTween_parameters.png"></p><ul><li>Play Tween脚本<br><img src="https://s2.loli.net/2024/12/01/ZDLSya53eYb6nQH.png" alt="Pasted image 20241201010424.png"></li><li>Tween Target 控制对象<ul><li>也就是控制哪个对象缓动</li><li>这里一般默认是哪个对象加了这个脚本，就选择哪个对象</li></ul></li><li>Include Children 是否带着子对象一起变化<ul><li>可能有其他子对象，类似按钮有Label</li></ul></li><li>Start State <ul><li>如果为真，则在激活触发之前,PlayTween将在启动时将所有关联的Tween重置为其起始状态</li><li>不要让缓动一走来自动播放，而是控制它什么时候播放</li></ul></li><li>TweenGroup 控制的是哪一组缓动<ul><li>和上面的Tween Group对应</li></ul></li><li>Trigger condition 触发条件<ul><li>也就是什么时候触发这个缓动，上面的Start State被设置为False，这里可以设置为True，开始缓动播放</li><li>On Click</li><li>On Hover</li><li>On Press</li><li>On Hover True</li><li>On Hover False</li><li>On Press True</li><li>On Press False</li><li>On Activate</li><li>On Activate True</li><li>On Activate False</li><li>On Double Click</li><li>On Select</li><li>On Select True</li><li>On Select False</li><li>Manual</li></ul></li><li>Play direction 触发的事件<ul><li>Reverse 反转播放<ul><li>一开始为结束状态，往开始状态转换</li></ul></li><li>Toggle 正反状态转换<ul><li>不断正反状态转换，从开始到结束，结束到开始</li></ul></li><li>Forward 正向播放</li></ul></li><li>If target is disabled 如果控制对象失活处理方式<ul><li>Do Nothing 啥也不做，一般选择这个</li><li>Enable Then Play 为了播放激活它</li><li>Ignore Disabled State 忽略失活状态<ul><li>不管你是不是激活的，继续缓动这个失活的对象</li></ul></li></ul></li><li>On activation 激活时<ul><li>Continue From Current 继续当前，一般选这个</li><li>Restart Tween 重新开始</li><li>Restart If Not Playing 如果没有播放重新开始</li></ul></li><li>When finished 播放完毕做啥<ul><li>Disable After Reverse 执行完后隐藏</li><li>Do Not Disable 什么也不做，一般选这个</li><li>Disable After Forward 如果是倒着播，播放完后隐藏</li></ul></li><li>On Finished<ul><li>播放完做什么</li></ul></li></ul><p><img src="https://s2.loli.net/2024/12/01/ue8oCVFdswTnZjm.png" alt="PlayTween_key_parameters.png"></p><p><img src="https://s2.loli.net/2024/12/01/ZqMOSGniQNgBwJj.png" alt="PlayTween_parameters 1.png"></p><h1 id="NGUI中显示3D模型和例子特效"><a href="#NGUI中显示3D模型和例子特效" class="headerlink" title="NGUI中显示3D模型和例子特效"></a>NGUI中显示3D模型和例子特效</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson18</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 NGUI中显示3D模型</span><br>        <span class="hljs-comment">//方法一：</span><br>        <span class="hljs-comment">//使用UI摄像机渲染3D模型</span><br>        <span class="hljs-comment">//1.改变NGUI的整体层级 为 UI层</span><br>        <span class="hljs-comment">//2.改变主摄像机和NGUI摄像机的 渲染层级</span><br>        <span class="hljs-comment">//3.将想要被UI摄像机渲染的对象层级改为 UI层</span><br>        <span class="hljs-comment">//4.调整模型和UI控件的Z轴距离</span><br><br>        <span class="hljs-comment">//方法二：</span><br>        <span class="hljs-comment">//使用多摄像机渲染 Render Texture</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 NGUI中显示粒子特效</span><br>        <span class="hljs-comment">//1.让Panel和粒子特效处于一个排序层</span><br>        <span class="hljs-comment">//2.在粒子特效的 Render参数中 设置自己的层级</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用UI摄像机渲染3D模型"><a href="#使用UI摄像机渲染3D模型" class="headerlink" title="使用UI摄像机渲染3D模型"></a>使用UI摄像机渲染3D模型</h2><ul><li>改变NGUI的整体层级 为 UI层<ul><li><img src="https://s2.loli.net/2024/12/01/K8UEtMDcuhjwoxa.png" alt="Pasted image 20241201012411.png"></li><li>3D模型也要改为UI层，如果模型不显示，可能是模型太小，改一下Scale<ul><li><img src="https://s2.loli.net/2024/12/01/6DR7BeZWdMk1fQJ.png" alt="Pasted image 20241201012455.png"></li><li><img src="https://s2.loli.net/2024/12/01/bvtmaPqpURAJyui.png" alt="Pasted image 20241201012533.png"></li></ul></li></ul></li><li>改变主摄像机和NGUI摄像机的 渲染层级<ul><li>主摄像机不渲染UI层</li><li>NGUI摄像机只渲染UI层</li><li>另外3D模型的渲染不受Depth影响，之和Z轴的实际距离有关</li></ul></li><li>将想要被UI摄像机渲染的对象层级改为 UI层<ul><li>也就是Tank改成UI层</li></ul></li><li>调整模型和UI控件的Z轴距离<ul><li>就能看到不同层级叠加的情况</li></ul></li></ul><h2 id="使用多摄像机渲染-Render-Texture"><a href="#使用多摄像机渲染-Render-Texture" class="headerlink" title="使用多摄像机渲染 Render Texture"></a>使用多摄像机渲染 Render Texture</h2><blockquote><p>这里可以使用3D摄像机，实现近大远小</p></blockquote><ul><li><p>创建一个Render Texture<br><img src="https://s2.loli.net/2024/12/01/Kj8HVyq29UnWISM.png" alt="Pasted image 20241201012913.png"></p></li><li><p>将刚刚的Render Texture拖到想要渲染的摄像机那里</p></li><li><p>这里是将摄像机看到的内容都放在了Tank这个Render Texture里面</p></li><li><p>其中左边的Camera和Tank4都是一个Water的Layer层，其他的相机都不渲染这个层<br><img src="https://s2.loli.net/2024/12/01/tpl5InaRfvgTWBV.png" alt="Pasted image 20241201013039.png"></p></li><li><p>此时将Render Texture中的内容渲染到Texture上，类似小地图的功能<br><img src="https://s2.loli.net/2024/12/01/Cr2LxgWzioQJ4ZD.png" alt="Pasted image 20241201013233.png"></p></li></ul><h2 id="NGUI中显示粒子特效"><a href="#NGUI中显示粒子特效" class="headerlink" title="NGUI中显示粒子特效"></a>NGUI中显示粒子特效</h2><ul><li>创建例子特效<ul><li><img src="https://s2.loli.net/2024/12/01/rIkxMg4VPC6n8Nh.png" alt="Pasted image 20241201013512.png"></li></ul></li><li>让Panel和粒子特效处于一个排序层<ul><li><img src="https://s2.loli.net/2024/12/01/pEgviIrs27dotFC.png" alt="Pasted image 20241201013641.png"></li></ul></li><li>在粒子特效的 Render参数中 设置自己的层级<ul><li>改层级或者同层中的优先度都可以改变显示顺序<br>  <img src="https://s2.loli.net/2024/12/01/xjg2XydAE5R9l7W.png" alt="Pasted image 20241201013621.png"></li></ul></li></ul><h1 id="事件触发播放音效、键盘绑定、语言本地化等知识点"><a href="#事件触发播放音效、键盘绑定、语言本地化等知识点" class="headerlink" title="事件触发播放音效、键盘绑定、语言本地化等知识点"></a>事件触发播放音效、键盘绑定、语言本地化等知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson19</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 NGUI 事件响应 播放音效</span><br>        <span class="hljs-comment">//PlaySound 脚本</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 NGUI控件和键盘按键绑定</span><br>        <span class="hljs-comment">//KeyBinding 脚本</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 PC端 tab键快捷切换选中</span><br>        <span class="hljs-comment">//KeyNavigation 脚本</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 语言本地化</span><br>        <span class="hljs-comment">//Localization脚本</span><br>        <span class="hljs-comment">//1.在Resources下创建一个txt文件 命名必须为Localization</span><br>        <span class="hljs-comment">//2.配置文件</span><br>        <span class="hljs-comment">//3.给想要切换文字的Label对象下挂载Localize 关联Key</span><br>        <span class="hljs-comment">//4.给用于切换语言的下拉列表下添加脚本LanguageSelection</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>添加播放音效脚本</p><ul><li><img src="https://s2.loli.net/2024/12/01/afz8oWbmtTjqJVy.png" alt="Pasted image 20241201014032.png"><br><img src="https://s2.loli.net/2024/12/01/1nrjMIfuV3HGtBR.png" alt="Pasted image 20241201014151.png"></li></ul></li><li><p>添加键盘绑定脚本</p><ul><li><img src="https://s2.loli.net/2024/12/01/blZIJVfXKgwtM5P.png" alt="Pasted image 20241201014239.png"></li><li><img src="https://s2.loli.net/2024/12/01/8qfhBbWcLaYldnP.png" alt="Pasted image 20241201014504.png"></li></ul></li><li><p>PC端 tab键快捷切换选中</p><ul><li><img src="https://s2.loli.net/2024/12/01/74qDY9dCMNkotKz.png" alt="Pasted image 20241201014610.png"></li><li>Sprite这四个对象需要添加碰撞器</li><li>按了Tab后，会到开始的右边的按钮，如果还需要按Tab切换，则需要这四个对象都添加Key Navigation脚本</li><li><img src="https://s2.loli.net/2024/12/01/JcFmYtoqv32Iu7n.png" alt="Pasted image 20241201014701.png"></li></ul></li><li><p>语言本地化</p></li><li><p>Localization脚本</p></li><li><p>在Resources下创建一个txt文件 命名必须为Localization</p><ul><li><img src="https://s2.loli.net/2024/12/01/64KbB2lZPcfYrNW.png" alt="Pasted image 20241201014952.png"></li></ul></li><li><p>配置文件</p><ul><li>表示volume的关键字，对应的中文为音量，英文为volume</li><li><img src="https://s2.loli.net/2024/12/01/h9W8l2qNsSaPeuE.png" alt="Pasted image 20241201015026.png"></li></ul></li><li><p>给想要切换文字的Label对象下挂载Localize 关联Key</p><ul><li>对Label组件添加Localize脚本</li><li>默认选择配置文件中的第一个</li><li><img src="https://s2.loli.net/2024/12/01/pNXaU7n6RsQjd4D.png" alt="Pasted image 20241201015140.png"></li><li><img src="https://s2.loli.net/2024/12/01/fSqVXb9coAUClLN.png" alt="Pasted image 20241201015213.png"></li></ul></li><li><p>给用于切换语言的下拉列表下添加脚本LanguageSelection</p><ul><li>添加一个PopUpList下拉列表<ul><li>添加PopupList脚本，以及碰撞器<ul><li>记得设置字体为Unity字体&#x2F;其他的字体也行，不能为空，否则下拉列表不显示文字</li><li>修改On Value Change的触发事件</li><li><img src="https://s2.loli.net/2024/12/01/uIj1wP3KJACEHZ8.png" alt="Pasted image 20241201015400.png"></li><li><img src="https://s2.loli.net/2024/12/01/9uj4gPetBa2H81X.png" alt="Pasted image 20241201015613.png"></li></ul></li><li>添加Language Selection脚本<ul><li><img src="https://s2.loli.net/2024/12/01/wxrjGetczCDyAsm.png" alt="Pasted image 20241201015453.png"></li></ul></li></ul></li></ul></li><li><p><img src="https://s2.loli.net/2024/12/01/K5ouifPFLcgQpEs.png" alt="Pasted image 20241201015723.png"></p></li><li><p>也能改图片</p></li><li><p>原理应该是Label标签就改文字，Sprite组件就改图片，但是图集估计要在同一个上面</p></li><li><p><img src="https://s2.loli.net/2024/12/01/GptVJS7gLsEZF8d.png" alt="Pasted image 20241201015847.png"></p></li><li><p><img src="https://s2.loli.net/2024/12/01/8b3KUg7dEOIyBnM.png" alt="Pasted image 20241201015910.png"></p></li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.yxtown.com/">游习堂</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unity知识整理(二_基础)</title>
    <link href="/2024/11/22/Unity%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%BA%8C_%E5%9F%BA%E7%A1%80)/"/>
    <url>/2024/11/22/Unity%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%BA%8C_%E5%9F%BA%E7%A1%80)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>同样是Unity基础知识，不过这里会附加一个项目<br>主要代码逻辑、代码会写在后面<br>目前内容不是很多，一边学习一边记笔记太费时间了，以后复习的时候慢慢补充</p></blockquote><h1 id="Mathf知识点"><a href="#Mathf知识点" class="headerlink" title="Mathf知识点"></a>Mathf知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson1</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Mathf和Math</span><br>        <span class="hljs-comment">//Math是C#中封装好的用于数学计算的工具类 —— 位于System命名空间中</span><br><br>        <span class="hljs-comment">//Mathf是Unity中封装好的用于数学计算的工具结构体 —— 位于UnityEngine命名空间中</span><br><br>        <span class="hljs-comment">//他们都是提供来用于进行数学相关计算的</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 他们的区别</span><br>        <span class="hljs-comment">//Mathf 和 Math中的相关方法几乎一样</span><br>        <span class="hljs-comment">//Math 是C#自带的工具类 主要就提供一些数学相关计算方法</span><br>        <span class="hljs-comment">//Mathf 是Unity专门封装的，不仅包含Math中的方法，还多了一些适用于游戏开发的方法</span><br>        <span class="hljs-comment">//所以我们在进行Unity游戏开发时</span><br>        <span class="hljs-comment">//使用Mathf中的方法用于数学计算即可</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 Mathf中的常用方法——一般计算一次</span><br>        <span class="hljs-comment">//1.π - PI</span><br>        print(Mathf.PI);<br><br>        <span class="hljs-comment">//2.取绝对值 - Abs</span><br>        print(Mathf.Abs(<span class="hljs-number">-10</span>));<br>        print(Mathf.Abs(<span class="hljs-number">-20</span>));<br>        print(Mathf.Abs(<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">//3.向上取整 - CeilToInt</span><br>        <span class="hljs-built_in">float</span> f = <span class="hljs-number">1.3f</span>;<br>        <span class="hljs-built_in">int</span> i = (<span class="hljs-built_in">int</span>)f;<br>        print(i);<br>        print(Mathf.CeilToInt(f));<br>        print(Mathf.CeilToInt(<span class="hljs-number">1.00001f</span>));<br><br>        <span class="hljs-comment">//4.向下取整 - FloorToInt</span><br>        print(Mathf.FloorToInt(<span class="hljs-number">9.6f</span>));<br><br>        <span class="hljs-comment">//5.钳制函数 - Clamp</span><br>        <span class="hljs-comment">// 第一个参数：变量，需要计算范围的值</span><br>        <span class="hljs-comment">// 第二个参数：范围值的最小值</span><br>        <span class="hljs-comment">// 第三个参数：范围值的最大值</span><br>        print(Mathf.Clamp(<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 11</span><br>        print(Mathf.Clamp(<span class="hljs-number">21</span>, <span class="hljs-number">11</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 20</span><br>        print(Mathf.Clamp(<span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// 15</span><br><br>        <span class="hljs-comment">//6.获取最大值 - Max</span><br>        print(Mathf.Max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>));<br>        print(Mathf.Max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">//7.获取最小值 - Min</span><br>        print(Mathf.Min(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">545</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1123</span>, <span class="hljs-number">123</span>));<br>        print(Mathf.Min(<span class="hljs-number">1.1f</span>, <span class="hljs-number">0.4f</span>));<br><br>        <span class="hljs-comment">//8.一个数的n次幂 - Pow</span><br>        print(<span class="hljs-string">&quot;一个数的n次方&quot;</span> + Mathf.Pow(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>));<br>        print(<span class="hljs-string">&quot;一个数的n次方&quot;</span> + Mathf.Pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<br><br>        <span class="hljs-comment">//9.四舍五入 - RoundToInt</span><br>        print(<span class="hljs-string">&quot;四舍五入&quot;</span> + Mathf.RoundToInt(<span class="hljs-number">1.3f</span>));<br>        print(<span class="hljs-string">&quot;四舍五入&quot;</span> + Mathf.RoundToInt(<span class="hljs-number">1.5f</span>));<br><br>        <span class="hljs-comment">//10.返回一个数的平方根 - Sqrt</span><br>        print(<span class="hljs-string">&quot;返回一个数的平方根&quot;</span> + Mathf.Sqrt(<span class="hljs-number">4</span>));<br>        print(<span class="hljs-string">&quot;返回一个数的平方根&quot;</span> + Mathf.Sqrt(<span class="hljs-number">16</span>));<br>        print(<span class="hljs-string">&quot;返回一个数的平方根&quot;</span> + Mathf.Sqrt(<span class="hljs-number">64</span>));<br><br>        <span class="hljs-comment">//11.判断一个数是否是2的n次方 - IsPowerOfTwo</span><br>        print(<span class="hljs-string">&quot;判断一个数是否是2的n次方&quot;</span> + Mathf.IsPowerOfTwo(<span class="hljs-number">4</span>));<br>        print(<span class="hljs-string">&quot;判断一个数是否是2的n次方&quot;</span> + Mathf.IsPowerOfTwo(<span class="hljs-number">8</span>));<br>        print(<span class="hljs-string">&quot;判断一个数是否是2的n次方&quot;</span> + Mathf.IsPowerOfTwo(<span class="hljs-number">3</span>));<br>        print(<span class="hljs-string">&quot;判断一个数是否是2的n次方&quot;</span> + Mathf.IsPowerOfTwo(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//12.判断正负数 - Sign</span><br>        print(<span class="hljs-string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 1</span><br>        print(<span class="hljs-string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 1</span><br>        print(<span class="hljs-string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="hljs-number">-10</span>)); <span class="hljs-comment">// -1</span><br>        print(<span class="hljs-string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 1</span><br>        print(<span class="hljs-string">&quot;判断正负数&quot;</span> + Mathf.Sign(<span class="hljs-number">-2</span>)); <span class="hljs-comment">// -1</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">//开始值</span><br>    <span class="hljs-built_in">float</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">float</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">float</span> time = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 Mathf中的常用方法——一般不停计算</span><br>        <span class="hljs-comment">//插值运算 - Lerp</span><br>        <span class="hljs-comment">// 应用场景，靠近某个物体的时候可以使用这个方法</span><br><br>        <span class="hljs-comment">//Lerp函数公式</span><br>        <span class="hljs-comment">//result = Mathf.Lerp(start, end, t);</span><br><br>        <span class="hljs-comment">//t为插值系数，取值范围为 0~1</span><br>        <span class="hljs-comment">//result = start + (end - start)*t</span><br><br>        <span class="hljs-comment">//插值运算用法一</span><br>        <span class="hljs-comment">//每帧改变start的值——变化速度先快后慢，位置无限接近，但是不会得到end位置</span><br>        <span class="hljs-comment">// 公式的意思是慢慢从start到end，但不会等于end，速度先快后慢，分析t的系数就知道了</span><br>        <span class="hljs-comment">// end是不变的，start一直变大</span><br>        start = Mathf.Lerp(start, <span class="hljs-number">10</span>, Time.deltaTime);<br><br>        <span class="hljs-comment">//插值运算用法二</span><br>        <span class="hljs-comment">//每帧改变t的值——变化速度匀速，位置每帧接近，当t&gt;=1时，得到结果</span><br>        <span class="hljs-comment">//result = start + (end - start)*t</span><br>        time += Time.deltaTime;<br>        result = Mathf.Lerp(start, <span class="hljs-number">10</span>, time);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三角函数知识点"><a href="#三角函数知识点" class="headerlink" title="三角函数知识点"></a>三角函数知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson2</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 弧度、角度相互转化</span><br>        <span class="hljs-comment">//弧度转角度</span><br>        <span class="hljs-built_in">float</span> rad = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">float</span> anger = rad * Mathf.Rad2Deg;<br>        print(anger);<br><br>        <span class="hljs-comment">//角度转弧度</span><br>        anger = <span class="hljs-number">1</span>;<br>        rad = anger * Mathf.Deg2Rad;<br>        print(rad);<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 三角函数</span><br>        <span class="hljs-comment">//注意：Mathf中的三角函数相关函数，传入的参数需要时弧度值</span><br>        print(Mathf.Sin(<span class="hljs-number">30</span> * Mathf.Deg2Rad)); <span class="hljs-comment">//0.5</span><br>        print(Mathf.Cos(<span class="hljs-number">60</span> * Mathf.Deg2Rad)); <span class="hljs-comment">//0.5</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 反三角函数</span><br>        <span class="hljs-comment">//注意：反三角函数得到的结果是 正弦或者余弦值对应的弧度</span><br>        rad = Mathf.Asin(<span class="hljs-number">0.5f</span>);<br>        print(rad * Mathf.Rad2Deg);<br>        rad = Mathf.Acos(<span class="hljs-number">0.5f</span>);<br>        print(rad * Mathf.Rad2Deg);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="坐标系知识点"><a href="#坐标系知识点" class="headerlink" title="坐标系知识点"></a>坐标系知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson3</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 世界坐标系</span><br>        <span class="hljs-comment">//目前学习的和世界坐标系相关的</span><br>        <span class="hljs-comment">//this.transform.position;</span><br>        <span class="hljs-comment">//this.transform.rotation;</span><br>        <span class="hljs-comment">//this.transform.eulerAngles;</span><br>        <span class="hljs-comment">//this.transform.lossyScale;</span><br>        <span class="hljs-comment">//修改他们 会是相对世界坐标系的变化</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 物体坐标系</span><br>        <span class="hljs-comment">//相对父对象的物体坐标系的位置 本地坐标 相对坐标</span><br>        <span class="hljs-comment">//this.transform.localPosition;</span><br>        <span class="hljs-comment">//this.transform.localEulerAngles;</span><br>        <span class="hljs-comment">//this.transform.localRotation;</span><br>        <span class="hljs-comment">//this.transform.localScale;</span><br>        <span class="hljs-comment">//修改他们 会是相对父对象物体坐标系的变化</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 屏幕坐标系</span><br>        <span class="hljs-comment">//Input.mousePosition</span><br>        <span class="hljs-comment">//Screen.width;</span><br>        <span class="hljs-comment">//Screen.height;</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 视口坐标系</span><br>        <span class="hljs-comment">//摄像机上的 视口范围</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 坐标转换相关</span><br>        <span class="hljs-comment">//世界转本地</span><br>        <span class="hljs-comment">//this.transform.InverseTransformDirection</span><br>        <span class="hljs-comment">//this.transform.InverseTransformPoint</span><br>        <span class="hljs-comment">//this.transform.InverseTransformVector</span><br><br>        <span class="hljs-comment">//本地转世界</span><br>        <span class="hljs-comment">//this.transform.TransformDirection</span><br>        <span class="hljs-comment">//this.transform.TransformPoint  </span><br>        <span class="hljs-comment">//this.transform.TransformVector</span><br><br>        <span class="hljs-comment">//世界转屏幕</span><br>        <span class="hljs-comment">//Camera.main.WorldToScreenPoint</span><br>        <span class="hljs-comment">//屏幕转世界</span><br>        <span class="hljs-comment">//Camera.main.ScreenToWorldPoint</span><br><br>        <span class="hljs-comment">//世界转视口</span><br>        <span class="hljs-comment">//Camera.main.WorldToViewportPoint</span><br>        <span class="hljs-comment">//视口转世界</span><br>        <span class="hljs-comment">//Camera.main.ViewportToWorldPoint</span><br><br>        <span class="hljs-comment">//视口转屏幕</span><br>        <span class="hljs-comment">//Camera.main.ViewportToScreenPoint</span><br>        <br>        <span class="hljs-comment">//屏幕转视口</span><br>        <span class="hljs-comment">//Camera.main.ScreenToViewportPoint;</span><br>        <br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/YqhNfZwRkm98utc.png" alt="Pasted image 20241122232147.png"><br><img src="https://s2.loli.net/2024/11/26/jJ8yR1xwYq3aiN9.png" alt="Pasted image 20241122232036.png"><br><img src="https://s2.loli.net/2024/11/26/s7JjOvqdFahE5Bu.png" alt="Pasted image 20241122232046.png"></p><p><img src="https://s2.loli.net/2024/11/26/4mgI68hjQGJ1LRX.png" alt="Pasted image 20241122232054.png"></p><h1 id="向量模长和单位向量知识点"><a href="#向量模长和单位向量知识点" class="headerlink" title="向量模长和单位向量知识点"></a>向量模长和单位向量知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson4</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 向量</span><br>        <span class="hljs-comment">//三维向量 - Vector3</span><br>        <span class="hljs-comment">//Vector3有两种几何意义</span><br>        <span class="hljs-comment">//1.位置 —— 代表一个点</span><br>        print(<span class="hljs-keyword">this</span>.transform.position);<br><br>        <span class="hljs-comment">//2.方向 —— 代表一个方向</span><br>        print(<span class="hljs-keyword">this</span>.transform.forward);<br>        print(<span class="hljs-keyword">this</span>.transform.up);<br><br>        Vector3 v = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        Vector2 v2 = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 两点决定一向量</span><br>        <span class="hljs-comment">//A和B此时 几何意义 是两个点</span><br>        Vector3 A = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        Vector3 B = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//求向量</span><br>        <span class="hljs-comment">//此时 AB和 BA 他们的几何意义 是两个向量</span><br>        Vector3 AB = B - A;<br>        Vector3 BA = A - B;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 零向量和负向量</span><br>        print(Vector3.zero);<br><br>        print(Vector3.forward);<br>        <span class="hljs-comment">// 大小相同，方向相反</span><br>        print(-Vector3.forward);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 向量的模长</span><br>        <span class="hljs-comment">//Vector3中提供了获取向量模长的成员属性</span><br>        <span class="hljs-comment">//magnitude</span><br>        print(AB.magnitude);<br>        Vector3 C = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>);<br>        print(C.magnitude);<br><br>        print(Vector3.Distance(A, B));<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点五 单位向量</span><br>        <span class="hljs-comment">//Vector3中提供了获取单位向量的成员属性</span><br>        <span class="hljs-comment">//normalized</span><br>        print(AB.normalized);<br>        print(AB / AB.magnitude);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="向量加减乘除知识点"><a href="#向量加减乘除知识点" class="headerlink" title="向量加减乘除知识点"></a>向量加减乘除知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson5</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 向量加法</span><br>        <span class="hljs-comment">//this.transform.position += new Vector3(1, 2, 3);</span><br>        <span class="hljs-comment">// 当前的位置，加上Vector3.forward * 5</span><br>        <span class="hljs-keyword">this</span>.transform.Translate(Vector3.forward * <span class="hljs-number">5</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 向量减法</span><br>        <span class="hljs-comment">//this.transform.position -= new Vector3(1, 2, 3);</span><br>        <span class="hljs-comment">// 当前的位置，减去Vector3.forward * 5</span><br>        <span class="hljs-keyword">this</span>.transform.Translate(-Vector3.forward * <span class="hljs-number">5</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 向量乘除标量</span><br>        <span class="hljs-comment">// 这个如果没有父对象，localScale和lossyScale是一致的</span><br>        <span class="hljs-comment">// 改localScale和想要改lossyScale的效果一样</span><br>        <span class="hljs-keyword">this</span>.transform.localScale *= <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//this.transform.localScale /= 2;</span><br><br>        <span class="hljs-comment">// 报错，因为这个相对世界坐标系的大小是不能改的</span><br>        <span class="hljs-comment">// this.transform.lossyScale *= 2;</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="向量点乘的知识点"><a href="#向量点乘的知识点" class="headerlink" title="向量点乘的知识点"></a>向量点乘的知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson6</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform target;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 补充知识 调试画线</span><br>        <span class="hljs-comment">//画线段</span><br>        <span class="hljs-comment">//前两个参数 分别是 起点 终点</span><br>        <span class="hljs-comment">// 第三个参数是颜色</span><br>        <span class="hljs-comment">//Debug.DrawLine(this.transform.position, this.transform.position + this.transform.forward, Color.red);</span><br>        <span class="hljs-comment">//画射线</span><br>        <span class="hljs-comment">//前两个参数 分别是 起点 方向</span><br>        <span class="hljs-comment">// 第三个参数是颜色</span><br>        <span class="hljs-comment">//Debug.DrawRay(this.transform.position, this.transform.forward, Color.white);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 通过点乘判断对象方位</span><br>        <span class="hljs-comment">//Vector3 提供了计算点乘的方法</span><br>        Debug.DrawRay(<span class="hljs-keyword">this</span>.transform.position, <span class="hljs-keyword">this</span>.transform.forward, Color.red);<br>        Debug.DrawRay(<br>            <span class="hljs-keyword">this</span>.transform.position,<br>            target.position - <span class="hljs-keyword">this</span>.transform.position,<br>            Color.red<br>        );<br>        <span class="hljs-comment">//得到两个向量的点乘结果 Vector3.Dot()能计算两个向量的点乘</span><br>        <span class="hljs-comment">//向量 a 点乘 AB 的结果</span><br>        <span class="hljs-built_in">float</span> dotResult = Vector3.Dot(<br>            <span class="hljs-keyword">this</span>.transform.forward,<br>            target.position - <span class="hljs-keyword">this</span>.transform.position<br>        );<br>        <span class="hljs-keyword">if</span> (dotResult &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            print(<span class="hljs-string">&quot;它在我前方&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            print(<span class="hljs-string">&quot;它在我后方&quot;</span>);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 通过点乘推导公式算出夹角</span><br>        <span class="hljs-comment">//步骤</span><br>        <span class="hljs-comment">//1.用单位向量算出点乘结果</span><br>        <span class="hljs-comment">// β = arcos(A*B) *表示点乘</span><br>        <span class="hljs-comment">// A和B都是单位向量</span><br>        dotResult = Vector3.Dot(<br>            <span class="hljs-keyword">this</span>.transform.forward,<br>            (target.position - <span class="hljs-keyword">this</span>.transform.position).normalized<br>        );<br>        <span class="hljs-comment">//2.用反三角函数得出角度</span><br>        print(<span class="hljs-string">&quot;角度-&quot;</span> + Mathf.Acos(dotResult) * Mathf.Rad2Deg);<br><br>        <span class="hljs-comment">//Vector3中提供了 得到两个向量之间夹角的方法</span><br>        <span class="hljs-comment">// 参数可以不传递单位向量，里面做了模长的单位化</span><br>        <span class="hljs-comment">// 只能得到夹角的大小，左侧还是右侧需要用叉乘</span><br>        print(<br>            <span class="hljs-string">&quot;角度2-&quot;</span><br>                + Vector3.Angle(<span class="hljs-keyword">this</span>.transform.forward, target.position - <span class="hljs-keyword">this</span>.transform.position)<br>        );<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/2ASgOzjqC79We8w.png" alt="Pasted image 20241123113843.png"><br><img src="https://s2.loli.net/2024/11/26/spXLGKN9uhPVYOb.png" alt="Pasted image 20241123113853.png"></p><p><img src="https://s2.loli.net/2024/11/26/RI6zulCbY7yU259.png" alt="Pasted image 20241123114612.png"></p><h1 id="向量叉乘知识点"><a href="#向量叉乘知识点" class="headerlink" title="向量叉乘知识点"></a>向量叉乘知识点</h1><ul><li><font color="red"> Unity3D中的是左手系</font></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson7</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform A;<br>    <span class="hljs-keyword">public</span> Transform B;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 叉乘计算</span><br>        <span class="hljs-comment">//print(Vector3.Cross(A.position, B.position));</span><br>        print(Vector3.Cross(Vector3.forward, Vector3.up)); <span class="hljs-comment">// (-1,0,0)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 叉乘几何意义</span><br>        <span class="hljs-comment">//假设向量 A和B 都在 XZ平面上</span><br>        <span class="hljs-comment">//向量A 叉乘 向量 B</span><br>        <span class="hljs-comment">//y大于0 证明 B在A右侧</span><br>        <span class="hljs-comment">//y小于0 证明 B在A左侧</span><br>        <span class="hljs-comment">// y等于0 B和A是共线的 AXB = |A||B|sinθ</span><br>        <span class="hljs-comment">// 只能判断方向，不能判断角度，角度要用点乘</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 判断的是第二个参数是第一个参数的左侧还是右侧</span><br>        <span class="hljs-comment">//Vector3 C = Vector3.Cross(A.position, B.position);</span><br>        <span class="hljs-comment">//if( C.y &gt; 0)</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    print(&quot;B在A的右侧&quot;);</span><br>        <span class="hljs-comment">//&#125;</span><br>        <span class="hljs-comment">//else</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    print(&quot;B在A的左侧&quot;);</span><br>        <span class="hljs-comment">//&#125;</span><br><br>        Vector3 C = Vector3.Cross(B.position, A.position);<br>        <span class="hljs-keyword">if</span> (C.y &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            print(<span class="hljs-string">&quot;A在B的右侧&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            print(<span class="hljs-string">&quot;A在B的左侧&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/25tiwqKCRpTmrDN.png" alt="Pasted image 20241123120959.png"><br><img src="https://s2.loli.net/2024/11/26/u2FdtovylQeXIPC.png" alt="Pasted image 20241123121029.png"></p><ul><li>这个视频里面的图是左手系，数学上是右手系，用右手螺旋定则来确定axb的方向，从向量a-&gt;向量b<br><img src="https://s2.loli.net/2024/11/26/3B8Zg1hLSGQXtMR.png" alt=".png"></li></ul><h1 id="向量插值运算知识点"><a href="#向量插值运算知识点" class="headerlink" title="向量插值运算知识点"></a>向量插值运算知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson8</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform target;<br>    <span class="hljs-keyword">public</span> Transform A;<br>    <span class="hljs-keyword">public</span> Transform B;<br>    <span class="hljs-keyword">public</span> Transform C;<br><br>    <span class="hljs-keyword">private</span> Vector3 startPos;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> time;<br><br>    <span class="hljs-keyword">private</span> Vector3 nowTarget;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        startPos = B.position;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 线性插值</span><br>        <span class="hljs-comment">// 和Mathf.Lerp()的区别是，这个是一个三维坐标，改的是三维的向量</span><br>        <span class="hljs-comment">//result = start + (end - start) * t</span><br><br>        <span class="hljs-comment">//1.先快后慢 每帧改变start位置 位置无限接近 但不会得到end位置</span><br>        A.position = Vector3.Lerp(A.position, target.position, Time.deltaTime);<br><br>        <span class="hljs-comment">//2.匀速 每帧改变时间  当t&gt;=1时 得到结果</span><br>        <span class="hljs-comment">//这种匀速移动 当time&gt;=1时  我改变了 目标位置后  它会直接瞬移到我们的目标位置</span><br>        <span class="hljs-keyword">if</span> (nowTarget != target.position)<br>        &#123;<br>            nowTarget = target.position;<br>            time = <span class="hljs-number">0</span>;<br>            startPos = B.position;<br>        &#125;<br>        time += Time.deltaTime;<br>        B.position = Vector3.Lerp(startPos, nowTarget, time);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 球形插值</span><br>        <span class="hljs-comment">// 球形插值可以模拟曲线运动，太阳东升西落，导弹发射</span><br>        C.position = Vector3.Slerp(<br>            Vector3.right * <span class="hljs-number">10</span>,<br>            Vector3.left * <span class="hljs-number">10</span> + Vector3.up * <span class="hljs-number">0.1f</span>,<br>            time * <span class="hljs-number">0.01f</span><br>        );<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/bavtd53WGAcsqP7.png" alt="Pasted image 20241123123359.png"></p><h1 id="四元数基础知识"><a href="#四元数基础知识" class="headerlink" title="四元数基础知识"></a>四元数基础知识</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson10</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 四元数 Quaternion</span><br>        <span class="hljs-comment">//四元数Q = [cos(β/2),  sin(β/2)x, sin(β/2)y, sin(β/2)z]</span><br>        <span class="hljs-comment">// Quaternion q = new Quaternion（sin(β/2)x,sin(β/2)y,sin(β/2)z,cos(β/2));</span><br>        <span class="hljs-comment">//计算原理</span><br>        <span class="hljs-comment">//Quaternion q = new Quaternion(Mathf.Sin(30 * Mathf.Deg2Rad), 0, 0, Mathf.Cos(30 * Mathf.Deg2Rad));</span><br>        <span class="hljs-comment">//提供的轴角对 初始化 四元数的方法</span><br>        <span class="hljs-comment">// 四元数Q=Quaternion.AngleAxis(角度，轴);</span><br>        Quaternion q = Quaternion.AngleAxis(<span class="hljs-number">60</span>, Vector3.right);<br><br>        <span class="hljs-comment">//创建一个立方体</span><br>        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);<br>        obj.transform.rotation = q;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 四元数和欧拉角转换</span><br>        <span class="hljs-comment">//1.欧拉角转四元数</span><br>        Quaternion q2 = Quaternion.Euler(<span class="hljs-number">60</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        GameObject obj2 = GameObject.CreatePrimitive(PrimitiveType.Cube);<br>        obj2.transform.rotation = q2;<br>        <span class="hljs-comment">//2.四元数转欧拉角</span><br>        print(q2.eulerAngles);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 四元数弥补的欧拉角缺点</span><br>        <span class="hljs-comment">//1.同一旋转的表示不唯一  四元数旋转后 转换后的欧拉角 始终是 -180~180度</span><br><br>        <span class="hljs-comment">//2.万向节死锁 通过四元数旋转对象可以避免万向节死锁</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    Vector3 e;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 四元数相乘代表旋转四元数</span><br>        <span class="hljs-comment">// 四元数只能表示-180到180的角度</span><br>        <span class="hljs-comment">// 第一个参数：正数，顺时针旋转，负数是逆时针旋转</span><br>        <span class="hljs-comment">// 第二个参数：Vector3.up虽然是世界坐标系，但是意思是物体自己的坐标系(1,0,0)旋转</span><br>        <span class="hljs-keyword">this</span>.transform.rotation *= Quaternion.AngleAxis(<span class="hljs-number">1</span>, Vector3.up);<br>        <span class="hljs-comment">// 万向节死锁</span><br>        <span class="hljs-comment">//e = this.transform.rotation.eulerAngles;</span><br>        <span class="hljs-comment">//e += Vector3.up;</span><br>        <span class="hljs-comment">//this.transform.rotation = Quaternion.Euler(e);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/SsHtLfodWJTxEiB.png" alt="Pasted image 20241123185734.png"><br><img src="https://s2.loli.net/2024/11/26/Tx2JKY4IgsplzB5.png" alt="Pasted image 20241123185807.png"></p><h1 id="四元数常用方法"><a href="#四元数常用方法" class="headerlink" title="四元数常用方法"></a>四元数常用方法</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson11</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform testObj;<br><br>    <span class="hljs-keyword">public</span> Transform target;<br>    <span class="hljs-keyword">public</span> Transform A;<br>    <span class="hljs-keyword">public</span> Transform B;<br><br>    <span class="hljs-keyword">private</span> Quaternion start;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> time;<br><br>    <span class="hljs-keyword">public</span> Transform lookA;<br>    <span class="hljs-keyword">public</span> Transform lookB;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 单位四元数</span><br>        <span class="hljs-comment">// 单位四元数角度的物体没有旋转角度</span><br>        print(Quaternion.identity);<br>        <span class="hljs-comment">//testObj.rotation = Quaternion.identity;</span><br><br>        Instantiate(testObj, Vector3.zero, Quaternion.identity);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 插值运算</span><br>        start = B.transform.rotation;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//无限接近 先快后慢</span><br>        <span class="hljs-comment">// 第一个参数：起始物体的旋转角度</span><br>        <span class="hljs-comment">// 第二个参数：想要旋转到的最终的旋转角度</span><br>        <span class="hljs-comment">// 第三个参数：插值的系数</span><br>        A.transform.rotation = Quaternion.Slerp(<br>            A.transform.rotation,<br>            target.rotation,<br>            Time.deltaTime<br>        );<br><br>        <span class="hljs-comment">//匀速变化 time&gt;=1到达目标</span><br>        <span class="hljs-comment">// 第一个参数：起始物体的旋转角度</span><br>        <span class="hljs-comment">// 第二个参数：想要旋转到的最终的旋转角度</span><br>        <span class="hljs-comment">// 第三个参数：插值的系数</span><br>        time += Time.deltaTime;<br>        B.transform.rotation = Quaternion.Slerp(start, target.rotation, time);<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 LookRotation</span><br>        <span class="hljs-comment">// 下面的方法可以让物体lookA看向物体lookB</span><br>        <span class="hljs-comment">//Quaternion q = Quaternion.LookRotation(lookB.position - lookA.position);</span><br>        <span class="hljs-comment">//lookA.rotation = q;</span><br>        <span class="hljs-comment">//lookA.MyLookAt(lookB);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/GeY8pZdnj2ucy3v.png" alt="Pasted image 20241123201218.png"></p><p><img src="https://s2.loli.net/2024/11/26/ExdD5nZWNXbcA91.png" alt="Pasted image 20241123201244.png"><br><img src="https://s2.loli.net/2024/11/26/OiyhHmBItS2ZjQn.png" alt="Pasted image 20241123201601.png"></p><h1 id="四元数计算"><a href="#四元数计算" class="headerlink" title="四元数计算"></a>四元数计算</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson12</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 四元数相乘</span><br>        Quaternion q = Quaternion.AngleAxis(<span class="hljs-number">20</span>, Vector3.up);<br>        <span class="hljs-comment">// 物体绕物体自身的Y轴旋转20度</span><br>        <span class="hljs-keyword">this</span>.transform.rotation *= q;<br>        <span class="hljs-comment">// 物体绕物体自身的Y轴继续旋转20度</span><br>        <span class="hljs-keyword">this</span>.transform.rotation *= q;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 四元数乘向量</span><br>        Vector3 v = Vector3.forward;<br>        print(v);<br>        <span class="hljs-comment">// 只能是四元数*向量，不能左边是向量，右边是四元数</span><br>        <span class="hljs-comment">// 这里是相当于将向量旋转了45度</span><br>        v = Quaternion.AngleAxis(<span class="hljs-number">45</span>, Vector3.up) * v;<br>        print(v);<br>        <span class="hljs-comment">// 这里是相当于将向量再旋转了45度</span><br>        v = Quaternion.AngleAxis(<span class="hljs-number">45</span>, Vector3.up) * v;<br>        print(v);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/JKom2NcaYuvQb9R.png" alt="Pasted image 20241123204357.png"></p><p><img src="https://s2.loli.net/2024/11/26/YoGINedp7RFQngK.png" alt="Pasted image 20241123204935.png"></p><h1 id="MonoBehaviour中的重要内容-延迟函数"><a href="#MonoBehaviour中的重要内容-延迟函数" class="headerlink" title="MonoBehaviour中的重要内容-延迟函数"></a>MonoBehaviour中的重要内容-延迟函数</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson13</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Test t;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 什么是延迟函数</span><br>        <span class="hljs-comment">//延迟函数顾名思义</span><br>        <span class="hljs-comment">//就是会延时执行的函数</span><br>        <span class="hljs-comment">//我们可以自己设定延时要执行的函数和具体延时的时间</span><br>        <span class="hljs-comment">//是MonoBehaviour基类中实现好的方法</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 延迟函数的使用</span><br>        <span class="hljs-comment">//1.延迟函数</span><br>        <span class="hljs-comment">//Invoke</span><br>        <span class="hljs-comment">//参数一：函数名 字符串</span><br>        <span class="hljs-comment">//参数二：延迟时间 秒为单位</span><br>        Invoke(<span class="hljs-string">&quot;DelayDoSomething&quot;</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//1-1.延时函数第一个参数传入的是函数名字符串</span><br>        <span class="hljs-comment">//1-2.延时函数没办法传入参数，只有包裹一层，包裹的意思就是调用其他的没有参数的方法，而这个没有参数的方法会传入参数调用我们想要的方法</span><br>        <span class="hljs-comment">//1-3.函数名必须是该脚本上申明的函数，也就是只能调用Lesson13.cs这个里面的函数</span><br><br>        <span class="hljs-comment">//2.延迟重复执行函数</span><br>        <span class="hljs-comment">//InvokeRepeating</span><br>        <span class="hljs-comment">//参数一：函数名字符串</span><br>        <span class="hljs-comment">//参数二：第一次执行的延迟时间</span><br>        <span class="hljs-comment">//参数三：之后每次执行的间隔时间</span><br>        <span class="hljs-comment">// 第一次调用是第五秒的时候调用DelayRe()函数，第六秒，。。。之后每过一秒后再次调用</span><br>        InvokeRepeating(<span class="hljs-string">&quot;DelayRe&quot;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//它的注意事项和延时函数一致</span><br><br>        <span class="hljs-comment">//3.取消延迟函数</span><br>        <span class="hljs-comment">//3-1取消该脚本上的所有延时函数执行</span><br>        <span class="hljs-comment">//CancelInvoke();</span><br><br>        <span class="hljs-comment">//3-2指定函数名取消</span><br>        <span class="hljs-comment">//只要取消了指定延迟，不管之前该函数开启了多少次，延迟执行都会统一取消</span><br>        <span class="hljs-comment">// 如果DelayDoSomething这个方法不存在或者并没有被延迟，那么执行下面的代码，也不会报错，只是没有效果</span><br>        <span class="hljs-comment">//CancelInvoke(&quot;DelayDoSomething&quot;);</span><br><br>        <span class="hljs-comment">//4.判断是否有延迟函数</span><br>        <span class="hljs-comment">// 如果延迟函数使用CancelInvoke()取消了，下面也无法判断到</span><br>        <span class="hljs-keyword">if</span> (IsInvoking())<br>        &#123;<br>            print(<span class="hljs-string">&quot;存在延迟函数&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (IsInvoking(<span class="hljs-string">&quot;DelayDoSomething&quot;</span>))<br>        &#123;<br>            print(<span class="hljs-string">&quot;存在延迟函数DelayDoSomething&quot;</span>);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 延迟函数受对象失活销毁影响</span><br>        <span class="hljs-comment">//脚本依附对象失活 或者 脚本自己失活</span><br>        <span class="hljs-comment">//延迟函数可以继续执行 不会受到影响的</span><br><br>        <span class="hljs-comment">//脚本依附对象销毁或者脚本移除</span><br>        <span class="hljs-comment">//延迟函数无法继续执行</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//对象激活 的生命周期函数中 开启延迟（重复执行的延迟）</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//对象失活 的生命周期函数中 停止延迟</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DelayDoSomething</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;延时执行的函数&quot;</span>);<br><br>        TestFun(<span class="hljs-number">2</span>);<br><br>        t.TestFun();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DelayRe</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;重复执行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;无参重载&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;传入参数&quot;</span> + i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="MonoBehaviour中的重要内容-协同程序"><a href="#MonoBehaviour中的重要内容-协同程序" class="headerlink" title="MonoBehaviour中的重要内容-协同程序"></a>MonoBehaviour中的重要内容-协同程序</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Threading;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson14</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    Thread t;<br><br>    <span class="hljs-comment">//申明一个变量作为一个公共内存容器</span><br>    Queue&lt;Vector3&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;Vector3&gt;();<br><br>    Queue&lt;Vector3&gt; queue2 = <span class="hljs-keyword">new</span> Queue&lt;Vector3&gt;();<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Unity是否支持多线程？</span><br>        <span class="hljs-comment">//首先要明确一点</span><br>        <span class="hljs-comment">//Unity是支持多线程的</span><br>        <span class="hljs-comment">//只是新开线程无法访问Unity相关对象的内容</span><br>        <span class="hljs-comment">// 所以线程一般用来计算一些复杂的内容</span><br><br>        <span class="hljs-comment">//注意：Unity中的多线程 要记住关闭</span><br>        <span class="hljs-comment">// 否则在Unity中，还会继续运行线程，这个线程和Unity编辑器是共生的</span><br><br>        t = <span class="hljs-keyword">new</span> Thread(Test);<br>        <span class="hljs-comment">//t.Start();</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 协同程序是什么？</span><br>        <span class="hljs-comment">//协同程序简称协程</span><br>        <span class="hljs-comment">//它是“假”的多线程，它不是多线程</span><br><br>        <span class="hljs-comment">//它的主要作用</span><br>        <span class="hljs-comment">//将代码分时执行，不卡主线程</span><br>        <span class="hljs-comment">//简单理解，是把可能会让主线程卡顿的耗时的逻辑分时分步执行</span><br><br>        <span class="hljs-comment">//主要使用场景</span><br>        <span class="hljs-comment">//异步加载文件</span><br>        <span class="hljs-comment">//异步下载文件</span><br>        <span class="hljs-comment">//场景异步加载</span><br>        <span class="hljs-comment">//批量创建时防止卡顿</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 协同程序和线程的区别</span><br>        <span class="hljs-comment">//新开一个线程是独立的一个管道，和主线程并行执行</span><br>        <span class="hljs-comment">//新开一个协程是在原线程之上开启，进行逻辑分时分步执行</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 协程的使用</span><br>        <span class="hljs-comment">//继承MonoBehavior的类 都可以开启 协程函数</span><br>        <span class="hljs-comment">//第一步：申明协程函数</span><br>        <span class="hljs-comment">//  协程函数2个关键点</span><br>        <span class="hljs-comment">//  1-1返回值为IEnumerator类型及其子类</span><br>        <span class="hljs-comment">//  1-2函数中通过 yield return 返回值; 进行返回</span><br><br>        <span class="hljs-comment">//第二步：开启协程函数</span><br>        <span class="hljs-comment">//协程函数 是不能够 直接这样去执行的！！！！！！！</span><br>        <span class="hljs-comment">//这样执行没有任何效果</span><br>        <span class="hljs-comment">//MyCoroutine(1, &quot;123&quot;);</span><br>        <span class="hljs-comment">//常用开启方式</span><br>        <span class="hljs-comment">//IEnumerator ie = MyCoroutine(1, &quot;123&quot;);</span><br>        <span class="hljs-comment">//StartCoroutine(ie);</span><br>        Coroutine c1 = StartCoroutine(MyCoroutine(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;123&quot;</span>));<br>        Coroutine c2 = StartCoroutine(MyCoroutine(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;123&quot;</span>));<br>        Coroutine c3 = StartCoroutine(MyCoroutine(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;123&quot;</span>));<br><br>        <span class="hljs-comment">//第三步：关闭协程</span><br>        <span class="hljs-comment">//关闭所有协程</span><br>        <span class="hljs-comment">// 这样只会打印三个1，就不会继续执行了</span><br>        StopAllCoroutines();<br><br>        <span class="hljs-comment">//关闭指定协程，如果c1协程被关闭了</span><br>        <span class="hljs-comment">// 再次关闭不会报错</span><br>        StopCoroutine(c1);<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点五 yield return 不同内容的含义</span><br>        <span class="hljs-comment">//1.下一帧执行</span><br>        <span class="hljs-comment">//yield return 数字;</span><br>        <span class="hljs-comment">//yield return null;</span><br>        <span class="hljs-comment">//在Update和LateUpdate之间执行</span><br><br>        <span class="hljs-comment">//2.等待指定秒后执行</span><br>        <span class="hljs-comment">//yield return new WaitForSeconds(秒);</span><br>        <span class="hljs-comment">//在Update和LateUpdate之间执行</span><br><br>        <span class="hljs-comment">//3.等待下一个固定物理帧更新时执行</span><br>        <span class="hljs-comment">//yield return new WaitForFixedUpdate();</span><br>        <span class="hljs-comment">//在FixedUpdate和碰撞检测相关函数之后执行</span><br><br>        <span class="hljs-comment">//4.等待摄像机和GUI渲染完成后执行</span><br>        <span class="hljs-comment">//yield return new WaitForEndOfFrame();</span><br>        <span class="hljs-comment">//在LateUpdate之后的渲染相关处理完毕后之后</span><br><br>        <span class="hljs-comment">//5.一些特殊类型的对象 比如异步加载相关函数返回的对象</span><br>        <span class="hljs-comment">//之后讲解 异步加载资源 异步加载场景 网络加载时再讲解</span><br>        <span class="hljs-comment">//一般在Update和LateUpdate之间执行</span><br><br>        <span class="hljs-comment">//6.跳出协程</span><br>        <span class="hljs-comment">//yield break;</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点六 协程受对象和组件失活销毁的影响</span><br>        <span class="hljs-comment">//协程开启后</span><br>        <span class="hljs-comment">//组件和物体销毁，协程不执行</span><br>        <span class="hljs-comment">//物体失活协程不执行，组件失活协程执行</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (queue.Count &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">this</span>.transform.position = queue.Dequeue();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//关键点一： 协同程序（协程）函数 返回值 必须是 IEnumerator或者继承它的类型</span><br>    <span class="hljs-function">IEnumerator <span class="hljs-title">MyCoroutine</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i, <span class="hljs-built_in">string</span> str</span>)</span><br>    &#123;<br>        print(i);<br>        <span class="hljs-comment">//关键点二： 协程函数当中 必须使用 yield return 进行返回</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        print(str);<br>        <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">1f</span></span>)</span>;<br>        <span class="hljs-comment">//1秒过后，在Update和LateUpdate之间执行下一行代码</span><br>        print(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForFixedUpdate</span>()</span>;<br>        print(<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-comment">//主要会用来 截图时 会使用</span><br>        <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForEndOfFrame</span>()</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            print(<span class="hljs-string">&quot;5&quot;</span>);<br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">5f</span></span>)</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            Thread.Sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-comment">//相当于模拟 复杂算法 算出了一个结果 然后放入公共容器中</span><br>            System.Random r = <span class="hljs-keyword">new</span> System.Random();<br>            queue.Enqueue(<span class="hljs-keyword">new</span> Vector3(r.Next(<span class="hljs-number">-10</span>, <span class="hljs-number">10</span>), r.Next(<span class="hljs-number">-10</span>, <span class="hljs-number">10</span>), r.Next(<span class="hljs-number">-10</span>, <span class="hljs-number">10</span>)));<br>            print(<span class="hljs-string">&quot;123&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>    &#123;<br>        t.Abort();<br>        t = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="MonoBehaviour中的重要内容-协同程序原理"><a href="#MonoBehaviour中的重要内容-协同程序原理" class="headerlink" title="MonoBehaviour中的重要内容-协同程序原理"></a>MonoBehaviour中的重要内容-协同程序原理</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> time;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> time</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.time = time;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson15</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br><br>    <span class="hljs-function">IEnumerator <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;第一次执行&quot;</span>);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        print(<span class="hljs-string">&quot;第二次执行&quot;</span>);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        print(<span class="hljs-string">&quot;第三次执行&quot;</span>);<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span>;<br>        print(<span class="hljs-string">&quot;第四次执行&quot;</span>);<br>        <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestClass</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 协程的本质</span><br>        <span class="hljs-comment">//协程可以分成两部分</span><br>        <span class="hljs-comment">//1.协程函数本体</span><br>        <span class="hljs-comment">//2.协程调度器</span><br><br>        <span class="hljs-comment">//协程本体就是一个能够中间暂停返回的函数</span><br>        <span class="hljs-comment">//协程调度器是Unity内部实现的，会在对应的时机帮助我们继续执行协程函数</span><br><br>        <span class="hljs-comment">//Unity只实现了协程调度部分</span><br>        <span class="hljs-comment">//协程的本体本质上就是一个 C#的迭代器方法</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 协程本体是迭代器方法的体现</span><br>        <span class="hljs-comment">//1.协程函数本体</span><br>        <span class="hljs-comment">//如果我们不通过 开启协程方法执行协程 </span><br>        <span class="hljs-comment">//Unity的协程调度器是不会帮助我们管理协程函数的</span><br>        IEnumerator ie = Test();<br><br>        <span class="hljs-comment">//但是我们可以自己执行迭代器函数内容</span><br>        <span class="hljs-comment">//ie.MoveNext();//会执行函数中内容遇到 yield return为止的逻辑</span><br>        <span class="hljs-comment">//print(ie.Current);//得到 yield return 返回的内容</span><br><br>        <span class="hljs-comment">//ie.MoveNext();</span><br>        <span class="hljs-comment">//print(ie.Current);</span><br><br>        <span class="hljs-comment">//ie.MoveNext();</span><br>        <span class="hljs-comment">//print(ie.Current);</span><br><br>        <span class="hljs-comment">//ie.MoveNext();</span><br>        <span class="hljs-comment">//TestClass tc = ie.Current as TestClass;</span><br>        <span class="hljs-comment">//print(tc.time);</span><br><br>        <span class="hljs-comment">//MoveNext 返回值 代表着 是否到了结尾（这个迭代器函数 是否执行完毕）</span><br>        <span class="hljs-keyword">while</span>(ie.MoveNext())<br>        &#123;<br>            print(ie.Current);<br>        &#125;<br><br>        <span class="hljs-comment">//2.协程调度器</span><br>        <span class="hljs-comment">//继承MonoBehavior后 开启协程</span><br>        <span class="hljs-comment">//相当于是把一个协程函数（迭代器）放入Unity的协程调度器中帮助我们管理进行执行</span><br>        <span class="hljs-comment">//具体的yield return 后面的规则 也是Unity定义的一些规则</span><br><br>        <span class="hljs-comment">//总结</span><br>        <span class="hljs-comment">//你可以简化理解迭代器函数</span><br>        <span class="hljs-comment">//C#看到迭代器函数和yield return 语法糖</span><br>        <span class="hljs-comment">//就会把原本是一个的 函数 变成&quot;几部分&quot;</span><br>        <span class="hljs-comment">//我们可以通过迭代器 从上到下遍历这 &quot;几部分&quot;进行执行</span><br>        <span class="hljs-comment">//就达到了将一个函数中的逻辑分时执行的目的</span><br><br>        <span class="hljs-comment">//而协程调度器就是 利用迭代器函数返回的内容来进行之后的处理</span><br>        <span class="hljs-comment">//比如Unity中的协程调度器</span><br>        <span class="hljs-comment">//根据yield return 返回的内容 决定了下一次在何时继续执行迭代器函数中的&quot;下一部分&quot;</span><br><br>        <span class="hljs-comment">//理论上来说 我们可以利用迭代器函数的特点 自己实现协程调度器来取代Unity自带的调度器</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//协程的本质 就是利用 </span><br>        <span class="hljs-comment">//C#的迭代器函数&quot;分步执行&quot;的特点</span><br>        <span class="hljs-comment">//加上</span><br>        <span class="hljs-comment">//协程调度逻辑</span><br>        <span class="hljs-comment">//实现的一套分时执行函数的规则</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="特殊文件夹知识点"><a href="#特殊文件夹知识点" class="headerlink" title="特殊文件夹知识点"></a>特殊文件夹知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson16</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 工程路径获取</span><br>        <span class="hljs-comment">//注意 该方式 获取到的路径 一般情况下 只在 编辑模式下使用</span><br>        <span class="hljs-comment">//我们不会在实际发布游戏后 还使用该路径</span><br>        <span class="hljs-comment">//游戏发布过后 该路径就不存在了</span><br>        <span class="hljs-comment">// 得到的是开发的Assets路径</span><br>        print(Application.dataPath);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 Resources 资源文件夹</span><br>        <span class="hljs-comment">//路径获取：</span><br>        <span class="hljs-comment">//一般不获取</span><br>        <span class="hljs-comment">//只能使用Resources相关API进行加载</span><br>        <span class="hljs-comment">//如果硬要获取 可以用工程路径拼接</span><br>        print(Application.dataPath + <span class="hljs-string">&quot;/Resources&quot;</span>);<br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//需要我们自己将创建Resources文件夹在Assets文件夹下</span><br>        <span class="hljs-comment">//作用：</span><br>        <span class="hljs-comment">//资源文件夹</span><br>        <span class="hljs-comment">//1-1.需要通过Resources相关API动态加载的资源需要放在其中</span><br>        <span class="hljs-comment">//1-2.该文件夹下所有文件都会被打包出去</span><br>        <span class="hljs-comment">//1-3.打包时Unity会对其压缩加密</span><br>        <span class="hljs-comment">//1-4.该文件夹打包后只读，只能通过Resources相关API加载</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 StreamingAssets 流动资源文件夹</span><br>        <span class="hljs-comment">//路径获取：</span><br>        print(Application.streamingAssetsPath);<br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//需要我们自己将创建StreamingAssets文件夹在Assets文件夹下</span><br>        <span class="hljs-comment">//作用：</span><br>        <span class="hljs-comment">//流文件夹</span><br>        <span class="hljs-comment">//2-1.打包出去不会被压缩加密，可以任由我们摆布</span><br>        <span class="hljs-comment">//2-2.移动平台只读，PC平台可读可写</span><br>        <span class="hljs-comment">//2-3.可以放入一些需要自定义动态加载的初始资源</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 persistentDataPath 持久数据文件夹</span><br>        <span class="hljs-comment">//路径获取：</span><br>        print(Application.persistentDataPath);<br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//不需要我们自己将创建</span><br>        <span class="hljs-comment">//作用：</span><br>        <span class="hljs-comment">//固定数据文件夹</span><br>        <span class="hljs-comment">//3-1.所有平台都可读可写</span><br>        <span class="hljs-comment">//3-2.一般用于放置动态下载或者动态创建的文件，游戏中创建或者获取的文件都放在其中</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点五 Plugins 插件文件夹</span><br>        <span class="hljs-comment">//路径获取：</span><br>        <span class="hljs-comment">//一般不获取</span><br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//需要我们自己将创建Plugins文件夹在Assets文件夹下</span><br>        <span class="hljs-comment">//作用：</span><br>        <span class="hljs-comment">//插件文件夹，使用别人开发好的插件或者代码</span><br>        <span class="hljs-comment">//不同平台的插件相关文件放在其中</span><br>        <span class="hljs-comment">//比如IOS和Android平台</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点六 Editor 编辑器文件夹</span><br>        <span class="hljs-comment">//路径获取：</span><br>        <span class="hljs-comment">//一般不获取</span><br>        <span class="hljs-comment">//如果硬要获取 可以用工程路径拼接</span><br>        print(Application.dataPath + <span class="hljs-string">&quot;/Editor&quot;</span>);<br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//需要我们自己将创建Editor文件夹在Assets文件夹下</span><br>        <span class="hljs-comment">//作用：</span><br>        <span class="hljs-comment">//编辑器文件夹</span><br>        <span class="hljs-comment">//5-1.开发Unity编辑器时，编辑器相关脚本放在该文件夹中</span><br>        <span class="hljs-comment">//5-2.该文件夹中内容不会被打包出去</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点七 默认资源文件夹 Standard Assets</span><br>        <span class="hljs-comment">//路劲过去：</span><br>        <span class="hljs-comment">//一般不获取</span><br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//需要我们自己将创建文件夹Standard Assets在Assets文件夹下</span><br>        <span class="hljs-comment">//作用：</span><br>        <span class="hljs-comment">//默认资源文件夹</span><br>        <span class="hljs-comment">//一般Unity自带资源都放在这个文件夹下</span><br>        <span class="hljs-comment">//代码和资源优先被编译</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Resources资源同步加载知识点"><a href="#Resources资源同步加载知识点" class="headerlink" title="Resources资源同步加载知识点"></a>Resources资源同步加载知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson17</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> AudioSource audioS;<br><br>    <span class="hljs-keyword">private</span> Texture tex;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Resources资源动态加载的作用</span><br>        <span class="hljs-comment">//1.通过代码动态加载Resources文件夹下指定路径资源</span><br>        <span class="hljs-comment">//2.避免繁琐的拖曳操作</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 常用资源类型</span><br>        <span class="hljs-comment">//1.预设体对象——GameObject</span><br>        <span class="hljs-comment">//2.音效文件——AudioClip</span><br>        <span class="hljs-comment">//3.文本文件——TextAsset 只支持特定类型的文本</span><br>        <span class="hljs-comment">//4.图片文件——Texture</span><br>        <span class="hljs-comment">//5.其它类型——需要什么用什么类型</span><br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//预设体对象加载需要实例化</span><br>        <span class="hljs-comment">//其它资源加载一般直接用</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 资源同步加载 普通方法</span><br>        <span class="hljs-comment">//在一个工程当中 Resources文件夹 可以有多个 通过API加载时 它会自己去这些同名的Resources文件夹中去找资源</span><br>        <span class="hljs-comment">// 如果有重名的，会按照Assets里面的顺序，找到的第一个资源来进行实例化</span><br>        <span class="hljs-comment">//打包时 Resources文件夹 里的内容 都会打包在一起</span><br>        <span class="hljs-comment">// Unity 使用 文件的完整相对路径（相对于 Resources 文件夹）来区分资源，而不仅仅是文件名</span><br><br>        <span class="hljs-comment">//1.预设体对象 想要创建在场景上 记住实例化</span><br>        <span class="hljs-comment">// 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中)</span><br>        <span class="hljs-comment">// 如果有Resouces/Resouces/下有Cube，可以找到</span><br>        <span class="hljs-comment">// Resouces/Lesson17/Cube 就找不到，必须指定为Resouces.Load(&quot;Lesson17/Cube&quot;);</span><br>        Object obj = Resources.Load(<span class="hljs-string">&quot;Cube&quot;</span>);<br>        <span class="hljs-comment">//第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化</span><br>        Instantiate(obj);<br><br>        <span class="hljs-comment">// 第一步：要去加载预设体的资源文件(本质上 就是加载 配置数据 在内存中)</span><br>        Object obj2 = Resources.Load(<span class="hljs-string">&quot;Sphere&quot;</span>);<br>        <span class="hljs-comment">//第二步：如果想要在场景上 创建预设体 一定是加载配置文件过后 然后实例化</span><br>        Instantiate(obj2);<br><br>        <span class="hljs-comment">//2.音效资源</span><br>        <span class="hljs-comment">//第一步：就是加载数据</span><br>        Object obj3 = Resources.Load(<span class="hljs-string">&quot;Music/BKMusic&quot;</span>);<br>        <span class="hljs-comment">//第二步：使用数据 我们不需要实例化 音效切片 我们只需要把数据 赋值到正确的脚本上即可</span><br>        audioS.clip = obj3 <span class="hljs-keyword">as</span> AudioClip;<br>        audioS.Play();<br><br>        <span class="hljs-comment">//3.文本资源</span><br>        <span class="hljs-comment">//文本资源支持的格式</span><br>        <span class="hljs-comment">//.txt</span><br>        <span class="hljs-comment">//.xml</span><br>        <span class="hljs-comment">//.bytes</span><br>        <span class="hljs-comment">//.json</span><br>        <span class="hljs-comment">//.html</span><br>        <span class="hljs-comment">//.csv</span><br>        <span class="hljs-comment">//.....</span><br>        TextAsset ta = Resources.Load(<span class="hljs-string">&quot;Txt/Test&quot;</span>) <span class="hljs-keyword">as</span> TextAsset;<br>        <span class="hljs-comment">//文本内容</span><br>        print(ta.text);<br>        <span class="hljs-comment">//字节数据组</span><br>        <span class="hljs-comment">//print(ta.bytes);</span><br><br>        <span class="hljs-comment">//4.图片</span><br>        <span class="hljs-comment">//tex = Resources.Load(&quot;Tex/TestJPG&quot;) as Texture;</span><br><br>        <span class="hljs-comment">//5.其它类型 需要什么类型 就用什么类型就行</span><br>        <span class="hljs-comment">// 动画</span><br><br>        <span class="hljs-comment">//6.问题：资源同名怎么办</span><br>        <span class="hljs-comment">//Resources.Load加载同名资源时，但是后缀不一样，无法准确加载出你想要的内容</span><br><br>        <span class="hljs-comment">//可以使用另外的API</span><br>        <span class="hljs-comment">//6-1加载指定类型的资源</span><br>        <span class="hljs-comment">//tex = Resources.Load(&quot;Tex/TestJPG&quot;, typeof(Texture)) as Texture;</span><br><br>        ta = Resources.Load(<span class="hljs-string">&quot;Tex/TestJPG&quot;</span>, <span class="hljs-keyword">typeof</span>(TextAsset)) <span class="hljs-keyword">as</span> TextAsset;<br>        <span class="hljs-comment">//print(ta.text);</span><br><br>        <span class="hljs-comment">//6-2加载指定名字的所有资源</span><br>        Object[] objs = Resources.LoadAll(<span class="hljs-string">&quot;Tex/TestJPG&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (Object item <span class="hljs-keyword">in</span> objs)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">is</span> Texture) &#123; &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">is</span> TextAsset) &#123; &#125;<br>        &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 资源同步加载 泛型方法</span><br><br>        <span class="hljs-comment">//TextAsset ta2 = Resources.Load&lt;TextAsset&gt;(&quot;Tex/TestJPG&quot;);</span><br>        <span class="hljs-comment">//print(ta2.text);</span><br><br>        <span class="hljs-comment">//tex = Resources.Load&lt;Texture&gt;(&quot;Tex/TestJPG&quot;);</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>    &#123;<br>        GUI.DrawTexture(<span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>), tex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Resouces资源异步加载知识点"><a href="#Resouces资源异步加载知识点" class="headerlink" title="Resouces资源异步加载知识点"></a>Resouces资源异步加载知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson18</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Texture tex;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Resources异步加载是什么？</span><br>        <span class="hljs-comment">//上节课学习的同步加载中</span><br>        <span class="hljs-comment">//如果我们加载过大的资源可能会造成程序卡顿</span><br>        <span class="hljs-comment">//卡顿的原因就是 从硬盘上把数据读取到内存中 是需要进行计算的</span><br>        <span class="hljs-comment">//越大的资源耗时越长，就会造成掉帧卡顿</span><br><br>        <span class="hljs-comment">//Resources异步加载 就是内部新开一个线程进行资源加载 不会造成主线程卡顿</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 Resources异步加载方法</span><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//异步加载 不能马上得到加载的资源 至少要等一帧</span><br><br>        <span class="hljs-comment">//1.通过异步加载中的完成事件监听 使用加载的资源</span><br>        <span class="hljs-comment">//这句代码 你可以理解 Unity 在内部 就会去开一个线程进行资源下载</span><br>        <span class="hljs-comment">//ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(&quot;Tex/TestJPG&quot;);</span><br>        <span class="hljs-comment">//马上进行一个 资源下载结束 的一个事件函数监听</span><br>        <span class="hljs-comment">//rq.completed += LoadOver;</span><br>        print(Time.frameCount);<br>        <span class="hljs-comment">//这个 刚刚执行了异步加载的 执行代码 资源还没有加载完毕 这样用 是不对的 </span><br>        <span class="hljs-comment">//一定要等加载结束过后 才能使用</span><br>        <span class="hljs-comment">//rq.asset ××××××××××××</span><br><br>        <span class="hljs-comment">//2.通过协程 使用加载的资源</span><br>        StartCoroutine(Load());<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//1.完成事件监听异步加载</span><br>        <span class="hljs-comment">//好处：写法简单</span><br>        <span class="hljs-comment">//坏处：只能在资源加载结束后 进行处理</span><br>        <span class="hljs-comment">//“线性加载”</span><br><br>        <span class="hljs-comment">//2.协程异步加载</span><br>        <span class="hljs-comment">//好处：可以在协程中处理复杂逻辑，比如同时加载多个资源，比如进度条更新</span><br>        <span class="hljs-comment">//坏处：写法稍麻烦</span><br>        <span class="hljs-comment">//“并行加载”</span><br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//理解为什么异步加载不能马上加载结束，为什么至少要等1帧</span><br>        <span class="hljs-comment">//理解协程异步加载的原理</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function">IEnumerator <span class="hljs-title">Load</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//迭代器函数 当遇到yield return时  就会 停止执行之后的代码</span><br>        <span class="hljs-comment">//然后 协程协调器 通过得到 返回的值 去判断 下一次执行后面的步骤 将会是何时</span><br>        ResourceRequest rq = Resources.LoadAsync&lt;Texture&gt;(<span class="hljs-string">&quot;Tex/TestJPG&quot;</span>);<br>        print(Time.frameCount);<br>        <span class="hljs-comment">//第一部分</span><br>        <span class="hljs-comment">//Unity 自己知道 该返回值 意味着你在异步加载资源 </span><br>        <span class="hljs-comment">//yield return rq;</span><br>        <span class="hljs-comment">//Unity 会自己判断 该资源是否加载完毕了 加载完毕过后 才会继续执行后面的代码</span><br>        print(Time.frameCount);<br>        <br>        <span class="hljs-comment">//判断资源是否加载结束</span><br>        <span class="hljs-keyword">while</span>(!rq.isDone)<br>        &#123;<br>            <span class="hljs-comment">//打印当前的 加载进度 </span><br>            <span class="hljs-comment">//该进度 不会特别准确 过渡也不是特别明显</span><br>            print(rq.progress);<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        tex = rq.asset <span class="hljs-keyword">as</span> Texture;<br><br>        <span class="hljs-comment">//yield return null;</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span>/第二部分</span><br>        <span class="hljs-comment">//yield return new WaitForSeconds(2f);</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span>/第三部分</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadOver</span>(<span class="hljs-params"> AsyncOperation rq</span>)</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;加载结束&quot;</span>);<br>        <span class="hljs-comment">//asset 是资源对象 加载完毕过后 就能够得到它</span><br>        tex = (rq <span class="hljs-keyword">as</span> ResourceRequest).asset <span class="hljs-keyword">as</span> Texture;<br>        print(Time.frameCount);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>( tex != <span class="hljs-literal">null</span>)<br>            GUI.DrawTexture(<span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>), tex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Resouces资源卸载"><a href="#Resouces资源卸载" class="headerlink" title="Resouces资源卸载"></a>Resouces资源卸载</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson19</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> Texture tex;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Resources重复加载资源会浪费内存吗？</span><br>        <span class="hljs-comment">//其实Resources加载一次资源过后</span><br>        <span class="hljs-comment">//该资源就一直存放在内存中作为缓存</span><br>        <span class="hljs-comment">//第二次加载时发现缓存中存在该资源</span><br>        <span class="hljs-comment">//会直接取出来进行使用</span><br>        <span class="hljs-comment">//所以 多次重复加载不会浪费内存</span><br>        <span class="hljs-comment">//但是 会浪费性能（每次加载都会去查找取出，始终伴随一些性能消耗）</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 如何手动释放掉缓存中的资源</span><br>        <span class="hljs-comment">//1.卸载指定资源</span><br>        <span class="hljs-comment">//Resources.UnloadAsset 方法</span><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//该方法 不能释放 GameObject对象 因为它会用于实例化对象</span><br>        <span class="hljs-comment">//它只能用于一些 不需要实例化的内容 比如 图片 和 音效 文本等等</span><br>        <span class="hljs-comment">//一般情况下 我们很少单独使用它</span><br>        <span class="hljs-comment">//GameObject obj = Resources.Load&lt;GameObject&gt;(&quot;Cube&quot;);</span><br>        <span class="hljs-comment">//即使是没有实例化的 GameObject对象也不能进行卸载</span><br>        <span class="hljs-comment">//Resources.UnloadAsset(obj);</span><br><br>        <span class="hljs-comment">//2.卸载未使用的资源</span><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//一般在过场景时和GC一起使用</span><br>        Resources.UnloadUnusedAssets();<br>        GC.Collect();<br>        <br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//Resources.UnloadAsset 卸载指定资源 但是不能卸载GameObject对象</span><br>        <span class="hljs-comment">//Resources.UnloadUnusedAssets 卸载未使用资源 一般过场景时配合GC使用</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(Input.GetKeyDown(KeyCode.Alpha1))<br>        &#123;<br>            print(<span class="hljs-string">&quot;加载资源&quot;</span>);<br>            tex = Resources.Load&lt;Texture&gt;(<span class="hljs-string">&quot;Tex/TestJPG&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Input.GetKeyDown(KeyCode.Alpha2))<br>        &#123;<br>            print(<span class="hljs-string">&quot;卸载资源&quot;</span>);<br>            Resources.UnloadAsset(tex);<br>            tex = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/pPIinzefQrOWoJD.png" alt="Pasted image 20241123235440.png"></p><p><img src="https://s2.loli.net/2024/11/26/ihbKJMAySflZ9Uo.png" alt="Pasted image 20241123235502.png"></p><h1 id="场景异步加载"><a href="#场景异步加载" class="headerlink" title="场景异步加载"></a>场景异步加载</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson20</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 回顾场景同步切换</span><br><br>        <span class="hljs-comment">//SceneManager.LoadScene(&quot;Lesson20Test&quot;);</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 场景同步切换的缺点</span><br>        <span class="hljs-comment">//在切换场景时</span><br>        <span class="hljs-comment">//Unity会删除当前场景上所有对象</span><br>        <span class="hljs-comment">//并且去加载下一个场景的相关信息</span><br>        <span class="hljs-comment">//如果当前场景 对象过多或者下一个场景对象过多</span><br>        <span class="hljs-comment">//这个过程会非常的耗时 会让玩家感受到卡顿</span><br><br>        <span class="hljs-comment">//所以异步切换就是来解决该问题的</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 场景异步切换</span><br>        <span class="hljs-comment">//场景异步加载和资源异步加载 几乎一致 有两种方式</span><br><br>        <span class="hljs-comment">//1.通过事件回调函数 异步加载</span><br>        <span class="hljs-comment">//AsyncOperation ao = SceneManager.LoadSceneAsync(&quot;Lesson20Test&quot;);</span><br>        <span class="hljs-comment">//当场景异步加载结束后 就会自动调用该事件函数 我们如果希望在加载结束后 做一些事情 那么久可以在该函数中</span><br>        <span class="hljs-comment">//写处理逻辑</span><br>        <span class="hljs-comment">//ao.completed += (a) =&gt;</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    print(&quot;加载结束&quot;);</span><br>        <span class="hljs-comment">//&#125;;</span><br><br>        <span class="hljs-comment">//ao.completed += LoadOver;</span><br><br><br>        <span class="hljs-comment">//2.通过协程异步加载</span><br>        <span class="hljs-comment">//需要注意的是 加载场景会把当前场景上 没有特别处理的对象 都删除了</span><br>        <span class="hljs-comment">//所以 协程中的部分逻辑 可能是执行不了的</span><br>        <span class="hljs-comment">//解决思路</span><br>        <span class="hljs-comment">//让处理场景加载的脚本依附的对象 过场景时 不被移除</span><br><br>        <span class="hljs-comment">//该脚本依附的对象 过场景时 不会被 移除</span><br>        DontDestroyOnLoad(<span class="hljs-keyword">this</span>.gameObject);<br><br>        StartCoroutine(LoadScene(<span class="hljs-string">&quot;Lesson20Test&quot;</span>));<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 总结</span><br>        <span class="hljs-comment">//场景异步加载 和 资源异步加载 一样</span><br>        <span class="hljs-comment">//有两种方式</span><br>        <span class="hljs-comment">//1.通过事件回调函数</span><br>        <span class="hljs-comment">//2.协程异步加载</span><br><br>        <span class="hljs-comment">//他们的优缺点表现和资源异步加载 也是一样的</span><br>        <span class="hljs-comment">//1.事件回调函数</span><br>        <span class="hljs-comment">//优点：写法简单，逻辑清晰</span><br>        <span class="hljs-comment">//缺点：只能加载完场景做一些事情 不能再加载过程中处理逻辑</span><br>        <span class="hljs-comment">//2.协程异步加载</span><br>        <span class="hljs-comment">//优点：可以在加载过程中处理逻辑，比如进度条更新等</span><br>        <span class="hljs-comment">//缺点：写法较为麻烦，要通过协程</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LoadOver</span>(<span class="hljs-params">AsyncOperation ao</span>)</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;LoadOver&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function">IEnumerator <span class="hljs-title">LoadScene</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//第一步</span><br>        <span class="hljs-comment">//异步加载场景</span><br>        AsyncOperation ao = SceneManager.LoadSceneAsync(name);<br>        <span class="hljs-comment">//Unity内部的 协程协调器 发现是异步加载类型的返回对象 那么就会等待</span><br>        <span class="hljs-comment">//等待异步加载结束后 才会继续执行 迭代器函数中后面的步骤</span><br>        <span class="hljs-comment">//2.通过协程异步加载</span><br>        <span class="hljs-comment">//需要注意的是,加载场景会把当前场景上没有特别处理的对象都删除了</span><br>        <span class="hljs-comment">// 此时的对象删除了，对象上的脚本也无法正常执行</span><br>        <span class="hljs-comment">//所以协程中的部分逻辑可能是执行不了的</span><br>        <span class="hljs-comment">//解决思路</span><br>        <span class="hljs-comment">//让处理场景加载的脚本依附的对象 过场景时 不被移除</span><br><br>        print(<span class="hljs-string">&quot;异步加载过程中 打印的信息&quot;</span>);<br>        <span class="hljs-comment">//协程的好处 是异步加载场景时 我可以在加载的同时 做一些别的逻辑</span><br>        <span class="hljs-comment">//yield return ao;</span><br>        <span class="hljs-comment">//第二步</span><br>        print(<span class="hljs-string">&quot;异步加载结束后 打印的信息&quot;</span>);<br><br>        <span class="hljs-comment">//比如 我们可以在异步加载过程中 去更新进度条</span><br>        <span class="hljs-comment">//第一种 就是利用 场景异步加载 的进度 去更新 但是 不是特别准确 一般也不会直接用</span><br>        <span class="hljs-comment">//while(!ao.isDone)</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    print(ao.progress);</span><br>        <span class="hljs-comment">//    yield return null;</span><br>        <span class="hljs-comment">//&#125;</span><br><br>        <span class="hljs-comment">//离开循环后 就会认为场景加载结束</span><br>        <span class="hljs-comment">//可以把进度条顶满 然后 隐藏进度条</span><br><br>        <span class="hljs-comment">//第二种 就是根据你游戏的规则 自己定义 进度条变化的条件</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> ao;<br>        <span class="hljs-comment">//场景加载结束 更新20%进度</span><br>        <span class="hljs-comment">//接着去加载场景中 的其它信息</span><br>        <span class="hljs-comment">//比如</span><br>        <span class="hljs-comment">//动态加载怪物</span><br>        <span class="hljs-comment">//这时 进度条 再更新20%</span><br>        <span class="hljs-comment">//动态加载 场景模型</span><br>        <span class="hljs-comment">//这时 就认为 加载结束了 进度条顶满</span><br>        <span class="hljs-comment">//隐藏进度条</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>File-&gt;Build Setting<br><img src="https://s2.loli.net/2024/11/26/Cih3rkgmMxfE6Iv.png" alt="Pasted image 20241124105711.png"></li></ul><p><img src="https://s2.loli.net/2024/11/26/IQvOKB45eul8AWH.png" alt="Pasted image 20241124105856.png"></p><h1 id="LineRenderer知识点"><a href="#LineRenderer知识点" class="headerlink" title="LineRenderer知识点"></a>LineRenderer知识点</h1><ul><li>Loop<ul><li>勾选后会将起点和终点连起来</li></ul></li><li>Positions<ul><li>线段的点，会首尾相连</li><li>是世界坐标系</li></ul></li><li>Width<ul><li>线段宽度曲线调整</li><li>可以右键 Add Key修改</li></ul></li><li>Color<ul><li>颜色</li></ul></li><li>CornerVertices角顶点，圆角)<ul><li>此属性指示在一条线中绘制角时使用了多少额外的顶点。增加此值，使线角看起来更圆</li></ul></li><li>End CapVertices（终端顶点，圆角)<ul><li>终点圆角</li></ul></li><li>Alignment 对齐方式<ul><li>View 视点 线段对着摄像机</li><li>Transform Z 线段面对其Z轴</li></ul></li><li>Texture Mode 纹理模式<ul><li>Stretch 拉伸 沿整条线映射纹理一次</li><li>Tile  瓷砖平铺 不停的重复纹理</li><li>Distribute Per Segment  分配执行</li><li>Repeat Per Segment 重复显示</li></ul></li><li>Shadow Bias 阴影偏移</li><li>Generate Lighting Data 生成光源数据<ul><li>如果材质球，是受到光影响的，那么这个选项就需要勾选</li></ul></li><li>Use World Space  是否使用世界坐标系</li><li>Materials  线使用的材质球</li><li>Lighting 光照影响<ul><li>Cast Shadows 是否开启阴影</li><li>Receive Shadows 接收阴影</li></ul></li><li>Probes 光照探针<ul><li>Light Probes 光探测器模式<ul><li>Off 不使用光探针</li><li>Blend Probes 使用内插光探针</li><li>Use Proxy Volume 使用三维网格内插光探针</li><li>Custom Provided 自定义从材质决定</li></ul></li><li>Reflection Probes 反射探测器模式<ul><li>off 不使用反射探针</li><li>Blend Probes 启用混合反射探针</li><li>BlendProbes And Skybox 启用混合反射探针并且和天空和混合</li><li>Simple 启用普通探针，重叠式不混合</li></ul></li></ul></li><li>Additional Settings 附加设置<ul><li>MotionVectors 运动矢量<ul><li>Camera Motion Only 使用相机运动来跟踪运动</li><li>PerObject Motion 特定对象来跟踪运动</li><li>Force No Motion 不跟踪</li></ul></li><li>Dynamic Occlusic 动态遮挡剔除</li><li>Sorting Layer 排序图层</li><li>Order in Layer  此线段在排序图层中的顺序<br><img src="https://s2.loli.net/2024/11/26/lbWRj52YPsI4man.png" alt="Pasted image 20241124112621.png"></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/26/1frgk9cLITYuywS.png" alt="参数1.png"><br><img src="https://s2.loli.net/2024/11/26/VKUZc3FYyujS1vp.png" alt="参数2.png"><br><img src="https://s2.loli.net/2024/11/26/6mG5p3TKd7O4huB.png" alt="参数3.png"></p><p><img src="https://s2.loli.net/2024/11/26/pUFREtcYGHaTdCJ.png" alt="参数4.png"></p><h1 id="物理系统之范围检测知识点"><a href="#物理系统之范围检测知识点" class="headerlink" title="物理系统之范围检测知识点"></a>物理系统之范围检测知识点</h1><ul><li>Edit-&gt;Project Setting<br><img src="https://s2.loli.net/2024/11/26/Fx6saP7OIX1WgEn.png" alt="Pasted image 20241124160435.png"></li><li>勾选是不忽略触发器<br><img src="https://s2.loli.net/2024/11/26/v4P9XlDFjpxKfmk.png" alt="Pasted image 20241124160551.png"></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson22</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识回顾 物理系统之碰撞检测</span><br>        <span class="hljs-comment">//碰撞产生的必要条件</span><br>        <span class="hljs-comment">//1.至少一个物体有刚体</span><br>        <span class="hljs-comment">//2.两个物体都必须有碰撞器</span><br><br>        <span class="hljs-comment">//碰撞和触发</span><br>        <span class="hljs-comment">//碰撞会产生实际的物理效果</span><br>        <span class="hljs-comment">//触发看起来不会产生碰撞但是可以通过函数监听触发</span><br><br>        <span class="hljs-comment">//碰撞检测主要用于实体物体之间产生物理效果时使用</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 什么是范围检测</span><br>        <span class="hljs-comment">//游戏中瞬时的攻击范围判断一般会使用范围检测</span><br>        <span class="hljs-comment">//举例：</span><br>        <span class="hljs-comment">//1.玩家在前方5m处释放一个地刺魔法，在此处范围内的对象将受到地刺伤害</span><br>        <span class="hljs-comment">//2.玩家攻击，在前方1米圆形范围内对象都受到伤害</span><br>        <span class="hljs-comment">//等等</span><br>        <span class="hljs-comment">//类似这种并没有实体物体 只想要检测在指定某一范围是否让敌方受到伤害时 便可以使用范围判断</span><br>        <span class="hljs-comment">//简而言之</span><br>        <span class="hljs-comment">//在指定位置 进行 范围判断 我们可以得到处于指定范围内的 对象</span><br>        <span class="hljs-comment">//目的是对 对象进行处理</span><br>        <span class="hljs-comment">//比如 受伤 减血等等</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 如何进行范围检测</span><br>        <span class="hljs-comment">//必备条件：想要被范围检测到的对象 必须具备碰撞器</span><br>        <span class="hljs-comment">//注意点：</span><br>        <span class="hljs-comment">//1.范围检测相关API 只有当执行该句代码时，进行一次范围检测，它是瞬时的</span><br>        <span class="hljs-comment">//2.范围检测相关API 并不会真正产生一个碰撞器，只是碰撞判断计算而已</span><br><br>        <span class="hljs-comment">//范围检测API</span><br>        <span class="hljs-comment">//1.盒状范围检测</span><br>        <span class="hljs-comment">//参数一：立方体中心点</span><br>        <span class="hljs-comment">//参数二：立方体三边大小</span><br>        <span class="hljs-comment">//参数三：立方体角度</span><br>        <span class="hljs-comment">//参数四：检测指定层级（不填检测所有层）</span><br>        <span class="hljs-comment">//参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span><br>        <span class="hljs-comment">//返回值：触发器数组，在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）</span><br>        print(LayerMask.NameToLayer(<span class="hljs-string">&quot;UI&quot;</span>));<br>        Collider[] colliders = Physics.OverlapBox(<br>            Vector3.zero,<br>            Vector3.one,<br>            Quaternion.AngleAxis(<span class="hljs-number">45</span>, Vector3.up),<br>            <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;UI&quot;</span>) | <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Default&quot;</span>),<br>            QueryTriggerInteraction.UseGlobal<br>        );<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; colliders.Length; i++)<br>        &#123;<br>            print(colliders[i].gameObject.name);<br>        &#125;<br>        <span class="hljs-comment">//0000 0001</span><br>        <span class="hljs-comment">//0010 0000</span><br><br>        <span class="hljs-comment">//重要知识点：</span><br>        <span class="hljs-comment">//关于层级</span><br>        <span class="hljs-comment">//通过名字得到层级编号 LayerMask.NameToLayer</span><br>        <span class="hljs-comment">//我们需要通过编号左移构建二进制数</span><br>        <span class="hljs-comment">//这样每一个编号的层级 都是 对应位为1的2进制数</span><br>        <span class="hljs-comment">//我们通过 位运算 可以选择想要检测层级</span><br>        <span class="hljs-comment">//好处 一个int 就可以表示所有想要检测的层级信息</span><br><br>        <span class="hljs-comment">//层级编号是 0~31 刚好32位</span><br>        <span class="hljs-comment">//是一个int数</span><br>        <span class="hljs-comment">//每一个编号 代表的 都是二进制的一位</span><br>        <span class="hljs-comment">//0—— 1 &lt;&lt; 0——0000 0000 0000 0000 0000 0000 0000 0001 = 1</span><br>        <span class="hljs-comment">//1—— 1 &lt;&lt; 1——0000 0000 0000 0000 0000 0000 0000 0010 = 2</span><br>        <span class="hljs-comment">//2—— 1 &lt;&lt; 2——0000 0000 0000 0000 0000 0000 0000 0100 = 4</span><br>        <span class="hljs-comment">//3—— 1 &lt;&lt; 3——0000 0000 0000 0000 0000 0000 0000 1000 = 8</span><br>        <span class="hljs-comment">//4—— 1 &lt;&lt; 4——0000 0000 0000 0000 0000 0000 0001 0000 = 16</span><br>        <span class="hljs-comment">//5—— 1 &lt;&lt; 5——0000 0000 0000 0000 0000 0000 0010 0000 = 32</span><br><br>        <span class="hljs-comment">//另一个API</span><br>        <span class="hljs-comment">//返回值：碰撞到的碰撞器数量</span><br>        <span class="hljs-comment">//参数：传入一个数组进行存储</span><br>        <span class="hljs-comment">//Physics.OverlapBoxNonAlloc()</span><br><br>        <span class="hljs-keyword">if</span> (Physics.OverlapBoxNonAlloc(Vector3.zero, Vector3.one, colliders) != <span class="hljs-number">0</span>) &#123; &#125;<br><br>        <span class="hljs-comment">//2.球形范围检测</span><br>        <span class="hljs-comment">//参数一：中心点</span><br>        <span class="hljs-comment">//参数二：球半径</span><br>        <span class="hljs-comment">//参数三：检测指定层级（不填检测所有层）</span><br>        <span class="hljs-comment">//参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span><br>        <span class="hljs-comment">//返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）</span><br>        colliders = Physics.OverlapSphere(Vector3.zero, <span class="hljs-number">5</span>, <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Default&quot;</span>));<br><br>        <span class="hljs-comment">//另一个API</span><br>        <span class="hljs-comment">//返回值：碰撞到的碰撞器数量</span><br>        <span class="hljs-comment">//参数：传入一个数组进行存储</span><br>        <span class="hljs-comment">//Physics.OverlapSphereNonAlloc</span><br>        <span class="hljs-keyword">if</span> (Physics.OverlapSphereNonAlloc(Vector3.zero, <span class="hljs-number">5</span>, colliders) != <span class="hljs-number">0</span>) &#123; &#125;<br><br>        <span class="hljs-comment">//3.胶囊范围检测</span><br>        <span class="hljs-comment">//参数一：半圆一中心点</span><br>        <span class="hljs-comment">//参数二：半圆二中心点</span><br>        <span class="hljs-comment">//参数三：半圆半径</span><br>        <span class="hljs-comment">//参数四：检测指定层级（不填检测所有层）</span><br>        <span class="hljs-comment">//参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span><br>        <span class="hljs-comment">//返回值：在该范围内的触发器（得到了对象触发器就可以得到对象的所有信息）</span><br>        colliders = Physics.OverlapCapsule(<br>            Vector3.zero,<br>            Vector3.up,<br>            <span class="hljs-number">1</span>,<br>            <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;UI&quot;</span>),<br>            QueryTriggerInteraction.UseGlobal<br>        );<br><br>        <span class="hljs-comment">//另一个API</span><br>        <span class="hljs-comment">//返回值：碰撞到的碰撞器数量</span><br>        <span class="hljs-comment">//参数：传入一个数组进行存储</span><br>        <span class="hljs-comment">//Physics.OverlapCapsuleNonAlloc</span><br>        <span class="hljs-keyword">if</span> (Physics.OverlapCapsuleNonAlloc(Vector3.zero, Vector3.up, <span class="hljs-number">1</span>, colliders) != <span class="hljs-number">0</span>) &#123; &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="物理系统之射线检测"><a href="#物理系统之射线检测" class="headerlink" title="物理系统之射线检测"></a>物理系统之射线检测</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson23</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 什么是射线检测</span><br>        <span class="hljs-comment">//物理系统中</span><br>        <span class="hljs-comment">//目前我们学习的物体相交判断</span><br>        <span class="hljs-comment">//1.碰撞检测——必备条件 1刚体2碰撞器</span><br>        <span class="hljs-comment">//2.范围检测——必备条件 碰撞器</span><br><br>        <span class="hljs-comment">//如果想要做这样的碰撞检测呢？</span><br>        <span class="hljs-comment">//1.鼠标选择场景上一物体</span><br>        <span class="hljs-comment">//2.FPS射击游戏（无弹道-不产生实际的子弹对象进行移动）</span><br>        <span class="hljs-comment">//等等 需要判断一条线和物体的碰撞情况</span><br><br>        <span class="hljs-comment">//射线检测 就是来解决这些问题的</span><br>        <span class="hljs-comment">//它可以在指定点发射一个指定方向的射线</span><br>        <span class="hljs-comment">//判断该射线与哪些碰撞器相交，得到对应对象</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 射线对象</span><br>        <span class="hljs-comment">//1.3D世界中的射线</span><br>        <span class="hljs-comment">//假设有一条</span><br>        <span class="hljs-comment">//起点为坐标(1,0,0)</span><br>        <span class="hljs-comment">//方向为世界坐标Z轴正方向的射线</span><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//理解参数含义</span><br>        <span class="hljs-comment">//参数一：起点</span><br>        <span class="hljs-comment">//参数二：方向（一定记住 不是两点决定射线方向，第二个参数 直接就代表方向向量）</span><br><br>        <span class="hljs-comment">//目前只是申明了一个射线对象 对于我们来说 没有任何的用处</span><br>        Ray r = <span class="hljs-keyword">new</span> Ray(Vector3.right, Vector3.forward);<br><br>        <span class="hljs-comment">//Ray中的参数</span><br>        print(r.origin); <span class="hljs-comment">//起点</span><br>        print(r.direction); <span class="hljs-comment">//方向</span><br><br>        <span class="hljs-comment">//2.摄像机发射出的射线</span><br>        <span class="hljs-comment">// 得到一条从屏幕位置作为起点</span><br>        <span class="hljs-comment">// 摄像机视口方向为 方向的射线</span><br>        Ray r2 = Camera.main.ScreenPointToRay(Input.mousePosition);<br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//单独的射线对于我们来说没有实际的意义</span><br>        <span class="hljs-comment">//我们需要用它结合物理系统进行射线碰撞判断</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 碰撞检测函数</span><br>        <span class="hljs-comment">//Physics类中提供了很多进行射线检测的静态函数</span><br>        <span class="hljs-comment">//他们有很多种重载类型 我们只需要掌握核心的几个函数 其它函数自然就明白什么意思了</span><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//射线检测也是瞬时的</span><br>        <span class="hljs-comment">//执行代码时进行一次射线检测</span><br><br>        <span class="hljs-comment">//1.最原始的射线检测</span><br>        <span class="hljs-comment">// 准备一条射线</span><br>        Ray r3 = <span class="hljs-keyword">new</span> Ray(Vector3.zero, Vector3.forward);<br>        <span class="hljs-comment">// 进行射线检测 如果碰撞到对象 返回true</span><br>        <span class="hljs-comment">//参数一：射线</span><br>        <span class="hljs-comment">//参数二: 检测的最大距离 超出这个距离不检测</span><br>        <span class="hljs-comment">//参数三：检测指定层级（不填检测所有层）</span><br>        <span class="hljs-comment">//参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span><br>        <span class="hljs-comment">//返回值：bool 当碰撞到对象时 返回 true 没有 返回false</span><br><br>        <span class="hljs-keyword">if</span> (<br>            Physics.Raycast(<br>                r3,<br>                <span class="hljs-number">1000</span>,<br>                <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Monster&quot;</span>),<br>                QueryTriggerInteraction.UseGlobal<br>            )<br>        )<br>        &#123;<br>            print(<span class="hljs-string">&quot;碰撞到了对象&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span><br>        <span class="hljs-comment">//就是把 第一个参数射线 变成了 射线的 两个点 一个起点 一个方向</span><br>        <span class="hljs-keyword">if</span> (<br>            Physics.Raycast(<br>                Vector3.zero,<br>                Vector3.forward,<br>                <span class="hljs-number">1000</span>,<br>                <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Monster&quot;</span>),<br>                QueryTriggerInteraction.UseGlobal<br>            )<br>        )<br>        &#123;<br>            print(<span class="hljs-string">&quot;碰撞到了对象2&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//2.获取相交的单个物体信息</span><br>        <span class="hljs-comment">//物体信息类 RaycastHit</span><br>        RaycastHit hitInfo;<br>        <span class="hljs-comment">//参数一：射线</span><br>        <span class="hljs-comment">//参数二：RaycastHit是结构体 是值类型 Unity会通过out 关键在 在函数内部处理后 得到碰撞数据后返回到该参数中</span><br>        <span class="hljs-comment">//参数三：距离</span><br>        <span class="hljs-comment">//参数四：检测指定层级（不填检测所有层）</span><br>        <span class="hljs-comment">//参数五：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span><br>        <span class="hljs-keyword">if</span> (<br>            Physics.Raycast(<br>                r3,<br>                <span class="hljs-keyword">out</span> hitInfo,<br>                <span class="hljs-number">1000</span>,<br>                <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Monster&quot;</span>),<br>                QueryTriggerInteraction.UseGlobal<br>            )<br>        )<br>        &#123;<br>            print(<span class="hljs-string">&quot;碰撞到了物体 得到了信息&quot;</span>);<br><br>            <span class="hljs-comment">//碰撞器信息</span><br>            print(<span class="hljs-string">&quot;碰撞到物体的名字&quot;</span> + hitInfo.collider.gameObject.name);<br>            <span class="hljs-comment">//碰撞到的点，是碰撞体表面的点</span><br>            print(hitInfo.point);<br>            <span class="hljs-comment">//法线信息</span><br>            print(hitInfo.normal);<br><br>            <span class="hljs-comment">//得到碰撞到对象的位置</span><br>            print(hitInfo.transform.position);<br><br>            <span class="hljs-comment">//得到碰撞到对象 离自己的距离</span><br>            print(hitInfo.distance);<br><br>            <span class="hljs-comment">//RaycastHit 该类 对于我们的意义</span><br>            <span class="hljs-comment">//它不仅可以得到我们碰撞到的对象信息</span><br>            <span class="hljs-comment">//还可以得到一些 碰撞的点 距离 法线等等的信息</span><br>        &#125;<br><br>        <span class="hljs-comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span><br>        <span class="hljs-keyword">if</span> (<br>            Physics.Raycast(<br>                Vector3.zero,<br>                Vector3.forward,<br>                <span class="hljs-keyword">out</span> hitInfo,<br>                <span class="hljs-number">1000</span>,<br>                <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Monster&quot;</span>),<br>                QueryTriggerInteraction.UseGlobal<br>            )<br>        ) &#123; &#125;<br><br>        <span class="hljs-comment">//3.获取相交的多个物体</span><br>        <span class="hljs-comment">//可以得到碰撞到的多个对象</span><br>        <span class="hljs-comment">//如果没有 就是容量为0的数组</span><br>        <span class="hljs-comment">//参数一：射线</span><br>        <span class="hljs-comment">//参数二：距离</span><br>        <span class="hljs-comment">//参数三：检测指定层级（不填检测所有层）</span><br>        <span class="hljs-comment">//参数四：是否忽略触发器 UseGlobal-使用全局设置 Collide-检测触发器 Ignore-忽略触发器 不填使用UseGlobal</span><br>        RaycastHit[] hits = Physics.RaycastAll(<br>            r3,<br>            <span class="hljs-number">1000</span>,<br>            <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Monster&quot;</span>),<br>            QueryTriggerInteraction.UseGlobal<br>        );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; hits.Length; i++)<br>        &#123;<br>            print(<span class="hljs-string">&quot;碰到的所有物体 名字分别是&quot;</span> + hits[i].collider.gameObject.name);<br>        &#125;<br><br>        <span class="hljs-comment">//还有一种重载 不用传入 射线 直接传入起点 和 方向 也可以用于判断</span><br>        <span class="hljs-comment">//之前的参数一射线 通过两个点传入</span><br>        hits = Physics.RaycastAll(<br>            Vector3.zero,<br>            Vector3.forward,<br>            <span class="hljs-number">1000</span>,<br>            <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Monster&quot;</span>),<br>            QueryTriggerInteraction.UseGlobal<br>        );<br><br>        <span class="hljs-comment">//还有一种函数 返回的碰撞的数量 通过out得到数据</span><br>        <span class="hljs-keyword">if</span> (<br>            Physics.RaycastNonAlloc(<br>                r3,<br>                hits,<br>                <span class="hljs-number">1000</span>,<br>                <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Monster&quot;</span>),<br>                QueryTriggerInteraction.UseGlobal<br>            ) &gt; <span class="hljs-number">0</span><br>        ) &#123; &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 使用时注意的问题</span><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//距离、层级两个参数 都是int类型</span><br>        <span class="hljs-comment">//当我们传入参数时 一定要明确传入的参数代表的是距离还是层级</span><br>        <span class="hljs-comment">//举例</span><br>        <span class="hljs-comment">//这样写是错误的 因为第二个参数 代表的是距离 不是层级</span><br>        <span class="hljs-keyword">if</span> (Physics.Raycast(r3, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Monster&quot;</span>))) &#123; &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实践小项目"><a href="#实践小项目" class="headerlink" title="实践小项目"></a>实践小项目</h1><p>![[实践类图.png]]</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.yxtown.com/">游习堂</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VStudio的一些设置</title>
    <link href="/2024/11/18/VStudio%E7%AD%89IDE%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/"/>
    <url>/2024/11/18/VStudio%E7%AD%89IDE%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本人用VStudio和VsCode用的比较多，所以就对他们的配置记录一下吧，如果有其他编译器的，也会记录在这里</p></blockquote><h1 id="VStudio-修改默认的编码格式"><a href="#VStudio-修改默认的编码格式" class="headerlink" title="VStudio 修改默认的编码格式"></a>VStudio 修改默认的编码格式</h1><p><a href="https://editorconfig.org/">EditorConfig官网</a></p><blockquote><p>这个方法只适合单个项目，不是修改VStudio这个软件</p></blockquote><ul><li><p>先进入项目根目录<br><img src="https://s2.loli.net/2024/11/18/UCym9RbG2gpsLew.png" alt="Pasted image 20241118154745.png"></p></li><li><p>创建<code>.deitorconfig</code>文件<br><img src="https://s2.loli.net/2024/11/18/jGYPbsolncAR1Ud.png" alt="Pasted image 20241118154834.png"></p></li><li><p>输入以下内容，然后保存。</p></li><li><p>所有的文件编码格式都会统一变为utf-8，那是不是如果需要统一改成其他的也可以啦。具体以后用到再说吧。之前创建的文件也会被修改为utf-8</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">root</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment"># 所在目录是项目根目录，此目录及子目录下保存的文件都会生效    </span><br> <br><span class="hljs-section">[*]</span>  <span class="hljs-comment"># 对于所有文件</span><br><span class="hljs-attr">indent_style</span> = tab  <span class="hljs-comment"># 缩进风格</span><br><span class="hljs-attr">tab_width</span> = <span class="hljs-number">4</span>  <span class="hljs-comment"># 缩进宽度</span><br><span class="hljs-attr">charset</span> = utf-<span class="hljs-number">8</span>  <span class="hljs-comment"># 文件编码格式</span><br><span class="hljs-attr">end_of_line</span> = crlf  <span class="hljs-comment"># 行尾格式，Windows一般为CRLF，Linux一般为LF，根据需要更改</span><br><span class="hljs-attr">insert_final_newline</span> = <span class="hljs-literal">true</span>   <span class="hljs-comment">#文件结尾添加换行符，以防警告</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/18/3YrKkobfFizZtCO.png" alt="Pasted image 20241118154902.png"></p></li></ul><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/NSJim/article/details/123253659">VS(Visual Studio)更改文件编码</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unity知识整理(一_入门)</title>
    <link href="/2024/11/13/Unity%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%80_%E5%85%A5%E9%97%A8)/"/>
    <url>/2024/11/13/Unity%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%80_%E5%85%A5%E9%97%A8)/</url>
    
    <content type="html"><![CDATA[<h1 id="新建工程和工程文件夹"><a href="#新建工程和工程文件夹" class="headerlink" title="新建工程和工程文件夹"></a>新建工程和工程文件夹</h1><ul><li>如果有其他项目，可以用Add来添加<br><img src="https://s2.loli.net/2024/11/13/haryWDjMFAq1mTk.png" alt="Pasted image 20241113204345.png"><br><img src="https://s2.loli.net/2024/11/13/jOcYQ9Nhq3pPzbr.png" alt="Pasted image 20241113204502.png"></li><li>可以选择已经下载好的版本<br><img src="https://s2.loli.net/2024/11/13/B8A3xaHgCeTVl9M.png" alt="Pasted image 20241113204404.png"></li></ul><p><img src="https://s2.loli.net/2024/11/13/oyXSYNBis5QKR1w.png" alt="Pasted image 20241113205241.png"></p><ul><li><p>添加别人的工程文件<br><img src="https://s2.loli.net/2024/11/13/suMmVWQKt4xLPcz.png" alt="Pasted image 20241113210240.png"><br><img src="https://s2.loli.net/2024/11/13/5B2yaoDiquxGjC1.png" alt="Pasted image 20241113210713.png"></p></li><li><p>这里可以选择打开项目使用的Unity的版本<br><img src="https://s2.loli.net/2024/11/13/AETyPnju9tRXVba.png" alt="Pasted image 20241113210518.png"></p></li></ul><p><img src="https://s2.loli.net/2024/11/13/bVGDMpZedy59rY1.png" alt="Pasted image 20241113210539.png"></p><ul><li>创建后包含的文件夹</li></ul><ol><li><font color="red">Assets：工程资源文件夹（美术资源，脚本等等）</font></li><li>Library：库文件夹（Unity自动生成管理）</li><li>Logs：日志文件夹，记录特殊信息（Unity自动生成管理）</li><li>obj：编译产生中间文件（Unity自动生成管理）</li><li>Packages：包配置信息（Unity自动生成管理）</li><li>ProjectSettings：工程设置信息（Unity自动生成管理）</li></ol><h1 id="Scene和Hierarchy窗口"><a href="#Scene和Hierarchy窗口" class="headerlink" title="Scene和Hierarchy窗口"></a>Scene和Hierarchy窗口</h1><h2 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h2><p><img src="https://s2.loli.net/2024/11/13/PbBmYnULuO45cqV.png" alt="Pasted image 20241113210954.png"></p><p><img src="https://s2.loli.net/2024/11/13/uaXsLOgBKd9e4fG.png" alt="Pasted image 20241113211126.png"></p><h2 id="Hierarchy层级窗口"><a href="#Hierarchy层级窗口" class="headerlink" title="Hierarchy层级窗口"></a>Hierarchy层级窗口</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">F2</span>：对象改名<br><span class="hljs-variable">Ctrl</span><span class="hljs-operator">+</span><span class="hljs-built_in">C</span>：复制<br><span class="hljs-variable">Ctrl</span><span class="hljs-operator">+</span><span class="hljs-variable">V</span>：粘贴<br><span class="hljs-variable">Ctrl</span><span class="hljs-operator">+</span><span class="hljs-built_in">D</span>：克隆一个，等价于复制<span class="hljs-operator">+</span>粘贴<br><span class="hljs-variable">Ctrl</span><span class="hljs-operator">+</span><span class="hljs-variable">Z</span>：撤销上一步<br><span class="hljs-built_in">Delete</span>：删除<br></code></pre></td></tr></table></figure><ul><li>Hierarchy鼠标右键<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Cube</span><span class="hljs-operator">:</span> 正方体<br><span class="hljs-built_in">Sphere</span>：球体<br><span class="hljs-variable">Capsule</span>：胶囊体<br><span class="hljs-built_in">Cylinder</span>：圆柱体<br><span class="hljs-variable">Plane</span>：平面<br><span class="hljs-variable">Quad</span>：面片<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/11/13/l4HagJ92cykNb35.png" alt="Pasted image 20241113211525.png"></li></ul><h2 id="Scene场景窗口"><a href="#Scene场景窗口" class="headerlink" title="Scene场景窗口"></a>Scene场景窗口</h2><p><img src="https://s2.loli.net/2024/11/13/pRm6ABzI1yJw32C.png" alt="Pasted image 20241113212238.png"></p><ul><li><p>着色器（一般选择这个就行）<br><img src="https://s2.loli.net/2024/11/13/4ZKrRpSLMgF5kzN.png" alt="Pasted image 20241113212955.png"></p></li><li><p>网格<br><img src="https://s2.loli.net/2024/11/13/Y3fHTio1NvtKMpG.png" alt="Pasted image 20241113213021.png"></p></li><li><p>着色器+网格<br><img src="https://s2.loli.net/2024/11/13/ak9Ob68Eo7Ai3hf.png" alt="Pasted image 20241113213036.png"></p></li><li><p>3D显示<br><img src="https://s2.loli.net/2024/11/13/jLmFGNJUw5S2O7k.png" alt="Pasted image 20241113213536.png"></p></li><li><p>2D显示<br><img src="https://s2.loli.net/2024/11/13/ylpQqjSKA7rmeTN.png" alt="Pasted image 20241113213601.png"></p></li></ul><p><img src="https://s2.loli.net/2024/11/13/YECS6i3fUoIXvnd.png" alt="Pasted image 20241113214635.png"></p><ul><li>对应的是X，Y，Z</li><li>可以点击有颜色的部分进行切换</li><li>Persp的文字是表示透视，点击后Iso是正交模式</li><li>透视模式是近大远小，Iso是都一样大<br><img src="https://s2.loli.net/2024/11/13/qdRF6aDQZzgcjPX.png" alt="Pasted image 20241113214824.png"></li><li>长按Q键+鼠标左键<ul><li>移动屏幕</li></ul></li><li>长按Alt键+鼠标左键<ul><li>相对于视口中心旋转屏幕</li></ul></li><li>选中物体+F键 或者 Hierarchy层窗口双击物体<ul><li>居中显示物体</li></ul></li><li>Shift+F键<ul><li>物体一直处于窗口中心，盯着物体移动</li></ul></li><li>鼠标右键+移动鼠标<ul><li>旋转视口</li></ul></li><li>鼠标右键+WASD<ul><li>漫游场景</li></ul></li><li>鼠标右键+WASD+Shift<ul><li>快速漫游场景</li></ul></li><li>长按Alt键+鼠标右键+移动鼠标<ul><li>相对屏幕中心拉近或者拉远</li></ul></li><li>鼠标中键滚轮<ul><li>相对屏幕中心拉近或者拉远</li></ul></li><li>鼠标中键按下+移动鼠标<ul><li>平移观察视口</li></ul></li><li>长按Alt键+滚动鼠标中键<ul><li>鼠标指哪就朝哪拉近拉远</li></ul></li><li>Global是相对于整个世界的坐标轴</li><li>Local是相对于物体本身的坐标轴<br><img src="https://s2.loli.net/2024/11/13/XQn8pgkfOetDzIc.png" alt="Pasted image 20241113215900.png"></li><li>选中后是一格一格移动物体</li><li>按住Ctrl，更小格移动物体，可以不用开启下面的这个按钮的<br><img src="https://s2.loli.net/2024/11/13/8dgyeFUOSasMQ1u.png" alt="Pasted image 20241113220426.png"></li></ul><p><img src="https://s2.loli.net/2024/11/13/mNLbG5OQnjVqozg.png" alt="Pasted image 20241113221904.png"></p><h1 id="Game和Project"><a href="#Game和Project" class="headerlink" title="Game和Project"></a>Game和Project</h1><blockquote><p>Game游戏窗口：游戏画面窗口，玩家能看到的画面内容<br>Project工程窗口：工程资源窗口，所有的工程资源都会在该窗口中显示，显示的内容为Assets文件夹中的所有内容</p></blockquote><h2 id="Game游戏窗口"><a href="#Game游戏窗口" class="headerlink" title="Game游戏窗口"></a>Game游戏窗口</h2><ul><li>是摄像机拍摄的内容，如果没有摄像机，就不显示</li></ul><p><img src="https://s2.loli.net/2024/11/13/SNJ4HPIX37BU5g2.png" alt="Pasted image 20241113223403.png"></p><ul><li><p>Free Aspect</p><ul><li>自由选择分辨率<br><img src="https://s2.loli.net/2024/11/13/iwAI2acT1HhMCFU.png" alt="Pasted image 20241113223318.png"><br><img src="https://s2.loli.net/2024/11/13/lWXmb8nHxJVAUFI.png" alt="Pasted image 20241113223900.png"></li></ul></li><li><p>Warn if No Cameras Rendering</p><ul><li>场景中没有摄像机时发出警告</li></ul></li><li><p>Clear Every Frame in Edit Mode</p><ul><li>游戏未播放时，也更新Game窗口，避免显示问题</li></ul></li><li><p>Maximize</p><ul><li>窗口最大化</li></ul></li><li><p>Close Tab</p><ul><li>关闭当前窗口</li></ul></li><li><p>Add Tab</p><ul><li>添加新窗口<br><img src="https://s2.loli.net/2024/11/13/eFqaEvsAlO2KpGM.png" alt="Pasted image 20241113223512.png"></li></ul></li></ul><h2 id="Project工程窗口"><a href="#Project工程窗口" class="headerlink" title="Project工程窗口"></a>Project工程窗口</h2><p><img src="https://s2.loli.net/2024/11/13/z91a83rSluhA2Wk.png" alt="Pasted image 20241113224222.png"></p><p><img src="https://s2.loli.net/2024/11/13/SOqZEaN8e29Lp6W.png" alt="Pasted image 20241113224413.png"></p><p><img src="https://s2.loli.net/2024/11/13/HZLD65sISaez2mp.png" alt="Pasted image 20241113224533.png"></p><h1 id="Inspector和Console窗口"><a href="#Inspector和Console窗口" class="headerlink" title="Inspector和Console窗口"></a>Inspector和Console窗口</h1><blockquote><p>Inspector检查窗口：<br>查看场景中游戏对象关联的C#脚本信息<br>Console控制台窗口:<br>用于查看调试信息的窗口<br>报错、警告、测试打印都可以显示在其中</p></blockquote><h2 id="Inspector检查窗口"><a href="#Inspector检查窗口" class="headerlink" title="Inspector检查窗口"></a>Inspector检查窗口</h2><ul><li><p>这个可以更换颜色，就是对象外面发光的颜色<br><img src="https://s2.loli.net/2024/11/13/NslHxZgOaJdD6uQ.png" alt="Pasted image 20241113232237.png"></p></li><li><p>对象是否激活，不激活就不显示对象了，和隐藏不一样</p></li><li><p>对象名字的修改，或者在对象上（Hierarchy上）进行修改<br><img src="https://s2.loli.net/2024/11/13/JjngtGY8RLekX3E.png" alt="Pasted image 20241113232402.png"></p></li><li><p>对象的标签（小标签）<br><img src="https://s2.loli.net/2024/11/13/SnfqK8RWtDx9IeO.png" alt="Pasted image 20241113232535.png"></p></li><li><p>对象的层级（大标签，同一个层级下可以有很多一样的标签）<br><img src="https://s2.loli.net/2024/11/13/OxcpiSRarHjCwfv.png" alt="Pasted image 20241113232718.png"></p></li><li><p>Transform</p><ul><li>位置信息</li><li>Position<ul><li>位置信息</li></ul></li><li>Rotation<ul><li>角度信息</li></ul></li><li>Scale<ul><li>缩放比例</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/13/R5JI8ugKEd1m9iz.png" alt="Pasted image 20241113232834.png"></p><h2 id="Console窗口"><a href="#Console窗口" class="headerlink" title="Console窗口"></a>Console窗口</h2><ul><li>打开Console窗口</li><li>快捷键<ul><li>Ctrl+Shift+C<br><img src="https://s2.loli.net/2024/11/13/LvIxH2tVW7KiaGS.png" alt="Pasted image 20241113233026.png"></li></ul></li><li>Clear<ul><li>清空控制台</li></ul></li><li>Clear on Play<ul><li>运行时清空</li></ul></li><li>Clear on Build<ul><li>构建时清空，也就是代码编译的时候清空控制台</li></ul></li><li>Collapse<ul><li>相同内容折叠显示</li></ul></li><li>Error Pause<ul><li>报错暂停运行</li></ul></li><li>气泡+!<ul><li>是否显示错误信息</li></ul></li><li>三角+！<ul><li>是否显示警告信息</li></ul></li><li>圆+！<ul><li>是否显示打印信息<br><img src="https://s2.loli.net/2024/11/13/qxDjG7kgORwEzYs.png" alt="Pasted image 20241113233205.png"></li></ul></li></ul><h1 id="工具栏和父子关系"><a href="#工具栏和父子关系" class="headerlink" title="工具栏和父子关系"></a>工具栏和父子关系</h1><p><img src="https://s2.loli.net/2024/11/14/BcG5ZKgpHu1zV4m.png" alt="image.png"></p><ul><li>File<ul><li>新建工程，新建场景，工程打包等等</li></ul></li><li>Edit<ul><li>对象编辑操作相关，工程设置，引擎设置相关</li></ul></li><li>Assets<ul><li>基本等同于Project窗口中右键相关功能</li></ul></li><li>GameObject<ul><li>基本等同于Hierarchy窗口中右键相关功能</li></ul></li><li>Commponent<ul><li>Unity自带的脚本，可以添加各系统中的脚本</li></ul></li><li>Window<ul><li>可以打开Unity各系统核心系统的窗口</li></ul></li><li>Help<ul><li>检查更i性能，查看版本等等功能</li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/14/Kd154oAgMTPOXqE.png" alt="image.png"></p><ul><li><p>换IDE的时候，找到可执行文件就行<br><img src="https://s2.loli.net/2024/11/14/VeUu4PaGt673JrK.png" alt="image.png"></p></li><li><p>编辑器使用中文</p></li><li><p>推荐英文了，改成中文后，需要重新启动项目<br><img src="https://s2.loli.net/2024/11/14/LJmBgYid8FuU1e2.png" alt="image.png"></p></li></ul><p><img src="https://s2.loli.net/2024/11/14/Vn8MfJH12XwebDu.png" alt="image.png"></p><ul><li><p>Edit (编辑)-&gt;Preferences(首选项)-&gt;languages(语言)-&gt;Editor language-&gt;简体中文<br><img src="https://s2.loli.net/2024/11/14/PkXxAINQvVgK3i8.png" alt="image.png"></p></li><li><p>快捷键设置<br><img src="https://s2.loli.net/2024/11/14/pGX1C9wnyKedLrN.png" alt="image.png"></p></li><li><p>设置格子的默认长度和步长<br><img src="https://s2.loli.net/2024/11/14/IWEPQFDaldckpRj.png" alt="image.png"></p></li></ul><p><img src="https://s2.loli.net/2024/11/14/H7fjTteOCyikZaS.png" alt="image.png"></p><ul><li><p>Ctrl+Alt+F</p><ul><li>物体移动到看见的窗口的中心点</li></ul></li><li><p>Ctrl+Shift+F</p><ul><li>能够将物体移动到当前视角</li><li>一般用来设置摄像机<br><img src="https://s2.loli.net/2024/11/14/hJ6tTHzdObELSXZ.png" alt="image.png"></li></ul></li><li><p>有资源商店<br><img src="https://s2.loli.net/2024/11/14/dyL1Pc7Qrnu9vsV.png" alt="image.png"></p></li><li><p>官方文档<br><img src="https://s2.loli.net/2024/11/14/weXQ8v9PURtcCGj.png" alt="image.png"></p></li><li><p><strong>Unity Manual（用户手册）</strong>：</p><ul><li><strong>内容</strong>：主要介绍 Unity 的基本概念、工作流程和各种工具的使用方法。</li><li><strong>用途</strong>：适用于入门和理解 Unity 的核心概念，比如项目设置、界面介绍、物理系统、渲染管道、资源管理、2D&#x2F;3D 工具、UI 系统等。</li><li><strong>示例</strong>：用户可以找到有关如何搭建场景、如何使用 Unity 的图形和音效工具、如何优化游戏的说明。</li><li><strong>适合对象</strong>：对 Unity 整体环境和功能模块有深入了解需求的开发者。</li></ul></li><li><p><strong>Unity Scripting API（脚本 API 文档）</strong>：</p><ul><li><strong>内容</strong>：详细介绍 Unity 的 API，包括所有脚本类、函数、属性等，主要围绕 C# 脚本编写和调用。</li><li><strong>用途</strong>：用于查找编程接口和具体的代码使用示例，特别是在编写脚本、调用 Unity 的内置功能时。</li><li><strong>示例</strong>：包含每个 API 的详细定义、参数说明、代码示例等，帮助开发者正确使用方法、类或属性。</li><li><strong>适合对象</strong>：需要通过代码操控 Unity 功能的开发者，尤其是编写和调试脚本时。</li></ul></li><li><p>构成父子对象</p><ul><li>其中Sphere是父对象</li><li>Cube是子对象</li></ul></li><li><p>子对象会随着父对象的变化而变化</p><ul><li>父对象移动，缩放，旋转，子对象相对应也会一起修改</li></ul></li><li><p>子对象Inspector窗口中Transform信息是相对父对象的</p><ul><li>子对象的Transform中的数据是相对坐标，是相对于父对象的</li></ul></li><li><p>Scene上方 Pivot 和 Global的作用</p><ul><li>Pivot是相对于自己对象</li><li>Center是父对象+子对象的综合的中心结果<br><img src="https://s2.loli.net/2024/11/14/rWCGA4BS8XYvcUl.png" alt="image.png"></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/14/Cw4renEpWHkvLtm.png" alt="image.png"></p><p><img src="https://s2.loli.net/2024/11/14/43ktELRFpGlSeqK.png" alt="image.png"></p><h1 id="反射机制和游戏场景"><a href="#反射机制和游戏场景" class="headerlink" title="反射机制和游戏场景"></a>反射机制和游戏场景</h1><ul><li>创建一个脚本<br><img src="https://s2.loli.net/2024/11/15/nW8KfN632etkzd1.png" alt="image.png"><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NewBehaviourScript</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> sex;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-comment">// 下面是初始化就有的代码</span><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>如何将脚本挂在对象上<br><img src="https://s2.loli.net/2024/11/15/DOtsYPfUmwZvNA3.png" alt="202411151140792.png"></li><li>这里可以看见public变量，并实时修改<br><img src="https://s2.loli.net/2024/11/15/dxCD6K9GbvBpI1Q.png" alt="image.png"></li><li>Scene的本质</li><li>就是一个配置文件<br><img src="https://s2.loli.net/2024/11/15/JLxzvXi5HkFMqTa.png" alt="image.png"></li></ul><p><img src="https://s2.loli.net/2024/11/15/MBuR72CE9frpILy.png" alt="image.png"><br><img src="https://s2.loli.net/2024/11/15/tzLOf3M5egDuX24.png" alt="image.png"></p><h1 id="预设体和资源包的导入导出"><a href="#预设体和资源包的导入导出" class="headerlink" title="预设体和资源包的导入导出"></a>预设体和资源包的导入导出</h1><h2 id="预设体"><a href="#预设体" class="headerlink" title="预设体"></a>预设体</h2><blockquote><p>预设体本质是记录了对象以及对象上的脚本信息</p></blockquote><ul><li><p>创建预设体<br><img src="https://s2.loli.net/2024/11/15/dYlcOw9P6H5pFn4.png" alt="image.png"></p></li><li><p>使用预设体</p></li><li><p>将选中的预设体拖回去就可以了<br><img src="https://s2.loli.net/2024/11/15/nJxYqMP3iDdzK5Q.png" alt="image.png"></p></li><li><p>修改（覆盖原有的预设体）</p></li><li><p>添加<br><img src="https://s2.loli.net/2024/11/15/RBi7XfZmrkKG2AO.png" alt="image.png"></p></li></ul><p><img src="https://s2.loli.net/2024/11/15/z6lEFOmJDaijKvX.png" alt="image.png"></p><ul><li><p>删除（也包含添加）</p></li><li><p>直接删除会弹出这个，点击open Prefab<br><img src="https://s2.loli.net/2024/11/15/UFCN7pSBoOAPRQn.png" alt="open Prefab"></p></li><li><p>会进入这个Prefab设置的界面，这里可以修改，修改后所有对应的预设体都会被修改</p></li><li><p>左上角的<code>&lt;</code>是用来返回Scene设置的<br><img src="https://s2.loli.net/2024/11/15/QMFPXwkEy7LBIvf.png" alt="image.png"></p></li><li><p>点击预设体的Open也能够进入上面的界面<br><img src="https://s2.loli.net/2024/11/15/4r236NRs8aLknBW.png" alt="image.png"></p></li><li><p>如果想要将对象和预设体的关系切断</p></li><li><p>点击这个Unpack</p></li><li><p>Unpack Completely主要用在预设体里面还有预设体的情况</p></li></ul><p><img src="https://s2.loli.net/2024/11/15/73oRFTVNjbM8Imz.png" alt="image.png"></p><p><img src="https://s2.loli.net/2024/11/15/2bDCSY9hqcJRgIv.png" alt="image.png"></p><h2 id="资源包的导入和导出"><a href="#资源包的导入和导出" class="headerlink" title="资源包的导入和导出"></a>资源包的导入和导出</h2><ul><li><p>import 是导入资源</p></li><li><p>export 是导出资源<br><img src="https://s2.loli.net/2024/11/18/FeMDxZXp6P8bN5H.png" alt="Pasted image 20241115123207.png"></p></li><li><p>导出资源</p></li><li><p>include dependencies的意思是会默认把脚本也关联上<br><img src="https://s2.loli.net/2024/11/18/BFcYMf7d168oLVs.png" alt="Pasted image 20241115123324.png"></p></li><li><p>这个就是导出后的Unity包<br><img src="https://s2.loli.net/2024/11/18/wuAWbFVjCNhxeXa.png" alt="Pasted image 20241115123453.png"></p></li><li><p>既然已经导出了资源包，我们把原来的删除</p></li><li><p>试试导入</p></li><li><p>一种方式是将资源包拖入Project中<br><img src="https://s2.loli.net/2024/11/18/7MVmTavb8jKoX6s.png" alt="Pasted image 20241115123631.png"></p></li><li><p>另一种就是右键Import<br><img src="https://s2.loli.net/2024/11/18/wPV2EbhDk4o7aOU.png" alt="Pasted image 20241115123735.png"></p></li></ul><h1 id="脚本基本规则"><a href="#脚本基本规则" class="headerlink" title="脚本基本规则"></a>脚本基本规则</h1><blockquote><ol><li>不在VStudio中创建脚本，统一在Unity中创建脚本</li><li>脚本可以放在Assets文件夹中任何位置，建议在Assets文件夹中创建一个Scripts文件夹，统一管理</li><li>类名和文件名必须一直，不然不能挂载（因为反射机制创建对象，会通过文件名去找Type）</li><li>不要用中文命名（我也不会用）</li><li>没有特殊需求，不用管命名空间</li><li>创建的脚本默认继承MonoBehaviour</li></ol></blockquote><h2 id="MonoBehaviour基类"><a href="#MonoBehaviour基类" class="headerlink" title="MonoBehaviour基类"></a>MonoBehaviour基类</h2><ul><li>继承MonoBehaviour类，一个文件中只能有一个类继承MonoBehaviour类<blockquote><ol><li>创建的脚本默认都继承MonoBehaviour，继承了它才能够挂载在GameObject上</li><li>继承了MonoBehaviour的脚本不能new，只能挂！！！！！！！！可以通过AddComponent()来创建脚本</li><li>继承了MonnBehaviour的脚本不要去写构造函数，因为我们不会去new它，写构造函数没有任何意义</li><li>继承了MonoBehaviour的脚本可以在一个对象上挂多个（如果没有加DisallowMultipleComponent特性)</li><li>继承MonoBehaviour的类也可以再次被继承，遵循面向对象继承多态的规则</li></ol></blockquote></li><li>不继承MonoBehaviour类<blockquote><ol><li>不继承MonoBehaviour的类不能挂载在GameObject上</li><li>不继承MonoBehaviour的类想怎么写怎么写，如果要使用需要自己new</li><li>不继承MonoBehaviour的类一般是单例模式的类(用于管理模块)或者数据结构类 (用于存储数据）</li><li>不继承MonoBehaviour的类不用保留默认出现的几个函数</li></ol></blockquote></li></ul><h2 id="挂载脚本的执行顺序"><a href="#挂载脚本的执行顺序" class="headerlink" title="挂载脚本的执行顺序"></a>挂载脚本的执行顺序</h2><p><img src="https://s2.loli.net/2024/11/18/WCkzVZvOq41PQeN.png" alt="Pasted image 20241116120518.png"></p><p><img src="https://s2.loli.net/2024/11/18/s9QTp3Wj6cOSyXu.png" alt="Pasted image 20241116120547.png"></p><ul><li>选择自己的脚本<br><img src="https://s2.loli.net/2024/11/18/7SC6qg3ODmfa2Ml.png" alt="Pasted image 20241116120600.png"></li><li>按照这个优先度来执行脚本</li><li>比如<code>UnityEngine.UI.ToggleGroup</code>就比<code>NewBehaviourScript</code>先执行</li><li>如果没有设置这个，那脚本执行顺序是不确定的<br><img src="https://s2.loli.net/2024/11/18/sGS5hlQrXPpkbYi.png" alt="Pasted image 20241116120644.png"></li></ul><h2 id="修改脚本默认内容"><a href="#修改脚本默认内容" class="headerlink" title="修改脚本默认内容"></a>修改脚本默认内容</h2><blockquote><p>一般不改</p></blockquote><p><img src="https://s2.loli.net/2024/11/18/R7XMn9vcaBDoU3z.png" alt="Pasted image 20241116120902.png"></p><ul><li>进入这个路径</li><li><code>看具体路径\2020.3.48f1c1\Editor\Data\Resources\ScriptTemplates</code></li><li>修改81那个文件就可以了<br><img src="https://s2.loli.net/2024/11/18/M8V3Ox46lf2othu.png" alt="Pasted image 20241116121408.png"></li></ul><h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><blockquote><p>所有继承MonoBehaviour的脚本，最终会挂载到GameObject游戏对象上<br>生命周期函数，就是该脚本依附的GameObject对象从出生到消亡整个生命周期中<br>会通过反射自动调用的一些特殊函数<br>生命周期函数访问修饰符一般是private和protected。不需要外部自己调用生命周期函数，是Unity自己调用<br>如果脚本依附的对象失活，这些生命周期函数都不会被调用，失活对象第一次从失活-&gt;激活，会调用Awake…等生命周期函数<br>不需要使用到的生命周期函数不要写，因为Unity会调用，有额外的开销</p></blockquote><p><img src="https://s2.loli.net/2024/11/18/vZBf3zcrYDAS5U8.png" alt="Pasted image 20241117105345.png"></p><h2 id="1-对象的初始化"><a href="#1-对象的初始化" class="headerlink" title="1. 对象的初始化"></a>1. <strong>对象的初始化</strong></h2><p>这些方法在脚本挂载的对象被创建时调用：</p><ul><li><code>Awake()</code><ul><li><strong>触发时机</strong>：脚本对应的类实例化后，所有其他对象的初始化之前。</li><li><strong>用途</strong>：初始化变量或引用。即使对象未启用，也会调用。</li><li>只会调用一次，反复激活脚本依附的对象不会二次调用<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Awake called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><code>OnEnable()</code><ul><li><strong>触发时机</strong>：对象或脚本被启用时。</li><li><strong>用途</strong>：每次对象激活时需要执行的逻辑。</li><li>当脚本依附的对象被激活时，都会调用一次，如果脚本在Unity中被失活了，不会调用</li><li>只有脚本时激活的，并且，对象被激活了（包含刚开始实例化对象的那一次）都会调用<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;OnEnable called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><code>Start()</code><ul><li><strong>触发时机</strong>：对象启用后，所有 <code>Awake()</code> 调用完成后第一次更新前。</li><li><strong>用途</strong>：需要在对象启用时执行的初始化逻辑。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Start called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="2-游戏循环更新"><a href="#2-游戏循环更新" class="headerlink" title="2. 游戏循环更新"></a>2. <strong>游戏循环更新</strong></h2><ul><li>下面的三个方法会一直不断调用，循环调用</li></ul><p>这些方法用于处理游戏对象的行为更新：</p><ul><li><p><code>Update()</code></p><ul><li><strong>触发时机</strong>：游戏每帧调用一次。</li><li><strong>用途</strong>：实现逐帧更新的逻辑。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Update called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>LateUpdate()</code></p><ul><li><strong>触发时机</strong>：每帧调用，但在所有 <code>Update()</code> 调用后。</li><li><strong>用途</strong>：用于更新需要依赖其他对象已完成更新的逻辑（如跟随摄像机）。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;LateUpdate called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>FixedUpdate()</code></p><ul><li><strong>触发时机</strong>：每固定时间间隔调用，与物理系统同步。</li><li><strong>用途</strong>：处理物理相关逻辑（如力和速度的应用）。</li><li>Edit-&gt;Project Setting-&gt;Time-&gt;Fixed Timestep<ul><li>修改这个，表示每多少秒调用一次<code>FixedUpdate()</code></li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/18/IP4bQ5ZEu9CUKLr.png" alt="Pasted image 20241117113557.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;FixedUpdate called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="3-暂停或停止时"><a href="#3-暂停或停止时" class="headerlink" title="3. 暂停或停止时"></a>3. <strong>暂停或停止时</strong></h2><h2 id="处理对象被禁用或销毁的阶段：-OnDisable-触发时机：对象或脚本被禁用时，对象被销毁前如果没有失活，会先失活，再销毁。失活了，再删除对象，只会调用OnDestroy-。-用途：释放资源或暂停逻辑。-OnDestroy-触发时机：对象销毁时。-程序中删除对象或程序结束，都会调用OnDestroy-，不论对象是否失活-用途：释放资源或清理逻辑。"><a href="#处理对象被禁用或销毁的阶段：-OnDisable-触发时机：对象或脚本被禁用时，对象被销毁前如果没有失活，会先失活，再销毁。失活了，再删除对象，只会调用OnDestroy-。-用途：释放资源或暂停逻辑。-OnDestroy-触发时机：对象销毁时。-程序中删除对象或程序结束，都会调用OnDestroy-，不论对象是否失活-用途：释放资源或清理逻辑。" class="headerlink" title="处理对象被禁用或销毁的阶段：- OnDisable()    - 触发时机：对象或脚本被禁用时，对象被销毁前如果没有失活，会先失活，再销毁。失活了，再删除对象，只会调用OnDestroy()。    - 用途：释放资源或暂停逻辑。- OnDestroy()    - 触发时机：对象销毁时。        - 程序中删除对象或程序结束，都会调用OnDestroy()，不论对象是否失活    - 用途：释放资源或清理逻辑。"></a>处理对象被禁用或销毁的阶段：<br>- <code>OnDisable()</code><br>    - <strong>触发时机</strong>：对象或脚本被禁用时，对象被销毁前如果没有失活，会先失活，再销毁。失活了，再删除对象，只会调用OnDestroy()。<br>    - <strong>用途</strong>：释放资源或暂停逻辑。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;OnDisable called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>- <code>OnDestroy()</code><br>    - <strong>触发时机</strong>：对象销毁时。<br>        - 程序中删除对象或程序结束，都会调用OnDestroy()，不论对象是否失活<br>    - <strong>用途</strong>：释放资源或清理逻辑。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;OnDestroy called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NewBehaviourScript</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// 当对象（自己这个类对象）被创建时，才会调用该生命周期函数</span><br>    <span class="hljs-comment">// 类似构造函数的存在，可以在一个类对象创建时进行一些初始化操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 在Unity中打印信息的两种方式</span><br>        <span class="hljs-comment">//1. 没有继承MonoBehaviour类的时候</span><br>        <span class="hljs-comment">//Debug.Log(&quot;123&quot;);</span><br>        <span class="hljs-comment">// Debug.LogError(&quot;报错&quot;);</span><br>        <span class="hljs-comment">// Debug.LogWarning(&quot;警告&quot;);</span><br><br>        <span class="hljs-comment">// 继承了MonoBehaviour，有一个线程的方法，可以使用</span><br>        print(<span class="hljs-string">&quot;Awake&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当脚本依附的GameObject对象被激活时调用</span><br>    <span class="hljs-comment">// 当脚本被激活时调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;OnEnable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-comment">// 默认访问修饰符是private</span><br>    <span class="hljs-comment">// 主要作用是初始化信息，相对于Awake要晚一些</span><br>    <span class="hljs-comment">// 在对象进行第一次帧更新之前才会执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;Start&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 主要用于物理更新</span><br>    <span class="hljs-comment">// 它是每一帧执行的，但是和游戏帧不一样</span><br>    <span class="hljs-comment">// 时间间隔可以在Project setting中的Time中设置</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;FixedUpdate&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-comment">// 主要用于处理游戏核心逻辑更新的函数</span><br>    <span class="hljs-comment">// 默认是以最快的游戏帧率运行</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;Update&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 一般这个更新用来处理摄像机的</span><br>    <span class="hljs-comment">// 因为Update()和LateUpdate()之间Unity进行了动画处理，进行动画的更新</span><br>    <span class="hljs-comment">// 如果在Update中处理摄像机，会导致某些内容渲染出错</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;LateUpdate&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当对象失活时调用这个函数</span><br>    <span class="hljs-comment">// 当脚本失活时调用这个函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;OnDisable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 当对象被销毁时调用</span><br>    <span class="hljs-comment">// 销毁前会调用OnDisable()</span><br>    <span class="hljs-comment">// 然后销毁，在程序中删除对象或程序结束，都会调用OnDestroy()</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;OnDestroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-渲染和碰撞"><a href="#4-渲染和碰撞" class="headerlink" title="4. 渲染和碰撞"></a>4. <strong>渲染和碰撞</strong></h2><p>与渲染或物理相关的生命周期函数：</p><ul><li><code>OnGUI()</code><ul><li><strong>触发时机</strong>：每帧用于绘制 UI 元素。</li><li><strong>用途</strong>：处理 GUI 的绘制逻辑。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span><br>&#123;<br>    GUILayout.Label(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><code>OnCollisionEnter(Collision collision)</code>**<ul><li><strong>触发时机</strong>：对象与其他碰撞器发生碰撞时。</li><li><strong>用途</strong>：处理碰撞事件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Collision detected&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><code>OnTriggerEnter(Collider other)</code><ul><li><strong>触发时机</strong>：对象进入触发器时。</li><li><strong>用途</strong>：处理触发器事件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Trigger entered&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="5-其他特殊事件"><a href="#5-其他特殊事件" class="headerlink" title="5. 其他特殊事件"></a>5. <strong>其他特殊事件</strong></h2><h2 id="一些其他常用的生命周期函数：-Reset-触发时机：在组件被添加到对象时调用。-用途：初始化默认值。-OnApplicationQuit-触发时机：游戏退出时。-用途：释放全局资源或保存数据。-OnDrawGizmos-触发时机：在编辑器模式下绘制场景中调试信息。-用途：绘制调试辅助图形。"><a href="#一些其他常用的生命周期函数：-Reset-触发时机：在组件被添加到对象时调用。-用途：初始化默认值。-OnApplicationQuit-触发时机：游戏退出时。-用途：释放全局资源或保存数据。-OnDrawGizmos-触发时机：在编辑器模式下绘制场景中调试信息。-用途：绘制调试辅助图形。" class="headerlink" title="一些其他常用的生命周期函数：- Reset()    - 触发时机：在组件被添加到对象时调用。    - 用途：初始化默认值。- OnApplicationQuit()    - 触发时机：游戏退出时。    - 用途：释放全局资源或保存数据。- OnDrawGizmos()    - 触发时机：在编辑器模式下绘制场景中调试信息。    - 用途：绘制调试辅助图形。"></a>一些其他常用的生命周期函数：<br>- <code>Reset()</code><br>    - <strong>触发时机</strong>：在组件被添加到对象时调用。<br>    - <strong>用途</strong>：初始化默认值。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Reset called&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>- <code>OnApplicationQuit()</code><br>    - <strong>触发时机</strong>：游戏退出时。<br>    - <strong>用途</strong>：释放全局资源或保存数据。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnApplicationQuit</span>()</span><br>&#123;<br>    Debug.Log(<span class="hljs-string">&quot;Application quitting&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><br>- <code>OnDrawGizmos()</code><br>    - <strong>触发时机</strong>：在编辑器模式下绘制场景中调试信息。<br>    - <strong>用途</strong>：绘制调试辅助图形。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnDrawGizmos</span>()</span><br>&#123;<br>    Gizmos.DrawSphere(transform.position, <span class="hljs-number">1f</span>);<br>&#125;<br></code></pre></td></tr></table></figure></h2><h2 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h2><table><thead><tr><th><strong>函数名</strong></th><th><strong>触发时机</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><code>Awake()</code></td><td>对象实例化后</td><td>初始化脚本或依赖引用</td></tr><tr><td><code>OnEnable()</code></td><td>对象启用时</td><td>每次对象激活执行逻辑</td></tr><tr><td><code>Start()</code></td><td>第一次更新前</td><td>延迟初始化逻辑</td></tr><tr><td><code>Update()</code></td><td>每帧调用一次</td><td>逐帧更新逻辑</td></tr><tr><td><code>LateUpdate()</code></td><td>每帧更新后</td><td>依赖其他对象更新的逻辑</td></tr><tr><td><code>FixedUpdate()</code></td><td>固定时间间隔（与物理同步）</td><td>处理物理逻辑</td></tr><tr><td><code>OnDisable()</code></td><td>对象被禁用时</td><td>暂停逻辑或释放资源</td></tr><tr><td><code>OnDestroy()</code></td><td>对象销毁时</td><td>清理资源</td></tr><tr><td><code>OnGUI()</code></td><td>每帧绘制 UI 元素</td><td>GUI 绘制</td></tr><tr><td><code>OnCollisionEnter()</code></td><td>碰撞发生时</td><td>处理碰撞事件</td></tr><tr><td><code>OnTriggerEnter()</code></td><td>进入触发器时</td><td>处理触发事件</td></tr><tr><td><code>Reset()</code></td><td>组件被添加到对象时</td><td>初始化默认值</td></tr><tr><td><code>OnApplicationQuit()</code></td><td>游戏退出时</td><td>保存数据或释放全局资源</td></tr><tr><td><code>OnDrawGizmos()</code></td><td>编辑器模式下绘制调试信息</td><td>调试辅助图形绘制</td></tr></tbody></table><h1 id="Inspector窗口可编辑的变量"><a href="#Inspector窗口可编辑的变量" class="headerlink" title="Inspector窗口可编辑的变量"></a>Inspector窗口可编辑的变量</h1><blockquote><p>也就是如何让自定义的类可以在Inspector窗口上进行显示</p></blockquote><ul><li>Iinspector显示的可编辑内容就是脚本的成员变量</li><li>私有和保护无法显示编辑，公共的可以显示编辑</li></ul><h2 id="如何让私有和保护的也可以被显示编辑"><a href="#如何让私有和保护的也可以被显示编辑" class="headerlink" title="如何让私有和保护的也可以被显示编辑"></a>如何让私有和保护的也可以被显示编辑</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 加上强制序列化字段特性</span><br><span class="hljs-comment">//[SerializeField]</span><br><span class="hljs-comment">// 所谓序列化指将对象保存到文件或者数据库字段中</span><br>[<span class="hljs-meta">SerializeField</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> privateInt;<br>[<span class="hljs-meta">SerializeField</span>]<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">string</span> protectedStr;<br></code></pre></td></tr></table></figure><h2 id="如何让公共的不显示编辑"><a href="#如何让公共的不显示编辑" class="headerlink" title="如何让公共的不显示编辑"></a>如何让公共的不显示编辑</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 在变量前加上特性[HideInInspector]</span><br><span class="hljs-comment">// 可以让公共变量不显示编辑</span><br>[<span class="hljs-meta">HideInInspector</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> publicInt = <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><h2 id="哪些类型不可以被显示编辑"><a href="#哪些类型不可以被显示编辑" class="headerlink" title="哪些类型不可以被显示编辑"></a>哪些类型不可以被显示编辑</h2><ol><li>Dictionary&lt;T,K&gt; dic; &#x2F;&#x2F; 字典不行</li><li>自定义类型</li></ol><h2 id="让自定义类型也可以被显示编辑"><a href="#让自定义类型也可以被显示编辑" class="headerlink" title="让自定义类型也可以被显示编辑"></a>让自定义类型也可以被显示编辑</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 加上序列化特性</span><br><span class="hljs-comment">// [System.Serializable]</span><br><span class="hljs-comment">// 字典怎样都无法显示编辑</span><br><br>[<span class="hljs-meta">System.Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> MyStruct<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> sex;<br>&#125;<br><br><span class="hljs-keyword">public</span> MyStruct myStruct;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/18/ZszNTrc1MVtO3mx.png" alt="Pasted image 20241117122436.png"></p><h2 id="其他的辅助特性"><a href="#其他的辅助特性" class="headerlink" title="其他的辅助特性"></a>其他的辅助特性</h2><ul><li>分组说明特性Header</li><li>他这个其实只是加一行，显示说明，并不是严格意义上的分组<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 分组说明特性Header</span><br><span class="hljs-comment">// 作用：为成员分组</span><br><span class="hljs-comment">// [Header(&quot;分组说明&quot;)]</span><br>[<span class="hljs-meta">Header(<span class="hljs-string">&quot;基础属性&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> sex;<br>[<span class="hljs-meta">Header(<span class="hljs-string">&quot;战斗属性&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> atk;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> def;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2024/11/18/4sqDb2rKchC67YR.png" alt="Pasted image 20241117122736.png"></p><ul><li><p>悬停注释Tooltip</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 悬停注释Tooltip</span><br><span class="hljs-comment">// 为变量添加说明</span><br><span class="hljs-comment">// [Tooltip(&quot;说明内容&quot;)]</span><br>[<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;闪避&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> miss;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/18/X8zRtWCgNTMdZJE.png" alt="Pasted image 20241117123110.png"></p></li><li><p>间隔特性Space()</p></li><li><p>默认间距是 6 像素</p></li><li><p><code>[Space(n)]</code>：在字段上方增加 <strong>n 像素</strong>的垂直间隔。</p></li><li><p><code>[Space]</code>：如果未指定数值，默认间隔为 <strong>6 像素</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 间隔特性Space()</span><br><span class="hljs-comment">// 让两个字段之间出现间隔</span><br><span class="hljs-comment">// [Space()]</span><br>[<span class="hljs-meta">Space</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> crit;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/18/hMylmiRz6OYQvVK.png" alt="Pasted image 20241117123640.png"></p></li><li><p>修饰数值的滑条范围Range</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 修饰数值的滑条范围Range</span><br><span class="hljs-comment">// [Rang(最小值，最大值)]</span><br>[<span class="hljs-meta">Range(0,10)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> luck;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2024/11/18/w76Ms8aloEuiTtB.png" alt="Pasted image 20241117123818.png"></p><ul><li><p>多行显示字符串，默认显示3行<code>[Multiline]</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//多行显示字符串，默认不写参数显示3行</span><br><span class="hljs-comment">//写参数就是对应行</span><br><span class="hljs-comment">// [Multiline]</span><br>[<span class="hljs-meta">Multiline(5)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> tips;<br></code></pre></td></tr></table></figure></li><li><p>如果不加<code>[Multiline]</code>，只能是一行，如果加了，可以多行，但是最初的时候会显示n行<br><img src="https://s2.loli.net/2024/11/18/tVxSpCOUse7Nzi5.png" alt="Pasted image 20241117124128.png"></p></li><li><p>滚动条显示字符串</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//滚动条显示字符串</span><br><span class="hljs-comment">//默认不写参数就是大于等于3行显示滚动条</span><br><span class="hljs-comment">//[TextArea(minLines, maxLines)]</span><br><span class="hljs-comment">//minLines：文本区域的最小行数。</span><br><span class="hljs-comment">//maxLines：文本区域的最大行数。</span><br><span class="hljs-comment">//最少显示3行，最多4行，大于等于4行就显示滚动条</span><br>[<span class="hljs-meta">TextArea(3, 4)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> myLife; <span class="hljs-comment">// 需要为string，否则报错type is not a supported string value</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/18/AvoCHyYui2d7UfJ.png" alt="Pasted image 20241117233101.png"></p></li><li><p>为变量添加快捷方法 ContextMenuItem</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//为变量添加快捷方法 ContextMenuItem</span><br><span class="hljs-comment">//参数1显示按钮名1</span><br><span class="hljs-comment">//参数2方法名不能有参数，返回值随便，因为也不用</span><br><span class="hljs-comment">//[ContextMenuItem(&quot;显示按钮名&quot;,&quot;方法名&quot;)]</span><br>[<span class="hljs-meta">ContextMenuItem(<span class="hljs-string">&quot;重置钱&quot;</span>,<span class="hljs-string">&quot;Test&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> money;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span> &#123;<br>money = <span class="hljs-number">99</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2024/11/18/4DFVXOTZqMC9ymN.png" alt="Pasted image 20241117233743.png"></p><ul><li>为方法添加特性能够在Inspector中执行</li><li>可以在编辑或者运行的时候点击这个哈哈哈哈的按钮，就会执行对应的方法，教程里面说运行的时候没有意义，等以后再说吧<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//为方法添加特性能够在Inspector中执行</span><br><span class="hljs-comment">//[ContextMenu(&quot;测试函数&quot;)]</span><br>[<span class="hljs-meta">ContextMenu(<span class="hljs-string">&quot;哈哈哈哈&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>()</span><br>&#123;<br>print(<span class="hljs-string">&quot;测试方法&quot;</span>);<br>money = <span class="hljs-number">11</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://s2.loli.net/2024/11/18/4BDm3OTXjAeu95C.png" alt="Pasted image 20241117234227.png"></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>Inspector窗口中的变量关联的就是对象的成员变量，运行时改变他们就是在改变成员变量</li><li>拖曳到Gameobject对象后再改变脚本中变量默认值界面上不会改变</li><li>运行中修改的信息不会保存</li><li>如果需要记录运行中脚本的值，可以先Copy Component，再停止运行，使用Paste Component Values</li><li>Paste Component As New的意思是在本对象上再复制一个脚本，值和原脚本一样，但是如果是运行中用这个，结束运行后会丢失这个复制的脚本<br><img src="https://s2.loli.net/2024/11/18/mbY5K8Ehq6RcTUW.png" alt="Pasted image 20241117234607.png"></li></ol><h1 id="MonoBehaviour中的重要内容"><a href="#MonoBehaviour中的重要内容" class="headerlink" title="MonoBehaviour中的重要内容"></a>MonoBehaviour中的重要内容</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NewBehaviourScript</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 重要成员</span><br>        <span class="hljs-comment">// 1. 获取依附的GameObject对象</span><br>        print(<span class="hljs-keyword">this</span>.gameObject);<br>        <span class="hljs-comment">// 2. 获得依附的GameObject的位置信息，三种方法，是等价的，一般直接用transform</span><br>        print(<span class="hljs-keyword">this</span>.transform.position); <span class="hljs-comment">// 位置</span><br>        print(<span class="hljs-keyword">this</span>.gameObject.transform.eulerAngles); <span class="hljs-comment">// 欧拉角</span><br>        print(transform.lossyScale); <span class="hljs-comment">// 缩放比例</span><br>        <span class="hljs-comment">// 3. 获取脚本是否激活</span><br>        <span class="hljs-comment">// 其实如果脚本本就是不激活的，那么就不会调用这个Start()生命周期函数了</span><br>        print(<span class="hljs-keyword">this</span>.enabled); <span class="hljs-comment">// 一定是True</span><br>        <span class="hljs-keyword">this</span>.enabled = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 不过可以通过反射得到脚本，控制其激活和失活</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 重要方法</span><br>        <span class="hljs-comment">// 1. 得到同一个对象下的其他脚本</span><br>        <span class="hljs-comment">// 根据脚本名获取类对象，如果获取失败，表示没有对应的脚本，返回NULL</span><br>        Lesson3_Test t = <span class="hljs-keyword">this</span>.GetComponent(<span class="hljs-string">&quot;Lesson3_Test&quot;</span>) <span class="hljs-keyword">as</span> Lesson3_Test;<br>        print(t);<br>        <span class="hljs-comment">// 根据Type获取</span><br>        t = <span class="hljs-keyword">this</span>.GetComponent(<span class="hljs-keyword">typeof</span>(Lesson3_Test)) <span class="hljs-keyword">as</span> Lesson3_Test;<br>        print(t);<br>        <span class="hljs-comment">// 用的最多</span><br>        <span class="hljs-comment">// 根据泛型获取</span><br>        t = <span class="hljs-keyword">this</span>.GetComponent&lt;Lesson3_Test&gt;();<br>        print(t);<br>        <span class="hljs-comment">// 所以只要能够获取场景中别的对象或者对象依附的脚本</span><br>        <span class="hljs-comment">// 就能够获取到它的所有信息，依附的对象就是gameObject，脚本用GetComponent()</span><br><br>        <span class="hljs-comment">// 2. 得到自己挂载的多个脚本</span><br>        <span class="hljs-comment">// 这里得到的只能是Lesson3_Test类的脚本，其他的得不到</span><br>        Lesson3_Test[] array = <span class="hljs-keyword">this</span>.GetComponents&lt;Lesson3_Test&gt;();<br>        print(array.Length);<br>        <span class="hljs-comment">// List&lt;T&gt; 是引用类型，在方法内部修改它的内容会直接反映到调用方</span><br>        List&lt;Lesson3_Test&gt; list = <span class="hljs-keyword">new</span> List&lt;Lesson3_Test&gt;();<br>        <span class="hljs-keyword">this</span>.GetComponents&lt;Lesson3_Test&gt;(list);<br>        print(list.Count);<br>        MonoBehaviour[] allScripts = <span class="hljs-keyword">this</span>.GetComponents&lt;MonoBehaviour&gt;();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> script <span class="hljs-keyword">in</span> allScripts)<br>        &#123;<br>            Debug.Log(<span class="hljs-string">$&quot;Script Name: <span class="hljs-subst">&#123;script.GetType().Name&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 得到子对象挂载的脚本（默认也会找自己身上是否挂载此脚本）</span><br>        <span class="hljs-comment">// 先找自己对象上是否挂载了这个脚本，如果没有，再找子对象，直到找到了一个或者全部子对象都找完了</span><br>        <span class="hljs-comment">// 参数：默认是false，表示不寻找失活的子对象上的脚本</span><br>        <span class="hljs-comment">// true，表示会寻找失活的子对象上的脚本</span><br>        t = <span class="hljs-keyword">this</span>.GetComponentInChildren&lt;Lesson3_Test&gt;();<br>        print(t);<br><br>        <span class="hljs-comment">// 得到子对象挂载的所有指定脚本（默认也会找自己身上是否挂载此脚本）</span><br>        Lesson3_Test[] lts = <span class="hljs-keyword">this</span>.GetComponentsInChildren&lt;Lesson3_Test&gt;(<span class="hljs-literal">true</span>);<br>        print(lts.Length);<br>        List&lt;Lesson3_Test&gt; list2 = <span class="hljs-keyword">new</span> List&lt;Lesson3_Test&gt;();<br>        <span class="hljs-keyword">this</span>.GetComponentsInChildren&lt;Lesson3_Test&gt;(<span class="hljs-literal">true</span>, list2);<br>        print(list2.Count);<br><br>        <span class="hljs-comment">// 4. 得到父对象挂载的脚本（默认也会找自己身上是否挂载此脚本）</span><br>        <span class="hljs-comment">// 这里是如果父对象失活了，子对象全部都会失活</span><br>        <span class="hljs-comment">// 所以没有参数，先找离自己最近的父对象，如果没找到，再找更远的父对象，找到一个就行了</span><br>        t = <span class="hljs-keyword">this</span>.GetComponentInParent&lt;Lesson3_Test&gt;();<br>        print(t);<br>        lts = <span class="hljs-keyword">this</span>.GetComponentsInParent&lt;Lesson3_Test&gt;(<span class="hljs-literal">true</span>);<br>        print(lts.Length);<br>        <span class="hljs-keyword">this</span>.GetComponentsInParent&lt;Lesson3_Test&gt;(<span class="hljs-literal">true</span>, list2);<br>        print(list2.Count);<br><br>        <span class="hljs-comment">// 5. 尝试获取脚本</span><br>        Lesson3_Test l3t;<br>        <span class="hljs-comment">// 提供一个更加安全的，获取单个脚本的方法，如果有，返回true，否则为false</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.TryGetComponent&lt;Lesson3_Test&gt;(<span class="hljs-keyword">out</span> l3t))<br>        &#123;<br>            <span class="hljs-comment">// 逻辑处理</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-comment">// 就是没有这个脚本了</span><br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="GameObject的成员变量"><a href="#GameObject的成员变量" class="headerlink" title="GameObject的成员变量"></a>GameObject的成员变量</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson4</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">//准备用来克隆的对象</span><br>    <span class="hljs-comment">//1.直接是场景上的某个对象</span><br>    <span class="hljs-comment">//2.可以是一个预设体对象</span><br>    <span class="hljs-keyword">public</span> GameObject myObj;<br><br>    <span class="hljs-keyword">public</span> GameObject myObj2;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 GameObject中的成员变量</span><br>        <span class="hljs-comment">//名字</span><br>        print(<span class="hljs-keyword">this</span>.gameObject.name);<br>        <span class="hljs-keyword">this</span>.gameObject.name = <span class="hljs-string">&quot;Lesson4wing2791改名&quot;</span>;<br>        print(<span class="hljs-keyword">this</span>.gameObject.name);<br>        <span class="hljs-comment">//是否激活</span><br>        print(<span class="hljs-keyword">this</span>.gameObject.activeSelf);<br>        <span class="hljs-comment">//是否是静态</span><br>        print(<span class="hljs-keyword">this</span>.gameObject.isStatic);<br>        <span class="hljs-comment">//层级，对象身上的Layer索引</span><br>        print(<span class="hljs-keyword">this</span>.gameObject.layer);<br>        <span class="hljs-comment">//层级，对象身上的Layer名字</span><br>        print(LayerMask.LayerToName(<span class="hljs-keyword">this</span>.gameObject.layer));<br>        <span class="hljs-comment">//标签，对象上的tag</span><br>        print(<span class="hljs-keyword">this</span>.gameObject.tag);<br>        <span class="hljs-comment">//this.transform，通过Mono去得到的依附对象的GameObject的位置信息</span><br>        <span class="hljs-comment">//两者信息是一样，都是依附的GameObject的位置信息</span><br>        <span class="hljs-comment">// 输出的信息会保留一位小数</span><br>        print(<span class="hljs-keyword">this</span>.gameObject.transform.position);<br>        <span class="hljs-comment">// 表示保留 7 位小数</span><br>        print(<span class="hljs-keyword">this</span>.gameObject.transform.position.ToString(<span class="hljs-string">&quot;F7&quot;</span>));<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 GameObject中的静态方法</span><br>        <span class="hljs-comment">//创建自带几何体</span><br>        <span class="hljs-comment">//只要得到了GameObject对象,就可以得到它身上挂载的任何脚本信息</span><br>        <span class="hljs-comment">//通过obj.GetComponent&lt;&gt;()来获取脚本信息</span><br>        GameObject obj = GameObject.CreatePrimitive(PrimitiveType.Cube);<br>        obj.name = <span class="hljs-string">&quot;wing2791创建的立方体&quot;</span>;<br><br>        <span class="hljs-comment">//查找对象相关的知识</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 查找单个对象</span><br>        <span class="hljs-comment">//两种找单个对象的共同点:</span><br>        <span class="hljs-comment">//1.无法找到失活的对象的</span><br>        <span class="hljs-comment">//  只能找到激活的对象</span><br><br>        <span class="hljs-comment">//2.如果场景中存在多个满足条件的对象</span><br>        <span class="hljs-comment">//  我们无法准确确定找到的是谁</span><br><br>        <span class="hljs-comment">//查找单个对象</span><br>        <span class="hljs-comment">//通过对象名查找</span><br>        <span class="hljs-comment">//查找效率低下,因为会在场景中的所有对象去查找</span><br>        <span class="hljs-comment">//没有找到返回null</span><br>        GameObject obj2 = GameObject.Find(<span class="hljs-string">&quot;wing2791&quot;</span>);<br>        <span class="hljs-keyword">if</span> (obj2 != <span class="hljs-literal">null</span>)<br>        &#123;<br>            print(obj2.name);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            print(<span class="hljs-string">&quot;没有找到对应对象&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//通过tag来查找对象</span><br>        <span class="hljs-comment">//GameObject obj3 = GameObject.FindWithTag(&quot;Player&quot;);</span><br>        <span class="hljs-comment">//该方法和上面这个方法 效果一样 只是名字不一样而已</span><br>        <span class="hljs-comment">// 如果Tag不存在，UnityException: Tag: UI is not defined.</span><br>        <span class="hljs-comment">// 在 Unity 中，GameObject.FindGameObjectWithTag(&quot;Untagged&quot;) 不会返回任何 GameObject，因为 Unity 的标签系统中不存在 &quot;Untagged&quot; 作为一个可用的查找标签。</span><br>        GameObject obj3 = GameObject.FindGameObjectWithTag(<span class="hljs-string">&quot;Respawn&quot;</span>);<br>        <span class="hljs-keyword">if</span> (obj3 != <span class="hljs-literal">null</span>)<br>        &#123;<br>            print(<span class="hljs-string">&quot;根据tag找的对象&quot;</span> + obj3.name);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            print(<span class="hljs-string">&quot;根据tag没有找到对应对象&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//得到某一个单个对象 目前有2种方式了</span><br>        <span class="hljs-comment">//1.是public从外部面板拖 进行关联</span><br>        <span class="hljs-comment">//2.通过API去找</span><br><br>        <span class="hljs-comment">//找到场景中挂载某一个脚本的对象</span><br>        <span class="hljs-comment">//效率更低，上面的GameObject.Find 和FindWithTag只是遍历对象</span><br>        <span class="hljs-comment">//此方法不仅要遍历对象，还要遍历对象上挂载的脚本</span><br>        Lesson4 o = GameObject.FindObjectOfType&lt;Lesson4&gt;();<br>        print(o.gameObject.name);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 查找多个对象</span><br>        <span class="hljs-comment">//查找多个对象</span><br>        <span class="hljs-comment">//只能是通过tag去找多个对象，没有方法是通过名字查找多个对象</span><br><br>        <span class="hljs-comment">//通过tag找到多个对象</span><br>        <span class="hljs-comment">//只能找到激活对象，无法找到失活对象</span><br>        GameObject[] objs = GameObject.FindGameObjectsWithTag(<span class="hljs-string">&quot;Player&quot;</span>);<br>        print(<span class="hljs-string">&quot;找到tag为Player对象的个数&quot;</span> + objs.Length);<br><br>        <span class="hljs-comment">//还有几个查找对象相关是用的比较少的方法，是GameObject父类Object提供的方法</span><br>        <span class="hljs-comment">//Unity中的Object和C#中的万物之父的区别</span><br>        <span class="hljs-comment">//Unity里面的Object不是指的万物之父object</span><br>        <span class="hljs-comment">//Unity里的Object命名空间在UnityEngine中的Object类是集成万物之父的一个自定义类</span><br>        <span class="hljs-comment">//C#中的Object命名空间是在System中的</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 实例化对象</span><br>        <span class="hljs-comment">//实例化对象（克隆对象）</span><br>        <span class="hljs-comment">//根据一个GameObject对象，创建出一个和它一模一样的对象</span><br>        GameObject obj5 = GameObject.Instantiate(myObj);<br>        <span class="hljs-comment">//如果继承了MonoBehavior，可以不用写GameObject一样能使用</span><br>        <span class="hljs-comment">//因为该方法是Unity里面的Object基类提供的，MonoBehaviour也是继承了Unity中的Object基类</span><br>        <span class="hljs-comment">//本来就有，可以直接用</span><br>        <span class="hljs-comment">//Instantiate(myObj);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 删除对象</span><br>        <span class="hljs-comment">//删除对象</span><br>        GameObject.Destroy(myObj2);<br>        <span class="hljs-comment">//第一个参数：表示删除的对象</span><br>        <span class="hljs-comment">//第二个参数：表示延迟时间删除（秒）</span><br>        GameObject.Destroy(obj5, <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">//Destroy不仅可以删除对象 还可以删除脚本，不过停止运行后，脚本还会恢复</span><br>        <span class="hljs-comment">//GameObject.Destroy(this);</span><br><br>        <span class="hljs-comment">//删除对象有两种作用</span><br>        <span class="hljs-comment">//1.删除指定的一个游戏对象</span><br>        <span class="hljs-comment">//2.删除一个指定的脚本对象</span><br>        <span class="hljs-comment">//注意：Destroy方法不会马上移除对象，只是给这个对象加了一个移除标识</span><br>        <span class="hljs-comment">//     一般情况下 它会在下一帧时把这个对象移除并从内存中移除</span><br><br>        <span class="hljs-comment">//如果没有特殊需求，就是一定要马上移除一个对象的话</span><br>        <span class="hljs-comment">//建议使用上面的 Destroy方法，因为是异步的，降低卡顿的几率</span><br>        <span class="hljs-comment">//下面这个方法 是立即把对象从内存中移除了</span><br>        <span class="hljs-comment">//GameObject.DestroyImmediate(myObj);</span><br><br>        <span class="hljs-comment">//如果是继承MonoBehavior的类 不用写GameObject</span><br>        <span class="hljs-comment">//Destroy(myObj2);</span><br>        <span class="hljs-comment">//DestroyImmediate(myObj);</span><br><br>        <span class="hljs-comment">//过场景不移除</span><br>        <span class="hljs-comment">//默认情况在切换场景时（Application.LoadLevel(&quot;SceneName&quot;);、SceneManager.LoadScene(&quot;SceneName&quot;);）</span><br>        <span class="hljs-comment">//场景中对象都会被自动删除掉</span><br>        <span class="hljs-comment">//如果你希望某个对象过场景不被移除（卸载）</span><br>        <span class="hljs-comment">//不想谁过场景被移除就传谁</span><br>        <span class="hljs-comment">//一般都是传脚本依附的GameObject对象</span><br>        <span class="hljs-comment">//下自己依附的GameObject对象 过场景不被删除</span><br>        GameObject.DontDestroyOnLoad(<span class="hljs-keyword">this</span>.gameObject);<br>        <span class="hljs-comment">//如果继承MOnoBehavior也可以直接写</span><br>        <span class="hljs-comment">//DontDestroyOnLoad(this.gameObject);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 GameObject中的成员方法</span><br>        <span class="hljs-comment">//创建空物体</span><br>        <span class="hljs-comment">//new一个GameObject就是在创建一个空物体</span><br>        GameObject obj6 = <span class="hljs-keyword">new</span> GameObject();<br>        GameObject obj7 = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;wing2791创建的空物体&quot;</span>);<br>        <span class="hljs-comment">// 加了脚本以后,会产生一个对象，会运行对象上的脚本</span><br>        <span class="hljs-comment">// 但是呢，如果脚本依附的对象失活了，这个脚本也不会运行，下面的代码是让对象失活</span><br>        <span class="hljs-comment">// 所以Lesson2和Lesson1没有被运行</span><br>        <span class="hljs-comment">// 实际意思是，先把这个Lesson4脚本运行完，如果有对象创建并且激活了，再运行上面的脚本</span><br>        GameObject obj8 = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;顺便加脚本的空物体&quot;</span>, <span class="hljs-keyword">typeof</span>(Lesson2), <span class="hljs-keyword">typeof</span>(Lesson1));<br><br>        <span class="hljs-comment">//为对象添加脚本</span><br>        <span class="hljs-comment">//继承MonoBehaviour的脚本是不能new</span><br>        <span class="hljs-comment">//如果想要动态的添加继承MonoBehaviour的脚本 在某一个对象上</span><br>        <span class="hljs-comment">//直接使用GameObject提供的方法即可</span><br>        Lesson1 les1 = obj6.AddComponent(<span class="hljs-keyword">typeof</span>(Lesson1)) <span class="hljs-keyword">as</span> Lesson1;<br>        <span class="hljs-comment">//用泛型更方便</span><br>        Lesson2 les2 = obj6.AddComponent&lt;Lesson2&gt;();<br>        <span class="hljs-comment">//得到的返回值是脚本信息</span><br>        <span class="hljs-comment">//得到脚本的成员方法和继承Mono的类得到脚本的方法一模一样</span><br><br>        <span class="hljs-comment">//标签比较</span><br>        <span class="hljs-comment">//下面两种比较的方法 是一样的</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.gameObject.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>))<br>        &#123;<br>            print(<span class="hljs-string">&quot;对象的标签 是 Player&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.gameObject.tag == <span class="hljs-string">&quot;Player&quot;</span>)<br>        &#123;<br>            print(<span class="hljs-string">&quot;对象的标签 是 Player&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//设置激活失活</span><br>        <span class="hljs-comment">//false 失活</span><br>        <span class="hljs-comment">//true 激活</span><br>        obj6.SetActive(<span class="hljs-literal">false</span>);<br>        obj7.SetActive(<span class="hljs-literal">false</span>);<br>        obj8.SetActive(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">//次要的成员方法，了解即可，不建议使用</span><br>        <span class="hljs-comment">//下面讲的方法 都不建议大家使用，效率比较低</span><br>        <span class="hljs-comment">//通过广播或者发送消息的形式让自己或者别人执行某些行为方法</span><br><br>        <span class="hljs-comment">//通知自己执行什么行为</span><br>        <span class="hljs-comment">//命令自己去执行这个TestFun这个函数 会在自己身上挂在的所有脚本去找这个名字的函数</span><br>        <span class="hljs-comment">//找到自己身上所有的脚本有这个名字的函数去执行</span><br>        <span class="hljs-comment">//意思是只要this.gameObject中的脚本中出现了TestFun的函数，都会执行，不管是哪个类</span><br>        <span class="hljs-comment">// 当然，只是执行脚本文件名一样的类，如果脚本中有其他的类，不去执行，反射也找不到啊</span><br>        <span class="hljs-keyword">this</span>.gameObject.SendMessage(<span class="hljs-string">&quot;TestFun&quot;</span>);<br>        <span class="hljs-keyword">this</span>.gameObject.SendMessage(<span class="hljs-string">&quot;TestFun2&quot;</span>, <span class="hljs-number">199</span>);<br><br>        <span class="hljs-comment">//广播行为 让自己和自己的子对象执行</span><br>        <span class="hljs-comment">//this.gameObject.BroadcastMessage(&quot;函数名&quot;);</span><br><br>        <span class="hljs-comment">//向父对象和自己发送消息 并执行</span><br>        <span class="hljs-comment">//this.gameObject.SendMessageUpwards(&quot;函数名&quot;);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestFun</span>()</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;Lesson4的TestFun&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TestFun2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span><br>    &#123;<br>        print(<span class="hljs-string">&quot;Lesson4的TestFun2&quot;</span> + a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Time知识点"><a href="#Time知识点" class="headerlink" title="Time知识点"></a>Time知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson5</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> Time相关内容主要用来干啥</span><br>        <span class="hljs-comment">//时间相关内容 主要 用于游戏中参与位移、记时、时间暂停等</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 时间缩放比例</span><br>        <span class="hljs-comment">//时间停止</span><br>        <span class="hljs-comment">//Time.timeScale = 0;</span><br>        <span class="hljs-comment">//回复正常，默认</span><br>        <span class="hljs-comment">//Time.timeScale = 1;</span><br>        <span class="hljs-comment">//2倍速</span><br>        <span class="hljs-comment">//Time.timeScale = 2;</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 帧间隔时间</span><br>        <span class="hljs-comment">//帧间隔时间 主要是用来计算位移</span><br>        <span class="hljs-comment">//路程 = 时间*速度</span><br>        <span class="hljs-comment">//根据需求选择参与计算的间隔时间</span><br>        <span class="hljs-comment">//如果希望游戏暂停时就不动的，那就使用deltaTime</span><br>        <span class="hljs-comment">//如果希望不受暂停影响unscaledDeltaTime</span><br><br>        <span class="hljs-comment">//帧间隔时间：最近的一帧用了多长时间（秒），如果是第一帧，那固定是0.02s</span><br>        <span class="hljs-comment">// 它是在当前帧的 Update() 被调用时，和上一帧的 Update() 之间的时间差</span><br>        <span class="hljs-comment">//受scale影响，也就是实际计算的时候会乘上这个Time.timeScale</span><br>        <span class="hljs-comment">//print(&quot;帧间隔时间&quot; + Time.deltaTime);</span><br>        <span class="hljs-comment">//不受scale影响的帧间隔时间</span><br>        <span class="hljs-comment">//print(&quot;不受scale影响的帧间隔时间&quot; + Time.unscaledDeltaTime);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 游戏开始到现在的时间</span><br>        <span class="hljs-comment">//单机游戏中计时，从游戏开始到现在的时间</span><br>        <span class="hljs-comment">//受scale影响</span><br>        <span class="hljs-comment">//print(&quot;游戏开始到现在的时间:&quot; + Time.time);</span><br>        <span class="hljs-comment">//不受scale影响</span><br>        <span class="hljs-comment">//print(&quot;不受scale影响的游戏开始到现在的时间:&quot; + Time.unscaledTime);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点五 帧数</span><br>        <span class="hljs-comment">// 一帧中，是多个脚本的多个Update在运行</span><br>        <span class="hljs-comment">//从开始到现在游戏跑了多少帧(次循环)</span><br>        print(Time.frameCount);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 物理帧间隔时间 FixedUpdate</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//受scale影响</span><br>        <span class="hljs-comment">//print(Time.fixedDeltaTime);</span><br>        <span class="hljs-comment">//不受scale影响</span><br>        <span class="hljs-comment">//print(Time.fixedUnscaledDeltaTime);</span><br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h1><h2 id="Vector3基础和位置相关知识点"><a href="#Vector3基础和位置相关知识点" class="headerlink" title="Vector3基础和位置相关知识点"></a>Vector3基础和位置相关知识点</h2><p><img src="https://s2.loli.net/2024/11/18/xIedDGX8Z6mNMw7.png" alt="Pasted image 20241118160300.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson6</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> Transform主要用来干嘛？</span><br>        <span class="hljs-comment">//游戏对象（GameObject）位移、旋转、缩放、父子关系、坐标转换等相关操作都由它处理</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 必备知识点 Vector3基础</span><br>        <span class="hljs-comment">//Vector3主要是用来表示三维坐标系中的 一个点 或者一个向量</span><br>        <span class="hljs-comment">//申明</span><br>        Vector3 v = <span class="hljs-keyword">new</span> Vector3();<br>        v.x = <span class="hljs-number">10</span>;<br>        v.y = <span class="hljs-number">10</span>;<br>        v.z = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//只传xy 默认z是0</span><br>        Vector3 v2 = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//一步到位</span><br>        Vector3 v3 = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 默认(0,0,0)</span><br>        Vector3 v4;<br>        v4.x = <span class="hljs-number">10</span>;<br>        v4.y = <span class="hljs-number">10</span>;<br>        v4.z = <span class="hljs-number">10</span>;<br><br>        <span class="hljs-comment">//Vector的基本计算</span><br>        <span class="hljs-comment">// + - * /</span><br>        Vector3 v1 = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        Vector3 v12 = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 对应用x+或者-x.....</span><br>        print(v1 + v12); <span class="hljs-comment">// (3,3,3)</span><br>        print(v1 - v12); <span class="hljs-comment">// (-1,-1,-1)</span><br><br>        print(v1 * <span class="hljs-number">10</span>); <span class="hljs-comment">// (10,10,10)</span><br>        print(v12 / <span class="hljs-number">2</span>); <span class="hljs-comment">// (1,1,1)</span><br><br>        <span class="hljs-comment">//常用</span><br>        <span class="hljs-comment">// 右边 x</span><br>        <span class="hljs-comment">// 上边 y</span><br>        <span class="hljs-comment">// 前边 z</span><br>        print(Vector3.zero); <span class="hljs-comment">// (0, 0, 0)</span><br>        print(Vector3.right); <span class="hljs-comment">// (1, 0, 0)</span><br>        print(Vector3.left); <span class="hljs-comment">// (-1, 0, 0)</span><br>        print(Vector3.forward); <span class="hljs-comment">// (0, 0, 1)</span><br>        print(Vector3.back); <span class="hljs-comment">// (0, 0, -1)</span><br>        print(Vector3.up); <span class="hljs-comment">// (0, 1, 0)</span><br>        print(Vector3.down); <span class="hljs-comment">// (0, -1, 0)</span><br><br>        <span class="hljs-comment">//常用的一个方法</span><br>        <span class="hljs-comment">//计算两个点之间的距离的方法</span><br>        print(Vector3.Distance(v1, v12));<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 位置</span><br>        <span class="hljs-comment">//相对世界坐标系，也就是绝对位置，如果这个对象是子对象，Unity中显示的是相对父对象的相对位置</span><br>        <span class="hljs-comment">//this.gameObject.transform // 这个脚本依附的对象的位置信息</span><br>        <span class="hljs-comment">//position的位置是相对于世界坐标系的原点的位置，可能和面板上显示的是不一样的</span><br>        <span class="hljs-comment">//因为如果对象有父子关系 并且父对象位置，不在原点，那么和面板上肯定就是不一样的</span><br>        print(<span class="hljs-keyword">this</span>.transform.position);<br><br>        <span class="hljs-comment">//相对父对象</span><br>        <span class="hljs-comment">//这两个坐标 对于我们来说 很重要 如果你想以面板坐标为准来进行位置设置</span><br>        <span class="hljs-comment">//那一定是通过localPosition来进行设置的</span><br>        print(<span class="hljs-keyword">this</span>.transform.localPosition);<br><br>        <span class="hljs-comment">//他们两个 可能出现是一样的情况</span><br>        <span class="hljs-comment">//1.父对象的坐标 就是世界坐标系原点0,0,0</span><br>        <span class="hljs-comment">//2.对象没有父对象</span><br><br>        <span class="hljs-comment">//注意：位置的赋值不能直接改变x，y，z 只能整体改变</span><br>        <span class="hljs-comment">//不能单独改 x y z某一个值</span><br>        <span class="hljs-comment">//this.transform.position.x = 10; // 报错</span><br>        <span class="hljs-keyword">this</span>.transform.position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">this</span>.transform.localPosition = Vector3.up * <span class="hljs-number">10</span>;<br><br>        <span class="hljs-comment">//如果只想改一个值x y和z要保持原有坐标一致</span><br>        <span class="hljs-comment">//1.直接赋值</span><br>        <span class="hljs-keyword">this</span>.transform.position = <span class="hljs-keyword">new</span> Vector3(<br>            <span class="hljs-number">19</span>,<br>            <span class="hljs-keyword">this</span>.transform.position.y,<br>            <span class="hljs-keyword">this</span>.transform.position.z<br>        );<br>        <span class="hljs-comment">//2.先取出来 再赋值</span><br>        <span class="hljs-comment">//虽然不能直接改 transform的 xyz 但是 Vector3是可以直接改 xyz的</span><br>        <span class="hljs-comment">//所以可以先取出来改Vector3 再重新赋值</span><br>        Vector3 vPos = <span class="hljs-keyword">this</span>.transform.localPosition;<br>        vPos.x = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">this</span>.transform.localPosition = vPos;<br><br>        <span class="hljs-comment">//如果你想得到对象当前的 一个朝向</span><br>        <span class="hljs-comment">//那么就是通过 trnasform.出来的</span><br>        <span class="hljs-comment">//对象当前的面朝向</span><br>        <span class="hljs-comment">// 那世界坐标系的朝向呢？这个是固定值啊，就是Vector3.right等等</span><br>        <span class="hljs-comment">// 这个对象当前的面朝向是相对于世界坐标系朝向的，只是把对象的转换为世界坐标系下的表示了</span><br>        print(<span class="hljs-keyword">this</span>.transform.forward);<br>        <span class="hljs-comment">//对象当前的头顶朝向</span><br>        print(<span class="hljs-keyword">this</span>.transform.up);<br>        <span class="hljs-comment">//对象当前的右手边</span><br>        print(<span class="hljs-keyword">this</span>.transform.right);<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 位移</span><br>        <span class="hljs-comment">//理解坐标系下的位移计算公式</span><br>        <span class="hljs-comment">//路程 = 方向 * 速度 * 时间</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 自己计算</span><br>        <span class="hljs-comment">//方式一 自己计算</span><br>        <span class="hljs-comment">//想要变化的 就是 position</span><br><br>        <span class="hljs-comment">//用当前的位置 + 我要动多长距离  得出最终所在的位置</span><br>        <span class="hljs-comment">//this.transform.position = this.transform.position + this.transform.up * 1 * Time.deltaTime;</span><br><br>        <span class="hljs-comment">//因为我用的是 this.transform.forward 所以它始终会朝向相对于自己的面朝向去动</span><br>        <span class="hljs-comment">//this.transform.position += this.transform.forward * 1 * Time.deltaTime;</span><br><br>        <span class="hljs-comment">//方向非常重要 因为 它决定了你的前进方向</span><br>        <span class="hljs-comment">//this.transform.position += Vector3.forward * 1 * Time.deltaTime;</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> API计算</span><br>        <span class="hljs-comment">//方式二 API</span><br>        <span class="hljs-comment">//参数一：表示位移多少  路程 = 方向 * 速度 * 时间</span><br>        <span class="hljs-comment">//参数二：表示相对坐标系，默认是相对于对象自己坐标系，意思就是以这个坐标系为标准坐标系，在上面进行偏移移动</span><br><br>        <span class="hljs-comment">//1.相对于世界坐标系的Z轴动,始终是朝世界坐标系的Z轴正方向移动</span><br>        <span class="hljs-comment">//this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World);</span><br><br>        <span class="hljs-comment">//2.相对于世界坐标的自己的面朝向去动,始终朝自己的面朝向移动</span><br>        <span class="hljs-comment">//this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.World);</span><br><br>        <span class="hljs-comment">//3.相对于自己的坐标系下的自己的面朝向向量移动,（一定不会这样让物体移动） XXXXXXX</span><br>        <span class="hljs-comment">//this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.Self);</span><br><br>        <span class="hljs-comment">//4.相对于自己的坐标系下的Z轴正方向移动,始终朝自己的面朝向移动</span><br>        <span class="hljs-keyword">this</span>.transform.Translate(Vector3.forward * <span class="hljs-number">1</span> * Time.deltaTime, Space.Self);<br><br>        <span class="hljs-comment">//注意：一般使用API来进行位移</span><br>        <span class="hljs-comment">// 如果上面2，4都启用，实际的是两者叠加的运动结果</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="角度和旋转相关知识点"><a href="#角度和旋转相关知识点" class="headerlink" title="角度和旋转相关知识点"></a>角度和旋转相关知识点</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson7</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 角度相关</span><br>        <span class="hljs-comment">//相对世界坐标角度</span><br>        <span class="hljs-comment">//print(this.transform.rotation);// 这个是四元数</span><br>        print(<span class="hljs-keyword">this</span>.transform.eulerAngles); <span class="hljs-comment">// 和Unity中显示的一样</span><br><br>        <span class="hljs-comment">//相对父对象角度</span><br>        print(<span class="hljs-keyword">this</span>.transform.localEulerAngles);<br><br>        <span class="hljs-comment">//注意：设置角度和设置位置一样 不能单独设置xyz 要一起设置</span><br>        <span class="hljs-comment">//如果我们希望改变的 角度 是面板上显示的内容 那一点是改变 相对父对象的角度</span><br>        <span class="hljs-comment">//this.transform.localEulerAngles = new Vector3(10, 10, 10);</span><br>        <span class="hljs-comment">//this.transform.eulerAngles = new Vector3(10, 10, 10);</span><br>        print(<span class="hljs-keyword">this</span>.transform.localEulerAngles);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 旋转相关</span><br>        <span class="hljs-comment">//自己计算（省略不讲了 和位置一样 不停改变角度即可）</span><br><br>        <span class="hljs-comment">//API计算</span><br>        <span class="hljs-comment">//自转</span><br>        <span class="hljs-comment">//每个轴具体转多少度，就是每个轴每帧改变多少</span><br>        <span class="hljs-comment">//第一个参数：相当于是旋转的角度每一帧</span><br>        <span class="hljs-comment">//第二个参数：默认不填，就是相对于自己坐标系进行的旋转，Space.Self</span><br>        <span class="hljs-comment">//this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime);</span><br>        <span class="hljs-comment">//this.transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.World);</span><br><br>        <span class="hljs-comment">//相对于某个轴转多少度,在【第三个参数】的坐标系下，绕找轴【第一个参数】进行旋转，旋转角度是【第二个参数】</span><br>        <span class="hljs-comment">//参数一：是相对哪个轴进行转动</span><br>        <span class="hljs-comment">//参数二：是转动的角度是多少</span><br>        <span class="hljs-comment">//参数三：默认不填,就是相对于自己的坐标系进行旋转</span><br>        <span class="hljs-comment">//       如果填，可以填写相对于世界坐标系进行旋转</span><br>        <span class="hljs-comment">//this.transform.Rotate(Vector3.right, 10 * Time.deltaTime);</span><br>        <span class="hljs-comment">//this.transform.Rotate(Vector3.right, 10 * Time.deltaTime, Space.World);</span><br><br>        <span class="hljs-comment">//相对于某一个点产生的轴进行旋转</span><br>        <span class="hljs-comment">//参数一：相当于哪一个点转圈圈</span><br>        <span class="hljs-comment">//参数二：相对于哪一个点的哪一个轴转圈圈</span><br>        <span class="hljs-comment">//参数三：转的度数：旋转速度 * 时间</span><br>        <span class="hljs-comment">// RotateAround 的轴和中心点都是明确定义的，不依赖对象的本地坐标系</span><br>        <span class="hljs-comment">// 使用的坐标系都是Space.World</span><br>        <span class="hljs-keyword">this</span>.transform.RotateAround(Vector3.zero, Vector3.right, <span class="hljs-number">10</span> * Time.deltaTime);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="缩放和看向相关知识点"><a href="#缩放和看向相关知识点" class="headerlink" title="缩放和看向相关知识点"></a>缩放和看向相关知识点</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson8</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform lookAtObj;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 缩放</span><br>        <span class="hljs-comment">//相对世界坐标系</span><br>        <span class="hljs-comment">// lossyScale只有get，没有set</span><br>        print(<span class="hljs-keyword">this</span>.transform.lossyScale);<br>        <span class="hljs-comment">//相对本地坐标系（父对象）</span><br>        print(<span class="hljs-keyword">this</span>.transform.localScale);<br><br>        <span class="hljs-comment">//注意：</span><br>        <span class="hljs-comment">//1.同样缩放不能只改xyz,只能一起改(相对于世界坐标系的缩放大小只能得,不能改)</span><br>        <span class="hljs-comment">//一般要修改缩放大小，都是改相对于父对象的缩放大小localScale</span><br>        <span class="hljs-comment">//this.transform.localScale = new Vector3(3, 3, 3);</span><br><br>        <span class="hljs-comment">//2.Unity没有提供关于缩放的API</span><br>        <span class="hljs-comment">//之前的 旋转 位移 都提供了 对应的 API 但是 缩放并没有</span><br>        <span class="hljs-comment">//如果你想要 让 缩放 发生变化 只能自己去写(自己算)</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//2.Unity没有提供关于缩放的API</span><br>        <span class="hljs-comment">//之前的 旋转 位移 都提供了 对应的 API 但是 缩放并没有</span><br>        <span class="hljs-comment">//如果你想要 让 缩放 发生变化 只能自己去写(自己算)</span><br>        <span class="hljs-comment">//this.transform.localScale += Vector3.one * Time.deltaTime;</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 看向</span><br>        <span class="hljs-comment">//让一个对象的面朝向（z轴）一直看向某一个点或者某一个对象</span><br>        <span class="hljs-comment">//看向一个点相对于世界坐标系的</span><br>        <span class="hljs-comment">//this.transform.LookAt(Vector3.zero);</span><br>        <span class="hljs-comment">//看向一个对象，传入一个对象的Transform信息，也是看向对象的Position的信息</span><br>        <span class="hljs-comment">// 第二个参数的意思是，让this.transform对象的【第二个参数的方向】尽可能的对齐lookAtObj的y轴</span><br>        <span class="hljs-comment">// 默认不填是Vector3.up</span><br>        <span class="hljs-keyword">this</span>.transform.LookAt(lookAtObj, Vector3.up);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="父子关系相关知识点"><a href="#父子关系相关知识点" class="headerlink" title="父子关系相关知识点"></a>父子关系相关知识点</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson9</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform son;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 获取和设置父对象</span><br>        <span class="hljs-comment">//获取父对象</span><br>        <span class="hljs-comment">// 如果this.transform没有父对象，那么这个this.transform.parent就是null</span><br>        <span class="hljs-comment">//print(this.transform.parent.name);</span><br>        <span class="hljs-comment">//设置父对象，断绝父子关系</span><br>        <span class="hljs-comment">//this.transform.parent = null;</span><br>        <span class="hljs-comment">//设置父对象，认爸爸</span><br>        <span class="hljs-comment">//this.transform.parent = GameObject.Find(&quot;Father2&quot;).transform;</span><br><br>        <span class="hljs-comment">//通过API来进行父子关系的设置</span><br>        <span class="hljs-comment">//this.transform.SetParent(null);//断绝父子关系</span><br>        <span class="hljs-comment">//this.transform.SetParent(GameObject.Find(&quot;Father2&quot;).transform);//认爸爸</span><br><br>        <span class="hljs-comment">//参数一：父对象</span><br>        <span class="hljs-comment">//参数二：是否保留世界坐标的位置，角度，缩放，信息</span><br>        <span class="hljs-comment">//       true：会保留世界坐标下的状态和父对象进行计算，得到本地坐标系的信息，其实也就是进行了父对象和子对象的绑定，其他没变</span><br>        <span class="hljs-comment">//       false：不会保留世界坐标系下的状态，直接把世界坐标系下的位置角度缩放，直接赋值到本地坐标系下，改变了子对象的位置信息</span><br>        <span class="hljs-comment">//this.transform.SetParent(GameObject.Find(&quot;Father3&quot;).transform, false);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 所有子对象关系分离</span><br>        <span class="hljs-comment">//和自己的子对象的关系进行分离，但是子对象自己的关系不管，如果子对象还有子对象，这个关系保留</span><br>        <span class="hljs-comment">//this.transform.DetachChildren();</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 获取子对象</span><br>        <span class="hljs-comment">//按名字查找儿子</span><br>        <span class="hljs-comment">//找到儿子的transform信息</span><br>        <span class="hljs-comment">//Find方法 是能够找到 失活的对象的 ！！！！！ GameObject相关的查找是不能找到失活对象的</span><br>        print(<span class="hljs-keyword">this</span>.transform.Find(<span class="hljs-string">&quot;Cube (1)&quot;</span>).name);<br>        <span class="hljs-comment">//只能找到自己的儿子 找不到自己的孙子 ！！！！！！</span><br>        <span class="hljs-comment">//print(this.transform.Find(&quot;GameObject&quot;).name);</span><br>        <span class="hljs-comment">//的效率比GameObject.Find相关要高一些，但是前提是你必须知道父亲是谁才能找</span><br><br>        <span class="hljs-comment">//遍历儿子</span><br>        <span class="hljs-comment">//如何得到有多少个儿子</span><br>        <span class="hljs-comment">//1.失活的儿子也会算数量</span><br>        <span class="hljs-comment">//2.找不到孙子，所以孙子不会算数量</span><br>        print(<span class="hljs-keyword">this</span>.transform.childCount);<br>        <span class="hljs-comment">//通过索引号 去得到自己对应的儿子</span><br>        <span class="hljs-comment">//如果编号超出了儿子数量的范围，会直接报错的</span><br>        <span class="hljs-comment">//返回值是transform，可以得到对应儿子的位置相关信息</span><br>        <span class="hljs-keyword">this</span>.transform.GetChild(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.transform.childCount; i++)<br>        &#123;<br>            print(<span class="hljs-string">&quot;儿子的名字：&quot;</span> + <span class="hljs-keyword">this</span>.transform.GetChild(i).name);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 儿子的操作</span><br>        <span class="hljs-comment">//判断自己的爸爸是谁</span><br>        <span class="hljs-comment">//一个对象判断自己是不是另一个对象的儿子</span><br>        <span class="hljs-keyword">if</span> (son.IsChildOf(<span class="hljs-keyword">this</span>.transform))<br>        &#123;<br>            print(<span class="hljs-string">&quot;是我的儿子&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//得到自己作为儿子的编号</span><br>        print(son.GetSiblingIndex());<br>        <span class="hljs-comment">//把自己设置为第一个儿子</span><br>        <span class="hljs-comment">// 这个在Hierarchy中的上下顺序，也就是实际的儿子对应的索引</span><br>        son.SetAsFirstSibling();<br>        <span class="hljs-comment">//把自己设置为最后一个儿子</span><br>        son.SetAsLastSibling();<br>        <span class="hljs-comment">//把自己设置为指定个儿子</span><br>        <span class="hljs-comment">//索引超出了范围（负数或者更大的数） 不会报错，会直接设置成最后一个编号</span><br>        son.SetSiblingIndex(<span class="hljs-number">1</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<code>this.transform.DetachChildren()</code>去除父子关系</li><li>如果子对象还有子对象，不影响子对象的关系<br><img src="https://s2.loli.net/2024/11/18/1HfoxrEDvkZn5PG.png" alt="Pasted image 20241118203515.png"><br><img src="https://s2.loli.net/2024/11/18/CFgcxXYuqKVW2Dr.png" alt="Pasted image 20241118203534.png"></li></ul><h2 id="坐标转换相关知识点"><a href="#坐标转换相关知识点" class="headerlink" title="坐标转换相关知识点"></a>坐标转换相关知识点</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson10</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 世界坐标转本地坐标</span><br>        print(Vector3.forward);<br><br>        <span class="hljs-comment">//世界坐标系转本地坐标系，可以帮助我们大概判断一个相对位置</span><br>        <span class="hljs-comment">//世界坐标系的点转换为相对本地坐标系的点</span><br>        <span class="hljs-comment">//受到缩放影响，比例相反</span><br>        <span class="hljs-comment">// Vector3.forward是世界坐标系下的点；this.transform是自己想要作为参考系的坐标系</span><br>        <span class="hljs-comment">// 将世界坐标系下的点Vector3.forward转换为this.transform坐标系下的点</span><br>        print(<span class="hljs-string">&quot;转换后的点 &quot;</span> + <span class="hljs-keyword">this</span>.transform.InverseTransformPoint(Vector3.forward));<br><br>        <span class="hljs-comment">//世界坐标系的方向转换为相对本地坐标系的方向</span><br>        <span class="hljs-comment">// 世界坐标系的方向可以理解为，从(0,0,0)开始的一个向量（方向）</span><br>        <span class="hljs-comment">// 从世界坐标系转换为相对对象坐标系的一个向量，模长不变</span><br><span class="hljs-comment">// 也可以理解为一个向量从世界坐标系的原点移动到本地坐标系的原点，然后求在本地坐标系下的终点的坐标</span><br>        <span class="hljs-comment">//不受缩放影响</span><br>        print(<span class="hljs-string">&quot;转换后的方向&quot;</span> + <span class="hljs-keyword">this</span>.transform.InverseTransformDirection(Vector3.forward));<br>        <span class="hljs-comment">//受缩放影响，比例相反</span><br>        print(<span class="hljs-string">&quot;转换后的方向(受缩放影响)&quot;</span> + <span class="hljs-keyword">this</span>.transform.InverseTransformVector(Vector3.forward));<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 本地坐标转世界坐标，更重要</span><br>        <span class="hljs-comment">//本地坐标系的点转换为相对世界坐标系的点，受到缩放影响</span><br>        <span class="hljs-comment">// 这里Vector3.forward是this.transform坐标系上的一个点</span><br>        <span class="hljs-comment">// 将其转换为为世界坐标系下的坐标，缩放一致</span><br>        print(<span class="hljs-string">&quot;本地 转 世界 点&quot;</span> + <span class="hljs-keyword">this</span>.transform.TransformPoint(Vector3.forward));<br><br><span class="hljs-comment">//本地坐标系的方向 转换 为相对世界坐标系的方向</span><br><span class="hljs-comment">// 也可以理解为一个向量从本地坐标系的原点移动到世界坐标系的原点，然后求在世界坐标系下的终点的坐标</span><br><span class="hljs-comment">//不受缩放影响</span><br>print(<span class="hljs-string">&quot;本地 转 世界 方向&quot;</span> + <span class="hljs-keyword">this</span>.transform.TransformDirection(Vector3.forward));<br>        <span class="hljs-comment">//受缩放影响，缩放一致</span><br>        print(<span class="hljs-string">&quot;本地 转 世界 方向&quot;</span> + <span class="hljs-keyword">this</span>.transform.TransformVector(Vector3.forward));<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Input触摸手柄陀螺仪相关知识点"><a href="#Input触摸手柄陀螺仪相关知识点" class="headerlink" title="Input触摸手柄陀螺仪相关知识点"></a>Input触摸手柄陀螺仪相关知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson11</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 注意：输入相关内容肯定是写在Update中的</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 鼠标在屏幕位置</span><br>        <span class="hljs-comment">//屏幕坐标的原点 是在 屏幕的左下角  往右是X轴正方向 往上时Y轴正方向</span><br>        <span class="hljs-comment">//返回值时Vector3 但是只有 x和y有值 z一直是0 是因为屏幕本来就是2D的 不存在Z轴</span><br>        <span class="hljs-comment">//print(Input.mousePosition);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 检测鼠标输入</span><br>        <span class="hljs-comment">//鼠标按下相关检测 对于我们来说</span><br>        <span class="hljs-comment">//比如： 1.可以做 发射子弹</span><br>        <span class="hljs-comment">//      2.可以控制摄像机 转动</span><br><br>        <span class="hljs-comment">//鼠标按下一瞬间 进入</span><br>        <span class="hljs-comment">//0左键 1右键 2中键</span><br>        <span class="hljs-comment">//只要按下的这一瞬间 进入一次</span><br>        <span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">0</span>))<br>        &#123;<br>            print(<span class="hljs-string">&quot;鼠标左键按下了&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//鼠标抬起一瞬间 进入</span><br>        <span class="hljs-keyword">if</span> (Input.GetMouseButtonUp(<span class="hljs-number">0</span>))<br>        &#123;<br>            print(<span class="hljs-string">&quot;鼠标左键抬起了&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//鼠标长按按下抬起都会进入</span><br>        <span class="hljs-comment">//就是 当按住按键不放时 会一直进入 这个判断</span><br>        <span class="hljs-keyword">if</span> (Input.GetMouseButton(<span class="hljs-number">1</span>))<br>        &#123;<br>            print(<span class="hljs-string">&quot;右键按下&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//中键滚动</span><br>        <span class="hljs-comment">//返回值的 y -1往下滚  0没有滚  1往上滚</span><br>        <span class="hljs-comment">//它的返回值 是Vector的值 我们鼠标中键滚动 会改变其中的Y值</span><br>        <span class="hljs-comment">// x: 鼠标滚轮在水平方向（横向滚动）上的变化量。通常只有在支持横向滚动的触控板或鼠标设备上有效。</span><br>        <span class="hljs-comment">// y: 鼠标滚轮在垂直方向（上下滚动）上的变化量。对于普通鼠标滚轮，y 是最常用的属性。</span><br>        <span class="hljs-comment">//print(Input.mouseScrollDelta);</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 检测键盘输入</span><br>        <span class="hljs-comment">//比如说 按一个键释放一个技能或者切换武器 等等的操作</span><br><br>        <span class="hljs-comment">//键盘按下，建议使用这个</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.W))<br>        &#123;<br>            print(<span class="hljs-string">&quot;W键按下&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//传入字符串的重载</span><br>        <span class="hljs-comment">//Input.GekeyDown()只能传入小写，不能是大写，不然会报错</span><br>        <span class="hljs-comment">//不过按键按大写和小写都你能触发下一行代码</span><br>        <span class="hljs-comment">// 不建议使用这个</span><br>        <span class="hljs-comment">//if (Input.GetKeyDown(&quot;q&quot;))</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    print(&quot;q按下&quot;);</span><br>        <span class="hljs-comment">//&#125;</span><br><br>        <span class="hljs-comment">//键盘抬起</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyUp(KeyCode.W))<br>        &#123;<br>            print(<span class="hljs-string">&quot;W键抬起&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//键盘长按</span><br>        <span class="hljs-keyword">if</span> (Input.GetKey(KeyCode.W))<br>        &#123;<br>            print(<span class="hljs-string">&quot;W键长按&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 检测默认轴输入</span><br>        <span class="hljs-comment">//我们学习鼠标 键盘输入 主要是用来</span><br>        <span class="hljs-comment">//控制玩家 比如 旋转 位移等等</span><br>        <span class="hljs-comment">//所以Unity提供了 更方便的方法 来帮助我们控制 对象的 位移和旋转</span><br><br>        <span class="hljs-comment">//键盘AD按下时 返回 -1(A)到1(D)之间的变换</span><br>        <span class="hljs-comment">// 没有按时，会慢慢回到0</span><br>        <span class="hljs-comment">//相当于 得到得这个值 就是我们的 左右方向 我们可以通过它来控制 对象左右移动 或者左右旋转</span><br>        <span class="hljs-comment">//print(Input.GetAxis(&quot;Horizontal&quot;));</span><br><br>        <span class="hljs-comment">//键盘SW按下时 返回 -1(S)到1(W)之间的变换</span><br>        <span class="hljs-comment">// 没有按时，会慢慢回到0</span><br>        <span class="hljs-comment">//得到得这个值 就是我们的 上下方向 我们可以通过它来控制 对象上下移动 或者上下旋转</span><br>        <span class="hljs-comment">//print(Input.GetAxis(&quot;Vertical&quot;));</span><br><br>        <span class="hljs-comment">//鼠标横向移动时 -1(左) 到 1(右) 左 右</span><br>        <span class="hljs-comment">// 测试了，这个的值左边是小于0，右边是大于0，并不是一直处于[-1,1]</span><br>        <span class="hljs-comment">// 速度越大，绝对值越大</span><br>        <span class="hljs-comment">// 没有移动时，会慢慢回到0</span><br>        print(Input.GetAxis(<span class="hljs-string">&quot;Mouse X&quot;</span>));<br><br>        <span class="hljs-comment">//鼠标竖向移动时  -1(下) 到 1(上) 下 上</span><br>        <span class="hljs-comment">// 测试了，这个的值下面是小于0，上面是大于0，并不是一直处于[-1,1]</span><br>        <span class="hljs-comment">// 速度越大，绝对值越大</span><br>        <span class="hljs-comment">// 没有移动时，会慢慢回到0</span><br>        print(Input.GetAxis(<span class="hljs-string">&quot;Mouse Y&quot;</span>));<br><br>        <span class="hljs-comment">//我们默认的 GetAxis方法 是有渐变的 会总 -1~0~1之间 渐变 会出现小数</span><br><br>        <span class="hljs-comment">//GetAxisRaw方法 和 GetAxis使用方式相同</span><br>        <span class="hljs-comment">//只不过 它的返回值 只会是 -1 0 1 不会有中间值</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 其它</span><br>        <span class="hljs-comment">//是否有任意键或鼠标长按</span><br>        <span class="hljs-keyword">if</span> (Input.anyKey)<br>        &#123;<br>            print(<span class="hljs-string">&quot;有一个键长按&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//是否有任意键或鼠标按下</span><br>        <span class="hljs-keyword">if</span> (Input.anyKeyDown)<br>        &#123;<br>            print(<span class="hljs-string">&quot;有一个键 按下&quot;</span>);<br>            <span class="hljs-comment">//这一帧的键盘输入</span><br>            print(Input.inputString);<br>        &#125;<br><br>        <span class="hljs-comment">//手柄输入相关</span><br>        <span class="hljs-comment">//得到连接的手柄的所有按钮名字</span><br>        <span class="hljs-built_in">string</span>[] strs = Input.GetJoystickNames();<br><br>        <span class="hljs-comment">//某一个手柄键按下</span><br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>)) &#123; &#125;<br><br>        <span class="hljs-comment">//某一个手柄键抬起</span><br>        <span class="hljs-keyword">if</span> (Input.GetButtonUp(<span class="hljs-string">&quot;Jump&quot;</span>)) &#123; &#125;<br><br>        <span class="hljs-comment">//某一个手柄键长按</span><br>        <span class="hljs-keyword">if</span> (Input.GetButton(<span class="hljs-string">&quot;Jump&quot;</span>)) &#123; &#125;<br><br>        <span class="hljs-comment">//移动设备触摸相关</span><br>        <span class="hljs-comment">//如果手机被触碰了</span><br>        <span class="hljs-keyword">if</span> (Input.touchCount &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// 触摸的第一个点</span><br>            Touch t1 = Input.touches[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">//位置</span><br>            print(t1.position);<br>            <span class="hljs-comment">//相对上次位置的变化</span><br>            print(t1.deltaPosition);<br>        &#125;<br><br>        <span class="hljs-comment">//是否启用多点触控</span><br>        Input.multiTouchEnabled = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//陀螺仪（重力感应）</span><br>        <span class="hljs-comment">//是否开启陀螺仪，必须开启下面的功能才能正常使用</span><br>        Input.gyro.enabled = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//重力加速度向量</span><br>        print(Input.gyro.gravity);<br>        <span class="hljs-comment">//旋转速度</span><br>        print(Input.gyro.rotationRate);<br>        <span class="hljs-comment">//陀螺仪 当前的旋转四元数</span><br>        <span class="hljs-comment">//比如 用这个角度信息 来控制 场景上的一个3D物体受到重力影响</span><br>        <span class="hljs-comment">//手机怎么动 它怎么动</span><br>        print(Input.gyro.attitude);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Input.GetAxis()里面的参数可以参考Project Setting的Input Manager<br><img src="https://s2.loli.net/2024/11/18/taEAFI5USqgP2ZC.png" alt="Pasted image 20241118220201.png"><br><img src="https://s2.loli.net/2024/11/18/r7fmc2eyBq1ECTF.png" alt="Pasted image 20241118220143.png"></li></ul><h1 id="屏幕相关Screen知识点"><a href="#屏幕相关Screen知识点" class="headerlink" title="屏幕相关Screen知识点"></a>屏幕相关Screen知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson12</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 静态属性</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 常用</span><br>        <span class="hljs-comment">//当前屏幕分辨率</span><br>        Resolution r = Screen.currentResolution;<br>        print(<span class="hljs-string">&quot;当前屏幕分辨率的宽&quot;</span> + r.width + <span class="hljs-string">&quot;高&quot;</span> + r.height);<br><br>        <span class="hljs-comment">//当前屏幕窗口宽高</span><br>        <span class="hljs-comment">//是当前窗口的宽高，不是设备分辨率的宽高</span><br>        <span class="hljs-comment">//一般写代码要用窗口宽高，不然窗口缩小后，UI会乱</span><br>        print(Screen.width);<br>        print(Screen.height);<br><br>        <span class="hljs-comment">//屏幕休眠模式</span><br>        <span class="hljs-comment">// 永不熄屏</span><br>        Screen.sleepTimeout = SleepTimeout.NeverSleep;<br>        <span class="hljs-comment">// 系统设置</span><br>        <span class="hljs-comment">//Screen.sleepTimeout = SleepTimeout.SystemSetting;</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 不常用</span><br>        <span class="hljs-comment">//运行时是否全屏模式</span><br>        Screen.fullScreen = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//窗口模式</span><br>        <span class="hljs-comment">//独占全屏：FullScreenMode.ExclusiveFullScreen</span><br>        <span class="hljs-comment">//全屏窗口：FullScreenMode.FullScreenWindow</span><br>        <span class="hljs-comment">//最大化窗口：FullScreenMode.MaximizedWindow</span><br>        <span class="hljs-comment">//窗口模式：FullScreenMode.Windowed</span><br>        Screen.fullScreenMode = FullScreenMode.Windowed;<br><br>        <span class="hljs-comment">//移动设备屏幕转向相关</span><br>        <span class="hljs-comment">//允许自动旋转为左横向 Home键在左</span><br>        Screen.autorotateToLandscapeLeft = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//允许自动旋转为右横向 Home键在右</span><br>        Screen.autorotateToLandscapeRight = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//允许自动旋转到纵向 Home键在下</span><br>        Screen.autorotateToPortrait = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//允许自动旋转到纵向倒着看 Home键在上</span><br>        Screen.autorotateToPortraitUpsideDown = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">//指定屏幕显示方向</span><br>        <span class="hljs-comment">//ScreenOrientation.AutoRotation：自动旋转</span><br>        <span class="hljs-comment">//ScreenOrientation.Landscape：横屏，左横向、右横向都可以</span><br>        <span class="hljs-comment">//ScreenOrientation.LandscapeLeft：左横向</span><br>        <span class="hljs-comment">//ScreenOrientation.LandscapeRight：右横向</span><br>        <span class="hljs-comment">//ScreenOrientation.Portrait：竖屏</span><br>        <span class="hljs-comment">//ScreenOrientation.PorraitUpsideDown：倒竖屏</span><br>        <span class="hljs-comment">//ScreenOrientation.Unknown：弃用</span><br>        Screen.orientation = ScreenOrientation.Landscape;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 静态方法</span><br>        <span class="hljs-comment">//设置分辨率 一般移动设备不使用</span><br>        <span class="hljs-comment">// 第三个参数是否全屏。false不是全屏，true是全屏</span><br>        <span class="hljs-comment">//true：游戏以全屏模式运行。</span><br>        <span class="hljs-comment">//false：游戏以窗口模式运行。</span><br>        Screen.SetResolution(<span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/18/UiEdyJHT4zSPBQV.png" alt="Pasted image 20241118222953.png"></p><h1 id="Camera可编辑参数知识点"><a href="#Camera可编辑参数知识点" class="headerlink" title="Camera可编辑参数知识点"></a>Camera可编辑参数知识点</h1><ul><li>Clear Flags<ul><li>Skybox<ul><li>天空盒，主要用在3D游戏</li></ul></li><li>Solid Color<ul><li>纯色填充，主要用在2D游戏</li></ul></li><li>Depth only<ul><li>叠加渲染，和Camera脚本的Depth一起使用</li><li>一般用在Depth较高的相机上面，后渲染的相机只渲染物体，背景不渲染，是透明的，所以可以叠加到另一个相机渲染的画面上</li></ul></li><li>Don’t Clear<ul><li>不清除渲染</li></ul></li></ul></li><li>Culling Mask<ul><li>表示这个相机可以渲染哪些层级</li></ul></li><li>Projection<ul><li>Perspective 透视模式 <ul><li>主要用于3D游戏</li></ul></li><li>Orthographic 正交摄像机<ul><li>主要用于2D游戏</li></ul></li></ul></li><li>FOV Axis<ul><li>视场角</li><li>决定视场的角度由垂直还是水平决定</li><li>一般竖直就可以了</li></ul></li><li>Field of View<ul><li>一般不改</li><li>如果值变小，东西会变近，相机可观测距离变远，但是变窄</li><li>如果值变大，东西会变远，相机可观测距离变近，但是变宽</li></ul></li><li>Size<ul><li>正交摄像机的观察范围</li><li>值越大，范围越大，但物体也变小；值越小，范围越小，但物体变大</li></ul></li><li>Clipping Planes<ul><li>裁剪平面距离<ul><li>Near 最小可以看见的距离</li><li>Far 最大可以看见的距离</li></ul></li></ul></li><li>Viewport Rect<ul><li>视口范围，屏幕上将绘制该摄像机视图的位置；主要用于双摄像机游戏；0~1是百分比的意思</li><li>X 0 Y 0 W 0.5 H 0.5<ul><li>意思是从左下角(0,0)开始，向上50%的高度，向右的宽度的窗口显示</li></ul></li></ul></li><li>Depth<ul><li>渲染顺序上的深度</li><li>数值越小，渲染顺序越靠前。渲染靠后的会覆盖渲染靠前的</li></ul></li><li>Rendering Path<ul><li>渲染路径</li></ul></li><li>Target Texture<ul><li>渲染纹理</li><li>把摄像机看到的内容渲染到Render Texture上，这个选项上正好可以加一个Render Texture</li><li>可以用于创建小地图，新建一个相机，然后俯视观察对象，将渲染的内容放在Render Texture上</li></ul></li><li>Occlusion Culling <ul><li>是否启用剔除遮挡</li><li>如果某个对象，完全被另一个对象遮挡，那么这个被遮挡的对象就不再渲染，可以节约性能</li></ul></li><li>Allow HDR<ul><li>是否允许高动态范围渲染</li></ul></li><li>Allow MSAA<ul><li>是否允许抗锯齿</li></ul></li><li>Allow Dynamic Resolution<ul><li>是否允许动态分辨率呈现</li></ul></li><li>Target Display<ul><li>用于哪个显示器</li></ul></li><li>Target Eye<ul><li>VR用的<br><img src="https://s2.loli.net/2024/11/18/iG9Cfuawc41NXZe.png" alt="Pasted image 20241118224450.png"></li></ul></li><li>裁剪平面</li><li>如果物体在裁剪平面范围以外，会看不见物体<br><img src="https://s2.loli.net/2024/11/18/8biSk4FRKqsyvZc.png" alt="Pasted image 20241118225935.png"></li></ul><p>![<a href="https://s2.loli.net/2024/11/18/apt9ITxSeC56Xbl.png">摄像机参数说明.png</a></p><p>![摄像机参数说明2.png]<img src="https://s2.loli.net/2024/11/18/apt9ITxSeC56Xbl.png" alt=".png"></p><h1 id="Camera代码相关的知识点"><a href="#Camera代码相关的知识点" class="headerlink" title="Camera代码相关的知识点"></a>Camera代码相关的知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson14</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> Transform obj;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 重要静态成员</span><br>        <span class="hljs-comment">//1.获取摄像机</span><br>        <span class="hljs-comment">//主摄像机的获取</span><br>        <span class="hljs-comment">//如果想通过这种方式 快速获取摄像机 那么场景上必须有一个 tag为MainCamera的摄像机</span><br>        <span class="hljs-comment">// 如果有两个MainCamera，不知道获取的是哪个</span><br>        print(Camera.main.name);<br>        <span class="hljs-comment">//获取摄像机的数量</span><br>        print(Camera.allCamerasCount);<br>        <span class="hljs-comment">//得到所有摄像机</span><br>        Camera[] allCamera = Camera.allCameras;<br>        print(allCamera.Length);<br><br>        <span class="hljs-comment">//2.渲染相关委托</span><br>        <span class="hljs-comment">//摄像机剔除对象不渲染前处理的委托函数</span><br>        <span class="hljs-comment">// 和Camera脚本上的Occlusion Culling有关</span><br>        Camera.onPreCull += (c) =&gt; &#123; &#125;;<br>        <span class="hljs-comment">//摄像机 渲染前处理的委托</span><br>        Camera.onPreRender += (c) =&gt; &#123; &#125;;<br>        <span class="hljs-comment">//摄像机 渲染后 处理的委托</span><br>        Camera.onPostRender += (c) =&gt; &#123; &#125;;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 重要成员</span><br>        <span class="hljs-comment">//1.界面上的参数 都可以在Camera中获取到</span><br>        <span class="hljs-comment">//比如 下面这句代码 就是得到主摄像机对象 上的深度 进行设置</span><br>        Camera.main.depth = <span class="hljs-number">10</span>;<br><br>        <span class="hljs-comment">//2.世界坐标转屏幕坐标 this.transform.position就是自己想要转换的世界坐标</span><br>        <span class="hljs-comment">// 屏幕坐标就是game左下角为(0,0),物体距离左下角的实际坐标</span><br>        <span class="hljs-comment">//转换过后x和y对应的就是屏幕坐标，z对应的是这个3D物体里我们的摄像机有多远</span><br>        <span class="hljs-comment">//我们会用这个来做的功能最多的就是头顶血条相关的功能，z轴可以控制血条的近大远小</span><br>        Vector3 v = Camera.main.WorldToScreenPoint(<span class="hljs-keyword">this</span>.transform.position);<br>        print(v);<br>        <span class="hljs-comment">//3.屏幕坐标转世界坐标</span><br>        <span class="hljs-comment">//print(Camera.main.ScreenToWorldPoint(v));</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//3.屏幕坐标转世界坐标</span><br>        <span class="hljs-comment">//只所以改变Z轴 是因为 如果不改 Z默认为0</span><br>        <span class="hljs-comment">//转换过去的世界坐标系的点 永远都是一个点 可以理解为 视口 相交的焦点</span><br>        <span class="hljs-comment">//如果改变了Z 那么转换过去的 世界坐标的点 就是相对于 摄像机前方多少的单位的横截面上的世界坐标点</span><br>        Vector3 v = Input.mousePosition;<br>        <span class="hljs-comment">// z的意思就是在相机前面多少的距离</span><br>        v.z = <span class="hljs-number">5</span>;<br>        obj.position = Camera.main.ScreenToWorldPoint(v);<br>        <span class="hljs-comment">//print(Camera.main.ScreenToWorldPoint(v));</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="光源组件知识点"><a href="#光源组件知识点" class="headerlink" title="光源组件知识点"></a>光源组件知识点</h1><ul><li>右键，能看到很多类型的光源<br><img src="https://s2.loli.net/2024/11/25/uyM1sbf5wr2SF7v.png" alt="Pasted image 20241120113043.png"></li><li>Directional Light （方向光）<ul><li>Shadow Type<ul><li>NoShadows 关闭阴影<ul><li>性能消耗最低</li><li><img src="https://s2.loli.net/2024/11/26/PoGbQKvxY6EBhg1.png" alt="Pasted image 20241120121053.png"></li></ul></li><li>HardShadows 生硬阴影<ul><li>性能消耗中等<br><img src="https://s2.loli.net/2024/11/26/BGIPvMnJfpDhN4b.png" alt="Pasted image 20241120121113.png"></li></ul></li><li>SoftShadows 柔和阴影<ul><li>性能消耗最高<br><img src="https://s2.loli.net/2024/11/25/e9H2rxUkzd5Y1Mb.png" alt="Pasted image 20241120121128.png"></li></ul></li></ul></li><li>Cookie Size<ul><li>遮罩大小，只有在Directional Light里面才有</li><li>方向光一般不设置遮罩大小</li></ul></li><li>Render Mode 渲染模式<ul><li>Auto 运行时确定</li><li>Important 以像素质量为单位进行渲染，效果逼真，消耗大</li><li>Not Important 以快速模式进行渲染</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/25/q3ZcbdLYMvJXWe8.png" alt="Pasted image 20241120120020.png"></p><ul><li>Point Light（点光源）<ul><li>Range<ul><li>发光范围</li></ul></li><li>Color<ul><li>光源的颜色</li></ul></li><li>Mode<ul><li>Realtime 实时光源<ul><li>每帧实时计算，效果好，消耗性能大</li></ul></li><li>Baked 烘焙光源<ul><li>预先计算</li></ul></li><li>Mixed 混合光源<ul><li>预先计算+实时计算</li></ul></li></ul></li><li>Intensity<ul><li>光照强度</li><li>值越大，光越亮</li></ul></li><li>Indirect Multiplier<ul><li>改变间接光的强度<ul><li>低于1，每次反弹会使光更暗</li><li>等于1，无变化</li><li>高于1，每次反弹会使光更亮（山洞）</li></ul></li></ul></li><li>Draw Halo （球形光环开关）<ul><li>是一个true或者false的开关，开启了效果如下图所示，一般用在方向光上</li></ul></li><li>Flare （耀斑）<ul><li>一般较强的光才有</li></ul></li><li>Culling Mask （剔除遮罩层）<ul><li>决定哪些层的对象受到该光源的影响，如果没有选中这个层，那么这个层的对象不会受到光源的影响</li></ul></li><li>RealtimeShadows <ul><li>Strength 阴影暗度0~1之间，越大越黑，指的是影子的明暗程度</li><li>Resolution 阴影贴图渲染分辨率，越高越逼真，消耗越高，可以自己设置，也可以使用默认的几个设置</li><li>Bias 阴影推离光源的距离 计算阴影时使用的参数</li><li>Normal Bias 阴影投射面沿法线收缩距离 计算阴影时使用的参数</li><li>Near Panel 渲染阴影的近裁剪面 计算阴影时使用的参数</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/25/L4uFoxKlp2hIgUv.png" alt="Pasted image 20241120114736.png"></p><ul><li><p>Draw Halo （球形光环开关）<br><img src="https://s2.loli.net/2024/11/25/yLZq3tmXK6iOPY9.png" alt="Pasted image 20241121114528.png"></p></li><li><p>Flare （耀斑）<br><img src="https://s2.loli.net/2024/11/25/6TotuY5gmb8BIRE.png" alt="Pasted image 20241121115201.png"></p></li><li><p>耀斑要想在界面上看见，摄像机要加这个脚本（Falre Layer）<br><img src="https://s2.loli.net/2024/11/25/pHfijuIen4gL2kM.png" alt="Pasted image 20241121115229.png"></p></li><li><p>Spot Light（聚光灯）</p><ul><li>Range<ul><li>发光距离，值变大了，但是原本照射的地方距离不变，就会导致原本位置的亮度变大</li></ul></li><li>Spot Angle<ul><li>聚光灯发光圆圈的半径（角度）</li></ul></li><li>Cookie （投影遮罩）<ul><li>更换Cookie的材质对象，能够呈现不同的显示效果</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/25/dWs8zvGEo2BMyK3.png" alt="Pasted image 20241120115019.png"></p><ul><li><p>投影遮罩<br><img src="https://s2.loli.net/2024/11/25/pSW7ZhfbCIPABq4.png" alt="Pasted image 20241121113657.png"></p></li><li><p>Area Light（面光源）</p></li><li><p>实际看起来没啥效果，是烘焙光源（Baked）</p></li><li><p>烘焙</p><ul><li>提前计算好，然后贴图上去，并不会实时计算光源，节约性能</li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/25/IcGHgNm128nVuoT.png" alt="光源参数说明1.png"></p><p>![光源参数说明2.png]<img src="https://s2.loli.net/2024/11/25/iz4crBunRbPLUhI.png" alt="2.png"></p><h1 id="光面板相关"><a href="#光面板相关" class="headerlink" title="光面板相关"></a>光面板相关</h1><ul><li><p>Window-&gt;Rendering-&gt;Lighting<br><img src="https://s2.loli.net/2024/11/25/46wOZGRiLnevMEx.png" alt="Pasted image 20241121194630.png"></p></li><li><p>重要的是Environment<br><img src="https://s2.loli.net/2024/11/26/YxeDfPJjuHcULBT.png" alt="Pasted image 20241121194731.png"></p></li><li><p>Skybox Material</p></li><li><p>天空盒材质的创建<br><img src="https://s2.loli.net/2024/11/26/Irmp4QCoV68xqyS.png" alt="Pasted image 20241121195016.png"><br><img src="https://s2.loli.net/2024/11/26/DKkMlrsuah5pzE1.png" alt="Pasted image 20241121195106.png"><br><img src="https://s2.loli.net/2024/11/26/9ECRoVwtG8WsZn6.png" alt="Pasted image 20241121195125.png"><br><img src="https://s2.loli.net/2024/11/26/kchsTf14xQr26PI.png" alt="Pasted image 20241121195145.png"></p></li><li><p>Sun Source 太阳来源</p><blockquote><p>当场景上有很多个方向光，需要指定某个作为太阳光，才设置这个</p></blockquote></li><li><h2 id="Environment-Lighting-Source-环境光的叠加会和来源叠加-Skybox-天空盒材质作为环境光颜色-Gradient-为天空、地平线、地面单独选择颜色和他们之间混合-Intensity-Multiplier-光强度，需要在山洞里面用的多"><a href="#Environment-Lighting-Source-环境光的叠加会和来源叠加-Skybox-天空盒材质作为环境光颜色-Gradient-为天空、地平线、地面单独选择颜色和他们之间混合-Intensity-Multiplier-光强度，需要在山洞里面用的多" class="headerlink" title="Environment Lighting  - Source      - 环境光的叠加会和来源叠加      - Skybox 天空盒材质作为环境光颜色      - Gradient 为天空、地平线、地面单独选择颜色和他们之间混合  - Intensity Multiplier      - 光强度，需要在山洞里面用的多"></a>Environment Lighting<br>  - Source<br>      - 环境光的叠加会和来源叠加<br>      - Skybox 天空盒材质作为环境光颜色<br>      - Gradient 为天空、地平线、地面单独选择颜色和他们之间混合<br>  - Intensity Multiplier<br>      - 光强度，需要在山洞里面用的多</h2></li></ul><p><img src="https://s2.loli.net/2024/11/26/oxRckLHsYKGWX1E.png" alt="光面板说明1.png"></p><ul><li>Fog （性能消耗比较大）<ul><li>Color 雾的颜色</li><li>Mode 雾影响和距离的关系<ul><li>Linear 线性<ul><li>Start 离相机多远开始有雾</li><li>End 离相机多远开始完全看不见</li></ul></li><li>Exponential 指数型</li><li>Exponential Qquare 比指数更快</li></ul></li></ul></li><li>Halo Texture<ul><li>光源周围光环的纹理，可以是圆的，方的。。。</li></ul></li><li>Halo Strength<ul><li>光环可见性，改的是光环的半径大小</li></ul></li><li>Flare Fade Speed<ul><li>耀斑最初出现之后，淡出的时间</li></ul></li><li>Flare Strength<ul><li>耀斑可见性，值越小，能够看见的半径越小</li></ul></li><li>Spot Cookie<ul><li>探照灯的形状，这个是默认设置，如果创建一个Spot Light，默认就是这个<br><img src="https://s2.loli.net/2024/11/26/1tRWGiwnPcp8KYy.png" alt="光面板说明2.png"></li></ul></li></ul><h1 id="碰撞检测之刚体"><a href="#碰撞检测之刚体" class="headerlink" title="碰撞检测之刚体"></a>碰撞检测之刚体</h1><blockquote><p>碰撞产生的必要条件<br>两个物体都要有碰撞器，只要一个物体有刚体</p></blockquote><ul><li>这个绿色的颜色就是碰撞器实际范围<br><img src="https://s2.loli.net/2024/11/26/LRpdbgyPw4cUkZ9.png" alt="Pasted image 20241121203407.png"></li><li>Rigidbody 刚体脚本（刚体）</li><li>Mass 质量（默认为千克）<ul><li>质量越大，惯性越大</li></ul></li><li>Drag 空气阻力<ul><li>根据力移动对象时影响对象的空气阻力大小</li><li>0表示没有空气阻力</li></ul></li><li>Angular Drag 扭矩空气阻力<ul><li>根据扭矩旋转对象时影响对象的空气阻力大小。0表示没有空气阻力</li><li>0的话则此时如果物体被撞旋转了，会一直旋转，不是0，会慢慢停止旋转</li></ul></li><li>use Gravity<ul><li>是否受重力影响</li></ul></li><li>Is Kinematic 物理运动学<ul><li>如果启动此选项，则对象将不会被物理引擎驱动，只能通过Transform对其操作</li><li>对于移动平台，或者如果要动画化附加了HingeJoint的刚体，此属性非常有用</li><li>理解为可以受到碰撞，但是状态不会改变了</li></ul></li><li>Interpolate 插值运算，让刚体物体移动更加平滑，如果物理帧很长的话，可以通过设置这个让他更平滑<ul><li>None 不应用插值运算</li><li>Interpolate 根据前一帧的变换来平滑变换</li><li>Extrapolate 根据下一帧的估计变换来平滑变换</li></ul></li><li>Collision Detection （碰撞检测模式）<ul><li>用于防止快速移动的对象穿过其他对象而不检测碰撞</li><li>Discrete （离散检测）<ul><li>对场景中的所有其他碰撞体使用离散碰撞检测。其他碰撞体在测试碰撞时会使用离散碰撞检测。用于正常碰撞（这是默认值）</li></ul></li><li>Continuous （连续检测）<ul><li>对动态碰撞体（具有刚体）使用离散碰撞检测</li><li>并对静态碰撞体（没有刚体）使用连续碰撞检测。</li><li>设置为连续动态（Continuous Dynamic）的刚体将在测试与该刚体的碰撞时使用连续碰撞检测。（此属性对物理性能有很大影响，如果没有快速对象的碰撞问题，请将其保留为Discrete设置）</li><li>其他刚体将使用离散碰撞检测。</li></ul></li><li>Continuous Dynamic （连续动态检测） 性能消耗高<ul><li>对设置为连续（Continuous）和连续动态（Continuous Dynamic）碰撞的游戏对象使用连续碰撞检测。还将对静态碰撞体（没有刚体）使用连续碰撞检测。</li><li>对于所有其他碰撞体，使用离散碰撞检测。用于快速移动的对象。</li></ul></li><li>Continuous Speculative （连续推测检测）<ul><li>对刚体和碰撞体使用推测性连续碰撞检测。该方法通常比连续碰撞检测的成本更低。</li></ul></li><li><img src="https://s2.loli.net/2024/11/26/DMQr1U5mLFqpzGH.png" alt="Pasted image 20241121210445.png"></li></ul></li><li>Constraints 约束，对刚体运动的限制<ul><li>Freeze Position<ul><li>有选择地停止刚体沿世界X、Y和Z轴的移动</li><li>如果选择了X和Z轴，那么X和Z的位置在碰撞时就不会变</li></ul></li><li>Freeze Rotation<ul><li>有选择地停止刚体围绕局部X、Y和Z轴的移动</li><li>如果选择了Y轴，那么在碰撞时就不会绕着Y轴旋转</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/26/3nWsJv78aPXxbcQ.png" alt="Pasted image 20241121203602.png"></p><p><img src="https://s2.loli.net/2024/11/26/KFB7G5DCS21RpjO.png" alt="Pasted image 20241121204429.png"></p><ul><li>这个时间和实际的物理更新有关，这个值大的话，表示过一秒后才更新物理世界，可能会发生类似卡顿的情况<br><img src="https://s2.loli.net/2024/11/26/EPomSaKAH56XgqU.png" alt="Pasted image 20241121205301.png"></li></ul><p><img src="https://s2.loli.net/2024/11/26/gySBfKFl7HM1u86.png" alt="刚体参数1.png"></p><p><img src="https://s2.loli.net/2024/11/26/NGRPC3TVoqye2F7.png" alt="刚体参数2.png"></p><p><img src="https://s2.loli.net/2024/11/26/fqWckHyV3w54sUT.png" alt="刚体参数3.png"></p><h1 id="碰撞检测之碰撞器"><a href="#碰撞检测之碰撞器" class="headerlink" title="碰撞检测之碰撞器"></a>碰撞检测之碰撞器</h1><ul><li><p>盒状、球状、胶囊状的3D碰撞器比较常用，准确性稍低，但是性能要求也低</p></li><li><p>网格、轮胎，地形的3D碰撞器准确性稍高，但是性能要求也高</p></li><li><p>IsTrigger</p><ul><li>是否是触发器，如果启用此属性</li><li>则该碰撞体将用于触发事件，并被物理引擎忽略主要用于进行没有物理效果的碰撞检测</li><li>比如，箭，会穿过怪物，但是，箭不会和怪物实际产生相互碰撞，一起后退的效果</li></ul></li><li><p>Material </p><ul><li>物理材质，可以确定碰撞体和其它对象碰撞时的交互（表现）方式。</li></ul></li><li><p>Center</p><ul><li>碰撞体在对象局部空间中的中心点位置,下图就是改了Center的值产生的结果</li><li><img src="https://s2.loli.net/2024/11/26/sORGpalnEBFq4Dc.png" alt="Pasted image 20241121214805.png"></li></ul></li><li><p>Edit Collider</p><ul><li>改变碰撞器的形状</li></ul></li><li><p>BoxCollider 盒状碰撞器</p><ul><li>Size 碰撞体在X、Y、Z方向上的大小</li></ul></li><li><p>Sphere Collider 球状碰撞器</p><ul><li>Radius 球形碰撞体的半径大小</li></ul></li><li><p>Capsule Collider 胶囊碰撞器</p><ul><li>Radius  胶囊体的半径</li><li>Height 胶囊体的高度</li><li>Direction 胶囊体在对象局部空间中的轴向</li></ul></li><li><p>异形物体使用多种碰撞器组合</p><ul><li>刚体对象的子对象碰撞器信息，参与碰撞检测</li><li>比如这种的金字塔，下面的子对象是加了碰撞器Collider，但是金字塔没有碰撞器，只有刚体，这样组合后就会和实际的金字塔的碰撞情况一致了，是一种处理异形物体的方法</li><li><img src="https://s2.loli.net/2024/11/26/E5D4jyoQLCFnSgA.png" alt="Pasted image 20241121220308.png"></li></ul></li><li><p>Mesh Collider</p><ul><li>Convex<ul><li>加了Rigidbody的圆柱体必须勾选Mesh Collider的Convex的选项，否则没有碰撞体力的效果</li><li>勾选此复选框可启用Convex。如果启用此属性，该MeshCollider将与其他 Mesh Collider 发生碰撞。ConvexMesh Collider最多 255 个三角形</li></ul></li><li>Cooking Options<ul><li>启用或禁用影响物理引擎对网格处理方式的网格烹制选项。</li></ul></li><li>Mesh<ul><li>引用需要用于碰撞的网格</li></ul></li></ul></li><li><p>Wheel Collider</p><ul><li>Car是一个整体的父对象，表示是一个整体的汽车，需要加上Rigidbody脚本，并且Mass设置大一些，否则会弹飞，如果没有加Rigidbody脚本，wheel Collider无法显示<ul><li>Cube是车的身体</li><li>Root是汽车的四个轮胎，需要加上wheel Collider</li><li><img src="https://s2.loli.net/2024/11/26/sEC6waxd2OYmt9R.png" alt="Pasted image 20241121221334.png"></li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/26/slwtaSRUXc5Yiuy.png" alt="碰撞器参数说明1.png"></p><p><img src="https://s2.loli.net/2024/11/26/xj6CytXopkLriA3.png" alt="碰撞器参数说明2.png"></p><p><img src="https://s2.loli.net/2024/11/26/jKBJtp9OMdgRETw.png" alt="碰撞器参数说明3.png"></p><p><img src="https://s2.loli.net/2024/11/26/VjGW9Z3ebuzyYiK.png" alt="碰撞器参数说明4.png"></p><p><img src="https://s2.loli.net/2024/11/26/Ah9QyueoENsHvxk.png" alt="碰撞器参数说明5.png"></p><h1 id="碰撞检测之物理材质"><a href="#碰撞检测之物理材质" class="headerlink" title="碰撞检测之物理材质"></a>碰撞检测之物理材质</h1><ul><li><p>创建物理材质<br><img src="https://s2.loli.net/2024/11/26/OTgoWQ9AmKFkVS6.png" alt="Pasted image 20241121221922.png"></p></li><li><p>物理材质在碰撞器上的位置<br><img src="https://s2.loli.net/2024/11/26/NY5tfOJ4CWj6bkn.png" alt="Pasted image 20241121222023.png"></p></li><li><p>Dynamic Friction</p><ul><li>已在移动时使用的摩擦力。通常为0到1之间的值。值为零就像冰一样，值为1将使对象迅速静止（除非用很大的力或重力推动对象）</li></ul></li><li><p>Static Friction</p><ul><li>当对象静止在表面上时使用的摩擦力。通常为0到1之间的值。值为零就像冰一样，值为1将导致很难让对象移动。</li></ul></li><li><p>Bounciness</p><ul><li>表面的弹性如何？值为0将不会反弹。值为1将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。</li></ul></li><li><p>Friction Combine</p><ul><li>两个碰撞对象的摩擦力的组合方式</li><li>Average 对两个摩擦值求平均值。</li><li>Minimum 使用两个值中的最小值</li><li>Maximum 使用两个值中的最大值</li><li>Multiply 两个摩擦值相乘。</li></ul></li><li><p>Bounce Combine</p><ul><li>两个碰撞对象的弹性的组合方式。其模式与Friction Combine模式相同</li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/26/bKnkrcMwSUFqVso.png" alt="物理材质参数说明.png"></p><h1 id="碰撞检测之碰撞检测函数"><a href="#碰撞检测之碰撞检测函数" class="headerlink" title="碰撞检测之碰撞检测函数"></a>碰撞检测之碰撞检测函数</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson16</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点回顾</span><br>    <span class="hljs-comment">//1.如何让两个游戏物体之间产生碰撞（至少1个刚体 和 两个碰撞器）</span><br>    <span class="hljs-comment">//2.如何让两个物体之间碰撞时表现出不同效果（物理材质）</span><br>    <span class="hljs-comment">//3.触发器的作用是什么(让两个物体碰撞没有物理效果，只进行碰撞处理)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 注意：碰撞和触发响应函数 属于 特殊的生命周期函数 也是通过反射调用</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 物理碰撞检测响应函数</span><br>    <span class="hljs-comment">//碰撞触发接触时会 自动执行这个函数</span><br>    <span class="hljs-comment">// Collision 碰撞相关</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//Collision类型的 参数 包含了 碰到自己的对象的相关信息</span><br><br>        <span class="hljs-comment">//关键参数</span><br>        <span class="hljs-comment">//1.碰撞到的对象碰撞器的信息</span><br>        <span class="hljs-comment">//collision.collider</span><br><br>        <span class="hljs-comment">//2.碰撞对象的依附对象（GameObject）</span><br>        <span class="hljs-comment">//collision.gameObject</span><br><br>        <span class="hljs-comment">//3.碰撞对象的依附对象的位置信息</span><br>        <span class="hljs-comment">//collision.transform</span><br><br>        <span class="hljs-comment">//4.触碰点数相关</span><br>        <span class="hljs-comment">//collision.contactCount</span><br>        <span class="hljs-comment">//接触点 具体的坐标</span><br>        <span class="hljs-comment">//ContactPoint[] pos = collision.contacts;</span><br><br>        <span class="hljs-comment">//只要得到了 碰撞到的对象的 任意一个信息 就可以得到它的所有信息</span><br><br>        print(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;被&quot;</span> + collision.gameObject.name + <span class="hljs-string">&quot;撞到了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//碰撞结束分离时  会自动执行的函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionExit</span>(<span class="hljs-params">Collision collision</span>)</span><br>    &#123;<br>        print(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;被&quot;</span> + collision.gameObject.name + <span class="hljs-string">&quot;结束碰撞了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//两个物体相互接触摩擦时 会不停的调用该函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionStay</span>(<span class="hljs-params">Collision collision</span>)</span><br>    &#123;<br>        print(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;一直在和&quot;</span> + collision.gameObject.name + <span class="hljs-string">&quot;接触&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 触发器检测响应函数</span><br>    <span class="hljs-comment">// 需要将碰撞器上的IsTrigger勾上</span><br>    <span class="hljs-comment">// Collider 碰撞相关，可以理解为是GameObject上的那个碰撞器的脚本</span><br><br>    <span class="hljs-comment">//触发开始的函数 当第一次接触时 会自动调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span><br>    &#123;<br>        print(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;被&quot;</span> + other.gameObject.name + <span class="hljs-string">&quot;触发了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//触发结束的函数 当水乳相融的状态结束时 会调用一次</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerExit</span>(<span class="hljs-params">Collider other</span>)</span><br>    &#123;<br>        print(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;被&quot;</span> + other.gameObject.name + <span class="hljs-string">&quot;结束水乳相融的状态了&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//当两个对象 水乳相融的时候 会不停调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerStay</span>(<span class="hljs-params">Collider other</span>)</span><br>    &#123;<br>        print(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">&quot;和&quot;</span> + other.gameObject.name + <span class="hljs-string">&quot;正在水乳相融&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 要明确什么时候会响应函数</span><br>    <span class="hljs-comment">//1.只要挂载的对象能和别的物体产生碰撞或者触发，那么对应的这6个函数就能够被响应，有没有刚体脚本不重要，有碰撞器脚本就可以了（碰撞的条件）</span><br>    <span class="hljs-comment">//2.6个函数不是说 我都得写 我们一般是根据需求来进行选择书写</span><br>    <span class="hljs-comment">//3.如果是一个异形物体，刚体在父对象上，如果你想通过子对象上挂脚本检测碰撞是不行的，必须挂载到这个刚体父对象上才行</span><br>    <span class="hljs-comment">//4.要明确物理碰撞和触发器响应的区别，触发器是有IsTrigger的设置的，碰撞就是碰撞的条件</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 碰撞和触发器函数都可以写成虚函数 在子类去重写逻辑</span><br>    <span class="hljs-comment">//一般会把想要重写的碰撞和触发函数写成保护类型的，没有必要写成public，因为不会自己手动调用，都是Unity</span><br>    <span class="hljs-comment">//通过反射帮助我们自动调用的</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/26/91tdX5jECVMmWlb.png" alt="生命周期函数图.bmp"></p><h1 id="碰撞检测之刚体加力知识点"><a href="#碰撞检测之刚体加力知识点" class="headerlink" title="碰撞检测之刚体加力知识点"></a>碰撞检测之刚体加力知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson17</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    Rigidbody rigidBody;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 刚体自带添加力的方法</span><br>        <span class="hljs-comment">//给刚体加力的目标就是</span><br>        <span class="hljs-comment">//让其有一个速度 朝向某一个方向移动</span><br><br>        <span class="hljs-comment">//1.首先应该获取刚体组件</span><br>        rigidBody = <span class="hljs-keyword">this</span>.GetComponent&lt;Rigidbody&gt;();<br><br>        <span class="hljs-comment">//2.添加力</span><br>        <span class="hljs-comment">//相对世界坐标</span><br>        <span class="hljs-comment">//世界坐标系 Z轴正方向加了一次瞬时的力</span><br>        <span class="hljs-comment">//加力过后对象是否停止移动，是由阻力决定的</span><br>        <span class="hljs-comment">//如果阻力为0，那给了一次力过后不会停止运动</span><br>        <span class="hljs-comment">//rigidBody.AddForce(Vector3.forward * 10);</span><br>        <span class="hljs-comment">//如果想要在 世界坐标系方法中 让对象 相对于自己的面朝向动</span><br>        <span class="hljs-comment">//rigidBody.AddForce(this.transform.forward * 10);</span><br><br>        <span class="hljs-comment">//相对本地坐标</span><br>        <span class="hljs-comment">//rigidBody.AddRelativeForce(Vector3.forward * 10);</span><br><br><br>        <span class="hljs-comment">//3.添加扭矩力，让其旋转</span><br>        <span class="hljs-comment">//相对世界坐标</span><br>        <span class="hljs-comment">//rigidBody.AddTorque(Vector3.up * 10);</span><br>        <span class="hljs-comment">//相对本地坐标</span><br>        <span class="hljs-comment">//rigidBody.AddRelativeTorque(Vector3.up * 10);</span><br><br>        <span class="hljs-comment">//4.直接改变速度</span><br>        <span class="hljs-comment">//速度方向是相对于世界坐标系的</span><br>        <span class="hljs-comment">//rigidBody.velocity = Vector3.forward * 5;</span><br><br>        <span class="hljs-comment">//5.模拟爆炸效果</span><br>        <span class="hljs-comment">//模拟爆炸的力一定是所有希望产生爆炸效果影响的对象，否则只有加了爆炸脚本的才受到影响</span><br>        <span class="hljs-comment">//都需要得到他们的刚体 来执行这个方法 才能都有效果</span><br>        <span class="hljs-comment">// 第一个参数是力的大小</span><br>        <span class="hljs-comment">// 第二个参数是爆炸中心</span><br>        <span class="hljs-comment">// 第三个参数是爆炸半径</span><br>        <span class="hljs-comment">//rigidBody.AddExplosionForce(100, Vector3.zero, 10);</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 力的几种模式</span><br><br>        <span class="hljs-comment">//第二个参数 力的模式 主要的作用 就是 计算方式不同而已</span><br>        <span class="hljs-comment">//由于4中计算方式的不同 最终的移动速度就会不同</span><br>        <span class="hljs-comment">//rigidBody.AddForce(Vector3.forward * 10, ForceMode.Acceleration);</span><br><br>        <span class="hljs-comment">//动量定理</span><br>        <span class="hljs-comment">//Ft = mv</span><br>        <span class="hljs-comment">// v = Ft/m;</span><br>        <span class="hljs-comment">//F:力</span><br>        <span class="hljs-comment">//t：时间</span><br>        <span class="hljs-comment">//m:质量</span><br>        <span class="hljs-comment">//v:速度</span><br><br>        <span class="hljs-comment">//1.Acceleration</span><br>        <span class="hljs-comment">//给物体增加一个持续的加速度，忽略其质量</span><br>        <span class="hljs-comment">//v = Ft/m</span><br>        <span class="hljs-comment">//F:(0,0,10)</span><br>        <span class="hljs-comment">//t:0.02s Fixed time</span><br>        <span class="hljs-comment">//m:默认为1，就是忽略其质量的意思</span><br>        <span class="hljs-comment">//v = 10*0.02/ 1 = 0.2m/s</span><br>        <span class="hljs-comment">//每物理帧移动0.2m/s*0.02 = 0.004m</span><br><br>        <span class="hljs-comment">//2.Force，最真实的情况</span><br>        <span class="hljs-comment">//给物体添加一个持续的力，与物体的质量有关</span><br>        <span class="hljs-comment">//v = Ft/m</span><br>        <span class="hljs-comment">//F:(0,0,10)</span><br>        <span class="hljs-comment">//t:0.02s</span><br>        <span class="hljs-comment">//m:2kg</span><br>        <span class="hljs-comment">//v = 10*0.02/ 2 = 0.1m/s</span><br>        <span class="hljs-comment">//每物理帧移动0.1m/s*0.02 = 0.002m</span><br><br>        <span class="hljs-comment">//3.Impulse</span><br>        <span class="hljs-comment">//给物体添加一个瞬间的力，与物体的质量有关,忽略时间，默认为1</span><br>        <span class="hljs-comment">//v = Ft/m</span><br>        <span class="hljs-comment">//F:(0,0,10)</span><br>        <span class="hljs-comment">//t:默认为1</span><br>        <span class="hljs-comment">//m:2kg</span><br>        <span class="hljs-comment">//v = 10*1/ 2 = 5m/s</span><br>        <span class="hljs-comment">//每物理帧移动5m/s*0.02 = 0.1m</span><br><br>        <span class="hljs-comment">//4.VelocityChange</span><br>        <span class="hljs-comment">//给物体添加一个瞬时速度，忽略质量，忽略时间</span><br>        <span class="hljs-comment">//v = Ft/m</span><br>        <span class="hljs-comment">//F:(0,0,10)</span><br>        <span class="hljs-comment">//t:默认为1</span><br>        <span class="hljs-comment">//m:默认为1</span><br>        <span class="hljs-comment">//v = 10*1/ 1 = 10m/s</span><br>        <span class="hljs-comment">//每物理帧移动10m/s*0.02 = 0.2m</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 力场脚本</span><br>        <span class="hljs-comment">// Constant Force脚本</span><br>        <span class="hljs-comment">// 脚本中可以设置，一直给予的持续力的大小，使用这个提供的脚本能够快速测试/实现其他功能</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//如果你希望即使有阻力，也希望对象一直动，那你就一直“推”就行了</span><br>        <span class="hljs-comment">//rigidBody.AddForce(Vector3.forward * 10);</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 补充 刚体的休眠</span><br>        <span class="hljs-comment">//获取刚体是否处于休眠状态 如果是</span><br>        <span class="hljs-keyword">if</span> (rigidBody.IsSleeping())<br>        &#123;<br>            <span class="hljs-comment">//就唤醒它</span><br>            rigidBody.WakeUp();<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>刚体的休眠，为了节约性能，刚体不进行计算了<br><img src="https://s2.loli.net/2024/11/26/XFodzIvPLRhOBt1.png" alt="Pasted image 20241121234518.png"></li></ul><h1 id="音频文件导入知识点"><a href="#音频文件导入知识点" class="headerlink" title="音频文件导入知识点"></a>音频文件导入知识点</h1><ul><li>这个是Unity中对mp3的一些设置<br><img src="https://s2.loli.net/2024/11/26/OlRqb9vkdpYj7mP.png" alt="Pasted image 20241122160356.png"></li><li>Force To Mono<ul><li>默认是多声道，勾选了这个选项就变成了单声道</li></ul></li><li><font color="red">Load in Background</font><ul><li>在后台加载，会新开一个线程加载音乐，如果是大音频用这个比较好，不会卡顿</li></ul></li><li>Ambisonic<ul><li>立体混响声，一般是VR才会选择这个选项，不然不会选择</li></ul></li><li><font color="red">Load Type</font><ul><li>Decompress On Load<ul><li>不压缩形式存在内存，加载块，但是内存占用高</li><li>适用于小音效</li></ul></li><li>Compress in memory<ul><li>压缩形式存在内存，加载慢，内存小</li><li>仅适用于较大音效文件</li></ul></li><li>Streaming<ul><li>以流形式存在，使用时解码。内存占用最小，cpu消耗高</li><li>性能换内存，一般内存特别紧张的时候才选这个</li></ul></li></ul></li><li><font color="red">Preload Audio Data</font><ul><li>预加载音频，勾选后进入场景就加载，不勾选，第一次使用时才加载</li><li>一般默认加载</li></ul></li><li>Compression Format<ul><li>PCM 音频以最高质量存储</li><li>Vorbis 相对PCM压缩的更小，根据质量决定</li><li>ADPCM 包含噪音，会被多次播放的声音，如碰撞声</li></ul></li><li>Quality<ul><li>音频质量</li><li>确定要应用于压缩剪辑的压缩量</li><li>不适用于PCM&#x2F;ADPCM&#x2F;HEVAG格式</li></ul></li><li>Sample Rate Setting<ul><li>PCM和ADPCM压缩格式允许自动优化或手动降低采样率</li><li>Preserve Sample Rate 此设置可保持采样率不变 (默认值)</li><li>Optimize Sample Rate  PCM和ADPCM压缩格式允许自动优化或手动降低采样率此设置根据分析的最高频率内容自动优化采样率</li><li>Override Sample Rate 此设置允许手动覆盖采样率，因此可有效地将其用于丢弃频率内容。</li></ul></li></ul><p><img src="https://s2.loli.net/2024/11/26/h4aLdzDNMCujQJr.png" alt="音频导入参数1.png"></p><p><img src="https://s2.loli.net/2024/11/26/aTSijsxnQldHY8g.png" alt="音频导入参数2.png"></p><h1 id="音频源和音频监听脚本知识点"><a href="#音频源和音频监听脚本知识点" class="headerlink" title="音频源和音频监听脚本知识点"></a>音频源和音频监听脚本知识点</h1><p><img src="https://s2.loli.net/2024/11/26/SJZbcMkeiP6tqLT.png" alt="Pasted image 20241122162845.png"></p><ul><li>AudioClip<ul><li>想要关联的音频文件</li></ul></li><li>Output<ul><li>默认会输出到Main Camera的Audio Listener脚本上</li></ul></li><li>Mute<ul><li>静音开关，如果勾选，后台的音乐会被静音</li></ul></li><li>Play On Awake<ul><li>运行时就播放，一般除了背景音乐，其他都不勾选</li></ul></li><li>Loop<ul><li>循环播放</li></ul></li><li>Priority<ul><li>优先级越高，越不容易被别的取代</li></ul></li><li>Volume<ul><li>音量大小</li></ul></li><li>Stereo Pan<ul><li>&lt;0是左声道</li><li><blockquote><p>0是右声道<br>Spatial Blend</p></blockquote></li></ul></li><li>默认是2D音效，远近声音一样大</li><li>3D音效是近大远小<br><img src="https://s2.loli.net/2024/11/26/bXwzgS27YfP1l8R.png" alt="音效源参数1.png"><br><img src="https://s2.loli.net/2024/11/26/kRAvE5gMCV8zQ4U.png" alt="音效源参数2.png"></li></ul><h1 id="Audio-Listener"><a href="#Audio-Listener" class="headerlink" title="Audio Listener"></a>Audio Listener</h1><blockquote><p>场景中一定要存在Audio Listener才能够听到声音<br>有且只有一个Audio Listener，否则会报错</p></blockquote><h1 id="代码控制音频源"><a href="#代码控制音频源" class="headerlink" title="代码控制音频源"></a>代码控制音频源</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson20</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    AudioSource audioSource;<br><br>    <span class="hljs-keyword">public</span> GameObject obj;<br><br>    <span class="hljs-keyword">public</span> AudioClip clip;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        audioSource = <span class="hljs-keyword">this</span>.GetComponent&lt;AudioSource&gt;();<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 如何动态控制音效播放</span><br>        <span class="hljs-comment">//1.直接在要播放音效的对象上挂载脚本 控制播放</span><br><br>        <span class="hljs-comment">//2.实例化挂载了音效源脚本的对象，设置了Play on Awake</span><br>        <span class="hljs-comment">//这种方法 其实用的比较少</span><br>        <span class="hljs-comment">//Instantiate(obj);</span><br><br>        <span class="hljs-comment">//3.用一个AudioSource来控制播放不同的音效</span><br>        <span class="hljs-comment">//AudioSource aus = this.gameObject.AddComponent&lt;AudioSource&gt;();</span><br>        <span class="hljs-comment">//aus.clip = clip;</span><br>        <span class="hljs-comment">//aus.Play();</span><br><br>        <span class="hljs-comment">//潜在知识点</span><br>        <span class="hljs-comment">//一个GameObject可以挂载多个 音效源脚本AudioSource</span><br>        <span class="hljs-comment">//使用时要注意 如果要挂载多个 那一定要自己管理他们 控制他们的播放 停止 不然 我们没有办法准确的获取</span><br>        <span class="hljs-comment">//谁是谁</span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 代码控制播放停止</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.P))<br>        &#123;<br>            <span class="hljs-comment">//播放音效</span><br>            audioSource.Play();<br>            <span class="hljs-comment">//延迟播放 填写的是秒数</span><br>            <span class="hljs-comment">//audioSource.PlayDelayed(5);</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.S))<br>        &#123;<br>            <span class="hljs-comment">//停止音效</span><br>            audioSource.Stop();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space))<br>        &#123;<br>            <span class="hljs-comment">//暂停，一旦暂停了，只能用audioSource.Play()或者audioSource.UnPause()来播放</span><br>            audioSource.Pause();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.X))<br>        &#123;<br>            <span class="hljs-comment">//停止暂停 和暂停后 Play效果是一样的 都会继续播放现在的音效</span><br>            audioSource.UnPause();<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 如何检测音效播放完毕</span><br>        <span class="hljs-comment">//如果你希望某一个音效播放完毕后 想要做什么事情</span><br>        <span class="hljs-comment">//那就可以在Update生命周期函数中 不停的去检测 它的 该属性</span><br>        <span class="hljs-comment">//如果是false就代表播放完毕了</span><br>        <span class="hljs-comment">// AudioSource没有提供音效播放完毕的委托</span><br>        <span class="hljs-keyword">if</span> (audioSource.isPlaying)<br>        &#123;<br>            print(<span class="hljs-string">&quot;播放中&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            print(<span class="hljs-string">&quot;播放结束&quot;</span>);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="麦克风输入相关的知识点"><a href="#麦克风输入相关的知识点" class="headerlink" title="麦克风输入相关的知识点"></a>麦克风输入相关的知识点</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Lesson21</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">private</span> AudioClip clip;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 获取设备麦克风信息</span><br>        <span class="hljs-built_in">string</span>[] strs = Microphone.devices;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.Length; i++)<br>        &#123;<br>            print(strs[i]);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 开始录制</span><br>        <span class="hljs-comment">//参数一：设备名 传空使用默认设备</span><br>        <span class="hljs-comment">//参数二：超过录制长度后是否重头录制，填true会把之前的覆盖了</span><br>        <span class="hljs-comment">//参数三：录制时长，单位是秒</span><br>        <span class="hljs-comment">//参数四：采样率</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space))<br>        &#123;<br>            <span class="hljs-comment">// 44100 Hz 是一个标准的采样率，常用于音频录制和回放。</span><br>            clip = Microphone.Start(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">10</span>, <span class="hljs-number">44100</span>);<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 结束录制</span><br>        <span class="hljs-keyword">if</span> (Input.GetKeyUp(KeyCode.Space))<br>        &#123;<br>            <span class="hljs-comment">// 结束录制</span><br>            Microphone.End(<span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">//第一次去获取没有才添加AudioSource脚本</span><br>            AudioSource s = <span class="hljs-keyword">this</span>.GetComponent&lt;AudioSource&gt;();<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span>)<br>                s = <span class="hljs-keyword">this</span>.gameObject.AddComponent&lt;AudioSource&gt;();<br>            s.clip = clip;<br>            s.Play();<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 获取音频数据用于存储或者传输</span><br>            <span class="hljs-comment">//规则 用于存储数组数据的长度 是用 声道数 * 剪辑长度</span><br>            <span class="hljs-built_in">float</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[clip.channels * clip.samples];<br>            <span class="hljs-comment">// 第一个参数是将录制的音频数据存在float数组中</span><br>            <span class="hljs-comment">// 第二个参数是偏移位置</span><br>            clip.GetData(f, <span class="hljs-number">0</span>);<br>            print(f.Length); <span class="hljs-comment">//44100 44100 Hz 是一个标准的采样率，常用于音频录制和回放。</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.yxtown.com/">游习堂</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WPF界面开发入门</title>
    <link href="/2024/11/13/WPF%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2024/11/13/WPF%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.bilibili.com/video/BV13D4y1u7XX/">【WPF入门教程 Visual Studio 2022】WPF界面开发入门</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Winform界面开发入门</title>
    <link href="/2024/11/12/Winform%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2024/11/12/Winform%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h1><table><thead><tr><th>控件名称</th><th>作用描述</th></tr></thead><tbody><tr><td><strong>Button</strong></td><td>按钮控件，触发事件或命令</td></tr><tr><td><strong>Label</strong></td><td>标签控件，显示文本或描述性信息</td></tr><tr><td><strong>TextBox</strong></td><td>文本框控件，允许用户输入或显示文本</td></tr><tr><td><strong>RichTextBox</strong></td><td>富文本框控件，支持格式化文本输入与显示</td></tr><tr><td><strong>CheckBox</strong></td><td>复选框控件，多选或布尔值选项</td></tr><tr><td><strong>RadioButton</strong></td><td>单选按钮控件，用于实现单选选项</td></tr><tr><td><strong>ListBox</strong></td><td>列表框控件，显示多项选择列表</td></tr><tr><td><strong>ComboBox</strong></td><td>组合框控件，显示下拉列表或允许输入</td></tr><tr><td><strong>PictureBox</strong></td><td>图片框控件，用于显示图像</td></tr><tr><td><strong>ProgressBar</strong></td><td>进度条控件，显示操作或加载进度</td></tr><tr><td><strong>DataGridView</strong></td><td>数据网格控件，显示、编辑表格数据</td></tr><tr><td><strong>TreeView</strong></td><td>树视图控件，以树形结构显示分级数据</td></tr><tr><td><strong>ListView</strong></td><td>列表视图控件，不同方式（图标、列表）展示数据</td></tr><tr><td><strong>Panel</strong></td><td>面板控件，用于分组或容纳其他控件</td></tr><tr><td><strong>TabControl</strong></td><td>选项卡控件，创建选项卡界面</td></tr><tr><td><strong>GroupBox</strong></td><td>分组框控件，将控件逻辑分组</td></tr><tr><td><strong>Timer</strong></td><td>定时器控件，在指定时间间隔触发事件</td></tr><tr><td><strong>TrackBar</strong></td><td>滑动条控件，在预定范围内调整数值</td></tr><tr><td><strong>NumericUpDown</strong></td><td>数字增减框控件，调整数值</td></tr><tr><td><strong>DateTimePicker</strong></td><td>日期时间选择器控件，选择日期或时间</td></tr><tr><td><strong>MenuStrip</strong></td><td>菜单条控件，创建应用程序顶部菜单栏</td></tr><tr><td><strong>ToolStrip</strong></td><td>工具条控件，创建工具栏，包含按钮或菜单项</td></tr><tr><td><strong>StatusStrip</strong></td><td>状态条控件，显示应用程序的状态信息</td></tr></tbody></table><h1 id="创建Winform项目"><a href="#创建Winform项目" class="headerlink" title="创建Winform项目"></a>创建Winform项目</h1><p><img src="https://s2.loli.net/2024/11/13/WromYGP8XBRj9Mn.png" alt="Pasted image 20241112202617.png"></p><p><img src="https://s2.loli.net/2024/11/13/9EaYdg1SnTtCAVq.png" alt="Pasted image 20241112205721.png"></p><p><img src="https://s2.loli.net/2024/11/13/GgEb4IeJyOk8HW7.png" alt="Pasted image 20241112205115.png"></p><h1 id="认识WinForm中基本创建内容"><a href="#认识WinForm中基本创建内容" class="headerlink" title="认识WinForm中基本创建内容"></a>认识WinForm中基本创建内容</h1><ul><li>Program.cs<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">StudyWinform</span><br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 应用程序的主入口点。</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        [<span class="hljs-meta">STAThread</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// [STAThread]：这个属性表明应用程序的主线程是单线程单元（Single Thread Apartment）模式。对于 Windows 窗体应用程序，这是一个常见要求，因为它保证 UI 组件在线程间的安全访问。</span><br>            <span class="hljs-comment">// Application.EnableVisualStyles()：启用应用程序的视觉样式，使应用程序中的控件以系统主题的样式呈现，提供更现代的外观。</span><br>            <span class="hljs-comment">// Application.SetCompatibleTextRenderingDefault(false)：指定应用程序中使用的文本渲染方式。false 表示使用 GDI+渲染文本，通常适用于 Windows 窗体应用的默认设置。</span><br>            <span class="hljs-comment">// Application.Run(new Form1())：启动应用程序的主窗口，并将 Form1 作为主窗体加载。Application.Run() 方法会启动消息循环（Message Loop），保持应用程序运行，直到用户关闭 Form1。</span><br>            Application.EnableVisualStyles();<br>            Application.SetCompatibleTextRenderingDefault(<span class="hljs-literal">false</span>);<br>            Application.Run(<span class="hljs-keyword">new</span> Form1());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2024/11/13/tBL8TGbR7udsIN9.png" alt="Pasted image 20241112205843.png"></p><p><img src="https://s2.loli.net/2024/11/13/9OTvyhQKgswe2VU.png" alt="Pasted image 20241112210057.png"></p><p><img src="https://s2.loli.net/2024/11/13/3fvStZk6ITrcFz9.png" alt="Pasted image 20241112210139.png"></p><p><img src="https://s2.loli.net/2024/11/13/dC7rlROJFqByu21.png" alt="Pasted image 20241112210302.png"></p><p><img src="https://s2.loli.net/2024/11/13/uMzpySP92FfHxgh.png" alt="Pasted image 20241112210431.png"></p><ul><li>是两个分部类，分部类不知道的看之前的C#笔记<br><img src="https://s2.loli.net/2024/11/13/G47irLDSkFKzmfO.png" alt="Pasted image 20241112210738.png"><br><img src="https://s2.loli.net/2024/11/13/D7I9fiFHGqVcjAn.png" alt="Pasted image 20241112210751.png"></li></ul><h1 id="工具箱的位置"><a href="#工具箱的位置" class="headerlink" title="工具箱的位置"></a>工具箱的位置</h1><p><img src="https://s2.loli.net/2024/11/13/WVGqBuditxk6beM.png" alt="Pasted image 20241112211805.png"><br><img src="https://s2.loli.net/2024/11/13/aRPNWOLHYFB7ovu.png" alt="Pasted image 20241112211949.png"></p><h1 id="实际WinForm操作（可视化）"><a href="#实际WinForm操作（可视化）" class="headerlink" title="实际WinForm操作（可视化）"></a>实际WinForm操作（可视化）</h1><ul><li>实际操作开始了<br><img src="https://s2.loli.net/2024/11/13/veIElrF3tySqw1V.png" alt="Pasted image 20241112213250.png"></li><li>双击这个按钮，能够跳转到代码编写部分（话说之前需要写界面的时候就试试C#了，比java的windowsbuilder要简单啊）<br><img src="https://s2.loli.net/2024/11/13/dMQAyskcNFtrHUz.png" alt="Pasted image 20241112213318.png"></li><li>这个(Name)其实就是这个按钮在代码中的变量名<br><img src="https://s2.loli.net/2024/11/13/i6nPH3Q1qOfvYCl.png" alt="Pasted image 20241112213711.png"></li></ul><p><img src="https://s2.loli.net/2024/11/13/bN5cj1COZ6EFwmM.png" alt="Pasted image 20241112214231.png"></p><h1 id="实际WinForm操作（代码）"><a href="#实际WinForm操作（代码）" class="headerlink" title="实际WinForm操作（代码）"></a>实际WinForm操作（代码）</h1><ul><li>给Click事件添加了一个委托，委托里面注册的是this.button1_Click()函数</li><li>点击事件触发时，就会调用button1_Click()函数<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">this</span>.button1.Click += <span class="hljs-keyword">new</span> System.EventHandler(<span class="hljs-keyword">this</span>.button1_Click);<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">button1_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/13/98bkjxYLmnBXZfl.png" alt="Pasted image 20241112215708.png"></p><ul><li><p>创建一个按钮，并且进行操作的代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeComponent</span>()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个新的 Button 控件实例，赋值给 button1 字段</span><br>    <span class="hljs-keyword">this</span>.button1 = <span class="hljs-keyword">new</span> System.Windows.Forms.Button();<br>    <span class="hljs-keyword">this</span>.SuspendLayout(); <span class="hljs-comment">// 暂停布局逻辑，用于批量设置控件属性</span><br>    <br>    <span class="hljs-comment">// 设置 button1 的外观和行为属性</span><br>    <span class="hljs-keyword">this</span>.button1.ForeColor = System.Drawing.SystemColors.ControlText; <span class="hljs-comment">// 设置按钮文本颜色</span><br>    <span class="hljs-keyword">this</span>.button1.Location = <span class="hljs-keyword">new</span> System.Drawing.Point(<span class="hljs-number">173</span>, <span class="hljs-number">109</span>); <span class="hljs-comment">// 按钮位置 (x:173, y:109)</span><br>    <span class="hljs-keyword">this</span>.button1.Name = <span class="hljs-string">&quot;button1&quot;</span>; <span class="hljs-comment">// 控件名称，用于代码中引用</span><br>    <span class="hljs-keyword">this</span>.button1.Size = <span class="hljs-keyword">new</span> System.Drawing.Size(<span class="hljs-number">103</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// 控件大小 (宽:103, 高:42)</span><br>    <span class="hljs-keyword">this</span>.button1.TabIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// Tab 键的顺序</span><br>    <span class="hljs-keyword">this</span>.button1.Text = <span class="hljs-string">&quot;第一个按钮&quot;</span>; <span class="hljs-comment">// 按钮上显示的文本</span><br>    <span class="hljs-keyword">this</span>.button1.UseVisualStyleBackColor = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 启用按钮的系统视觉样式</span><br><br>    <span class="hljs-comment">// 事件绑定 - 设置点击和鼠标进入事件的处理方法</span><br>    <span class="hljs-keyword">this</span>.button1.Click += <span class="hljs-keyword">new</span> System.EventHandler(<span class="hljs-keyword">this</span>.button1_Click); <span class="hljs-comment">// 点击事件，调用 button1_Click</span><br>    <span class="hljs-keyword">this</span>.button1.MouseEnter += <span class="hljs-keyword">new</span> System.EventHandler(<span class="hljs-keyword">this</span>.button1_MouseEnter); <span class="hljs-comment">// 鼠标进入事件，调用 button1_MouseEnter</span><br><br>    <span class="hljs-comment">// 窗体的其他属性设置</span><br>    <span class="hljs-keyword">this</span>.AutoScaleDimensions = <span class="hljs-keyword">new</span> System.Drawing.SizeF(<span class="hljs-number">6F</span>, <span class="hljs-number">12F</span>); <span class="hljs-comment">// 缩放尺寸</span><br>    <span class="hljs-keyword">this</span>.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font; <span class="hljs-comment">// 缩放模式</span><br>    <span class="hljs-keyword">this</span>.ClientSize = <span class="hljs-keyword">new</span> System.Drawing.Size(<span class="hljs-number">863</span>, <span class="hljs-number">427</span>); <span class="hljs-comment">// 设置窗体的宽度和高度</span><br>    <span class="hljs-keyword">this</span>.Controls.Add(<span class="hljs-keyword">this</span>.button1); <span class="hljs-comment">// 将 button1 添加到窗体的控件集合中</span><br>    <span class="hljs-keyword">this</span>.Name = <span class="hljs-string">&quot;Form1&quot;</span>; <span class="hljs-comment">// 窗体名称</span><br>    <span class="hljs-keyword">this</span>.Text = <span class="hljs-string">&quot;Form1&quot;</span>; <span class="hljs-comment">// 窗体标题栏显示的文本</span><br><br>    <span class="hljs-keyword">this</span>.ResumeLayout(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 恢复布局逻辑</span><br>&#125;<br><br><span class="hljs-comment">// 字段定义一个button1的按钮变量</span><br><span class="hljs-keyword">private</span> System.Windows.Forms.Button button1;<br></code></pre></td></tr></table></figure></li><li><p>子集实例化按钮的例子</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">StudyWinform</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// InitializeComponent();</span><br><br>            <span class="hljs-comment">// 手动创建5个按钮</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>            &#123;<br>                Button button = <span class="hljs-keyword">new</span> Button();<br>                button.Text = <span class="hljs-string">&quot;按钮&quot;</span> + i.ToString();<br>                <span class="hljs-comment">// Point是一个struct，即他是一个值类型</span><br>                <span class="hljs-comment">// Location是一个Point类型的属性，get回来的是值在栈上的副本，并不是引用</span><br>                <span class="hljs-comment">// 所以Location.X的修改是对值类型副本的修改，而非值本身的修改，是无意义的，故提示错误。</span><br>                <span class="hljs-comment">// button.Location.X = 50;</span><br>                button.Location = <span class="hljs-keyword">new</span> Point(i * <span class="hljs-number">50</span>, <span class="hljs-number">0</span>);<br>                button.Size = <span class="hljs-keyword">new</span> Size(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);<br>                <span class="hljs-comment">// 两个效果一样</span><br>                <span class="hljs-comment">//button.Click += Button_Click;</span><br>                button.Click += <span class="hljs-keyword">new</span> EventHandler(Button_Click);<br>                <span class="hljs-comment">// button.Click += Button_Click;</span><br>                <span class="hljs-comment">// 利用了编译器的简化语法，直接添加了 Button_Click 方法</span><br>                <span class="hljs-comment">// 编译器会自动推断 Button_Click 是符合 EventHandler 委托类型的</span><br>                <span class="hljs-comment">// 所以可以简化写法，不用显式创建 EventHandler 对象。</span><br>                <span class="hljs-comment">// button.Click += new EventHandler(Button_Click);</span><br>                <span class="hljs-comment">// 这是显式写法，明确创建一个 EventHandler 实例并将 Button_Click 方法作为参数传递进去</span><br>                <span class="hljs-comment">// 这种写法更详细，但在功能上没有任何额外效果</span><br><br>                <span class="hljs-keyword">this</span>.Controls.Add(button);<br><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>        MessageBox.Show(<span class="hljs-string">&quot;我被点击了&quot;</span>);<br>            Button button = sender <span class="hljs-keyword">as</span> Button;<br>            button.Text = <span class="hljs-string">&quot;被点击&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置字体</p></li><li><p>后续还有好多都是类似的，除非很重要或者特殊，不然不展示了<br><img src="https://s2.loli.net/2024/11/13/ABDfLHye4uascJ6.png" alt="Pasted image 20241112230046.png"></p></li></ul><p><img src="https://s2.loli.net/2024/11/13/FHmcEfPouBYOb7a.png" alt="Pasted image 20241112230056.png"></p><ul><li><p>可以将输入变成*的属性设置<br><img src="https://s2.loli.net/2024/11/13/237HDg6wvKOduai.png" alt="Pasted image 20241112230800.png"></p></li><li><p>新建窗体<br><img src="https://s2.loli.net/2024/11/13/CasW3drJEAbqilO.png" alt="Pasted image 20241112231425.png"><br><img src="https://s2.loli.net/2024/11/13/5QKcb9PMT71Z68l.png" alt="Pasted image 20241112231453.png"></p></li></ul><p><img src="https://s2.loli.net/2024/11/13/hm7NPTSguWJO8CY.png" alt="Pasted image 20241112231511.png"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// InitializeComponent();</span><br><br>        <span class="hljs-comment">// 手动创建5个按钮</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Button button = <span class="hljs-keyword">new</span> Button();<br>            button.Text = <span class="hljs-string">&quot;按钮&quot;</span> + i.ToString();<br>            <span class="hljs-comment">// Point是一个struct，即他是一个值类型</span><br>            <span class="hljs-comment">// Location是一个Point类型的属性，get回来的是值在栈上的副本，并不是引用</span><br>            <span class="hljs-comment">// 所以Location.X的修改是对值类型副本的修改，而非值本身的修改，是无意义的，故提示错误。</span><br>            <span class="hljs-comment">// button.Location.X = 50;</span><br>            button.Location = <span class="hljs-keyword">new</span> Point(i * <span class="hljs-number">50</span>, <span class="hljs-number">0</span>);<br>            button.Size = <span class="hljs-keyword">new</span> Size(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);<br>            <span class="hljs-comment">// 两个效果一样</span><br>            <span class="hljs-comment">//button.Click += Button_Click;</span><br>            button.Click += <span class="hljs-keyword">new</span> EventHandler(Button_Click);<br>            <span class="hljs-comment">// button.Click += Button_Click;</span><br>            <span class="hljs-comment">// 利用了编译器的简化语法，直接添加了 Button_Click 方法</span><br>            <span class="hljs-comment">// 编译器会自动推断 Button_Click 是符合 EventHandler 委托类型的</span><br>            <span class="hljs-comment">// 所以可以简化写法，不用显式创建 EventHandler 对象。</span><br>            <span class="hljs-comment">// button.Click += new EventHandler(Button_Click);</span><br>            <span class="hljs-comment">// 这是显式写法，明确创建一个 EventHandler 实例并将 Button_Click 方法作为参数传递进去</span><br>            <span class="hljs-comment">// 这种写法更详细，但在功能上没有任何额外效果</span><br><br>            <span class="hljs-keyword">this</span>.Controls.Add(button);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Button_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// MessageBox.Show(&quot;按钮被点击了&quot;);</span><br>        Button button = sender <span class="hljs-keyword">as</span> Button;<br>        button.Text = <span class="hljs-string">&quot;被点击&quot;</span>;<br>        <span class="hljs-comment">// Application.Run(new Index())：</span><br>        <span class="hljs-comment">// 启动消息循环，显示窗体，并让应用程序保持运行直到窗体关闭。</span><br>        <span class="hljs-comment">// new Index().Show()：</span><br>        <span class="hljs-comment">// 仅显示窗体，且不启动消息循环，程序仍然会继续执行。</span><br>        <span class="hljs-comment">// 表示一个新窗口，一个线程上只能有一个，使用会报错，关闭主窗口，子窗口也会关闭</span><br>        <span class="hljs-comment">// Application.Run(new Index());</span><br>        <span class="hljs-keyword">new</span> Index().Show();<br>        <span class="hljs-comment">// 这里this是表示Main里面的new Form1()</span><br>        <span class="hljs-comment">// 隐藏主窗口</span><br>        <span class="hljs-keyword">this</span>.Hide();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="设置子窗口关闭时关闭主窗口"><a href="#设置子窗口关闭时关闭主窗口" class="headerlink" title="设置子窗口关闭时关闭主窗口"></a>设置子窗口关闭时关闭主窗口</h1><ul><li>新建的Index窗口添加这个事件</li><li>关闭的时候关闭所有程序<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">this</span>.FormClosed += <span class="hljs-keyword">new</span> System.Windows.Forms.FormClosedEventHandler(<span class="hljs-keyword">this</span>.Index_FormClosed);<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Index_FormClosed</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, FormClosedEventArgs e</span>)</span><br>&#123;<br><span class="hljs-comment">// 让整个程序全部退出</span><br>Application.Exit();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="GDI"><a href="#GDI" class="headerlink" title="GDI"></a>GDI</h1><ul><li>GDI绘图的基本步骤</li></ul><ol><li>在窗体或者空间上创建画家（确定画在哪里，由谁来画）</li><li>创建或使用已有的画笔或画刷、以及要画图像相关的坐标点</li><li>使用画家对象的相关方法绘制图像</li><li>销毁画家及画笔等</li></ol><ul><li>需要放在From中的Paint事件中<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.ComponentModel;<br><span class="hljs-keyword">using</span> System.Data;<br><span class="hljs-keyword">using</span> System.Drawing;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">using</span> System.Windows.Forms;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">StudyWinform</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            InitializeComponent();<br>            <span class="hljs-keyword">this</span>.Paint += Form1_Paint;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_Paint</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, PaintEventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 使用Paint事件传递的Graphics对象，避免手动释放资源</span><br>            Graphics g = e.Graphics;<br>            <span class="hljs-comment">// 创建一个画笔</span><br>            <span class="hljs-keyword">using</span> (Pen pen = <span class="hljs-keyword">new</span> Pen(Color.Red, <span class="hljs-number">5</span>))<br>            &#123;<br>                <span class="hljs-comment">// 准备两个点</span><br>                Point p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">50</span>, <span class="hljs-number">80</span>);<br>                Point p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">250</span>, <span class="hljs-number">80</span>);<br><br>                <span class="hljs-comment">// 画直线</span><br>                g.DrawLine(pen, p1, p2);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="俄罗斯方块（联网）"><a href="#俄罗斯方块（联网）" class="headerlink" title="俄罗斯方块（联网）"></a>俄罗斯方块（联网）</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.bilibili.com/video/BV1JY4y1G7jo">【Winform入门教程 Visual Studio 2022】Winform界面开发入门</a><br><a href="https://zhuanlan.zhihu.com/p/483896504">中国象棋游戏开发实战（C#）</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>知识点三_网络编程相关知识(Cpp)</title>
    <link href="/2024/11/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86(Cpp)/"/>
    <url>/2024/11/05/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86(Cpp)/</url>
    
    <content type="html"><![CDATA[<h1 id="网络编程的基础知识，socket的库函数"><a href="#网络编程的基础知识，socket的库函数" class="headerlink" title="网络编程的基础知识，socket的库函数"></a>网络编程的基础知识，socket的库函数</h1><ul><li><p>网络通讯是指两台计算机中的程序进行数据传输的过程</p></li><li><p>客户程序（端）：指主动发起通讯的程序</p></li><li><p>服务程序（端&#x2F;器）：指被动的等待，然后为向它发起通讯的客户端提供服务</p></li><li><p>demo1.cpp</p></li><li><p>客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo1.cpp，此程序用于演示socket的客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo1 服务端的IP 服务端的端口\nExample:./demo1 192.168.101.139 5005\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第1步：创建客户端的socket。</span><br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第2步：向服务器发起连接请求。</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span> *h;                     <span class="hljs-comment">// 用于存放服务端IP的结构体。</span><br>    <span class="hljs-keyword">if</span> ((h = <span class="hljs-built_in">gethostbyname</span>(argv[<span class="hljs-number">1</span>])) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 把字符串格式的IP转换成结构体。</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;gethostbyname failed.\n&quot;</span><br>             &lt;&lt; endl;<br>        <span class="hljs-built_in">close</span>(sockfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放服务端IP和端口的结构体。</span><br>    <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>    servaddr.sin_family = AF_INET;<br>    <span class="hljs-built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length); <span class="hljs-comment">// 指定服务端的IP地址。</span><br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));           <span class="hljs-comment">// 指定服务端的通信端口。</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) != <span class="hljs-number">0</span>) <span class="hljs-comment">// 向服务端发起连接清求。</span><br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sockfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第3步：与服务端通讯，客户发送一个请求报文后等待服务端的回复，收到回复后，再发下一个请求报文。</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">3</span>; ii++) <span class="hljs-comment">// 循环3次，将与服务端进行三次通讯。</span><br>    &#123;<br>        <span class="hljs-type">int</span> iret;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-built_in">sprintf</span>(buffer, <span class="hljs-string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>, ii + <span class="hljs-number">1</span>, ii + <span class="hljs-number">1</span>); <span class="hljs-comment">// 生成请求报文内容。</span><br>        <span class="hljs-comment">// 向服务端发送请求报文。</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">send</span>(sockfd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-comment">// 接收服务端的回应报文，如果服务端没有发送回应报文，recv()函数将阻塞等待。</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">recv</span>(sockfd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 第4步：关闭socket，释放资源。</span><br>    <span class="hljs-built_in">close</span>(sockfd);<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>服务端</p></li><li><p>demo2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo2.cpp，此程序用于演示socket通信的服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo2 通讯端口\nExample:./demo2 5005\n\n&quot;</span>; <span class="hljs-comment">// 端口大于1024，不与其它的重复。</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;注意：运行服务端程序的Linux系统的防火墙必须要开通5005端口。\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;      如果是云服务器，还要开通云平台的访问策略。\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第1步：创建服务端的socket。</span><br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (listenfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第2步：把服务端用于通信的IP和端口绑定到socket上。</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放服务端IP和端口的数据结构。</span><br>    <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>    servaddr.sin_family = AF_INET;                <span class="hljs-comment">// 指定协议。</span><br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); <span class="hljs-comment">// 服务端任意网卡的IP都可以用于通讯。</span><br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));     <span class="hljs-comment">// 指定通信端口，普通用户只能用1024以上的端口。</span><br>    <span class="hljs-comment">// 绑定服务端的IP和端口。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第3步：把socket设置为可连接（监听）的状态。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第4步：受理客户端的连接请求，如果没有客户端连上来，accept()函数将阻塞等待。</span><br>    <span class="hljs-type">int</span> clientfd = <span class="hljs-built_in">accept</span>(listenfd, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (clientfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;客户端已连接。\n&quot;</span>;<br><br>    <span class="hljs-comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> iret;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-comment">// 接收客户端的请求报文，如果客户端没有发送请求报文，recv()函数将阻塞等待。</span><br>        <span class="hljs-comment">// 如果客户端已断开连接，recv()函数将返回0,直接退出服务端</span><br>        <span class="hljs-comment">// 如果 iret &gt; 0，表示成功接收到数据，返回的是接收到的字节数。</span><br>        <span class="hljs-comment">// 如果 iret == 0，表示连接已关闭，数据传输结束。</span><br>        <span class="hljs-comment">// 如果 iret &lt; 0，则发生错误。常见错误可能是网络问题或对方异常断开连接。</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">recv</span>(clientfd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">&quot;ok&quot;</span>); <span class="hljs-comment">// 生成回应报文内容。</span><br>        <span class="hljs-comment">// 向客户端发送回应报文。</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">send</span>(clientfd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 第6步：关闭socket，释放资源。</span><br>    <span class="hljs-built_in">close</span>(listenfd); <span class="hljs-comment">// 关闭服务端用于监听的socket。</span><br>    <span class="hljs-built_in">close</span>(clientfd); <span class="hljs-comment">// 关闭客户端连上来的socket。</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>客户端，封装成类了<br>demo7.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo7.cpp，此程序用于演示封装socket通讯的客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ctcpclient</span> <span class="hljs-comment">// TCP通讯的客户端类。</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_clientfd;        <span class="hljs-comment">// 客户端的socket，-1表示未连接或连接已断开；&gt;=0表示有效的socket。</span><br>    string m_ip;           <span class="hljs-comment">// 服务端的IP/域名。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_port; <span class="hljs-comment">// 通讯端口。</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ctcpclient</span>() : <span class="hljs-built_in">m_clientfd</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 向服务端发起连接请求，成功返回true，失败返回false。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;in_ip, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> in_port)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果socket已连接，直接返回失败。</span><br><br>        m_ip = in_ip;<br>        m_port = in_port; <span class="hljs-comment">// 把服务端的IP和端口保存到成员变量中。</span><br><br>        <span class="hljs-comment">// 第1步：创建客户端的socket。</span><br>        <span class="hljs-keyword">if</span> ((m_clientfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 第2步：向服务器发起连接请求。</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放协议、端口和IP地址的结构体。</span><br>        <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>        servaddr.sin_family = AF_INET;     <span class="hljs-comment">// ①协议族，固定填AF_INET。</span><br>        servaddr.sin_port = <span class="hljs-built_in">htons</span>(m_port); <span class="hljs-comment">// ②指定服务端的通信端口。</span><br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span> *h;                                <span class="hljs-comment">// 用于存放服务端IP地址(大端序)的结构体的指针。</span><br>        <span class="hljs-keyword">if</span> ((h = <span class="hljs-built_in">gethostbyname</span>(m_ip.<span class="hljs-built_in">c_str</span>())) == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 把域名/主机名/字符串格式的IP转换成结构体。</span><br>        &#123;<br>            <span class="hljs-comment">// 调用系统库函数加::</span><br>            ::<span class="hljs-built_in">close</span>(m_clientfd);<br>            m_clientfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length); <span class="hljs-comment">// ③指定服务端的IP(大端序)。</span><br><br>        <span class="hljs-comment">// 向服务端发起连接清求。</span><br>        <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">connect</span>(m_clientfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            ::<span class="hljs-built_in">close</span>(m_clientfd);<br>            m_clientfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 向服务端发送报文，成功返回true，失败返回false。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;buffer)</span> <span class="hljs-comment">// buffer不要用const char *，定义为const string&amp;既支持string类型，也支持C风格的字符串，定义成const char*则不支持string</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果socket的状态是未连接，直接返回失败。</span><br>                          <span class="hljs-comment">//::send：调用全局的 send 函数，避免在当前作用域或命名空间中出现同名的 send 影响调用。</span><br>                          <span class="hljs-comment">// m_clientfd：是目标客户端的文件描述符。</span><br>                          <span class="hljs-comment">// buffer.data()：获取数据缓冲区的指针，即需要发送的数据的起始地址。</span><br>                          <span class="hljs-comment">// buffer.size()：指定发送的数据长度。</span><br>                          <span class="hljs-comment">// 0：是发送标志位，在这里使用 0 表示默认行为。</span><br>        <span class="hljs-keyword">if</span> ((::<span class="hljs-built_in">send</span>(m_clientfd, buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收服务端的报文，成功返回true，失败返回false。</span><br>    <span class="hljs-comment">// buffer-存放接收到的报文的内容，maxlen-本次接收报文的最大长度。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recv</span><span class="hljs-params">(string &amp;buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxlen)</span></span><br><span class="hljs-function">    </span>&#123;                                                                 <span class="hljs-comment">// 如果直接操作string对象的内存，必须保证：1)不能越界；2）操作后手动设置数据的大小。</span><br>                                                                      <span class="hljs-comment">// 因为是直接操作string对象的内存，因为传递了首地址，直接操控了string对象的内存，所以需要手动设置数据的大小。如果通过string类的成员函数操控string对象，会自动设置数据的大小。</span><br>        buffer.<span class="hljs-built_in">clear</span>();                                               <span class="hljs-comment">// 清空容器。</span><br>        buffer.<span class="hljs-built_in">resize</span>(maxlen);                                        <span class="hljs-comment">// 设置容器的大小为maxlen。</span><br>                                                                      <span class="hljs-comment">// 这里获取首地址可以用buffer.c_str(),buffer.data()不过这些都是const，&amp;buffer[0]是非const</span><br>                                                                      <span class="hljs-comment">// readn -1失败，0 socker连接已断开，&gt;0成功收到了数据，是数据的大小</span><br>        <span class="hljs-type">int</span> readn = ::<span class="hljs-built_in">recv</span>(m_clientfd, &amp;buffer[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 直接操作buffer的内存。</span><br>        <span class="hljs-keyword">if</span> (readn &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            buffer.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;                     <span class="hljs-comment">// 清空string的大小，大小变为0，并释放存储字符内容的空间，否则大小为maxlen</span><br>        buffer.<span class="hljs-built_in">resize</span>(readn); <span class="hljs-comment">// 重置buffer的实际大小。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 断开与服务端的连接。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果socket的状态是未连接，直接返回失败。</span><br><br>        ::<span class="hljs-built_in">close</span>(m_clientfd);<br>        m_clientfd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ctcpclient</span>() &#123; <span class="hljs-built_in">close</span>(); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo7 服务端的IP 服务端的端口\nExample:./demo7 192.168.101.138 5005\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    ctcpclient tcpclient;<br>    <span class="hljs-keyword">if</span> (tcpclient.<span class="hljs-built_in">connect</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>])) == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 向服务端发起连接请求。</span><br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第3步：与服务端通讯，客户发送一个请求报文后等待服务端的回复，收到回复后，再发下一个请求报文。</span><br>    string buffer;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">10</span>; ii++) <span class="hljs-comment">// 循环3次，将与服务端进行三次通讯。</span><br>    &#123;<br>        buffer = <span class="hljs-string">&quot;这是第&quot;</span> + <span class="hljs-built_in">to_string</span>(ii + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个超级女生，编号&quot;</span> + <span class="hljs-built_in">to_string</span>(ii + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;。&quot;</span>;<br>        <span class="hljs-comment">// 向服务端发送请求报文。</span><br>        <span class="hljs-keyword">if</span> (tcpclient.<span class="hljs-built_in">send</span>(buffer) == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 接收服务端的回应报文，如果服务端没有发送回应报文，recv()函数将阻塞等待。</span><br>        <span class="hljs-keyword">if</span> (tcpclient.<span class="hljs-built_in">recv</span>(buffer, <span class="hljs-number">1024</span>) == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;recv()&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>服务端，封装成类了<br>demo8.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo8.cpp，此程序用于演示封装socket通讯的服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ctcpserver</span> <span class="hljs-comment">// TCP通讯的服务端类。</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_listenfd;        <span class="hljs-comment">// 监听的socket，-1表示未初始化。</span><br>    <span class="hljs-type">int</span> m_clientfd;        <span class="hljs-comment">// 客户端连上来的socket，-1表示客户端未连接。</span><br>    string m_clientip;     <span class="hljs-comment">// 客户端字符串格式的IP。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_port; <span class="hljs-comment">// 服务端用于通讯的端口。</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ctcpserver</span>() : <span class="hljs-built_in">m_listenfd</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">m_clientfd</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> in_port)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 第1步：创建服务端的socket。</span><br>        <span class="hljs-keyword">if</span> ((m_listenfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        m_port = in_port;<br><br>        <span class="hljs-comment">// 第2步：把服务端用于通信的IP和端口绑定到socket上。</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放协议、端口和IP地址的结构体。</span><br>        <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>        servaddr.sin_family = AF_INET;                <span class="hljs-comment">// ①协议族，固定填AF_INET。</span><br>        servaddr.sin_port = <span class="hljs-built_in">htons</span>(m_port);            <span class="hljs-comment">// ②指定服务端的通信端口。</span><br>        servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); <span class="hljs-comment">// ③如果操作系统有多个IP，全部的IP都可以用于通讯。</span><br><br>        <span class="hljs-comment">// 绑定服务端的IP和端口（为socket分配IP和端口）。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">close</span>(m_listenfd);<br>            m_listenfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 第3步：把socket设置为可连接（监听）的状态。listen(m_listenfd, 5) 将套接字 m_listenfd 设置为被动监听状态，以便接受客户端连接。5 表示等待连接的队列大小，即最多允许 5 个连接排队</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(m_listenfd, <span class="hljs-number">5</span>) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">close</span>(m_listenfd);<br>            m_listenfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 受理客户端的连接（从已连接的客户端中取出一个客户端），</span><br>    <span class="hljs-comment">// 如果没有已连接的客户端，accept()函数将阻塞等待。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> caddr;          <span class="hljs-comment">// 客户端的地址信息。</span><br>        <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">sizeof</span>(caddr); <span class="hljs-comment">// struct sockaddr_in的大小。</span><br>                                           <span class="hljs-comment">// ::accept()的第二第三个参数为空，表示不关心客户端的地址信息，如果想要知道客户端的地址信息，第二个参数传入客户端地址信息的地址，第三个参数传入客户端地址的大小的地址</span><br>        <span class="hljs-keyword">if</span> ((m_clientfd = ::<span class="hljs-built_in">accept</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;caddr, &amp;addrlen)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        m_clientip = <span class="hljs-built_in">inet_ntoa</span>(caddr.sin_addr); <span class="hljs-comment">// 把客户端的地址从大端序转换成字符串。无论在大端序还是小端序系统上，inet_ntoa 都可以正确将 caddr.sin_addr 转换成字符串格式的 IP 地址</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取客户端的IP(字符串格式)。</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">clientip</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_clientip;<br>    &#125;<br><br>    <span class="hljs-comment">// 向对端发送报文，成功返回true，失败返回false。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;buffer)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> ((::<span class="hljs-built_in">send</span>(m_clientfd, buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收对端的报文，成功返回true，失败返回false。</span><br>    <span class="hljs-comment">// buffer-存放接收到的报文的内容，maxlen-本次接收报文的最大长度。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recv</span><span class="hljs-params">(string &amp;buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxlen)</span></span><br><span class="hljs-function">    </span>&#123;<br>        buffer.<span class="hljs-built_in">clear</span>();                                               <span class="hljs-comment">// 清空容器。</span><br>        buffer.<span class="hljs-built_in">resize</span>(maxlen);                                        <span class="hljs-comment">// 设置容器的大小为maxlen。</span><br>        <span class="hljs-type">int</span> readn = ::<span class="hljs-built_in">recv</span>(m_clientfd, &amp;buffer[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 直接操作buffer的内存。</span><br>        <span class="hljs-keyword">if</span> (readn &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            buffer.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        buffer.<span class="hljs-built_in">resize</span>(readn); <span class="hljs-comment">// 重置buffer的实际大小。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭监听的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">closelisten</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_listenfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ::<span class="hljs-built_in">close</span>(m_listenfd);<br>        m_listenfd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭客户端连上来的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">closeclient</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ::<span class="hljs-built_in">close</span>(m_clientfd);<br>        m_clientfd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ctcpserver</span>()<br>    &#123;<br>        <span class="hljs-built_in">closelisten</span>();<br>        <span class="hljs-built_in">closeclient</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo8 通讯端口\nExample:./demo8 5005\n\n&quot;</span>; <span class="hljs-comment">// 端口大于1024，不与其它的重复。</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;注意：运行服务端程序的Linux系统的防火墙必须要开通5005端口。\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;      如果是云服务器，还要开通云平台的访问策略。\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    ctcpserver tcpserver;<br>    <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">initserver</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>])) == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;initserver()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 受理客户端的连接（从已连接的客户端中取出一个客户端），</span><br>    <span class="hljs-comment">// 如果没有已连接的客户端，accept()函数将阻塞等待。</span><br>    <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">accept</span>() == <span class="hljs-literal">false</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;客户端已连接(&quot;</span> &lt;&lt; tcpserver.<span class="hljs-built_in">clientip</span>() &lt;&lt; <span class="hljs-string">&quot;)。\n&quot;</span>;<br><br>    string buffer;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">// 接收对端的报文，如果对端没有发送报文，recv()函数将阻塞等待。</span><br>        <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">recv</span>(buffer, <span class="hljs-number">1024</span>) == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;recv()&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        buffer = <span class="hljs-string">&quot;ok&quot;</span>;<br>        <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">send</span>(buffer) == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 向对端发送报文。</span><br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>多线程的服务端<br>demo10.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo10.cpp，此程序用于演示多进程的socket服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ctcpserver</span> <span class="hljs-comment">// TCP通讯的服务端类。</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_listenfd;        <span class="hljs-comment">// 监听的socket，-1表示未初始化。</span><br>    <span class="hljs-type">int</span> m_clientfd;        <span class="hljs-comment">// 客户端连上来的socket，-1表示客户端未连接。</span><br>    string m_clientip;     <span class="hljs-comment">// 客户端字符串格式的IP。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_port; <span class="hljs-comment">// 服务端用于通讯的端口。</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ctcpserver</span>() : <span class="hljs-built_in">m_listenfd</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">m_clientfd</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> in_port)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 第1步：创建服务端的socket。</span><br>        <span class="hljs-keyword">if</span> ((m_listenfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        m_port = in_port;<br><br>        <span class="hljs-comment">// 第2步：把服务端用于通信的IP和端口绑定到socket上。</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放协议、端口和IP地址的结构体。</span><br>        <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>        servaddr.sin_family = AF_INET;                <span class="hljs-comment">// ①协议族，固定填AF_INET。</span><br>        servaddr.sin_port = <span class="hljs-built_in">htons</span>(m_port);            <span class="hljs-comment">// ②指定服务端的通信端口。</span><br>        servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); <span class="hljs-comment">// ③如果操作系统有多个IP，全部的IP都可以用于通讯。</span><br><br>        <span class="hljs-comment">// 绑定服务端的IP和端口（为socket分配IP和端口）。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">close</span>(m_listenfd);<br>            m_listenfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 第3步：把socket设置为可连接（监听）的状态。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(m_listenfd, <span class="hljs-number">5</span>) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">close</span>(m_listenfd);<br>            m_listenfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 受理客户端的连接（从已连接的客户端中取出一个客户端），</span><br>    <span class="hljs-comment">// 如果没有已连接的客户端，accept()函数将阻塞等待。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> caddr;          <span class="hljs-comment">// 客户端的地址信息。</span><br>        <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">sizeof</span>(caddr); <span class="hljs-comment">// struct sockaddr_in的大小。</span><br>        <span class="hljs-keyword">if</span> ((m_clientfd = ::<span class="hljs-built_in">accept</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;caddr, &amp;addrlen)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        m_clientip = <span class="hljs-built_in">inet_ntoa</span>(caddr.sin_addr); <span class="hljs-comment">// 把客户端的地址从大端序转换成字符串。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取客户端的IP(字符串格式)。</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">clientip</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_clientip;<br>    &#125;<br><br>    <span class="hljs-comment">// 向对端发送报文，成功返回true，失败返回false。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;buffer)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> ((::<span class="hljs-built_in">send</span>(m_clientfd, buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收对端的报文，成功返回true，失败返回false。</span><br>    <span class="hljs-comment">// buffer-存放接收到的报文的内容，maxlen-本次接收报文的最大长度。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recv</span><span class="hljs-params">(string &amp;buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxlen)</span></span><br><span class="hljs-function">    </span>&#123;<br>        buffer.<span class="hljs-built_in">clear</span>();                                               <span class="hljs-comment">// 清空容器。</span><br>        buffer.<span class="hljs-built_in">resize</span>(maxlen);                                        <span class="hljs-comment">// 设置容器的大小为maxlen。</span><br>        <span class="hljs-type">int</span> readn = ::<span class="hljs-built_in">recv</span>(m_clientfd, &amp;buffer[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 直接操作buffer的内存。</span><br>        <span class="hljs-keyword">if</span> (readn &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            buffer.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        buffer.<span class="hljs-built_in">resize</span>(readn); <span class="hljs-comment">// 重置buffer的实际大小。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭监听的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">closelisten</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_listenfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ::<span class="hljs-built_in">close</span>(m_listenfd);<br>        m_listenfd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭客户端连上来的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">closeclient</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ::<span class="hljs-built_in">close</span>(m_clientfd);<br>        m_clientfd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ctcpserver</span>()<br>    &#123;<br>        <span class="hljs-built_in">closelisten</span>();<br>        <span class="hljs-built_in">closeclient</span>();<br>    &#125;<br>&#125;;<br><br>ctcpserver tcpserver;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FathEXIT</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>; <span class="hljs-comment">// 父进程的信号处理函数。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChldEXIT</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>; <span class="hljs-comment">// 子进程的信号处理函数。</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo10 通讯端口\nExample:./demo10 5005\n\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;注意：运行服务端程序的Linux系统的防火墙必须要开通5005端口。\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;      如果是云服务器，还要开通云平台的访问策略。\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 忽略全部的信号，不希望被打扰。顺便解决了僵尸进程的问题。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">1</span>; ii &lt;= <span class="hljs-number">64</span>; ii++)<br>        <span class="hljs-built_in">signal</span>(ii, SIG_IGN);<br><br>    <span class="hljs-comment">// 设置信号,在shell状态下可用 &quot;kill 进程号&quot; 或 &quot;Ctrl+c&quot; 正常终止些进程</span><br>    <span class="hljs-comment">// 但请不要用 &quot;kill -9 +进程号&quot; 强行终止</span><br>    <span class="hljs-built_in">signal</span>(SIGTERM, FathEXIT);<br>    <span class="hljs-built_in">signal</span>(SIGINT, FathEXIT); <span class="hljs-comment">// SIGTERM 15 SIGINT 2</span><br><br>    <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">initserver</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>])) == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;initserver()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">// 受理客户端的连接（从已连接的客户端中取出一个客户端），</span><br>        <span class="hljs-comment">// 如果没有已连接的客户端，accept()函数将阻塞等待。</span><br>        <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">accept</span>() == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept()&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> pid = fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork()&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-comment">// 系统资源不足。</span><br>        <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<br>        &#123;                            <span class="hljs-comment">// 父进程。</span><br>            tcpserver.<span class="hljs-built_in">closeclient</span>(); <span class="hljs-comment">// 父进程关闭客户端连接的socket。</span><br>            <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// 父进程返回到循环开始的位置，继续受理客户端的连接。</span><br>        &#125;<br><br>        tcpserver.<span class="hljs-built_in">closelisten</span>(); <span class="hljs-comment">// 子进程关闭监听的socket。</span><br><br>        <span class="hljs-comment">// 子进程需要重新设置信号。</span><br>        <span class="hljs-built_in">signal</span>(SIGTERM, ChldEXIT); <span class="hljs-comment">// 子进程的退出函数与父进程不一样。</span><br>        <span class="hljs-built_in">signal</span>(SIGINT, SIG_IGN);   <span class="hljs-comment">// 子进程不需要捕获SIGINT信号。</span><br><br>        <span class="hljs-comment">// 子进程负责与客户端进行通讯。</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;客户端已连接(&quot;</span> &lt;&lt; tcpserver.<span class="hljs-built_in">clientip</span>() &lt;&lt; <span class="hljs-string">&quot;)。\n&quot;</span>;<br><br>        string buffer;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-comment">// 接收对端的报文，如果对端没有发送报文，recv()函数将阻塞等待。</span><br>            <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">recv</span>(buffer, <span class="hljs-number">1024</span>) == <span class="hljs-literal">false</span>)<br>            &#123;<br>                <span class="hljs-comment">// 客户端停止发送消息时，会输出recv(): Invalid argument</span><br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;recv()&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>            buffer = <span class="hljs-string">&quot;ok&quot;</span>;<br>            <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">send</span>(buffer) == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 向对端发送报文。</span><br>            &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 子进程一定要退出，否则又会回到accept()函数的位置。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 父进程的信号处理函数。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FathEXIT</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span><br>    <span class="hljs-built_in">signal</span>(SIGINT, SIG_IGN);<br>    <span class="hljs-built_in">signal</span>(SIGTERM, SIG_IGN);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;父进程退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;<br><br>    <span class="hljs-built_in">kill</span>(<span class="hljs-number">0</span>, SIGTERM); <span class="hljs-comment">// 向全部的子进程发送15的信号，通知它们退出。</span><br><br>    <span class="hljs-comment">// 在这里增加释放资源的代码（全局的资源）。</span><br>    tcpserver.<span class="hljs-built_in">closelisten</span>(); <span class="hljs-comment">// 父进程关闭监听的socket。</span><br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 子进程的信号处理函数。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChldEXIT</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span><br>    <span class="hljs-built_in">signal</span>(SIGINT, SIG_IGN);<br>    <span class="hljs-built_in">signal</span>(SIGTERM, SIG_IGN);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;子进程&quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot;退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 在这里增加释放资源的代码（只释放子进程的资源）。</span><br>    tcpserver.<span class="hljs-built_in">closeclient</span>(); <span class="hljs-comment">// 子进程关闭客户端连上来的socket。</span><br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>demo11.cpp</p></li><li><p>实现文件传输功能-客户端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo11.cpp，此程序用于演示文件传输的客户端。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ctcpclient</span> <span class="hljs-comment">// TCP通讯的客户端类。</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_clientfd;        <span class="hljs-comment">// 客户端的socket，-1表示未连接或连接已断开；&gt;=0表示有效的socket。</span><br>    string m_ip;           <span class="hljs-comment">// 服务端的IP/域名。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_port; <span class="hljs-comment">// 通讯端口。</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ctcpclient</span>() : <span class="hljs-built_in">m_clientfd</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 向服务端发起连接请求，成功返回true，失败返回false。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;in_ip, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> in_port)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果socket已连接，直接返回失败。</span><br><br>        m_ip = in_ip;<br>        m_port = in_port; <span class="hljs-comment">// 把服务端的IP和端口保存到成员变量中。</span><br><br>        <span class="hljs-comment">// 第1步：创建客户端的socket。</span><br>        <span class="hljs-keyword">if</span> ((m_clientfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 第2步：向服务器发起连接请求。</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放协议、端口和IP地址的结构体。</span><br>        <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>        servaddr.sin_family = AF_INET;     <span class="hljs-comment">// ①协议族，固定填AF_INET。</span><br>        servaddr.sin_port = <span class="hljs-built_in">htons</span>(m_port); <span class="hljs-comment">// ②指定服务端的通信端口。</span><br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span> *h;                                <span class="hljs-comment">// 用于存放服务端IP地址(大端序)的结构体的指针。</span><br>        <span class="hljs-keyword">if</span> ((h = <span class="hljs-built_in">gethostbyname</span>(m_ip.<span class="hljs-built_in">c_str</span>())) == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">// 把域名/主机名/字符串格式的IP转换成结构体。</span><br>        &#123;<br>            ::<span class="hljs-built_in">close</span>(m_clientfd);<br>            m_clientfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length); <span class="hljs-comment">// ③指定服务端的IP(大端序)。</span><br><br>        <span class="hljs-comment">// 向服务端发起连接清求。</span><br>        <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">connect</span>(m_clientfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            ::<span class="hljs-built_in">close</span>(m_clientfd);<br>            m_clientfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 向服务端发送报文（字符串），成功返回true，失败返回false。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;buffer)</span> <span class="hljs-comment">// buffer不要用const char *</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果socket的状态是未连接，直接返回失败。</span><br><br>        <span class="hljs-keyword">if</span> ((::<span class="hljs-built_in">send</span>(m_clientfd, buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 向服务端发送报文（二进制数据），成功返回true，失败返回false。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">void</span> *buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果socket的状态是未连接，直接返回失败。</span><br><br>        <span class="hljs-keyword">if</span> ((::<span class="hljs-built_in">send</span>(m_clientfd, buffer, size, <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收服务端的报文，成功返回true，失败返回false。</span><br>    <span class="hljs-comment">// buffer-存放接收到的报文的内容，maxlen-本次接收报文的最大长度。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recv</span><span class="hljs-params">(string &amp;buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxlen)</span></span><br><span class="hljs-function">    </span>&#123;                                                                 <span class="hljs-comment">// 如果直接操作string对象的内存，必须保证：1)不能越界；2）操作后手动设置数据的大小。</span><br>        buffer.<span class="hljs-built_in">clear</span>();                                               <span class="hljs-comment">// 清空容器。</span><br>        buffer.<span class="hljs-built_in">resize</span>(maxlen);                                        <span class="hljs-comment">// 设置容器的大小为maxlen。</span><br>        <span class="hljs-type">int</span> readn = ::<span class="hljs-built_in">recv</span>(m_clientfd, &amp;buffer[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 直接操作buffer的内存。</span><br>        <span class="hljs-keyword">if</span> (readn &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            buffer.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        buffer.<span class="hljs-built_in">resize</span>(readn); <span class="hljs-comment">// 重置buffer的实际大小。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 断开与服务端的连接。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果socket的状态是未连接，直接返回失败。</span><br><br>        ::<span class="hljs-built_in">close</span>(m_clientfd);<br>        m_clientfd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 向服务端发送文件内容。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;filename, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> filesize)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 以二进制的方式打开文件。</span><br>        <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(filename, ios::binary)</span></span>;<br>        <span class="hljs-keyword">if</span> (fin.<span class="hljs-built_in">is_open</span>() == <span class="hljs-literal">false</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">&quot;失败。\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> onread = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 每次调用fin.read()时打算读取的字节数。  每次应搬砖头数。</span><br>        <span class="hljs-type">int</span> totalbytes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从文件中已读取的字节总数。 已搬砖头数。</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];  <span class="hljs-comment">// 存放读取数据的buffer。     每次搬七块砖头。</span><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br><br>            <span class="hljs-comment">// 计算本次应该读取的字节数，如果剩余的数据超过4096字节，就读4096字节。</span><br>            <span class="hljs-keyword">if</span> (filesize - totalbytes &gt; <span class="hljs-number">4096</span>)<br>                onread = <span class="hljs-number">4096</span>;<br>            <span class="hljs-keyword">else</span><br>                onread = filesize - totalbytes;<br><br>            <span class="hljs-comment">// 从文件中读取数据。</span><br>            fin.<span class="hljs-built_in">read</span>(buffer, onread);<br><br>            <span class="hljs-comment">// 把读取到的数据发送给对端。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">send</span>(buffer, onread) == <span class="hljs-literal">false</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-comment">// 计算文件已读取的字节总数，如果文件已读完，跳出循环。</span><br>            totalbytes = totalbytes + onread;<br><br>            <span class="hljs-keyword">if</span> (totalbytes == filesize)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ctcpclient</span>() &#123; <span class="hljs-built_in">close</span>(); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">5</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo11 服务端的IP 服务端的端口 文件名 文件大小\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Example:./demo11 192.168.101.138 5005 aaa.txt 2424\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    ctcpclient tcpclient;<br>    <span class="hljs-keyword">if</span> (tcpclient.<span class="hljs-built_in">connect</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>])) == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 向服务端发起连接请求。</span><br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 以下是发送文件的流程。</span><br>    <span class="hljs-comment">// 1）把待传输文件名和文件的大小告诉服务端。</span><br>    <span class="hljs-comment">// 定义文件信息的结构体。</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">st_fileinfo</span><br>    &#123;<br>        <span class="hljs-type">char</span> filename[<span class="hljs-number">256</span>]; <span class="hljs-comment">// 文件名。</span><br>        <span class="hljs-type">int</span> filesize;       <span class="hljs-comment">// 文件大小。</span><br>    &#125; fileinfo;<br>    <span class="hljs-built_in">memset</span>(&amp;fileinfo, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(fileinfo));<br>    <span class="hljs-built_in">strcpy</span>(fileinfo.filename, argv[<span class="hljs-number">3</span>]); <span class="hljs-comment">// 文件名。</span><br>    fileinfo.filesize = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 文件大小。</span><br>    <span class="hljs-comment">// 把文件信息的结构体发送给服务端。</span><br>    <span class="hljs-keyword">if</span> (tcpclient.<span class="hljs-built_in">send</span>(&amp;fileinfo, <span class="hljs-built_in">sizeof</span>(fileinfo)) == <span class="hljs-literal">false</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;发送文件信息的结构体&quot;</span> &lt;&lt; fileinfo.filename &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; fileinfo.filesize &lt;&lt; <span class="hljs-string">&quot;)。&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 2）等待服务端的确认报文（文件名和文件的大小的确认）。</span><br>    string buffer;<br>    <span class="hljs-keyword">if</span> (tcpclient.<span class="hljs-built_in">recv</span>(buffer, <span class="hljs-number">2</span>) == <span class="hljs-literal">false</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;recv()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (buffer != <span class="hljs-string">&quot;ok&quot;</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;服务端没有回复ok。\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3）发送文件内容。</span><br>    <span class="hljs-keyword">if</span> (tcpclient.<span class="hljs-built_in">sendfile</span>(fileinfo.filename, fileinfo.filesize) == <span class="hljs-literal">false</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sendfile()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 4）等待服务端的确认报文（服务端已接收完文件）。</span><br>    <span class="hljs-keyword">if</span> (tcpclient.<span class="hljs-built_in">recv</span>(buffer, <span class="hljs-number">2</span>) == <span class="hljs-literal">false</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;recv()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (buffer != <span class="hljs-string">&quot;ok&quot;</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送文件内容失败。\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;发送文件内容成功。\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>demo12.cpp</p></li><li><p>实现文件传输功能-服务端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo12.cpp，此程序用于演示文件传输的服务端。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ctcpserver</span> <span class="hljs-comment">// TCP通讯的服务端类。</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_listenfd;        <span class="hljs-comment">// 监听的socket，-1表示未初始化。</span><br>    <span class="hljs-type">int</span> m_clientfd;        <span class="hljs-comment">// 客户端连上来的socket，-1表示客户端未连接。</span><br>    string m_clientip;     <span class="hljs-comment">// 客户端字符串格式的IP。</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_port; <span class="hljs-comment">// 服务端用于通讯的端口。</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ctcpserver</span>() : <span class="hljs-built_in">m_listenfd</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">m_clientfd</span>(<span class="hljs-number">-1</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> in_port)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 第1步：创建服务端的socket。</span><br>        <span class="hljs-keyword">if</span> ((m_listenfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        m_port = in_port;<br><br>        <span class="hljs-comment">// 第2步：把服务端用于通信的IP和端口绑定到socket上。</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放协议、端口和IP地址的结构体。</span><br>        <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>        servaddr.sin_family = AF_INET;                <span class="hljs-comment">// ①协议族，固定填AF_INET。</span><br>        servaddr.sin_port = <span class="hljs-built_in">htons</span>(m_port);            <span class="hljs-comment">// ②指定服务端的通信端口。</span><br>        servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); <span class="hljs-comment">// ③如果操作系统有多个IP，全部的IP都可以用于通讯。</span><br><br>        <span class="hljs-comment">// 绑定服务端的IP和端口（为socket分配IP和端口）。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">close</span>(m_listenfd);<br>            m_listenfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 第3步：把socket设置为可连接（监听）的状态。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(m_listenfd, <span class="hljs-number">5</span>) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">close</span>(m_listenfd);<br>            m_listenfd = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 受理客户端的连接（从已连接的客户端中取出一个客户端），</span><br>    <span class="hljs-comment">// 如果没有已连接的客户端，accept()函数将阻塞等待。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> caddr;          <span class="hljs-comment">// 客户端的地址信息。</span><br>        <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">sizeof</span>(caddr); <span class="hljs-comment">// struct sockaddr_in的大小。</span><br>        <span class="hljs-keyword">if</span> ((m_clientfd = ::<span class="hljs-built_in">accept</span>(m_listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;caddr, &amp;addrlen)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        m_clientip = <span class="hljs-built_in">inet_ntoa</span>(caddr.sin_addr); <span class="hljs-comment">// 把客户端的地址从大端序转换成字符串。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取客户端的IP(字符串格式)。</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> string &amp;<span class="hljs-title">clientip</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> m_clientip;<br>    &#125;<br><br>    <span class="hljs-comment">// 向对端发送报文，成功返回true，失败返回false。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;buffer)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span> ((::<span class="hljs-built_in">send</span>(m_clientfd, buffer.<span class="hljs-built_in">data</span>(), buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收对端的报文（字符串），成功返回true，失败返回false。</span><br>    <span class="hljs-comment">// buffer-存放接收到的报文的内容，maxlen-本次接收报文的最大长度。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recv</span><span class="hljs-params">(string &amp;buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> maxlen)</span></span><br><span class="hljs-function">    </span>&#123;<br>        buffer.<span class="hljs-built_in">clear</span>();                                               <span class="hljs-comment">// 清空容器。</span><br>        buffer.<span class="hljs-built_in">resize</span>(maxlen);                                        <span class="hljs-comment">// 设置容器的大小为maxlen。</span><br>        <span class="hljs-type">int</span> readn = ::<span class="hljs-built_in">recv</span>(m_clientfd, &amp;buffer[<span class="hljs-number">0</span>], buffer.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 直接操作buffer的内存。</span><br>        <span class="hljs-keyword">if</span> (readn &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            buffer.<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        buffer.<span class="hljs-built_in">resize</span>(readn); <span class="hljs-comment">// 重置buffer的实际大小。</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收客户端的报文（二进制数据），成功返回true，失败返回false。</span><br>    <span class="hljs-comment">// buffer-存放接收到的报文的内容，size-本次接收报文的最大长度。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-type">void</span> *buffer, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">recv</span>(m_clientfd, buffer, size, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭监听的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">closelisten</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_listenfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ::<span class="hljs-built_in">close</span>(m_listenfd);<br>        m_listenfd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭客户端连上来的socket。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">closeclient</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_clientfd == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ::<span class="hljs-built_in">close</span>(m_clientfd);<br>        m_clientfd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收文件内容。</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recvfile</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;filename, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> filesize)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ofstream fout;<br>        fout.<span class="hljs-built_in">open</span>(filename, ios::binary);<br>        <span class="hljs-keyword">if</span> (fout.<span class="hljs-built_in">is_open</span>() == <span class="hljs-literal">false</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;打开文件&quot;</span> &lt;&lt; filename &lt;&lt; <span class="hljs-string">&quot;失败。\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> totalbytes = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已接收文件的总字节数。</span><br>        <span class="hljs-type">int</span> onread = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 本次打算接收的字节数。</span><br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];  <span class="hljs-comment">// 接收文件内容的缓冲区。4096可以更改，主要看磁盘情况，现在一般是1000-5000，这里是读取1页，大概4K</span><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-comment">// 计算本次应该接收的字节数。</span><br>            <span class="hljs-keyword">if</span> (filesize - totalbytes &gt; <span class="hljs-number">4096</span>)<br>                onread = <span class="hljs-number">4096</span>;<br>            <span class="hljs-keyword">else</span><br>                onread = filesize - totalbytes;<br><br>            <span class="hljs-comment">// 接收文件内容。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(buffer, onread) == <span class="hljs-literal">false</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-comment">// 把接收到的内容写入文件。</span><br>            fout.<span class="hljs-built_in">write</span>(buffer, onread);<br><br>            <span class="hljs-comment">// 计算已接收文件的总字节数，如果文件接收完，跳出循环。</span><br>            totalbytes = totalbytes + onread;<br><br>            <span class="hljs-keyword">if</span> (totalbytes == filesize)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ctcpserver</span>()<br>    &#123;<br>        <span class="hljs-built_in">closelisten</span>();<br>        <span class="hljs-built_in">closeclient</span>();<br>    &#125;<br>&#125;;<br><br>ctcpserver tcpserver;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FathEXIT</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>; <span class="hljs-comment">// 父进程的信号处理函数。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChldEXIT</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>; <span class="hljs-comment">// 子进程的信号处理函数。</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo12 通讯端口 文件存放的目录\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Example:./demo12 5005 /tmp\n\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;注意：运行服务端程序的Linux系统的防火墙必须要开通5005端口。\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;      如果是云服务器，还要开通云平台的访问策略。\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 忽略全部的信号，不希望被打扰。顺便解决了僵尸进程的问题。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">1</span>; ii &lt;= <span class="hljs-number">64</span>; ii++)<br>        <span class="hljs-built_in">signal</span>(ii, SIG_IGN);<br><br>    <span class="hljs-comment">// 设置信号,在shell状态下可用 &quot;kill 进程号&quot; 或 &quot;Ctrl+c&quot; 正常终止些进程</span><br>    <span class="hljs-comment">// 但请不要用 &quot;kill -9 +进程号&quot; 强行终止</span><br>    <span class="hljs-built_in">signal</span>(SIGTERM, FathEXIT);<br>    <span class="hljs-built_in">signal</span>(SIGINT, FathEXIT); <span class="hljs-comment">// SIGTERM 15 SIGINT 2</span><br><br>    <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">initserver</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>])) == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;initserver()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">// 受理客户端的连接（从已连接的客户端中取出一个客户端），</span><br>        <span class="hljs-comment">// 如果没有已连接的客户端，accept()函数将阻塞等待。</span><br>        <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">accept</span>() == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept()&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> pid = fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork()&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-comment">// 系统资源不足。</span><br>        <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<br>        &#123;                            <span class="hljs-comment">// 父进程。</span><br>            tcpserver.<span class="hljs-built_in">closeclient</span>(); <span class="hljs-comment">// 父进程关闭客户端连接的socket。</span><br>            <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// 父进程返回到循环开始的位置，继续受理客户端的连接。</span><br>        &#125;<br><br>        tcpserver.<span class="hljs-built_in">closelisten</span>(); <span class="hljs-comment">// 子进程关闭监听的socket。</span><br><br>        <span class="hljs-comment">// 子进程需要重新设置信号。</span><br>        <span class="hljs-built_in">signal</span>(SIGTERM, ChldEXIT); <span class="hljs-comment">// 子进程的退出函数与父进程不一样。</span><br>        <span class="hljs-built_in">signal</span>(SIGINT, SIG_IGN);   <span class="hljs-comment">// 子进程不需要捕获SIGINT信号。</span><br><br>        <span class="hljs-comment">// 子进程负责与客户端进行通讯。</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;客户端已连接(&quot;</span> &lt;&lt; tcpserver.<span class="hljs-built_in">clientip</span>() &lt;&lt; <span class="hljs-string">&quot;)。\n&quot;</span>;<br><br>        <span class="hljs-comment">// 以下是接收文件的流程。</span><br>        <span class="hljs-comment">// 1）接收文件名和文件大小信息。</span><br>        <span class="hljs-comment">// 定义文件信息的结构体。</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">st_fileinfo</span><br>        &#123;<br>            <span class="hljs-type">char</span> filename[<span class="hljs-number">256</span>]; <span class="hljs-comment">// 文件名。</span><br>            <span class="hljs-type">int</span> filesize;       <span class="hljs-comment">// 文件大小。</span><br>        &#125; fileinfo;<br>        <span class="hljs-built_in">memset</span>(&amp;fileinfo, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(fileinfo));<br>        <span class="hljs-comment">// 用结构体存放接收报文的内容。</span><br>        <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">recv</span>(&amp;fileinfo, <span class="hljs-built_in">sizeof</span>(fileinfo)) == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;recv()&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;文件信息结构体&quot;</span> &lt;&lt; fileinfo.filename &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; fileinfo.filesize &lt;&lt; <span class="hljs-string">&quot;)。&quot;</span> &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 2）给客户端回复确认报文，表示客户端可以发送文件了。</span><br>        <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">send</span>(<span class="hljs-string">&quot;ok&quot;</span>) == <span class="hljs-literal">false</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 3）接收文件内容。  string   char * + const char * + char *,这里char*不能拼接，其中一个转换为string就可以拼接了</span><br>        <span class="hljs-keyword">if</span> (tcpserver.<span class="hljs-built_in">recvfile</span>(<span class="hljs-built_in">string</span>(argv[<span class="hljs-number">2</span>]) + <span class="hljs-string">&quot;/&quot;</span> + fileinfo.filename, fileinfo.filesize) == <span class="hljs-literal">false</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;接收文件内容失败。\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;接收文件内容成功。\n&quot;</span>;<br><br>        <span class="hljs-comment">// 4）给客户端回复确认报文，表示文件已接收成功。</span><br>        tcpserver.<span class="hljs-built_in">send</span>(<span class="hljs-string">&quot;ok&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 子进程一定要退出，否则又会回到accept()函数的位置。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 父进程的信号处理函数。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FathEXIT</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span><br>    <span class="hljs-built_in">signal</span>(SIGINT, SIG_IGN);<br>    <span class="hljs-built_in">signal</span>(SIGTERM, SIG_IGN);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;父进程退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;<br><br>    <span class="hljs-built_in">kill</span>(<span class="hljs-number">0</span>, SIGTERM); <span class="hljs-comment">// 向全部的子进程发送15的信号，通知它们退出。</span><br><br>    <span class="hljs-comment">// 在这里增加释放资源的代码（全局的资源）。</span><br>    tcpserver.<span class="hljs-built_in">closelisten</span>(); <span class="hljs-comment">// 父进程关闭监听的socket。</span><br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 子进程的信号处理函数。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChldEXIT</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 以下代码是为了防止信号处理函数在执行的过程中再次被信号中断。</span><br>    <span class="hljs-built_in">signal</span>(SIGINT, SIG_IGN);<br>    <span class="hljs-built_in">signal</span>(SIGTERM, SIG_IGN);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;子进程&quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot;退出，sig=&quot;</span> &lt;&lt; sig &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 在这里增加释放资源的代码（只释放子进程的资源）。</span><br>    tcpserver.<span class="hljs-built_in">closeclient</span>(); <span class="hljs-comment">// 子进程关闭客户端连上来的socket。</span><br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="网络通讯的原理"><a href="#网络通讯的原理" class="headerlink" title="网络通讯的原理"></a>网络通讯的原理</h1><ul><li>demo1.cpp</li><li>和下面的demo2.cpp结合，能用来测试四次挥手的情况</li><li>如果客户端和服务端完成三次握手后，如果客户端断开连接后，会有个2MSL的时间的等待，客户端影响不大，只是那个端口不能用了，但如果是服务端主动断开连接后，服务端因为需要服务多个客户端，无法及时重启使用指定端口，会导致有问题，如果想要服务端主动断开并且也能立刻启用端口需要加代码,放在bind函数前  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="hljs-built_in">sizeof</span>(opt));<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo1.cpp，此程序用于演示socket的客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo1 服务端的IP 服务端的端口\nExample:./demo1 192.168.101.139 5005\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第1步：创建客户端的socket。</span><br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第2步：向服务器发起连接请求。</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span> *h;                     <span class="hljs-comment">// 用于存放服务端IP的结构体。</span><br>    <span class="hljs-keyword">if</span> ((h = <span class="hljs-built_in">gethostbyname</span>(argv[<span class="hljs-number">1</span>])) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 把字符串格式的IP转换成结构体。</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;gethostbyname failed.\n&quot;</span><br>             &lt;&lt; endl;<br>        <span class="hljs-built_in">close</span>(sockfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放服务端IP和端口的结构体。</span><br>    <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>    servaddr.sin_family = AF_INET;<br>    <span class="hljs-built_in">memcpy</span>(&amp;servaddr.sin_addr, h-&gt;h_addr, h-&gt;h_length); <span class="hljs-comment">// 指定服务端的IP地址。</span><br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));           <span class="hljs-comment">// 指定服务端的通信端口。</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) != <span class="hljs-number">0</span>) <span class="hljs-comment">// 向服务端发起连接清求。</span><br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sockfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// sleep(100);</span><br><br>    <span class="hljs-comment">// 第3步：与服务端通讯，客户发送一个请求报文后等待服务端的回复，收到回复后，再发下一个请求报文。</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">3</span>; ii++) <span class="hljs-comment">// 循环3次，将与服务端进行三次通讯。</span><br>    &#123;<br>        <span class="hljs-type">int</span> iret;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-built_in">sprintf</span>(buffer, <span class="hljs-string">&quot;这是第%d个超级女生，编号%03d。&quot;</span>, ii + <span class="hljs-number">1</span>, ii + <span class="hljs-number">1</span>); <span class="hljs-comment">// 生成请求报文内容。</span><br>        <span class="hljs-comment">// 向服务端发送请求报文。</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">send</span>(sockfd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-comment">// 接收服务端的回应报文，如果服务端没有发送回应报文，recv()函数将阻塞等待。</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">recv</span>(sockfd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 第4步：关闭socket，释放资源。</span><br>    <span class="hljs-built_in">close</span>(sockfd);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>demo2.cpp</li><li>和上面的demo1.cpp结合，能用来测试四次挥手的情况</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：demo2.cpp，此程序用于演示socket通信的服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Using:./demo2 通讯端口\nExample:./demo2 5005\n\n&quot;</span>; <span class="hljs-comment">// 端口大于1024，不与其它的重复。</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;注意：运行服务端程序的Linux系统的防火墙必须要开通5005端口。\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;      如果是云服务器，还要开通云平台的访问策略。\n\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第1步：创建服务端的socket。</span><br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (listenfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第2步：把服务端用于通信的IP和端口绑定到socket上。</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr; <span class="hljs-comment">// 用于存放服务端IP和端口的数据结构。</span><br>    <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>    servaddr.sin_family = AF_INET;                <span class="hljs-comment">// 指定协议。</span><br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY); <span class="hljs-comment">// 服务端任意网卡的IP都可以用于通讯。</span><br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));     <span class="hljs-comment">// 指定通信端口，普通用户只能用1024以上的端口。</span><br><br>    <span class="hljs-comment">// int opt = 1;</span><br>    <span class="hljs-comment">// setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));</span><br><br>    <span class="hljs-comment">// 绑定服务端的IP和端口。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第3步：把socket设置为可连接（监听）的状态。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第4步：受理客户端的连接请求，如果没有客户端连上来，accept()函数将阻塞等待。</span><br>    <span class="hljs-type">int</span> clientfd = <span class="hljs-built_in">accept</span>(listenfd, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (clientfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>        <span class="hljs-built_in">close</span>(listenfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;客户端已连接。\n&quot;</span>;<br><br>    <span class="hljs-comment">// close(listenfd);</span><br>    <span class="hljs-comment">// close(clientfd);</span><br>    <span class="hljs-comment">// return 0;</span><br><br>    <span class="hljs-comment">// 第5步：与客户端通信，接收客户端发过来的报文后，回复ok。</span><br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> iret;<br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-comment">// 接收客户端的请求报文，如果客户端没有发送请求报文，recv()函数将阻塞等待。</span><br>        <span class="hljs-comment">// 如果客户端已断开连接，recv()函数将返回0,直接退出服务端</span><br>        <span class="hljs-comment">// 如果 iret &gt; 0，表示成功接收到数据，返回的是接收到的字节数。</span><br>        <span class="hljs-comment">// 如果 iret == 0，表示连接已关闭，数据传输结束。</span><br>        <span class="hljs-comment">// 如果 iret &lt; 0，则发生错误。常见错误可能是网络问题或对方异常断开连接。</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">recv</span>(clientfd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;iret=&quot;</span> &lt;&lt; iret &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;接收：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br><br>        <span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">&quot;ok&quot;</span>); <span class="hljs-comment">// 生成回应报文内容。</span><br>        <span class="hljs-comment">// 向客户端发送回应报文。</span><br>        <span class="hljs-keyword">if</span> ((iret = <span class="hljs-built_in">send</span>(clientfd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>)) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;发送：&quot;</span> &lt;&lt; buffer &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 第6步：关闭socket，释放资源。</span><br>    <span class="hljs-built_in">close</span>(listenfd); <span class="hljs-comment">// 关闭服务端用于监听的socket。</span><br>    <span class="hljs-built_in">close</span>(clientfd); <span class="hljs-comment">// 关闭客户端连上来的socket。</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="I-O复用模型，selcet，poll，epoll，非阻塞的IO"><a href="#I-O复用模型，selcet，poll，epoll，非阻塞的IO" class="headerlink" title="I&#x2F;O复用模型，selcet，poll，epoll，非阻塞的IO"></a>I&#x2F;O复用模型，selcet，poll，epoll，非阻塞的IO</h1><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul><li><p>client.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 网络通讯的客户端程序。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:./client ip port\n&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br> <br>    <span class="hljs-keyword">if</span> ((sockfd=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>))&lt;<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket() failed.\n&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;servaddr,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(servaddr));<br>    servaddr.sin_family=AF_INET;<br>    servaddr.sin_port=<span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br>    servaddr.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr,<span class="hljs-built_in">sizeof</span>(servaddr)) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect(%s:%s) failed.\n&quot;</span>,argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>]); <span class="hljs-built_in">close</span>(sockfd);  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect ok.\n&quot;</span>);<br><br>    <span class="hljs-comment">// printf(&quot;开始时间：%d&quot;,time(0));</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii=<span class="hljs-number">0</span>;ii&lt;<span class="hljs-number">200000</span>;ii++)<br>    &#123;<br>        <span class="hljs-comment">// 从命令行输入内容。</span><br>        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input:&quot;</span>); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">send</span>(sockfd,buf,<span class="hljs-built_in">strlen</span>(buf),<span class="hljs-number">0</span>) &lt;=<span class="hljs-number">0</span>)<br>        &#123; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write() failed.\n&quot;</span>);  <span class="hljs-built_in">close</span>(sockfd);  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(sockfd,buf,<span class="hljs-built_in">sizeof</span>(buf),<span class="hljs-number">0</span>) &lt;=<span class="hljs-number">0</span>) <br>        &#123; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read() failed.\n&quot;</span>);  <span class="hljs-built_in">close</span>(sockfd);  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv:%s\n&quot;</span>,buf);<br>    &#125;<br><br>    <span class="hljs-comment">// printf(&quot;结束时间：%d&quot;,time(0));</span><br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>tcpselect.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：tcpselect.cpp，此程序用于演示采用select模型实现网络通讯的服务端。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: ./tcpselect port\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    <span class="hljs-type">int</span> listensock = <span class="hljs-built_in">initserver</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listensock=%d\n&quot;</span>, listensock);<br><br>    <span class="hljs-keyword">if</span> (listensock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;initserver() failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 读事件：1）已连接队列中有已经准备好的socket（有新的客户端连上来了）；</span><br>    <span class="hljs-comment">//               2）接收缓存中有数据可以读（对端发送的报文已到达）；</span><br>    <span class="hljs-comment">//               3）tcp连接已断开（对端调用close()函数关闭了连接）。</span><br>    <span class="hljs-comment">// 写事件：发送缓冲区没有满，可以写入数据（可以向对端发送报文）。</span><br><br>    <span class="hljs-comment">// C语言提供了4个宏来操控位图</span><br>    <span class="hljs-comment">// void FD_CLR(int fd, fd_set * set); // 把socket从bitmap中删除</span><br>    <span class="hljs-comment">// int FD_ISSET(int fd, fd_set * set); // 判断socket是否在bitmap中，如果不在返回0，在则返回大于0</span><br>    <span class="hljs-comment">// void FD_SET(int fd, fd_set * set); // 把socket加入到集合中 fd是socket set是bitmap的地址</span><br>    <span class="hljs-comment">// void FD_ZERO(fd_set * set); // 初始化位图，把全部的1024个位置全部变为0</span><br>    <span class="hljs-comment">// fd_set 是int[32]的数组，里面占用bit为 4*8*32=1024位，是一个bitmap</span><br>    fd_set readfds;               <span class="hljs-comment">// 需要监视读事件的socket的集合，大小为16字节（1024位）的bitmap。</span><br>    <span class="hljs-built_in">FD_ZERO</span>(&amp;readfds);            <span class="hljs-comment">// 初始化readfds，把bitmap的每一位都置为0。</span><br>    <span class="hljs-built_in">FD_SET</span>(listensock, &amp;readfds); <span class="hljs-comment">// 把服务端用于监听的socket加入readfds。</span><br><br>    <span class="hljs-type">int</span> maxfd = listensock; <span class="hljs-comment">// readfds中socket的最大值。</span><br><br>    <span class="hljs-comment">// select有超时机制，如果在timeout时间后，如果监视的socket没有任何事件发生，就会返回超时</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) <span class="hljs-comment">// 事件循环。</span><br>    &#123;<br>        <span class="hljs-comment">// 用于表示超时时间的结构体。</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> timeout;<br>        timeout.tv_sec = <span class="hljs-number">10</span>; <span class="hljs-comment">// 秒</span><br>        timeout.tv_usec = <span class="hljs-number">0</span>; <span class="hljs-comment">// 微秒。</span><br><br>        fd_set tmpfds = readfds; <span class="hljs-comment">// 在select()函数中，会修改bitmap，所以，要把readfds复制一份给tmpfds，再把tmpfds传给select()。</span><br><br>        <span class="hljs-comment">// 调用select() 等待事件的发生（监视哪些socket发生了事件)。</span><br>        <span class="hljs-comment">// maxfd+1:告诉select，它的bitmap有多大</span><br>        <span class="hljs-comment">// 在select()函数中，会修改bitmap，所以，要把readfds复制一份给tmpfds，再把tmpfds传给select()</span><br>        <span class="hljs-comment">// 第三个参数是需要监视的写事件的bitmap，如果不关心写事件，则填空</span><br>        <span class="hljs-comment">// 第四个参数填需要关心的异常事件的bitmap，在监视普通IO事件的时候可以用到第四个参数，网络编程中用不到</span><br>        <span class="hljs-comment">// 第五个参数填超时时间，如果没有超时时间，NULL表示永远等待</span><br>        <span class="hljs-type">int</span> infds = <span class="hljs-built_in">select</span>(maxfd + <span class="hljs-number">1</span>, &amp;tmpfds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// int infds = select(maxfd + 1, &amp;tmpfds, NULL, NULL, &amp;timeout);</span><br><br>        <span class="hljs-comment">// 如果infds&lt;0，表示调用select()失败。会设置errno全局变量</span><br>        <span class="hljs-keyword">if</span> (infds &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;select() failed&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果infds==0，表示select()超时。</span><br>        <span class="hljs-keyword">if</span> (infds == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select() timeout.\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果infds&gt;0，表示有事件发生，infds存放了已发生事件的个数。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> eventfd = <span class="hljs-number">0</span>; eventfd &lt;= maxfd; eventfd++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(eventfd, &amp;tmpfds) == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果eventfd在bitmap中的标志为0，表示它没有事件，continue</span><br><br>            <span class="hljs-comment">// 如果发生事件的是listensock，表示已连接队列中有已经准备好的socket（有新的客户端连上来了）。</span><br>            <span class="hljs-keyword">if</span> (eventfd == listensock)<br>            &#123;<br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>                <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(client);<br>                <span class="hljs-type">int</span> clientsock = <span class="hljs-built_in">accept</span>(listensock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br>                <span class="hljs-keyword">if</span> (clientsock &lt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept() failed&quot;</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept client(socket=%d) ok.\n&quot;</span>, clientsock);<br><br>                <span class="hljs-built_in">FD_SET</span>(clientsock, &amp;readfds); <span class="hljs-comment">// 把bitmap中新连上来的客户端的标志位置为1。</span><br><br>                <span class="hljs-keyword">if</span> (maxfd &lt; clientsock)<br>                    maxfd = clientsock; <span class="hljs-comment">// 更新maxfd的值。</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 如果是客户端连接的socke有事件，表示接收缓存中有数据可以读（对端发送的报文已到达），或者有客户端已断开连接。</span><br>                <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 存放从接收缓冲区中读取的数据。</span><br>                <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>                <span class="hljs-comment">// recv&lt;0：表示已经发生了错误</span><br>                <span class="hljs-comment">// recv=0：连接已经被对方断开</span><br>                <span class="hljs-comment">// recv&gt;0：表示成功读取的字节数</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(eventfd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 如果客户端的连接已断开。</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client(eventfd=%d) disconnected.\n&quot;</span>, eventfd);<br><br>                    <span class="hljs-built_in">close</span>(eventfd); <span class="hljs-comment">// 关闭客户端的socket</span><br><br>                    <span class="hljs-built_in">FD_CLR</span>(eventfd, &amp;readfds); <span class="hljs-comment">// 把bitmap中已关闭客户端的标志位清空。</span><br><br>                    <span class="hljs-keyword">if</span> (eventfd == maxfd) <span class="hljs-comment">// 重新计算maxfd的值，注意，只有当eventfd==maxfd时才需要计算。</span><br>                    &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = maxfd; ii &gt; <span class="hljs-number">0</span>; ii--) <span class="hljs-comment">// 从后面往前找。</span><br>                        &#123;<br>                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FD_ISSET</span>(ii, &amp;readfds))<br>                            &#123;<br>                                maxfd = ii;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 如果客户端有报文发过来。</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv(eventfd=%d):%s\n&quot;</span>, eventfd, buffer);<br><br>                    <span class="hljs-comment">// 把接收到的报文内容原封不动的发回去。</span><br>                    <span class="hljs-built_in">send</span>(eventfd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket() failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(opt);<br>    <span class="hljs-built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, len);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    servaddr.sin_family = AF_INET;<br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sock;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="poll模型"><a href="#poll模型" class="headerlink" title="poll模型"></a>poll模型</h3><ul><li>tcppoll.cpp<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：tcppoll.cpp，此程序用于演示采用poll模型实现网络通讯的服务端。</span><br><span class="hljs-comment"> * 作者：吴从周</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: ./tcppoll port\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    <span class="hljs-type">int</span> listensock = <span class="hljs-built_in">initserver</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listensock=%d\n&quot;</span>, listensock);<br><br>    <span class="hljs-keyword">if</span> (listensock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;initserver() failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在select模型中用bitmap存放需要监视的socket</span><br>    <span class="hljs-comment">// 在poll模型中用结构体数组存放需要监视的socket</span><br>    <span class="hljs-comment">// struct pollfd&#123;</span><br>    <span class="hljs-comment">//     int fd; // 需要监视的socket</span><br>    <span class="hljs-comment">//     short events; // 需要监视的事件</span><br>    <span class="hljs-comment">//     short revents; // poll返回的事件</span><br>    <span class="hljs-comment">// &#125;;</span><br>    <span class="hljs-comment">// 在程序中我们设置需要监视的socket和事件，把结构体传给poll</span><br>    <span class="hljs-comment">// 如果有事件发生了，poll只会修改这个成员(revents)，另外两个成员（fd和events）不会修改</span><br>    <span class="hljs-comment">// 在select模型中，bitmap模型大小固定是1024，而poll模型中，数组的大小由我们决定</span><br>    pollfd fds[<span class="hljs-number">2048</span>]; <span class="hljs-comment">// fds存放需要监视的socket。</span><br><br>    <span class="hljs-comment">// 初始化数组，把全部的socket设置为-1，如果数组中的socket的值为-1，那么，poll将忽略它。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">2048</span>; ii++)<br>        fds[ii].fd = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// 打算让poll监视listensock读事件。</span><br>    fds[listensock].fd = listensock;<br>    fds[listensock].events = POLLIN; <span class="hljs-comment">// POLLIN表示读事件，POLLOUT表示写事件。</span><br>    <span class="hljs-comment">// fds[listensock].events=POLLIN|POLLOUT; // 既监视读事件，也监视写事件</span><br><br>    <span class="hljs-type">int</span> maxfd = listensock; <span class="hljs-comment">// fds数组中需要监视的socket的实际大小。</span><br>    <span class="hljs-comment">//  0  1  2  3  4  5  6 ... 2047  结构体数组位置下标</span><br>    <span class="hljs-comment">// -1 -1 -1  3  4 -1  6 ... -1    按数组索引填写，一般选择这个，效率高，写代码方便</span><br>    <span class="hljs-comment">//  3  4  6 -1 -1 -1 -1 ... -1    按空格位置补齐，数组空间利用率高</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) <span class="hljs-comment">// 事件循环。</span><br>    &#123;<br>        <span class="hljs-comment">// 调用poll() 等待事件的发生（监视哪些socket发生了事件)。</span><br>        <span class="hljs-comment">// 第一个参数：结构体数组名</span><br>        <span class="hljs-comment">// 第二个参数：最大的socketId+1，表示有效的socket的数量</span><br>        <span class="hljs-comment">// 第三个参数：超时时间，ms</span><br>        <span class="hljs-type">int</span> infds = <span class="hljs-built_in">poll</span>(fds, maxfd + <span class="hljs-number">1</span>, <span class="hljs-number">10000</span>); <span class="hljs-comment">// 超时时间为10秒。</span><br><br>        <span class="hljs-comment">// 如果infds&lt;0，表示调用poll()失败。</span><br>        <span class="hljs-keyword">if</span> (infds &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;poll() failed&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果infds==0，表示poll()超时。</span><br>        <span class="hljs-keyword">if</span> (infds == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;poll() timeout.\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果infds&gt;0，表示有事件发生，infds存放了已发生事件的个数。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> eventfd = <span class="hljs-number">0</span>; eventfd &lt;= maxfd; eventfd++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (fds[eventfd].fd &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果fd为负，忽略它。</span><br><br>            <span class="hljs-keyword">if</span> ((fds[eventfd].revents &amp; POLLIN) == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果没有读事件，continue</span><br><br>            <span class="hljs-comment">// 如果发生事件的是listensock，表示已连接队列中有已经准备好的socket（有新的客户端连上来了）。</span><br>            <span class="hljs-keyword">if</span> (eventfd == listensock)<br>            &#123;<br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>                <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(client);<br>                <span class="hljs-type">int</span> clientsock = <span class="hljs-built_in">accept</span>(listensock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br>                <span class="hljs-keyword">if</span> (clientsock &lt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept() failed&quot;</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept client(socket=%d) ok.\n&quot;</span>, clientsock);<br><br>                <span class="hljs-comment">// 修改fds数组中clientsock位置的元素</span><br>                <span class="hljs-comment">// 表示监听clientsock的事件</span><br>                fds[clientsock].fd = clientsock;<br>                fds[clientsock].events = POLLIN;<br><br>                <span class="hljs-keyword">if</span> (maxfd &lt; clientsock)<br>                    maxfd = clientsock; <span class="hljs-comment">// 更新maxfd的值。</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 如果是客户端连接的socke有事件，表示有报文发过来了或者连接已断开。</span><br><br>                <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 存放从客户端读取的数据。</span><br>                <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(eventfd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 如果客户端的连接已断开。</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client(eventfd=%d) disconnected.\n&quot;</span>, eventfd);<br><br>                    <span class="hljs-built_in">close</span>(eventfd);       <span class="hljs-comment">// 关闭客户端的socket。</span><br>                    fds[eventfd].fd = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 修改fds数组中clientsock位置的元素，置为-1，poll将忽略该元素。</span><br><br>                    <span class="hljs-comment">// 重新计算maxfd的值，注意，只有当eventfd==maxfd时才需要计算。</span><br>                    <span class="hljs-keyword">if</span> (eventfd == maxfd)<br>                    &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = maxfd; ii &gt; <span class="hljs-number">0</span>; ii--) <span class="hljs-comment">// 从后面往前找。</span><br>                        &#123;<br>                            <span class="hljs-keyword">if</span> (fds[ii].fd != <span class="hljs-number">-1</span>)<br>                            &#123;<br>                                maxfd = ii;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 如果客户端有报文发过来。</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv(eventfd=%d):%s\n&quot;</span>, eventfd, buffer);<br><br>                    <span class="hljs-built_in">send</span>(eventfd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket() failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(opt);<br>    <span class="hljs-built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, len);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    servaddr.sin_family = AF_INET;<br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sock;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><ul><li>tcpepoll.cpp<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：tcpepoll.cpp，此程序用于演示采用epoll模型实现网络通讯的服务端。</span><br><span class="hljs-comment"> * 作者：吴从周</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: ./tcpepoll port\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    <span class="hljs-type">int</span> listensock = <span class="hljs-built_in">initserver</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listensock=%d\n&quot;</span>, listensock);<br><br>    <span class="hljs-keyword">if</span> (listensock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;initserver() failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建epoll句柄</span><br>    <span class="hljs-comment">// 创建一个epoll实例，类似于文件描述符，是一个整数</span><br>    <span class="hljs-comment">// 参数随便，大于0就行</span><br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 为服务端的listensock准备读事件</span><br>    <span class="hljs-comment">// typedef union epoll_data&#123;</span><br>    <span class="hljs-comment">//     void *ptr;</span><br>    <span class="hljs-comment">//     int fd;</span><br>    <span class="hljs-comment">//     uint32_t u32;</span><br>    <span class="hljs-comment">//     uint64_t u64;</span><br>    <span class="hljs-comment">// &#125;epoll_data_t;</span><br>    <span class="hljs-comment">// struct epoll_event&#123;</span><br>    <span class="hljs-comment">//     uint32_t events; // epoll事件 EPOLLIN读事件，EPOLLOUT写事件</span><br>    <span class="hljs-comment">//     epoll_data_t data; // 用户数据变量</span><br>    <span class="hljs-comment">// &#125;;</span><br>    epoll_event ev;          <span class="hljs-comment">// 声明事件的数据结构。</span><br>    ev.data.fd = listensock; <span class="hljs-comment">// 指定事件的自定义数据，会随着epoll_wait()返回的事件一并返回。</span><br>    <span class="hljs-comment">// 如果启用下面的代码，会导致data共同体中的fd成员失效，后续中的socket判断会用到这个，但是不能用</span><br>    <span class="hljs-comment">// 因为是水平触发，所以会一直触发</span><br>    <span class="hljs-comment">// ev.data.ptr=(void*)&quot;超女&quot;;   // 指定事件的自定义数据，会随着epoll_wait()返回的事件一并返回。</span><br>    ev.events = EPOLLIN; <span class="hljs-comment">// 打算让epoll监视listensock的读事件。</span><br><br>    <span class="hljs-comment">// 第一个参数是epollfd句柄</span><br>    <span class="hljs-comment">// 第二个参数是EPOLL_CTL_ADD宏</span><br>    <span class="hljs-comment">// EPOLL_CTL_ADD：向 epoll 实例中添加一个文件描述符，并设置对该描述符的监听事件。</span><br>    <span class="hljs-comment">// EPOLL_CTL_MOD：修改 epoll 实例中已经存在的文件描述符的监听事件。</span><br>    <span class="hljs-comment">// EPOLL_CTL_DEL：从 epoll 实例中删除文件描述符，不再监听它的事件。</span><br>    <span class="hljs-comment">// 第三个参数是需要监听的socket</span><br>    <span class="hljs-comment">// 第四个参数是事件结构体的地址</span><br>    <span class="hljs-comment">// 将 listensock 添加（EPOLL_CTL_ADD）到 epollfd 指向的 epoll 实例中，并使用 ev 中的事件信息作为关注的事件（例如 EPOLLIN）。</span><br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, listensock, &amp;ev); <span class="hljs-comment">// 把需要监视的socket和事件加入epollfd中。</span><br><br>    <span class="hljs-comment">// 自己定义的数组，大一点，小一点都没事</span><br>    epoll_event evs[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 存放epoll返回的事件。</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) <span class="hljs-comment">// 事件循环。</span><br>    &#123;<br>        <span class="hljs-comment">// 等待监视的socket有事件发生。</span><br>        <span class="hljs-comment">// 第一个参数：epoll句柄，epoll实例</span><br>        <span class="hljs-comment">// 第二个参数：如果epoll监听的socket有事件发生，将发生事件放在evs数组中</span><br>        <span class="hljs-comment">// indfs是返回值，表示有事件发生的socket的数量</span><br>        <span class="hljs-type">int</span> infds = <span class="hljs-built_in">epoll_wait</span>(epollfd, evs, <span class="hljs-number">10</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-comment">// 返回失败。</span><br>        <span class="hljs-keyword">if</span> (infds &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll() failed&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 超时。</span><br>        <span class="hljs-keyword">if</span> (infds == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll() timeout.\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果infds&gt;0，表示有事件发生的socket的数量。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; infds; ii++) <span class="hljs-comment">// 遍历epoll返回的数组evs。</span><br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;ptr=%s,events=%d\n&quot;,evs[ii].data.ptr,evs[ii].events);</span><br><br>            <span class="hljs-comment">// 如果发生事件的是listensock，表示有新的客户端连上来。</span><br>            <span class="hljs-keyword">if</span> (evs[ii].data.fd == listensock)<br>            &#123;<br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>                <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(client);<br>                <span class="hljs-type">int</span> clientsock = <span class="hljs-built_in">accept</span>(listensock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept client(socket=%d) ok.\n&quot;</span>, clientsock);<br><br>                <span class="hljs-comment">// 为新客户端准备读事件，并添加到epoll中。</span><br>                ev.data.fd = clientsock;<br>                ev.events = EPOLLIN;<br>                <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, clientsock, &amp;ev);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 如果是客户端连接的socket有事件，表示有报文发过来或者连接已断开。</span><br>                <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 存放从客户端读取的数据。</span><br>                <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>                <span class="hljs-comment">// evs[ii].data.fd存放了socket的值</span><br>                <span class="hljs-comment">// buffer是客户端的数据</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(evs[ii].data.fd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 如果客户端的连接已断开。</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client(eventfd=%d) disconnected.\n&quot;</span>, evs[ii].data.fd);<br>                    <span class="hljs-built_in">close</span>(evs[ii].data.fd); <span class="hljs-comment">// 关闭客户端的socket</span><br>                    <span class="hljs-comment">// 从epollfd中删除客户端的socket，如果socket被关闭了，会自动从epollfd中删除，所以，以下代码不必启用。</span><br>                    <span class="hljs-comment">// epoll_ctl(epollfd,EPOLL_CTL_DEL,evs[ii].data.fd,0);</span><br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 如果客户端有报文发过来。</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv(eventfd=%d):%s\n&quot;</span>, evs[ii].data.fd, buffer);<br><br>                    <span class="hljs-comment">// 把接收到的报文内容原封不动的发回去。</span><br>                    <span class="hljs-built_in">send</span>(evs[ii].data.fd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket() failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(opt);<br>    <span class="hljs-built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, len);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    servaddr.sin_family = AF_INET;<br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sock;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h3><blockquote><p>阻塞：在进程&#x2F;线程中，发起一个调用，在调用返回之前，进程&#x2F;线程会被阻塞等待，等待中的进程&#x2F;线程会让出CPU的使用权<br>非阻塞：在进程&#x2F;线程中，发起一个调用，会立即返回<br>会阻塞的四个函数：connect(),accept(),send(),recv()<br>在传统的网络服务端程序中（每连接，每个线程&#x2F;进程），采用阻塞IO<br>在IO复用的模型中，事件循环不能被阻塞在任何环节，所以，应该采用非阻塞IO</p></blockquote><h4 id="非阻塞IO-connect"><a href="#非阻塞IO-connect" class="headerlink" title="非阻塞IO-connect()"></a>非阻塞IO-connect()</h4><ul><li>对非阻塞的IO调用connect()函数，不管是否能够连接成功，connect()都会立即返回失败，<code>errno==EINPROGRESS</code><br>对非阻塞的IO调用connect()函数后，如果socket的状态是可写的，证明连接是成功的，否则是失败的</li></ul><h4 id="非阻塞IO-accept"><a href="#非阻塞IO-accept" class="headerlink" title="非阻塞IO-accept()"></a>非阻塞IO-accept()</h4><ul><li>对非阻塞的IO调用accept()，如果已连接队列中没有socket,函数立即返回失败，<code>errno==EAGAIN</code></li></ul><h4 id="非阻塞IO-recv"><a href="#非阻塞IO-recv" class="headerlink" title="非阻塞IO-recv()"></a>非阻塞IO-recv()</h4><ul><li>对非阻塞的IO调用recv(),如果没有数据可读(接收缓冲区为空),函数立即返回失败,<code>errno==EAGAIN</code></li></ul><h4 id="非阻塞IO-send"><a href="#非阻塞IO-send" class="headerlink" title="非阻塞IO-send()"></a>非阻塞IO-send()</h4><ul><li><p>对非阻塞的IO调用send(),如果socket不可写（发送缓冲区已经满），函数立即返回失败，<code>errno==EAGAIN</code></p></li><li><p>client1.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 网络通讯的客户端程序。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 把socket设置成非阻塞。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> flags;<br><br>    <span class="hljs-comment">// 获取fd的状态。</span><br>    <span class="hljs-keyword">if</span> ((flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)<br>        flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 在原来的状态上设置socket为非阻塞</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:./client1 ip port\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-keyword">if</span> ((sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket() failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">setnonblocking</span>(sockfd); <span class="hljs-comment">// 把sockfd设置成非阻塞。</span><br><br>    <span class="hljs-built_in">memset</span>(&amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(servaddr));<br>    servaddr.sin_family = AF_INET;<br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// 因为connect在客户端使用的多，在服务端用的少，我们需要处理的是服务端的非阻塞</span><br>    <span class="hljs-comment">// 作为了解即可</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 对于非阻塞的connect(),调用connect()都是返回EINPROGRESS</span><br>        <span class="hljs-keyword">if</span> (errno != EINPROGRESS)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect(%s:%s) failed.\n&quot;</span>, argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>            <span class="hljs-built_in">close</span>(sockfd);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里是判断sockfd是否是可写的，如果是可写的</span><br>    <span class="hljs-comment">// 表示连接是成功的</span><br>    pollfd fds;<br>    fds.fd = sockfd;<br>    fds.events = POLLOUT;<br>    <span class="hljs-comment">// 用poll来监听sockfd的写事件</span><br>    <span class="hljs-built_in">poll</span>(&amp;fds, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 如果是可写的，那么表示连接成功</span><br>    <span class="hljs-keyword">if</span> (fds.revents == POLLOUT)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect ok.\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect failed.\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// printf(&quot;开始时间：%d&quot;,time(0));</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">200000</span>; ii++)<br>    &#123;<br>        <span class="hljs-comment">// 从命令行输入内容。</span><br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input:&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>        <span class="hljs-comment">// strcpy(buf,&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbccccccccccccccccddddddddddddd&quot;);</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">send</span>(sockfd, buf, <span class="hljs-built_in">strlen</span>(buf), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write() failed.\n&quot;</span>);<br>            <span class="hljs-built_in">close</span>(sockfd);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(sockfd, buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read() failed.\n&quot;</span>);<br>            <span class="hljs-built_in">close</span>(sockfd);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv:%s\n&quot;</span>, buf);<br>    &#125;<br><br>    <span class="hljs-comment">// printf(&quot;结束时间：%d&quot;,time(0));</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>tcpepoll1.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：tcpepoll1.cpp，此程序用于临时的演示。</span><br><span class="hljs-comment"> * 作者：吴从周</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-comment">// 把socket设置成非阻塞。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> flags;<br><br>    <span class="hljs-comment">// 获取fd（socket）的状态。</span><br>    <span class="hljs-keyword">if</span> ((flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)<br>        flags = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 在原来的状态上设置socket为非阻塞</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);<br>&#125;<br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: ./tcpepoll1 port\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    <span class="hljs-type">int</span> listensock = <span class="hljs-built_in">initserver</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listensock=%d\n&quot;</span>, listensock);<br><br>    <span class="hljs-built_in">setnonblocking</span>(listensock); <span class="hljs-comment">// 把监听的socket设置为非阻塞。</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">accept</span>(listensock, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 非阻塞都会产生EAGAIN错误，如果不是这个错误，才真的是出错了</span><br>            <span class="hljs-keyword">if</span> (errno != EAGAIN)<br>            &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept:&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端已连接。\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (listensock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;initserver() failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建epoll句柄。</span><br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 为服务端的listensock准备读事件。</span><br>    epoll_event ev;          <span class="hljs-comment">// 声明事件的数据结构。</span><br>    ev.data.fd = listensock; <span class="hljs-comment">// 指定事件的自定义数据，会随着epoll_wait()返回的事件一并返回。</span><br>    <span class="hljs-comment">// ev.data.ptr=(void*)&quot;超女&quot;;   // 指定事件的自定义数据，会随着epoll_wait()返回的事件一并返回。</span><br>    ev.events = EPOLLIN; <span class="hljs-comment">// 打算让epoll监视listensock的读事件。</span><br><br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, listensock, &amp;ev); <span class="hljs-comment">// 把需要监视的socket和事件加入epollfd中。</span><br><br>    epoll_event evs[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 存放epoll返回的事件。</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) <span class="hljs-comment">// 事件循环。</span><br>    &#123;<br>        <span class="hljs-comment">// 等待监视的socket有事件发生。</span><br>        <span class="hljs-type">int</span> infds = <span class="hljs-built_in">epoll_wait</span>(epollfd, evs, <span class="hljs-number">10</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-comment">// 返回失败。</span><br>        <span class="hljs-keyword">if</span> (infds &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll() failed&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 超时。</span><br>        <span class="hljs-keyword">if</span> (infds == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll() timeout.\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果infds&gt;0，表示有事件发生的socket的数量。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; infds; ii++) <span class="hljs-comment">// 遍历epoll返回的数组evs。</span><br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;ptr=%s,events=%d\n&quot;,evs[ii].data.ptr,evs[ii].events);</span><br><br>            <span class="hljs-comment">// 如果发生事件的是listensock，表示有新的客户端连上来。</span><br>            <span class="hljs-keyword">if</span> (evs[ii].data.fd == listensock)<br>            &#123;<br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>                <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(client);<br>                <span class="hljs-type">int</span> clientsock = <span class="hljs-built_in">accept</span>(listensock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept client(socket=%d) ok.\n&quot;</span>, clientsock);<br><br>                <span class="hljs-comment">// 为新客户端准备读事件，并添加到epoll中。</span><br>                ev.data.fd = clientsock;<br>                ev.events = EPOLLIN;<br>                <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, clientsock, &amp;ev);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 如果是客户端连接的socke有事件，表示有报文发过来或者连接已断开。</span><br>                <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 存放从客户端读取的数据。</span><br>                <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(evs[ii].data.fd, buffer, <span class="hljs-built_in">sizeof</span>(buffer), <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 如果客户端的连接已断开。</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client(eventfd=%d) disconnected.\n&quot;</span>, evs[ii].data.fd);<br>                    <span class="hljs-built_in">close</span>(evs[ii].data.fd); <span class="hljs-comment">// 关闭客户端的socket</span><br>                    <span class="hljs-comment">// 从epollfd中删除客户端的socket，如果socket被关闭了，会自动从epollfd中删除，所以，以下代码不必启用。</span><br>                    <span class="hljs-comment">// epoll_ctl(epollfd,EPOLL_CTL_DEL,evs[ii].data.fd,0);</span><br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 如果客户端有报文发过来。</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv(eventfd=%d):%s\n&quot;</span>, evs[ii].data.fd, buffer);<br><br>                    <span class="hljs-comment">// 把接收到的报文内容原封不动的发回去。</span><br>                    <span class="hljs-built_in">send</span>(evs[ii].data.fd, buffer, <span class="hljs-built_in">strlen</span>(buffer), <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket() failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(opt);<br>    <span class="hljs-built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, len);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    servaddr.sin_family = AF_INET;<br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sock;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="水平触发-Level-triggered-LT-和边缘触发-Edge-triggered-ET"><a href="#水平触发-Level-triggered-LT-和边缘触发-Edge-triggered-ET" class="headerlink" title="水平触发(Level-triggered,LT)和边缘触发(Edge-triggered,ET)"></a>水平触发(Level-triggered,LT)和边缘触发(Edge-triggered,ET)</h3><ul><li><p>**水平触发 (Level-triggered)**：即事件持续有效，只要条件满足，就会持续通知。</p></li><li><p>**边缘触发 (Edge-triggered)**：即事件在状态发生变化的一瞬间触发，比如从低到高或从高到低的变化。</p></li><li><p>client2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 网络通讯的客户端程序。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:./client2 ip port\n&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> sockfd;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br> <br>    <span class="hljs-keyword">if</span> ((sockfd=<span class="hljs-built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>))&lt;<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket() failed.\n&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; &#125;<br><br>    <span class="hljs-built_in">memset</span>(&amp;servaddr,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(servaddr));<br>    servaddr.sin_family=AF_INET;<br>    servaddr.sin_port=<span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]));<br>    servaddr.sin_addr.s_addr=<span class="hljs-built_in">inet_addr</span>(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr,<span class="hljs-built_in">sizeof</span>(servaddr)) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect(%s:%s) failed.\n&quot;</span>,argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>]); <span class="hljs-built_in">close</span>(sockfd);  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect ok.\n&quot;</span>);<br><br>    <span class="hljs-comment">// printf(&quot;开始时间：%d&quot;,time(0));</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii=<span class="hljs-number">0</span>;ii&lt;<span class="hljs-number">200000</span>;ii++)<br>    &#123;<br>        <span class="hljs-comment">// 从命令行输入内容。</span><br>        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input:&quot;</span>); <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<br>        <span class="hljs-comment">// strcpy(buf,&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbccccccccccccccccddddddddddddd&quot;);</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">send</span>(sockfd,buf,<span class="hljs-built_in">strlen</span>(buf),<span class="hljs-number">0</span>) &lt;=<span class="hljs-number">0</span>)<br>        &#123; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write() failed.\n&quot;</span>);  <span class="hljs-built_in">close</span>(sockfd);  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(buf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">recv</span>(sockfd,buf,<span class="hljs-built_in">sizeof</span>(buf),<span class="hljs-number">0</span>) &lt;=<span class="hljs-number">0</span>) <br>        &#123; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read() failed.\n&quot;</span>);  <span class="hljs-built_in">close</span>(sockfd);  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv:%s\n&quot;</span>,buf);<br>    &#125;<br><br>    <span class="hljs-comment">// printf(&quot;结束时间：%d&quot;,time(0));</span><br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>tcpepoll2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 程序名：tcpepoll2.cpp，此程序用于演示采用epoll模型的边缘触发。</span><br><span class="hljs-comment"> * 作者：吴从周</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-comment">// 把socket设置成非阻塞。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> flags;<br><br>    <span class="hljs-comment">// 获取fd的状态。</span><br>    <span class="hljs-keyword">if</span> ((flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>)) == <span class="hljs-number">-1</span>)<br>        flags = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);<br>&#125;<br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: ./tcpepoll2 port\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化服务端用于监听的socket。</span><br>    <span class="hljs-type">int</span> listensock = <span class="hljs-built_in">initserver</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listensock=%d\n&quot;</span>, listensock);<br><br>    <span class="hljs-keyword">if</span> (listensock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;initserver() failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">setnonblocking</span>(listensock); <span class="hljs-comment">// 把listensock设置为非阻塞。</span><br><br>    <span class="hljs-comment">// 创建epoll句柄。</span><br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 为服务端的listensock准备读事件。</span><br>    epoll_event ev;          <span class="hljs-comment">// 声明事件的数据结构。</span><br>    ev.data.fd = listensock; <span class="hljs-comment">// 指定事件的自定义数据，会随着epoll_wait()返回的事件一并返回。</span><br>    <span class="hljs-comment">// ev.data.ptr=(void*)&quot;超女&quot;;   // 指定事件的自定义数据，会随着epoll_wait()返回的事件一并返回。</span><br>    ev.events = EPOLLIN; <span class="hljs-comment">// 打算让epoll监视listensock的读事件，LT（水平）模式。</span><br>    <span class="hljs-comment">// ev.events=EPOLLIN | EPOLLET;      // 打算让epoll监视listensock的读事件，ET（边缘）模式。</span><br><br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, listensock, &amp;ev); <span class="hljs-comment">// 把需要监视的socket和事件加入epollfd中。</span><br><br>    epoll_event evs[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 存放epoll返回的事件。</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) <span class="hljs-comment">// 事件循环。</span><br>    &#123;<br>        <span class="hljs-comment">// 等待监视的socket有事件发生。</span><br>        <span class="hljs-type">int</span> infds = <span class="hljs-built_in">epoll_wait</span>(epollfd, evs, <span class="hljs-number">10</span>, <span class="hljs-number">-1</span>);<br><br>        <span class="hljs-comment">// 返回失败。</span><br>        <span class="hljs-keyword">if</span> (infds &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll() failed&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 超时。</span><br>        <span class="hljs-keyword">if</span> (infds == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll() timeout.\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果infds&gt;0，表示有事件发生的socket的数量。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; infds; ii++) <span class="hljs-comment">// 遍历epoll返回的数组evs。</span><br>        &#123;<br>            <span class="hljs-comment">// printf(&quot;ptr=%s,events=%d\n&quot;,evs[ii].data.ptr,evs[ii].events);</span><br><br>            <span class="hljs-comment">// 如果发生事件的是listensock，表示有新的客户端连上来。</span><br>            <span class="hljs-keyword">if</span> (evs[ii].data.fd == listensock)<br>            &#123;<br>                <span class="hljs-comment">// ET(边缘触发)需要用非阻塞的循环来写</span><br>                <span class="hljs-comment">// 因为边缘触发可能会有socket未处理，但也不会再次通知</span><br>                <span class="hljs-comment">// 只能通过循环accept()来一直找是否还有未连接的socket</span><br>                <span class="hljs-comment">// 必须要用非阻塞的，否则，没有connect的时候会阻塞在accept()这里</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>                &#123;<br>                    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>                    <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(client);<br>                    <span class="hljs-type">int</span> clientsock = <span class="hljs-built_in">accept</span>(listensock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br>                    <span class="hljs-comment">// clientsock &lt; 0：accept 返回值 clientsock 小于 0 时表示发生了错误，未能成功接受连接</span><br>                    <span class="hljs-comment">// errno == EAGAIN：在非阻塞模式下，如果没有新的连接可以接受，accept 会返回 -1，并将 errno 设置为 EAGAIN，表示当前没有可用的客户端连接</span><br>                    <span class="hljs-comment">// 表示已连接队列中没有socket了</span><br>                    <span class="hljs-keyword">if</span> ((clientsock &lt; <span class="hljs-number">0</span>) &amp;&amp; (errno == EAGAIN))<br>                        <span class="hljs-keyword">break</span>;<br><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept client(socket=%d) ok.\n&quot;</span>, clientsock);<br><br>                    <span class="hljs-comment">// 为新客户端准备读事件，并添加到epoll中。</span><br>                    <span class="hljs-built_in">setnonblocking</span>(clientsock); <span class="hljs-comment">// 把客户端连接的socket设置为非阻塞。</span><br>                    ev.data.fd = clientsock;<br>                    <span class="hljs-comment">// ev.events=EPOLLOUT;                       // LT-水平触发。</span><br>                    ev.events = EPOLLOUT | EPOLLET; <span class="hljs-comment">// ET-边缘触发。</span><br>                    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, clientsock, &amp;ev);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;触发了写件事。\n&quot;</span>);<br>                <span class="hljs-comment">// 这里是一直发送数据，会存在发送缓冲区，而客户端读取速度慢一点</span><br>                <span class="hljs-comment">// 服务端的发送缓冲区就会满，后续就等待客户端的接收缓冲区接收数据，发送缓冲区就会空出位置</span><br>                <span class="hljs-comment">// 发送缓冲区就从满-&gt;不满，此时就会在边缘模式下再次触发写事件</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ii = <span class="hljs-number">0</span>; ii &lt; <span class="hljs-number">10000000</span>; ii++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">send</span>(ev.data.fd, <span class="hljs-string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbb&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>) &lt;= <span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (errno == EAGAIN)<br>                        &#123;<br>                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;发送缓冲区已填懣。\n&quot;</span>);<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">/* 读事件代码</span><br><span class="hljs-comment">                // 如果是客户端连接的socke有事件，表示有报文发过来或者连接已断开。</span><br><span class="hljs-comment">                // 边缘触发的代码可以用于水平触发，而水平触发的代码不能用于边缘触发</span><br><span class="hljs-comment">                // 修改服务器的监听/客户端连接的socket的events为水平或者边缘触发</span><br><span class="hljs-comment">                char buffer[1024];       // 存放从客户端读取的数据。</span><br><span class="hljs-comment">                memset(buffer,0,sizeof(buffer));</span><br><span class="hljs-comment">                int    readn;                 // 每次调用recv()的返回值。</span><br><span class="hljs-comment">                char *ptr=buffer;        // buffer的位置指针。</span><br><span class="hljs-comment">                while (true)</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                    // readn是读取的字节数，如果大于0，表示还有数据，继续读取，ptr是当前buffer中可以存放数据的位置</span><br><span class="hljs-comment">                    if ( (readn=recv(evs[ii].data.fd,ptr,5,0))&lt;=0 )</span><br><span class="hljs-comment">                    &#123;</span><br><span class="hljs-comment">                        if ( (readn&lt;0) &amp;&amp; (errno==EAGAIN) )</span><br><span class="hljs-comment">                        &#123;   // 如果数据被读取完了，把接收到的报文内容原封不动的发回去。</span><br><span class="hljs-comment">                            send(evs[ii].data.fd,buffer,strlen(buffer),0);</span><br><span class="hljs-comment">                            printf(&quot;recv(eventfd=%d):%s\n&quot;,evs[ii].data.fd,buffer);</span><br><span class="hljs-comment">                        &#125;</span><br><span class="hljs-comment">                        else</span><br><span class="hljs-comment">                        &#123;</span><br><span class="hljs-comment">                            // 如果客户端的连接已断开。</span><br><span class="hljs-comment">                            printf(&quot;client(eventfd=%d) disconnected.\n&quot;,evs[ii].data.fd);</span><br><span class="hljs-comment">                            close(evs[ii].data.fd);            // 关闭客户端的socket</span><br><span class="hljs-comment">                        &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                        break;        // 跳出循环。</span><br><span class="hljs-comment">                    &#125;</span><br><span class="hljs-comment">                    else</span><br><span class="hljs-comment">                        ptr=ptr+readn;                    // buffer的位置指针后移。</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">                */</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 初始化服务端的监听端口。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initserver</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket() failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(opt);<br>    <span class="hljs-built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;opt, len);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> servaddr;<br>    servaddr.sin_family = AF_INET;<br>    servaddr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    servaddr.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;servaddr, <span class="hljs-built_in">sizeof</span>(servaddr)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sock, <span class="hljs-number">5</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen() failed&quot;</span>);<br>        <span class="hljs-built_in">close</span>(sock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sock;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>知识点二_constexpr_RTTR安装_局域网为什么使用MAC地址通信_弱类型枚举和强类型枚举</title>
    <link href="/2024/11/02/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C_constexpr_RTTR%E5%AE%89%E8%A3%85_%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8MAC%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1_%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE/"/>
    <url>/2024/11/02/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C_constexpr_RTTR%E5%AE%89%E8%A3%85_%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8MAC%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1_%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE%E5%92%8C%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h1><p><code>constexpr</code> 是 C++11 引入的关键字，主要用于在编译时求值表达式。它允许定义常量表达式，以便在编译阶段进行优化，提高程序的运行效率。随着 C++14 和 C++17 的发展，<code>constexpr</code> 的功能进一步增强，使得它能够处理更复杂的编译时计算逻辑。<br>以下是 <code>constexpr</code> 的一些重要特性和应用场景：</p><h3 id="1-基本用法和作用"><a href="#1-基本用法和作用" class="headerlink" title="1. 基本用法和作用"></a>1. 基本用法和作用</h3><ul><li><strong>定义常量</strong>：<code>constexpr</code> 可以定义在编译时确定的常量。例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">constexpr <span class="hljs-built_in">int</span> max_size = <span class="hljs-number">100</span>; <span class="hljs-comment">// 编译期确定的常量</span><br></code></pre></td></tr></table></figure></li><li><strong>用于函数</strong>：<code>constexpr</code> 函数会在编译期进行求值，只要所有参数都是编译期常量。这样可以避免运行时计算，提高性能。例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">constexpr <span class="hljs-built_in">int</span> <span class="hljs-title">square</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    constexpr <span class="hljs-built_in">int</span> result = square(<span class="hljs-number">5</span>); <span class="hljs-comment">// 在编译期求值</span><br>&#125;<br><br></code></pre></td></tr></table></figure>如果在运行时调用 <code>constexpr</code> 函数（如传递非 <code>constexpr</code> 参数），它也能正常执行，只是求值会在运行时进行，而不是编译期。</li></ul><h3 id="2-constexpr-变量和-const-的区别"><a href="#2-constexpr-变量和-const-的区别" class="headerlink" title="2. constexpr 变量和 const 的区别"></a>2. <code>constexpr</code> 变量和 <code>const</code> 的区别</h3><ul><li>**<code>const</code>**：用于定义只读的常量，不能在定义后更改，但并不保证值在编译时已知。例如，<code>const</code> 可以用于不可变的运行时常量。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> x = std::time(<span class="hljs-number">0</span>); <span class="hljs-comment">// 运行时初始化的常量</span><br></code></pre></td></tr></table></figure></li><li>**<code>constexpr</code>**：要求其初始化表达式在编译期可知。<code>constexpr</code> 变量必须在编译时初始化，否则会报错。例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">constexpr <span class="hljs-built_in">int</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// 编译期初始化</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-constexpr-函数的规则"><a href="#3-constexpr-函数的规则" class="headerlink" title="3. constexpr 函数的规则"></a>3. <code>constexpr</code> 函数的规则</h3><ul><li>C++11 要求 <code>constexpr</code> 函数必须是单一表达式的返回值函数，不支持循环和分支。</li><li>C++14 允许 <code>constexpr</code> 函数包含更复杂的逻辑，例如分支（<code>if</code>）和循环（<code>for</code>、<code>while</code>），进一步增强了其功能。</li><li>C++17 允许在 <code>constexpr</code> 函数中定义局部变量和使用 <code>constexpr</code> 复合数据结构。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">constexpr <span class="hljs-built_in">int</span> <span class="hljs-title">factorial</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        result *= i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-编译期计算的应用场景"><a href="#4-编译期计算的应用场景" class="headerlink" title="4. 编译期计算的应用场景"></a>4. 编译期计算的应用场景</h3><ul><li><strong>元编程</strong>：通过 <code>constexpr</code> 函数实现编译期计算，不需要在运行时执行。</li><li><strong>数组大小</strong>：编译期常量有助于定义数组大小等。</li><li><strong>数学常量或计算</strong>：如阶乘、斐波那契数列、平方根等不需要在运行时计算的值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">constexpr <span class="hljs-built_in">int</span> <span class="hljs-title">fib</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (n &lt;= <span class="hljs-number">1</span>) ? n : fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-constexpr-与-consteval-和-constinit"><a href="#5-constexpr-与-consteval-和-constinit" class="headerlink" title="5. constexpr 与 consteval 和 constinit"></a>5. <code>constexpr</code> 与 <code>consteval</code> 和 <code>constinit</code></h3><ul><li>**<code>consteval</code>**：C++20 引入，用于要求表达式必须在编译时求值。所有 <code>consteval</code> 函数的结果必须在编译时确定，否则编译报错。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">consteval <span class="hljs-built_in">int</span> <span class="hljs-title">cube</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> x * x * x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>**<code>constinit</code>**：C++20 引入，用于强制静态变量的编译期初始化，但不要求其值是常量（可以在运行时更改）。适用于要求初始化，但不要求保持常量的变量。</li></ul><h3 id="6-使用-constexpr-的注意事项"><a href="#6-使用-constexpr-的注意事项" class="headerlink" title="6. 使用 constexpr 的注意事项"></a>6. 使用 <code>constexpr</code> 的注意事项</h3><ul><li>确保 <code>constexpr</code> 表达式在编译期可知。对于复杂表达式，可能需要逐步分解以满足编译期可评估的要求。</li><li>避免在性能敏感的代码中使用过多递归 <code>constexpr</code> 表达式，这可能导致编译时间延长。</li></ul><h1 id="RTTR安装"><a href="#RTTR安装" class="headerlink" title="RTTR安装"></a>RTTR安装</h1><p><a href="https://www.rttr.org/doc/master/building_install_page.html">官方安装说明</a></p><blockquote><p>RTTR (Run-Time Type Reflection) 是一个 C++ 库，提供了运行时类型反射功能，允许在运行时查询和操作类型信息。这使得 C++ 程序可以在运行时更灵活地处理类型，例如进行序列化、反序列化、动态创建对象、调用方法等。</p></blockquote><p>在 Windows 系统上安装 RTTR 库可以通过多种方式完成，包括手动编译、使用包管理器（如 <code>vcpkg</code>）或使用预编译的库文件。下面是详细步骤：</p><h3 id="使用-vcpkg-安装-RTTR"><a href="#使用-vcpkg-安装-RTTR" class="headerlink" title="使用 vcpkg 安装 RTTR"></a>使用 vcpkg 安装 RTTR</h3><p><code>vcpkg</code> 是一个 C++ 包管理工具，可以轻松安装和管理库。使用 <code>vcpkg</code> 安装 RTTR 是最简单的方式。</p><ol><li><strong>安装 vcpkg</strong>（如果未安装）：<ul><li>打开终端（PowerShell 或命令提示符），克隆 <code>vcpkg</code> 仓库并编译：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">git clone https://github.com/microsoft/vcpkg.git<br><span class="hljs-built_in">cd</span> vcpkg<br>.\bootstrap<span class="hljs-literal">-vcpkg</span>.bat<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>安装 RTTR</strong>：<ul><li>使用以下命令安装 RTTR：</li></ul></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">.\vcpkg install rttr<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>集成到 Visual Studio</strong>（可选）：<ul><li>若使用 Visual Studio，可以将 <code>vcpkg</code> 安装路径集成到 IDE 中，自动包含已安装库：</li></ul></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs powershell">.\vcpkg integrate install<br>```    <br><span class="hljs-number">4</span>. **配置项目**：<br>    - 在项目属性中，确保将 `vcpkg` 安装的 `include` 和 `lib` 路径添加到包含目录中。<br>    - `C:\Users\<span class="hljs-number">13248</span>\Downloads\vcpkg\installed\x64<span class="hljs-literal">-windows</span>\include`<br>    - `C:\Users\<span class="hljs-number">13248</span>\Downloads\vcpkg\installed\x64<span class="hljs-literal">-windows</span>\lib`<br>    - `C:\Users\<span class="hljs-number">13248</span>\Downloads\vcpkg\installed\x64<span class="hljs-literal">-windows</span>\bin\rttr_core.dll`放在目录的sin一起<br>    - 使用 `#include &lt;rttr/registration&gt;` 包含 RTTR 头文件。<br><br><span class="hljs-comment">### 配置测试代码（release才行，不然会断点调试）</span><br><br>编译成功后，可以测试 RTTR 是否安装正确。创建一个简单的 C++ 程序来检查 RTTR 功能：<br><br>```cpp<br><span class="hljs-comment">#include &lt;rttr/registration&gt;</span><br><span class="hljs-comment">#include &lt;iostream&gt;</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> rttr;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span></span> &#123;<br>public:<br>    TestClass() : value(<span class="hljs-number">0</span>) &#123;&#125;<br>    void setValue(int v) &#123; value = v; &#125;<br>    int getValue() const &#123; <span class="hljs-keyword">return</span> value; &#125;<br><br>private:<br>    int value;<br>&#125;;<br><br>RTTR_REGISTRATION<br>&#123;<br>    registration::class_&lt;TestClass&gt;(<span class="hljs-string">&quot;TestClass&quot;</span>)<br>        .constructor&lt;&gt;()<br>        .property(<span class="hljs-string">&quot;value&quot;</span>, &amp;TestClass::getValue, &amp;TestClass::setValue);<br>&#125;<br><br>int main() &#123;<br>    <span class="hljs-built_in">type</span> testType = <span class="hljs-built_in">type</span>::get_by_name(<span class="hljs-string">&quot;TestClass&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (testType.is_valid()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;RTTR is working correctly!&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;RTTR is not installed/configured correctly.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译并运行程序，如果输出 <code>&quot;RTTR is working correctly!&quot;</code>，则说明安装和配置成功。</p><h3 id="RTTR-的主要功能"><a href="#RTTR-的主要功能" class="headerlink" title="RTTR 的主要功能"></a>RTTR 的主要功能</h3><ol><li><strong>类型注册</strong>：允许开发者注册类、枚举和属性等，以便在运行时进行反射。</li><li><strong>对象创建</strong>：可以在运行时通过类型信息动态创建对象。</li><li><strong>方法调用</strong>：可以动态调用类的方法，而无需在编译时了解方法的具体签名。</li><li><strong>属性访问</strong>：可以动态读取和设置对象的属性。</li><li><strong>序列化</strong>：支持将对象序列化为字符串或其他格式，方便存储或传输。</li></ol><h3 id="使用-RTTR-的基本步骤"><a href="#使用-RTTR-的基本步骤" class="headerlink" title="使用 RTTR 的基本步骤"></a>使用 RTTR 的基本步骤</h3><ol><li><strong>安装 RTTR</strong>：可以通过 <code>vcpkg</code> 或手动下载源代码进行安装。</li><li><strong>包含头文件</strong>：在代码中包含 RTTR 的头文件。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rttr/registration&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>注册类型</strong>：使用 <code>RTTR_REGISTRATION</code> 宏注册类型。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">RTTR_REGISTRATION<br>&#123;<br>    rttr::registration::<span class="hljs-built_in">class_</span>&lt;YourClass&gt;(<span class="hljs-string">&quot;YourClass&quot;</span>)<br>        .constructor&lt;&gt;()<br>        .<span class="hljs-built_in">property</span>(<span class="hljs-string">&quot;propertyName&quot;</span>, &amp;YourClass::getProperty, &amp;YourClass::setProperty);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>使用类型反射</strong>：在程序中获取类型信息，创建对象或调用方法。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">rttr::type myType = rttr::type::<span class="hljs-built_in">get</span>&lt;YourClass&gt;();<br></code></pre></td></tr></table></figure><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个简单的 RTTR 使用示例，定义了一个类并注册它，以演示如何在运行时访问类型信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;rttr/registration&gt;</span> <span class="hljs-comment">// 包含 RTTR 的注册头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> <span class="hljs-comment">// 包含输入输出流头文件</span></span><br><br><span class="hljs-comment">// 定义 TestClass 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 默认构造函数，初始化值为 0</span><br><span class="hljs-built_in">TestClass</span>() : <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br><span class="hljs-comment">// 设置值的方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123; value = v; &#125;<br><br><span class="hljs-comment">// 获取值的方法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><br><span class="hljs-comment">// 打印当前值的方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;TestClass Current Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> value; <span class="hljs-comment">// 存储值的私有成员变量</span><br>&#125;;<br><br><span class="hljs-comment">// 定义另一个类 AnotherClass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 默认构造函数，初始化文本为 &quot;Hello&quot;</span><br><span class="hljs-built_in">AnotherClass</span>() : <span class="hljs-built_in">text</span>(<span class="hljs-string">&quot;Hello&quot;</span>) &#123;&#125;<br><br><span class="hljs-comment">// 设置文本的方法,const std::string&amp;这个类型需要和下面的getText一样</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setText</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; t)</span> </span>&#123; text = t; &#125;<br><br><span class="hljs-comment">// 获取文本的方法，返回值类型需要和const std::string&amp;一样</span><br><span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getText</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> text; &#125;<br><br><span class="hljs-comment">// 打印当前文本的方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printText</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;AnotherClass Current Text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>std::string text; <span class="hljs-comment">// 存储文本的私有成员变量</span><br>&#125;;<br><br><span class="hljs-comment">// 使用 RTTR 进行注册</span><br>RTTR_REGISTRATION<br>&#123;<br><span class="hljs-comment">// 注册 TestClass</span><br>rttr::registration::<span class="hljs-built_in">class_</span>&lt;TestClass&gt;(<span class="hljs-string">&quot;TestClass&quot;</span>)<br>.constructor&lt;&gt;() <span class="hljs-comment">// 注册无参数构造函数</span><br>.<span class="hljs-built_in">property</span>(<span class="hljs-string">&quot;value&quot;</span>, &amp;TestClass::getValue, &amp;TestClass::setValue) <span class="hljs-comment">// 注册属性 &quot;value&quot;</span><br>.<span class="hljs-built_in">method</span>(<span class="hljs-string">&quot;printValue&quot;</span>, &amp;TestClass::printValue); <span class="hljs-comment">// 注册方法 &quot;printValue&quot;</span><br><br><span class="hljs-comment">// 注册 AnotherClass</span><br>rttr::registration::<span class="hljs-built_in">class_</span>&lt;AnotherClass&gt;(<span class="hljs-string">&quot;AnotherClass&quot;</span>)<br>.constructor&lt;&gt;() <span class="hljs-comment">// 注册无参数构造函数</span><br>.<span class="hljs-built_in">property</span>(<span class="hljs-string">&quot;text&quot;</span>, &amp;AnotherClass::getText, &amp;AnotherClass::setText) <span class="hljs-comment">// 注册属性 &quot;text&quot;</span><br>.<span class="hljs-built_in">method</span>(<span class="hljs-string">&quot;printText&quot;</span>, &amp;AnotherClass::printText); <span class="hljs-comment">// 注册方法 &quot;printText&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 创建 TestClass 的实例</span><br>TestClass test;<br>test.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 设置值为 42</span><br><br><span class="hljs-comment">// 获取 TestClass 的类型信息</span><br>rttr::type testType = rttr::type::<span class="hljs-built_in">get</span>(test);<br><br><span class="hljs-comment">// 获取并调用 printValue 方法</span><br><span class="hljs-keyword">auto</span> testMethod = testType.<span class="hljs-built_in">get_method</span>(<span class="hljs-string">&quot;printValue&quot;</span>);<br><span class="hljs-keyword">if</span> (testMethod.<span class="hljs-built_in">is_valid</span>()) &#123; <span class="hljs-comment">// 检查方法是否有效</span><br>testMethod.<span class="hljs-built_in">invoke</span>(test); <span class="hljs-comment">// 动态调用 printValue 方法</span><br>&#125;<br><br><span class="hljs-comment">// 创建 AnotherClass 的实例</span><br>AnotherClass another;<br>another.<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">// 设置文本为 &quot;World&quot;</span><br><br><span class="hljs-comment">// 获取 AnotherClass 的类型信息</span><br>rttr::type anotherType = rttr::type::<span class="hljs-built_in">get</span>(another);<br><br><span class="hljs-comment">// 获取并调用 printText 方法</span><br><span class="hljs-keyword">auto</span> anotherMethod = anotherType.<span class="hljs-built_in">get_method</span>(<span class="hljs-string">&quot;printText&quot;</span>);<br><span class="hljs-keyword">if</span> (anotherMethod.<span class="hljs-built_in">is_valid</span>()) &#123; <span class="hljs-comment">// 检查方法是否有效</span><br>anotherMethod.<span class="hljs-built_in">invoke</span>(another); <span class="hljs-comment">// 动态调用 printText 方法</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 返回 0，表示程序正常结束</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="配置与编译"><a href="#配置与编译" class="headerlink" title="配置与编译"></a>配置与编译</h3><p>确保在编译和链接时正确配置 RTTR，包括：</p><ul><li>添加 RTTR 的包含目录到项目设置中。</li><li>添加 RTTR 的库文件到链接器输入中。</li></ul><h3 id="常见问题与解决方案"><a href="#常见问题与解决方案" class="headerlink" title="常见问题与解决方案"></a>常见问题与解决方案</h3><ol><li><strong>找不到头文件</strong>：确保正确设置了包含目录。</li><li><strong>链接错误</strong>：确保链接了正确的库文件，例如 <code>rttr_core.lib</code>。</li><li><strong>运行时错误</strong>：检查类型注册是否正确，确保使用的类型与注册的一致。</li></ol><h1 id="局域网为什么使用MAC地址通信"><a href="#局域网为什么使用MAC地址通信" class="headerlink" title="局域网为什么使用MAC地址通信"></a>局域网为什么使用MAC地址通信</h1><blockquote><p>如果一个局域网内的主机A想要访问很远的一个局域网内的主机B。这两台主机都是接入了Internet互联网，中间会经过Ip地址和多次的MAC地址的转换，最终将主机A的消息发送到了主机B，Ip地址从始至终没有改变，但是MAC一直在变化。<br>而局域网中的通信只使用MAC地址就行，为什么不用Ip了呢？</p></blockquote><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><ul><li>ARP协议，工作在网络层的协议，但是可以产生在数据链路层（网络接口层）传递的帧<ul><li>作用：<code>将Ip地址转换为MAC地址</code></li><li>通过发送MAC地址的广播帧，不断广播，到达目的Ip地址的主机，回复响应的ARP帧，最后返回发送主机，获取到了目标Ip地址的主机的MAC帧。但是实际上并不是一次性获取到目标Ip地址的MAC地址，只是获取到了下一跳主机或者路由器的MAC地址</li></ul></li></ul><h3 id="局域网之间用MAC地址通信，为什么不用Ip呢"><a href="#局域网之间用MAC地址通信，为什么不用Ip呢" class="headerlink" title="局域网之间用MAC地址通信，为什么不用Ip呢"></a>局域网之间用MAC地址通信，为什么不用Ip呢</h3><ul><li>我所理解的局域网，并不是按照地域，距离划分，而是只是工作在物理层，数据链路层的主机间的通信。在局域网中，只是有主机，集线器，二层交换机等只使用到前两层进行消息传递的网络中。但是实际上，有路由器，三层交换机都没事，只要不连接到互联网上，都算是局域网。比如多个局域网通过一个路由器连接等。<ul><li>因此在局域网中，主机连到交换机上，交换机有一个MAC地址表，能够记录对应的MAC地址在交换机的哪个端口上，如果不知道，则广播除了接收消息的端口的其他所有端口</li><li>因此直接使用MAC地址进行通信就可以了</li><li>不使用Ip地址，因为<code>交换机本身是工作在前两层</code>，Ip地址在网络层，他应该是无法解析对应的数据的，所以Ip地址也用不上</li></ul></li><li>MAC地址是设备出厂时就固定了的，<code>每台主机唯一标识了一个MAC地址</code>，两者一一对应。而局域网中，只是简单的局域网通信，DHCP服务器或者路由器分配Ip地址的话，就只能给局域网内的每个主机分配私有Ip地址了，而具体分配到哪个主机，还是需要MAC地址唯一确定。<ul><li>所以在一个独立的局域网中，如果你想要给另一台主机发消息，还是需要知道他的地址，然后会使用ARP协议，获取其MAC地址，通过MAC地址来找到对应的交换机的哪个端口，将消息发送出去</li></ul></li><li>那为什么局域网内部还是要有Ip地址呢？<ul><li>我的理解是如果有多个局域网，通过一个或者多个路由器或者三层交换机相连。<code>不同局域网内的主机通信是需要的</code></li><li>举例就是有两家网吧，他们各自的网吧中的电脑都组成一个小的局域网。现在举办联谊，两个网吧的游戏爱好者进行比赛，那么消息通信就需要使用Ip地址了</li><li>因为Ip地址能够划分不同的区域，假如192.168.1.x是网吧A，192.168.2.x是网吧B，这就涉及到了分割广播域，需要路由器来完成，具体我也不记得了，就不细说了。大概意思就是能够知道192.168.1.x如果发送信息到192.168.2.x，就只是固定的交换机的那几个端口，其他的端口也就不发送消息了，作用也是一定程度上明确了要发送的方向</li></ul></li><li>MAC地址本身是没有区域划分的，而Ip地址是有区域划分的。类似于分层结构，先Ip地址找到主机大致的是属于哪个局域网，局域网内部再直接使用唯一的MAC地址找到对应的主机</li><li><code>历史遗留问题</code>，刚开始使用MAC进行小范围的信息传递没问题，等接入的设备多了，范围广了，就不好快速准确发送消息了，就出来Ip地址大致确定属于哪个区域，再准确投递消息</li></ul><h1 id="弱类型枚举和强类型枚举"><a href="#弱类型枚举和强类型枚举" class="headerlink" title="弱类型枚举和强类型枚举"></a>弱类型枚举和强类型枚举</h1><p>在 C++ 中，枚举类型通常有两种形式：强类型枚举（<code>enum class</code>）和弱类型枚举（传统的 <code>enum</code>）。</p><h3 id="弱类型枚举（传统的-enum）"><a href="#弱类型枚举（传统的-enum）" class="headerlink" title="弱类型枚举（传统的 enum）"></a>弱类型枚举（传统的 <code>enum</code>）</h3><p>弱类型枚举允许 <strong>隐式转换</strong>，即可以将整数值直接赋给枚举类型，反之亦然。这是因为弱类型枚举实际上与整数类型具有兼容性，枚举的底层类型默认是 <code>int</code>，可以直接用整数来赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red = <span class="hljs-number">1</span>,<br>    Green = <span class="hljs-number">2</span>,<br>    Blue = <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color = <span class="hljs-number">2</span>;  <span class="hljs-comment">// int 隐式转换为 Color</span><br>    cout &lt;&lt; color &lt;&lt; endl;  <span class="hljs-comment">// 输出 2</span><br>    <br>    <span class="hljs-type">int</span> x = Red;  <span class="hljs-comment">// Color 隐式转换为 int</span><br>    cout &lt;&lt; x &lt;&lt; endl;  <span class="hljs-comment">// 输出 1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul><li>在上述代码中，<code>Color color = 2;</code> 允许将一个整数（<code>2</code>）赋值给枚举类型 <code>Color</code>。这就是因为传统的 <code>enum</code> 枚举类型是弱类型枚举，它允许枚举和 <code>int</code> 之间进行隐式转换。</li><li>同样，<code>int x = Red;</code> 也可以成功地将枚举值赋值给整数。</li></ul><h3 id="强类型枚举（enum-class）"><a href="#强类型枚举（enum-class）" class="headerlink" title="强类型枚举（enum class）"></a>强类型枚举（<code>enum class</code>）</h3><p>强类型枚举（<code>enum class</code>）则不同，它不允许与 <code>int</code> 之间进行隐式转换，必须显式进行类型转换。这是为了避免类型混淆和错误。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red = <span class="hljs-number">1</span>,<br>    Green = <span class="hljs-number">2</span>,<br>    Blue = <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Color color = 2;  // 编译错误：不能将 int 隐式转换为 Color</span><br>    Color color = <span class="hljs-built_in">static_cast</span>&lt;Color&gt;(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 必须显式转换</span><br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(color) &lt;&lt; endl;  <span class="hljs-comment">// 输出 2</span><br>    <br>    <span class="hljs-comment">// int x = Color::Red;  // 编译错误：不能将 Color 转换为 int</span><br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(Color::Red);  <span class="hljs-comment">// 显式转换</span><br>    cout &lt;&lt; x &lt;&lt; endl;  <span class="hljs-comment">// 输出 1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="弱类型枚举可能带来的问题"><a href="#弱类型枚举可能带来的问题" class="headerlink" title="弱类型枚举可能带来的问题"></a>弱类型枚举可能带来的问题</h3><p>在C++中，enum class 是一种改进的枚举类型，它相对于传统的 enum 具有一些额外的优点。这个语法是C++11引入的，目的是解决传统 enum 存在的一些问题。<br><strong>1.</strong> 作用域内枚举（Scoped Enums）</p><ul><li><strong>解释</strong>：传统的 enum 是<strong>非作用域</strong>的，意味着它的枚举成员（如 Up, Down）会泄露到外部的作用域中，可能导致命名冲突。而 enum class 是作用域内的，枚举成员只能通过枚举类型的名称访问。</li><li><strong>示例</strong>：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Direction d = Direction::Up; <span class="hljs-comment">// 使用了作用域限定符 Direction::</span><br></code></pre></td></tr></table></figure>这样，Up 不会与其他枚举中的值或全局变量冲突。</li></ul><p><strong>2.</strong> 强类型（Strongly Typed）</p><ul><li><strong>解释</strong>：传统的 enum 是<strong>弱类型</strong>的，可以隐式地转换为整数，导致一些潜在的错误。enum class 是<strong>强类型</strong>的，枚举类型不能隐式转换为整数，必须进行显式转换。</li><li><strong>示例</strong>：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Direction d = Direction::Up;<br><br><span class="hljs-type">int</span> n = d; <span class="hljs-comment">// 错误，不能隐式转换为int</span><br><br><span class="hljs-type">int</span> n = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(d); <span class="hljs-comment">// 正确，需要显式转换</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>3.</strong> 底层类型指定</p><ul><li><strong>解释</strong>：在 enum class 中，可以明确指定枚举的底层类型（如 int, unsigned int），默认是 int。这给了开发者更多的控制权，特别是在对内存占用或特定位宽有要求的情况下。</li><li><strong>示例</strong>：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Direction</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span><br>&#123;<br>    None = <span class="hljs-number">0</span>,<br>    Up,<br>    Down,<br>    Left,<br>    Right<br><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h4><ul><li>在强类型枚举中，<code>Color color = 2;</code> 是不允许的，因为强类型枚举不允许隐式地将 <code>int</code> 转换为枚举类型。</li><li>需要通过 <code>static_cast&lt;Color&gt;(2)</code> 显式地进行转换，才能将整数 <code>2</code> 转换为 <code>Color</code> 枚举类型。</li><li>同样，若要将枚举值转换为整数，需要使用 <code>static_cast&lt;int&gt;(color)</code>。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>弱类型枚举（传统的 <code>enum</code>）</strong>：允许隐式地将整数赋给枚举类型，反之亦然。</li><li><strong>强类型枚举（<code>enum class</code>）</strong>：不允许隐式转换，必须显式地进行类型转换。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/ruisun09/article/details/108535736">RTTR实现C++反射（1）集成rttr库_可以参考doxygen的安装</a><br><a href="https://cmake.org/download/">CMake下载地址</a><br><a href="https://blog.csdn.net/nanke_yh/article/details/124346308">Windows下Boost库的安装与使用</a><br><a href="https://blog.csdn.net/ff900709/article/details/82225288">局域网内和局域网间的通信（交换机和路由器）</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cpp或者CSharp发现的知识点</title>
    <link href="/2024/11/01/Cpp%E6%88%96%E8%80%85CSharp%E5%8F%91%E7%8E%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2024/11/01/Cpp%E6%88%96%E8%80%85CSharp%E5%8F%91%E7%8E%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ol><li>aspDotNet生命周期（C#）</li><li>PInvoke 和restful(C#)</li><li><del>C++实现反射（C++）</del></li><li>编码格式的问题，char接收中文为2字节，宽字符，utf-8中文占用3字节</li><li>欧拉角的万向节死锁</li><li>C++配置文件的编写</li><li>C++中push_back()和emplace_back()的区别</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSharp知识整理(四)</title>
    <link href="/2024/10/28/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E5%9B%9B)/"/>
    <url>/2024/10/28/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-协变-out-和逆变-in"><a href="#一、-协变-out-和逆变-in" class="headerlink" title="一、 协变(out)和逆变(in)"></a>一、 协变(out)和逆变(in)</h1><p>协变（covariance）和逆变（contravariance）是泛型类型参数的一种变换方式，主要用于解决泛型类型的继承关系，特别是在处理委托和接口时。这些概念在 C# 中尤其重要，因为它们帮助我们在类型安全的同时实现灵活的类型转换。</p><ul><li>out一般指返回值</li><li>in一般指参数</li><li>都是里氏转换原则，out是使用父类接收子类，没问题</li><li>in是将参数为父类的赋值为参数为子类的，但是调用的时候还是子类进行调用，传入的参数也是子类。但是由于子类的函数是父类，此时就是父类的参数接收子类，符合里氏转换原则。可以看文后的参考<a href="https://www.cnblogs.com/VVStudy/p/11404300.html" title="发布于 2019-08-28 12:04">C# - 协变、逆变 看完这篇就懂了</a></li></ul><h3 id="1-协变（Covariance）"><a href="#1-协变（Covariance）" class="headerlink" title="1. 协变（Covariance）"></a>1. 协变（Covariance）</h3><p><strong>协变</strong>允许你使用更具体的类型替换泛型类型参数。例如，协变允许你将一个返回类型为派生类的方法赋值给一个返回类型为基类的方法。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123; &#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span> &#123; &#125;<br><br><span class="hljs-comment">// 协变的委托</span><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> TOutput <span class="hljs-title">MyDelegate</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">TOutput</span>&gt;()</span>;<br><br><span class="hljs-comment">// 使用协变</span><br>MyDelegate&lt;Dog&gt; dogDelegate = () =&gt; <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">// 可以使用 Dog</span><br>MyDelegate&lt;Animal&gt; animalDelegate = dogDelegate; <span class="hljs-comment">// 可以向上转型到 Animal</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>MyDelegate&lt;out TOutput&gt;</code> 中的 <code>out</code> 关键字指示该类型参数是协变的，这意味着它只会出现在返回类型中。</p><h3 id="2-逆变（Contravariance）"><a href="#2-逆变（Contravariance）" class="headerlink" title="2. 逆变（Contravariance）"></a>2. 逆变（Contravariance）</h3><p><strong>逆变</strong>允许你使用更一般的类型替换泛型类型参数。例如，逆变允许你将一个接受派生类的方法赋值给一个接受基类的方法。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123; &#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span> &#123; &#125;<br><br><span class="hljs-comment">// 逆变的委托</span><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyAction</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">TInput</span>&gt;(<span class="hljs-params">TInput input</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HandleAnimal</span>(<span class="hljs-params">Animal animal</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Handling animal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建逆变的委托</span><br>        MyAction&lt;Animal&gt; animalAction = HandleAnimal;<br>        MyAction&lt;Dog&gt; dogAction = animalAction; <span class="hljs-comment">// 使用逆变</span><br><br>        <span class="hljs-comment">// 这段代码不会报错，因为 HandleAnimal 可以接受 Dog</span><br>        dogAction(<span class="hljs-keyword">new</span> Dog()); <span class="hljs-comment">// 输出: Handling animal</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul><li><strong>协变</strong>（使用 <code>out</code>）:<ul><li>适用于返回类型。</li><li>可以将派生类赋值给基类。</li></ul></li><li><strong>逆变</strong>（使用 <code>in</code>）:<ul><li>适用于参数类型。</li><li>可以将基类赋值给派生类。</li></ul></li></ul><h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. 应用场景</h3><ul><li><strong>协变</strong>通常用于处理返回值的场景，比如泛型集合的查询操作。</li><li><strong>逆变</strong>通常用于处理接受参数的场景，比如事件处理和回调函数。</li></ul><h1 id="二、-object和Object的区别"><a href="#二、-object和Object的区别" class="headerlink" title="二、 object和Object的区别"></a>二、 object和Object的区别</h1><p>在C#中，<code>object</code>和<code>Object</code>指向的是同一个类型，但它们的用法和意义略有不同：</p><h3 id="1-object（小写）"><a href="#1-object（小写）" class="headerlink" title="1. object（小写）"></a>1. <code>object</code>（小写）</h3><ul><li><code>object</code> 是 C# 的关键字，表示 .NET 类型系统中的基类 <code>System.Object</code>。</li><li>它是所有类型（包括值类型和引用类型）的基类，意味着任何类型都可以作为 <code>object</code> 的实例。</li><li>在代码中，使用 <code>object</code> 关键字是表示类型时的常见做法。<br>例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> myObject = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-Object（大写）"><a href="#2-Object（大写）" class="headerlink" title="2. Object（大写）"></a>2. <code>Object</code>（大写）</h3><ul><li><code>Object</code> 是 .NET 框架中的类，完整名称是 <code>System.Object</code>。</li><li>它位于 <code>System</code> 命名空间中，是所有类型在 .NET 类型系统中的根类型。</li><li>可以通过 <code>System.Object</code> 直接引用它，但通常情况下使用 <code>object</code> 关键字。<br>例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">System.Object myObject = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. 主要区别</h3><ul><li><code>object</code> 是关键字，作为语法糖使用，更简洁。</li><li><code>Object</code> 是 .NET 类，可以通过完全限定名 <code>System.Object</code> 访问。<br>在大多数场合下，两者是可以互换使用的，但通常推荐使用 <code>object</code> 关键字，因为它更符合 C# 的编码风格。</li></ul><h1 id="三、-匿名函数"><a href="#三、-匿名函数" class="headerlink" title="三、 匿名函数"></a>三、 匿名函数</h1><p>匿名函数是指没有名称的函数，通常用于简化代码、实现短小的功能，尤其是在处理回调、事件或作为<code>参数传递</code>时。C# 支持两种匿名函数的形式：<strong>匿名方法</strong> 和 <strong>Lambda 表达式</strong>。</p><ul><li>脱离委托和事件，是不会使用匿名函数的</li><li>添加到委托或者事件容器后，不记录，无法单独移除，只能Clear()</li></ul><h3 id="1-匿名方法"><a href="#1-匿名方法" class="headerlink" title="1. 匿名方法"></a>1. 匿名方法</h3><p>匿名方法使用 <code>delegate</code> 关键字来定义一个没有名称的函数。适用于不需要重用的简单逻辑。<br>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 使用匿名方法定义一个委托</span><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = <span class="hljs-built_in">delegate</span> (<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-comment">// 调用匿名方法</span><br><span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>Console.WriteLine(result); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><h3 id="2-Lambda-表达式"><a href="#2-Lambda-表达式" class="headerlink" title="2. Lambda 表达式"></a>2. Lambda 表达式</h3><p>Lambda 表达式是一种更简洁的语法形式，用于编写匿名函数。语法为 <code>(参数列表) =&gt; 表达式或语句块</code>。<br>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 使用 Lambda 表达式定义一个委托</span><br><span class="hljs-comment">// 也可以写(int a,int b)=&gt;a+b;</span><br><span class="hljs-comment">// 参数类型和委托或事件一致</span><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; a + b;<br><br><span class="hljs-comment">// 调用 Lambda 表达式</span><br><span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>Console.WriteLine(result); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><h4 id="带块体的-Lambda-表达式"><a href="#带块体的-Lambda-表达式" class="headerlink" title="带块体的 Lambda 表达式"></a>带块体的 Lambda 表达式</h4><p>如果 Lambda 表达式包含多条语句，可以用 <code>&#123;&#125;</code> 包围，并显式使用 <code>return</code> 返回值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Adding numbers&quot;</span>);<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>Console.WriteLine(result); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><h3 id="3-匿名方法与-Lambda-表达式的区别"><a href="#3-匿名方法与-Lambda-表达式的区别" class="headerlink" title="3. 匿名方法与 Lambda 表达式的区别"></a>3. 匿名方法与 Lambda 表达式的区别</h3><ul><li><strong>语法</strong>：Lambda 表达式的语法更加简洁，通常更易于阅读。</li><li><strong>特性</strong>：Lambda 表达式支持类型推断，不需要显式指定参数的类型。</li><li><strong>捕获外部变量</strong>：匿名方法和 Lambda 表达式都可以捕获外部作用域中的变量。</li></ul><h1 id="四、-闭包"><a href="#四、-闭包" class="headerlink" title="四、 闭包"></a>四、 闭包</h1><ul><li>闭包是一个编程概念，指的是一个函数可以捕获并访问其所在作用域（外部函数或环境）中的变量，即使在这些变量的生命周期结束后，该函数依然可以访问这些变量的值。闭包可以让函数“记住”创建它时的环境。</li><li>在 C# 中，闭包通常与匿名函数（匿名方法或 Lambda 表达式）结合使用。当一个匿名函数捕获了外部作用域中的变量时，就形成了一个闭包。这些捕获的变量会与匿名函数一起存储，即使这些变量在创建闭包的作用域中已经不存在，闭包仍然可以访问它们。</li></ul><h3 id="闭包的示例"><a href="#闭包的示例" class="headerlink" title="闭包的示例"></a>闭包的示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-title">makeAdder</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 返回一个 Lambda 表达式，捕获外部变量 x</span><br>    <span class="hljs-comment">// 这里y被外部使用，作为了返回值，所以其声明周期和makeAdder一样</span><br>    <span class="hljs-keyword">return</span> y =&gt; x + y;<br>&#125;<br><br><span class="hljs-keyword">var</span> addFive = makeAdder(<span class="hljs-number">5</span>);<span class="hljs-comment">//此时addFive中的y为5</span><br>Console.WriteLine(addFive(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 8</span><br><br><span class="hljs-keyword">var</span> addTen = makeAdder(<span class="hljs-number">10</span>);<span class="hljs-comment">//此时addTen中的y为10</span><br>Console.WriteLine(addTen(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 13</span><br></code></pre></td></tr></table></figure><p>在上面的示例中：</p><ol><li><code>makeAdder</code> 方法返回一个 <code>Func&lt;int, int&gt;</code> 类型的 Lambda 表达式。</li><li>这个 Lambda 表达式捕获了 <code>makeAdder</code> 方法的参数 <code>x</code>，即形成了一个闭包。</li><li>当 <code>addFive</code> 和 <code>addTen</code> 调用时，即使 <code>makeAdder</code> 方法已经执行完毕并退出，其返回的 Lambda 表达式依然可以访问被捕获的 <code>x</code> 值（分别为 5 和 10）。</li></ol><h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ol><li><strong>捕获变量而非值</strong>：闭包捕获的是外部变量的引用，而不是它的值。这意味着如果外部变量的值发生变化，闭包访问的值也会相应改变。</li><li><strong>持久性</strong>：即使捕获变量所在的作用域已经结束，闭包仍然可以访问这些变量。</li></ol><h3 id="捕获变量的行为"><a href="#捕获变量的行为" class="headerlink" title="捕获变量的行为"></a>捕获变量的行为</h3><p>闭包在捕获变量时会捕获其引用，而不是当前值。这可能会导致意料之外的行为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;Func&lt;<span class="hljs-built_in">int</span>&gt;&gt; actions = <span class="hljs-keyword">new</span> List&lt;Func&lt;<span class="hljs-built_in">int</span>&gt;&gt;();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>    actions.Add(() =&gt; i);<br>&#125;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> action <span class="hljs-keyword">in</span> actions)<br>&#123;<br>    Console.WriteLine(action()); <span class="hljs-comment">// 输出 3, 3, 3，而不是 0, 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>i</code> 被捕获为引用，因此当循环结束时，<code>i</code> 的最终值是 3，因此所有的闭包都会返回 3。</p><h3 id="解决上述问题的方式"><a href="#解决上述问题的方式" class="headerlink" title="解决上述问题的方式"></a>解决上述问题的方式</h3><p>可以使用一个临时变量来解决这个问题，让闭包捕获不同的值：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>&#123;<br>    <span class="hljs-built_in">int</span> temp = i; <span class="hljs-comment">// 临时变量，闭包捕获的是 temp</span><br>    actions.Add(() =&gt; temp);<br>&#125;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> action <span class="hljs-keyword">in</span> actions)<br>&#123;<br>    Console.WriteLine(action()); <span class="hljs-comment">// 输出 0, 1, 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>闭包是一个非常强大的概念，可以使得函数在定义时记住它们的环境。闭包与匿名函数的结合使用为 C# 增添了函数式编程的特性，使得代码更加灵活和简洁。</p><h1 id="五、-多线程"><a href="#五、-多线程" class="headerlink" title="五、  多线程"></a>五、  多线程</h1><p>多线程是指在一个程序中同时执行多个线程的技术。线程是操作系统调度的最小单位，多个线程共享同一进程的内存空间，每个线程都有自己的栈空间和寄存器上下文。多线程可以提高程序的并发性和响应速度，尤其在处理 I&#x2F;O 操作、长时间运行的任务或用户界面响应时非常有用。</p><ul><li>默认是前台线程t，主线程会等待t线程结束，如果t线程不结束，主线程就不会结束。t设置为后台线程以后，Main主线程结束以后，t线程也会一起结束。</li></ul><h3 id="在-C-中使用多线程"><a href="#在-C-中使用多线程" class="headerlink" title="在 C# 中使用多线程"></a>在 C# 中使用多线程</h3><p>在 C# 中，可以使用多种方法来实现多线程编程。常见的方法包括：</p><ol><li><strong><code>Thread</code> 类</strong></li><li><strong><code>Task</code> 并行库</strong></li><li><strong>异步编程 (<code>async</code>&#x2F;<code>await</code>)</strong></li><li><strong>线程池</strong></li></ol><h4 id="1-Thread-类"><a href="#1-Thread-类" class="headerlink" title="1. Thread 类"></a>1. <code>Thread</code> 类</h4><p><code>Thread</code> 类是最基本的创建和管理线程的方法。可以使用 <code>Thread</code> 类来创建一个新线程并启动它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个线程，执行方法为 PrintNumbers</span><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(PrintNumbers);<br>        thread.IsBackground = <span class="hljs-literal">true</span>;<br>        thread.Start(); <span class="hljs-comment">// 启动线程</span><br><br><br>        <span class="hljs-comment">// 主线程继续执行其他任务</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>        <span class="hljs-comment">// 注释下面这行，并且thread为后台线程，一旦主线程运行完毕，则主线程会自动退出，子线程也会结束</span><br>        thread.Join(); <span class="hljs-comment">// 等待子线程执行完成,此时主线程在这里暂停不动</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行2...&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;子线程输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 让线程休眠500毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>thread.Join()</code> 方法用于阻塞调用线程（通常是主线程），直到指定的线程（子线程）完成执行。这意味着，调用 <code>Join()</code> 的线程会等待子线程执行完成后再继续执行后续的代码。</li><li>运行结果<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">主线程继续运行...<br>子线程输出: <span class="hljs-number">1</span><br>子线程输出: <span class="hljs-number">2</span><br>子线程输出: <span class="hljs-number">3</span><br>子线程输出: <span class="hljs-number">4</span><br>子线程输出: <span class="hljs-number">5</span><br>主线程继续运行<span class="hljs-number">2.</span>..<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Task-并行库"><a href="#2-Task-并行库" class="headerlink" title="2. Task 并行库"></a>2. <code>Task</code> 并行库</h4><p><code>Task</code> 类提供了更高级的抽象，用于处理并行编程。与 <code>Thread</code> 类相比，<code>Task</code> 更加灵活，并且能够更好地管理线程的生命周期。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个 Program 类，并声明一个 Main 方法，该方法返回 Task。</span><br>    <span class="hljs-comment">// 由于它被标记为 async，表示它可以使用 await 关键字。</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 启动一个异步任务</span><br>        <span class="hljs-comment">// 使用 Task.Run 方法启动一个新的任务。这个任务会执行 PrintNumbers 方法。</span><br>        <span class="hljs-comment">// Task.Run 方法用于在线程池中异步执行代码，因此 PrintNumbers 方法会在一个独立的线程上运行，</span><br>        <span class="hljs-comment">// 而主线程不会被阻塞。</span><br>        Task task = Task.Run(() =&gt; PrintNumbers());<br><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>        <span class="hljs-comment">// 使用 await 关键字等待 task 完成。此时，主线程会在 await 处暂停，</span><br>        <span class="hljs-comment">// 直到 PrintNumbers 任务执行完毕。此操作确保在程序结束之前，所有的异步操作都已经完成。</span><br>        <span class="hljs-keyword">await</span> task; <span class="hljs-comment">// 等待任务完成,不会继续运行下面的主线程代码</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行2...&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Task 输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            Task.Delay(<span class="hljs-number">500</span>).Wait(); <span class="hljs-comment">// 等待500毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-异步编程-async-await"><a href="#3-异步编程-async-await" class="headerlink" title="3. 异步编程 (async&#x2F;await)"></a>3. 异步编程 (<code>async</code>&#x2F;<code>await</code>)</h4><p>C# 提供了异步编程的支持，通过 <code>async</code> 和 <code>await</code> 关键字，可以方便地进行异步操作，特别适合 I&#x2F;O 密集型任务。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">await</span> PrintNumbersAsync(); <span class="hljs-comment">// 阻塞，不会继续运行下面的代码</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PrintNumbersAsync</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;异步输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">500</span>); <span class="hljs-comment">// 异步等待500毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h4><p>线程池用于管理一组预先创建的线程，可以减少创建和销毁线程的开销。可以使用 <code>ThreadPool.QueueUserWorkItem</code> 方法将工作项排队到线程池。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 将任务排队到线程池</span><br>        ThreadPool.QueueUserWorkItem(PrintNumbers);<br>        <span class="hljs-comment">// 不会阻塞运行，主线程会继续运行，导致子线程没有运行完就结束了</span><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>        Thread.Sleep(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 主线程等待一段时间以确保输出</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> state</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;线程池输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 等待500毫秒</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h5><p>线程池的线程数量在 .NET 中是动态管理的，通常不会固定在一个特定的数量上。以下是一些关于线程池的关键信息：</p><h6 id="1-动态调整"><a href="#1-动态调整" class="headerlink" title="1. 动态调整"></a>1. 动态调整</h6><ul><li>线程池会根据当前的工作负载动态增加或减少线程数量。</li><li>当工作线程的数量低于线程池的最低数量时，线程池会创建新线程来处理新的任务。</li><li>当没有任务需要处理时，线程池会减少空闲线程的数量，以释放系统资源。</li></ul><h6 id="2-最大线程数量"><a href="#2-最大线程数量" class="headerlink" title="2. 最大线程数量"></a>2. 最大线程数量</h6><ul><li>线程池的最大线程数量可以通过 <code>ThreadPool.SetMaxThreads</code> 方法进行设置。默认情况下，这个上限通常是系统可以支持的最大线程数量，但具体的值可能依赖于系统配置和负载。</li><li>&#96;public static void SetMaxThreads(int workerThreads, int completionPortThreads);<ul><li><strong><code>workerThreads</code></strong>: 指定工作线程的最大数量。</li><li><strong><code>completionPortThreads</code></strong>: 指定用于处理异步 IO 操作的最大线程数量。&#96;</li></ul></li></ul><h6 id="3-最小线程数量"><a href="#3-最小线程数量" class="headerlink" title="3. 最小线程数量"></a>3. 最小线程数量</h6><ul><li>线程池的最小线程数量也可以通过 <code>ThreadPool.SetMinThreads</code> 方法进行设置。这个值定义了线程池在没有任务时保持的最小线程数量。</li><li><code>ThreadPool.SetMinThreads(int workerThreads, int completionPortThreads)</code> 用于设置线程池中工作线程和异步 IO 线程的最小数量。</li></ul><h6 id="4-默认行为"><a href="#4-默认行为" class="headerlink" title="4. 默认行为"></a>4. 默认行为</h6><ul><li>在没有特殊配置的情况下，线程池会自动管理线程数量，通常在较低负载时只会保持几个线程。</li><li>当高负载时，线程池会创建更多线程以满足需求，具体数量会根据需要而变化。</li></ul><h6 id="5-线程池的优点"><a href="#5-线程池的优点" class="headerlink" title="5. 线程池的优点"></a>5. 线程池的优点</h6><ul><li>通过重用线程，减少了创建和销毁线程的开销，能够提高性能。</li><li>适用于处理大量短任务，避免了频繁创建和销毁线程的开销。</li></ul><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>使用 <code>ThreadPool.QueueUserWorkItem</code> 提交任务的代码示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Threading;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 向线程池队列中添加多个任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        &#123;<br>            <span class="hljs-comment">// i是PrintNumbers()的参数</span><br>            <span class="hljs-comment">// 设置最大工作线程数量为 10，最大异步 IO 线程数量为 5</span><br>            <span class="hljs-comment">// ThreadPool.SetMaxThreads(10, 5);</span><br>            <span class="hljs-comment">// 如果你提交了 15 个计算任务（需要工作线程），</span><br>            <span class="hljs-comment">// 线程池会调度最多 10 个工作线程来执行这些任务。</span><br>            <span class="hljs-comment">// 同时，如果还有 10 个异步文件读取操作（需要异步 IO 线程），</span><br>            <span class="hljs-comment">// 线程池最多会使用 5 个线程来处理这些异步 IO 操作。</span><br>            ThreadPool.QueueUserWorkItem(PrintNumbers, i);<br>        &#125;<br><br>        Console.WriteLine(<span class="hljs-string">&quot;主线程继续运行...&quot;</span>);<br>        <span class="hljs-comment">// 等待用户输入以防程序提前结束</span><br>        Console.ReadLine();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> state</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> num = (<span class="hljs-built_in">int</span>)state;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;任务 <span class="hljs-subst">&#123;num&#125;</span> 输出: <span class="hljs-subst">&#123;i&#125;</span>&quot;</span>);<br>            Thread.Sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">// 模拟工作负载</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，主线程提交了多个任务到线程池，线程池会处理这些任务，而主线程则继续执行其他操作。具体有多少个线程被创建会根据线程池的管理策略而变化。</p><h3 id="多线程的常见问题"><a href="#多线程的常见问题" class="headerlink" title="多线程的常见问题"></a>多线程的常见问题</h3><ul><li><strong>线程安全</strong>：多个线程访问共享资源时，可能会出现竞争条件，导致数据不一致。可以使用锁 (<code>lock</code>) 或同步机制解决。</li><li><strong>死锁</strong>：两个或多个线程互相等待对方释放资源，导致程序无法继续执行。</li><li><strong>资源管理</strong>：创建太多线程可能会耗尽系统资源，应该合理使用线程池或任务。</li></ul><h3 id="线程安全的例子"><a href="#线程安全的例子" class="headerlink" title="线程安全的例子"></a>线程安全的例子</h3><p>使用 <code>lock</code> 关键字防止多个线程同时访问共享资源：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">object</span> _lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _counter = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">IncrementCounter</span>()</span><br>&#123;<br><span class="hljs-comment">// lock(引用类型对象)</span><br>    <span class="hljs-keyword">lock</span> (_lock)<br>    &#123;<br>        _counter++;<br>        Console.WriteLine(<span class="hljs-string">$&quot;计数器值: <span class="hljs-subst">&#123;_counter&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多线程是一个复杂而强大的工具，正确使用可以显著提高程序的性能和响应性。</p><h1 id="六、-关闭死循环的线程"><a href="#六、-关闭死循环的线程" class="headerlink" title="六、 关闭死循环的线程"></a>六、 关闭死循环的线程</h1><p>如果一个线程进入了死循环，需要通过合适的方法来关闭或释放它，以避免资源浪费或程序无法正常退出。可以使用以下几种方法来处理：</p><h3 id="1-使用线程间的信号（如-bool-标志位）"><a href="#1-使用线程间的信号（如-bool-标志位）" class="headerlink" title="1. 使用线程间的信号（如 bool 标志位）"></a>1. 使用线程间的信号（如 <code>bool</code> 标志位）</h3><ul><li>在线程执行的死循环中检查一个 <code>bool</code> 标志位，当需要退出时，设置这个标志位来结束循环，从而退出线程。<br><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> keepRunning = <span class="hljs-literal">true</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ThreadMethod</span>()</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (keepRunning)<br>    &#123;<br>        <span class="hljs-comment">// 执行任务</span><br>        Thread.Sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟一些工作</span><br>    &#125;<br>    Console.WriteLine(<span class="hljs-string">&quot;线程已终止&quot;</span>);<br>&#125;<br><br>Thread thread = <span class="hljs-keyword">new</span> Thread(ThreadMethod);<br>thread.Start();<br><br><span class="hljs-comment">// 需要终止线程时，将标志位设为 false</span><br>keepRunning = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-使用-CancellationToken"><a href="#2-使用-CancellationToken" class="headerlink" title="2. 使用 CancellationToken"></a>2. 使用 <code>CancellationToken</code></h3><ul><li><code>CancellationToken</code> 是专为取消异步任务和线程而设计的机制，可以在需要时向线程发送取消请求。<br><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        CancellationTokenSource cancellationTokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ThreadMethod</span>(<span class="hljs-params">CancellationToken token</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">while</span> (!token.IsCancellationRequested)<br>            &#123;<br>                <span class="hljs-comment">// 执行任务</span><br>                Thread.Sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟一些工作</span><br>            &#125;<br>            Console.WriteLine(<span class="hljs-string">&quot;线程已取消&quot;</span>);<br>        &#125;<br><br>        Thread thread = <span class="hljs-keyword">new</span> Thread(() =&gt; ThreadMethod(cancellationTokenSource.Token));<br>        thread.Start();<br><br>        <span class="hljs-comment">// 需要终止线程时，调用 Cancel 方法</span><br>        cancellationTokenSource.Cancel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-使用-Abort-方法（不推荐）"><a href="#3-使用-Abort-方法（不推荐）" class="headerlink" title="3. 使用 Abort() 方法（不推荐）"></a>3. 使用 <code>Abort()</code> 方法（不推荐）</h3><ul><li>在非常特殊的情况下，可以调用 <code>Thread.Abort()</code> 强制终止线程，不过这种方法不安全，可能会导致资源没有正确释放和程序的不稳定性。</li><li>在 .NET Core 和 .NET 5 及更高版本中，<code>Thread.Abort()</code> 已被移除。</li><li><code>System.PlatformNotSupportedException:“Thread abort is not supported on this platform.”</code><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Thread thread = <span class="hljs-keyword">new</span> Thread();<br>thread.Abort();<br>thread = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-使用-Join-等待线程退出"><a href="#4-使用-Join-等待线程退出" class="headerlink" title="4. 使用 Join() 等待线程退出"></a>4. 使用 <code>Join()</code> 等待线程退出</h3><ul><li>配合上述方法使用 <code>Join()</code> 等待线程完成，有助于确保线程在主线程结束前正确退出。</li></ul><h3 id="5-CancellationToken-感觉和bool标志位一样啊，有什么优势"><a href="#5-CancellationToken-感觉和bool标志位一样啊，有什么优势" class="headerlink" title="5. CancellationToken 感觉和bool标志位一样啊，有什么优势"></a>5. CancellationToken 感觉和bool标志位一样啊，有什么优势</h3><p><code>CancellationToken</code> 和 <code>bool</code> 标志位在某种程度上都可以用于控制线程的停止，但 <code>CancellationToken</code> 提供了一些更强大和灵活的功能。以下是它们之间的主要区别和 <code>CancellationToken</code> 的优势：</p><h4 id="1-更强的并发控制"><a href="#1-更强的并发控制" class="headerlink" title="1. 更强的并发控制"></a>1. <strong>更强的并发控制</strong></h4><ul><li><strong>CancellationToken</strong> 可以与多个任务、线程或异步操作一起使用，允许它们共享同一个取消请求。这使得在复杂的并发场景中更容易管理任务的取消。</li><li><strong>标志位</strong> 通常只在单个线程中使用，不便于在多个线程之间共享。</li></ul><h4 id="2-内置机制"><a href="#2-内置机制" class="headerlink" title="2. 内置机制"></a>2. <strong>内置机制</strong></h4><ul><li><code>CancellationToken</code> 是 .NET 中设计的一个专门用于取消操作的机制，提供了一种标准的方式来处理取消请求。它通过 <code>CancellationTokenSource</code> 提供了一个清晰的结构。</li><li>使用 <strong>标志位</strong> 时，开发者需要手动管理状态，容易引入错误，比如忘记检查标志位。</li></ul><h4 id="3-可取消操作的通知"><a href="#3-可取消操作的通知" class="headerlink" title="3. 可取消操作的通知"></a>3. <strong>可取消操作的通知</strong></h4><ul><li>使用 <code>CancellationToken</code>，可以很方便地在执行操作时检查取消请求。例如，在异步方法中，可以传递 <code>CancellationToken</code>，在特定的点检查是否被取消。</li><li>通过 <code>CancellationToken</code>，还可以在需要的地方抛出 <code>OperationCanceledException</code>，提供更明确的取消处理逻辑。</li></ul><h4 id="4-与-Task-并行库的兼容性"><a href="#4-与-Task-并行库的兼容性" class="headerlink" title="4. 与 Task 并行库的兼容性"></a>4. <strong>与 Task 并行库的兼容性</strong></h4><ul><li><code>CancellationToken</code> 与 Task 并行库（TPL）紧密集成，可以在使用 <code>Task</code> 的场景中直接使用，比如 <code>Task.Run</code>、<code>async/await</code> 结构中，允许更自然的取消行为。</li><li><strong>标志位</strong> 需要额外的逻辑来与 <code>Task</code> 一起使用，整合不如 <code>CancellationToken</code> 流畅。</li></ul><h4 id="5-异步操作的支持"><a href="#5-异步操作的支持" class="headerlink" title="5. 异步操作的支持"></a>5. <strong>异步操作的支持</strong></h4><ul><li>在异步编程中，<code>CancellationToken</code> 是非常有用的，可以在执行异步操作时轻松管理取消逻辑。</li><li>使用 <strong>标志位</strong> 可能会导致代码的可读性下降，因为你需要在每个异步方法中手动传递和检查标志位。</li></ul><h5 id="使用-CancellationToken"><a href="#使用-CancellationToken" class="headerlink" title="使用 CancellationToken"></a>使用 <code>CancellationToken</code></h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>CancellationToken token = cts.Token;<br><br>Task.Run(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        token.ThrowIfCancellationRequested();<br>        Console.WriteLine(i);<br>        Thread.Sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;, token);<br><br><span class="hljs-comment">// 取消操作</span><br>cts.Cancel();<br></code></pre></td></tr></table></figure><h5 id="使用-bool-标志位"><a href="#使用-bool-标志位" class="headerlink" title="使用 bool 标志位"></a>使用 <code>bool</code> 标志位</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> keepRunning = <span class="hljs-literal">true</span>;<br><br>Task.Run(() =&gt;<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!keepRunning) <span class="hljs-keyword">return</span>;<br>        Console.WriteLine(i);<br>        Thread.Sleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// 取消操作</span><br>keepRunning = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>CancellationToken</strong> 提供了一个更强大和灵活的方式来管理取消请求，特别是在复杂的并发和异步编程中。</li><li>虽然 <code>bool</code> 标志位可以简单地实现基本的取消逻辑，但在需要更复杂或可重用的取消机制时，<code>CancellationToken</code> 是更推荐的选择。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>使用标志位和 <code>CancellationToken</code> 是更推荐的做法</strong>，因为它们允许线程在执行任务时检查退出条件，能够安全地终止线程。</li><li>**避免使用 <code>Thread.Abort()</code>**，除非没有其他选择。</li></ul><h1 id="七、-预处理指令"><a href="#七、-预处理指令" class="headerlink" title="七、 预处理指令"></a>七、 预处理指令</h1><p>预处理器指令是编程语言中用于在编译期间进行条件编译、宏定义、文件包含等操作的特殊指令。在 C# 中，预处理器指令以 <code>#</code> 开头。以下是 C# 中一些常见的预处理器指令及其说明：</p><h3 id="1-define-和-undef"><a href="#1-define-和-undef" class="headerlink" title="1. #define 和 #undef"></a>1. <code>#define</code> 和 <code>#undef</code></h3><ul><li><code>#define</code>：定义一个符号，之后可以在代码中通过条件编译使用。</li><li><code>#undef</code>：取消定义一个符号。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>    Console.WriteLine(<span class="hljs-string">&quot;Debugging mode&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> DEBUG</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-if-elif-else-endif"><a href="#2-if-elif-else-endif" class="headerlink" title="2. #if, #elif, #else, #endif"></a>2. <code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code></h3><ul><li><code>#if</code>：根据条件编译代码块。可以与 <code>#define</code> 结合使用。</li><li><code>#elif</code>、<code>#else</code> 和 <code>#endif</code>：用于条件编译中的其他情况。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br>    Console.WriteLine(<span class="hljs-string">&quot;Debugging mode&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> RELEASE</span><br>    Console.WriteLine(<span class="hljs-string">&quot;Release mode&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    Console.WriteLine(<span class="hljs-string">&quot;No mode defined&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-region-和-endregion"><a href="#3-region-和-endregion" class="headerlink" title="3. #region 和 #endregion"></a>3. <code>#region</code> 和 <code>#endregion</code></h3><ul><li><code>#region</code>：用于定义一个代码区域，可以在代码编辑器中折叠和展开。</li><li><code>#endregion</code>：结束一个区域的定义。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">region</span> MyRegion</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span><br>&#123;<br>    <span class="hljs-comment">// Method implementation</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-error-和-warning"><a href="#4-error-和-warning" class="headerlink" title="4. #error 和 #warning"></a>4. <code>#error</code> 和 <code>#warning</code></h3><ul><li><code>#error</code>：强制编译错误并输出指定的消息。</li><li><code>#warning</code>：发出编译警告并输出指定的消息。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">error</span> &quot;This code should not be compiled&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">warning</span> &quot;This code should not be compiled&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-line"><a href="#5-line" class="headerlink" title="5. #line"></a>5. <code>#line</code></h3><ul><li><code>#line</code>**：用于设置行号和文件名。主要用于代码生成或预处理。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">line</span> 100 &quot;MyFile.cs&quot;</span><br></code></pre></td></tr></table></figure>使用 <code>#line 100 &quot;MyFile.cs&quot;</code> 将后续代码的行号视为 100，并且指定了文件名为 <code>&quot;MyFile.cs&quot;</code>。因此，如果在这个方法中发生编译错误，编译器会报告这个错误位于 <code>MyFile.cs</code> 的第 100 行，而不是实际源文件中的行号。这对于代码生成和预处理非常有用，尤其是在使用代码生成器或动态生成代码的情况下。</li></ul><h3 id="6-pragma"><a href="#6-pragma" class="headerlink" title="6. #pragma"></a>6. <code>#pragma</code></h3><ul><li><code>#pragma</code>：用于启用或禁用编译器特性，常用于控制警告的显示。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> <span class="hljs-keyword">warning</span> disable 0168 // 忽略未使用的变量警告</span><br><span class="hljs-comment">// 0168是代码，具体可以参考编译器给的警告提示，或者文档说明</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="八、-反射"><a href="#八、-反射" class="headerlink" title="八、 反射"></a>八、 反射</h1><p>反射是 .NET 提供的一种强大功能，允许程序在运行时检查和操作类型信息，包括类、结构、接口、方法、属性等。通过反射，开发者可以动态地创建对象、调用方法、访问字段和属性，甚至可以修改它们的值。这在许多情况下非常有用，例如在插件系统、序列化和调试工具中。</p><ul><li>在反射中，如果有方法重载（同名但参数不同的方法），<code>GetMethod</code> 方法必须精确选择某个重载方法，可以通过指定方法的参数类型来获取它。</li></ul><h3 id="反射的主要功能"><a href="#反射的主要功能" class="headerlink" title="反射的主要功能"></a>反射的主要功能</h3><ol><li><strong>获取类型信息</strong>：<ul><li>可以使用反射获取类的名称、基类、实现的接口、方法、属性、字段等信息。</li></ul></li><li><strong>创建实例</strong>：<ul><li>可以通过反射动态创建类型的实例，而不需要在编译时知道其类型。</li></ul></li><li><strong>调用方法</strong>：<ul><li>可以使用反射调用对象的方法，包括私有和保护方法。</li></ul></li><li><strong>访问和修改字段和属性</strong>：<ul><li>通过反射可以读取和设置对象的字段和属性值。可以是私有的</li></ul></li><li><strong>动态加载程序集</strong>：<ul><li>可以在运行时加载和使用外部程序集。</li></ul></li></ol><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><p>以下是一些使用反射的示例代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Message: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 获取类型信息</span><br>        Type myType = <span class="hljs-keyword">typeof</span>(MyClass);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Class Name: <span class="hljs-subst">&#123;myType.Name&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 创建实例</span><br>        <span class="hljs-built_in">object</span> myObject = Activator.CreateInstance(myType);<br><br>        <span class="hljs-comment">// 访问属性</span><br>        PropertyInfo propertyInfo = myType.GetProperty(<span class="hljs-string">&quot;MyProperty&quot;</span>);<br>        propertyInfo.SetValue(myObject, <span class="hljs-number">42</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;MyProperty Value: <span class="hljs-subst">&#123;propertyInfo.GetValue(myObject)&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 调用方法</span><br>        MethodInfo methodInfo = myType.GetMethod(<span class="hljs-string">&quot;MyMethod&quot;</span>);<br>        methodInfo.Invoke(myObject, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;Hello, Reflection!&quot;</span> &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><ol><li><strong>获取类型信息</strong>：<ul><li>使用 <code>typeof(MyClass)</code> 获取 <code>MyClass</code> 类型的 <code>Type</code> 对象。</li></ul></li><li><strong>创建实例</strong>：<ul><li>使用 <code>Activator.CreateInstance(myType)</code> 动态创建 <code>MyClass</code> 的实例。</li></ul></li><li><strong>访问属性</strong>：<ul><li>使用 <code>GetProperty</code> 获取 <code>MyProperty</code> 的 <code>PropertyInfo</code> 对象，使用 <code>SetValue</code> 和 <code>GetValue</code> 来设置和读取属性值。</li></ul></li><li><strong>调用方法</strong>：<ul><li>使用 <code>GetMethod</code> 获取 <code>MyMethod</code> 的 <code>MethodInfo</code> 对象，使用 <code>Invoke</code> 方法调用该方法。</li></ul></li></ol><h3 id="基本示例2"><a href="#基本示例2" class="headerlink" title="基本示例2"></a>基本示例2</h3><p>以下是如何选择特定的重载方法的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> variable = <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>        MyProperty = <span class="hljs-number">1</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;(): 构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> myProperty</span>)</span><br>    &#123;<br>        MyProperty = myProperty;<br>        Console.WriteLine(<span class="hljs-string">&quot;(int myProperty): 构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> myProperty, <span class="hljs-built_in">int</span> i</span>) : <span class="hljs-title">this</span>(<span class="hljs-params">myProperty</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;(int myProperty,int i): 构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> a</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Message: <span class="hljs-subst">&#123;message&#125;</span>, Number: <span class="hljs-subst">&#123;a&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Message: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;静态show方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 获取类型信息</span><br>        Type myType = <span class="hljs-keyword">typeof</span>(MyClass);<br>        Type myType2 = (<span class="hljs-keyword">new</span> MyClass()).GetType();<br>        <span class="hljs-comment">// 如果有namespace，需要加上命名空间，如System.Int32</span><br>        <span class="hljs-comment">// 这里的MyClass没有命名空间</span><br>        Type myType3 = Type.GetType(<span class="hljs-string">&quot;MyClass&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Class Name: <span class="hljs-subst">&#123;myType.Name&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Class Name: <span class="hljs-subst">&#123;myType2.Name&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Class Name: <span class="hljs-subst">&#123;myType3.Name&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 得到类的程序集信息</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Assembly Name: <span class="hljs-subst">&#123;myType.Assembly&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Assembly Name: <span class="hljs-subst">&#123;myType2.Assembly&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Assembly Name: <span class="hljs-subst">&#123;myType3.Assembly&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 获取类中的所有公共成员</span><br>        MemberInfo[] infos = myType.GetMembers();<br>        <span class="hljs-comment">// 这里使用的info变量，后面不允许用了，和C++不一样</span><br>        <span class="hljs-comment">// 局部变量继续使用没问题</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> info <span class="hljs-keyword">in</span> infos)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Member: <span class="hljs-subst">&#123;info&#125;</span>&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">$&quot;Member Name: <span class="hljs-subst">&#123;info.Name&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取所有的构造函数</span><br>        ConstructorInfo[] ctors = myType.GetConstructors();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> ctor <span class="hljs-keyword">in</span> ctors)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Constructor: <span class="hljs-subst">&#123;ctor&#125;</span>&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">$&quot;Constructor Name: <span class="hljs-subst">&#123;ctor.Name&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// new Type[0] 创建了一个长度为 0 的 Type 数组。</span><br>        <span class="hljs-comment">// 这表示我们在查找构造函数时，指定它没有任何参数。</span><br>        <span class="hljs-comment">// 也就是说，我们想获取的是一个无参数的构造函数（也称为默认构造函数）。</span><br>        <span class="hljs-comment">// new Type[] 表示构造函数的参数类型列表</span><br>        <span class="hljs-comment">// new object[] 是用于实际调用方法或构造函数时传递的参数值</span><br>        <span class="hljs-comment">// 获取一个无参构造函数</span><br>        ConstructorInfo infoNoneConstruct = myType.GetConstructor(<span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 执行(int myProperty)构造</span><br>        MyClass myClass = infoNoneConstruct.Invoke(<span class="hljs-literal">null</span>) <span class="hljs-keyword">as</span> MyClass;<br>        Console.WriteLine(<span class="hljs-string">$&quot;myClass.MyProperty : <span class="hljs-subst">&#123;myClass.MyProperty&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 获取一个(int myProperty)构造函数</span><br>        ConstructorInfo infoOneConstruct = myType.GetConstructor(<span class="hljs-keyword">new</span> Type[] &#123; <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>) &#125;);<br>        <span class="hljs-comment">// 执行无参构造，无参构造，没有参数，传null</span><br>        MyClass myClass1 = infoOneConstruct.Invoke(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-number">2</span> &#125;) <span class="hljs-keyword">as</span> MyClass;<br>        Console.WriteLine(<span class="hljs-string">$&quot;myClass1.MyProperty : <span class="hljs-subst">&#123;myClass1.MyProperty&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 获取一个(int myProperty, int i)构造函数</span><br>        ConstructorInfo infoTwoConstruct = myType.GetConstructor(<span class="hljs-keyword">new</span> Type[] &#123; <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>) &#125;);<br>        <span class="hljs-comment">// 执行(int myProperty, int i)构造</span><br>        MyClass myClass2 = infoTwoConstruct.Invoke(<span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;) <span class="hljs-keyword">as</span> MyClass;<br>        Console.WriteLine(<span class="hljs-string">$&quot;myClass2.MyProperty : <span class="hljs-subst">&#123;myClass2.MyProperty&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 获取类的公共成员变量</span><br>        FieldInfo[] fieldInfos = myType.GetFields();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fieldInfo <span class="hljs-keyword">in</span> fieldInfos)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;fieldInfos: <span class="hljs-subst">&#123;fieldInfo&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 得到指定名称的公共成员变量</span><br>        FieldInfo infoMyProperty = myType.GetField(<span class="hljs-string">&quot;variable&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;variable is <span class="hljs-subst">&#123;infoMyProperty&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 通过反射获取和设置对象的值</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;myClass的variable变量的值为 :<span class="hljs-subst">&#123;infoMyProperty.GetValue(myClass)&#125;</span>&quot;</span>);<br>        <span class="hljs-comment">// 通过反射设置指定对象的某个变量的值</span><br>        infoMyProperty.SetValue(myClass, <span class="hljs-number">1000</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;myClass修改后的variable变量的值为 :<span class="hljs-subst">&#123;infoMyProperty.GetValue(myClass)&#125;</span>&quot;</span>);<br><br><br>        <span class="hljs-comment">// 创建实例</span><br>        <span class="hljs-built_in">object</span> myObject = Activator.CreateInstance(myType);<br><br>        <span class="hljs-comment">// 访问属性</span><br>        PropertyInfo propertyInfo = myType.GetProperty(<span class="hljs-string">&quot;MyProperty&quot;</span>);<br>        propertyInfo.SetValue(myObject, <span class="hljs-number">42</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;MyProperty Value: <span class="hljs-subst">&#123;propertyInfo.GetValue(myObject)&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 如果方法被重载了，会报错System.Reflection.AmbiguousMatchException</span><br>        <span class="hljs-comment">//MethodInfo methodDefault = myType.GetMethod(&quot;MyMethod&quot;);</span><br>        <span class="hljs-comment">//methodDefault.Invoke(myObject, new object[] &#123; &quot;Hello, Reflection! Default Method!&quot;, 1234 &#125;);</span><br><br>        MethodInfo[] methods = myType.GetMethods();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> method <span class="hljs-keyword">in</span> methods)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;method :<span class="hljs-subst">&#123;method&#125;</span>&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">$&quot;method Name:<span class="hljs-subst">&#123;method.Name&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 调用重载方法MyMethod(string, int)</span><br>        MethodInfo methodInfoWithTwoParams = myType.GetMethod(<span class="hljs-string">&quot;MyMethod&quot;</span>, <span class="hljs-keyword">new</span> Type[] &#123; <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>) &#125;);<br>        methodInfoWithTwoParams.Invoke(myObject, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;Hello, Reflection!&quot;</span>, <span class="hljs-number">123</span> &#125;);<br><br>        <span class="hljs-comment">// 调用重载方法MyMethod(string)</span><br>        MethodInfo methodInfoWithOneParam = myType.GetMethod(<span class="hljs-string">&quot;MyMethod&quot;</span>, <span class="hljs-keyword">new</span> Type[] &#123; <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>) &#125;);<br>        methodInfoWithOneParam.Invoke(myObject, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; <span class="hljs-string">&quot;Hello, Reflection!&quot;</span> &#125;);<br><br>        <span class="hljs-comment">// 调用静态方法show()</span><br>        MethodInfo methodShow = myType.GetMethod(<span class="hljs-string">&quot;show&quot;</span>, <span class="hljs-keyword">new</span> Type[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 第二个参数填null,new Type[0],new object[0]都可以，保证传入的参数是0个就行</span><br>        methodShow.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 其他</span><br>        <span class="hljs-comment">// 得枚举 GetEnumName GetEnumNames</span><br>        <span class="hljs-comment">// 得事件 GetEvent GetEvents</span><br>        <span class="hljs-comment">// 得接口 GetInterface GetInterfaces</span><br>        <span class="hljs-comment">// 得属性 GetProperty GetPropertys</span><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ol><li><code>GetMethod(&quot;MyMethod&quot;, new Type[] &#123; typeof(string), typeof(int) &#125;)</code> 用于获取接受 <code>string</code> 和 <code>int</code> 参数的重载方法。</li><li><code>GetMethod(&quot;MyMethod&quot;, new Type[] &#123; typeof(string) &#125;)</code> 用于获取接受单个 <code>string</code> 参数的重载方法。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>性能开销</strong>：反射会带来一定的性能开销，因此在性能敏感的代码中应谨慎使用。</li><li><strong>类型安全</strong>：使用反射时，由于许多操作在运行时进行，因此可能会引入类型安全问题。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>序列化&#x2F;反序列化</strong>：在将对象转换为字节流或从字节流恢复对象时，反射可以用于访问对象的字段和属性。</li><li><strong>依赖注入</strong>：在一些依赖注入框架中，反射用于创建服务的实例。</li><li><strong>插件系统</strong>：在插件架构中，反射可以用于加载和实例化插件类。</li></ul><h3 id="Activator"><a href="#Activator" class="headerlink" title="Activator"></a><code>Activator</code></h3><p><code>Activator</code> 是一个用于在运行时动态创建对象的类，通常用于反射或依赖注入的场景。<code>Activator.CreateInstance</code> 是其中一个常用的方法，用于创建一个指定类型的实例。下面是一些常见的使用方式和示例。</p><h3 id="1-创建无参数构造函数的实例"><a href="#1-创建无参数构造函数的实例" class="headerlink" title="1. 创建无参数构造函数的实例"></a>1. 创建无参数构造函数的实例</h3><p>如果要创建一个使用无参数构造函数的类实例，可以这样做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>        Value = <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 原始对象</span><br>        MyClass originalObject = <span class="hljs-keyword">new</span> MyClass();<br>        originalObject.Value = <span class="hljs-number">100</span>;<br>        Type targetType = originalObject.GetType();  <span class="hljs-comment">// 可以是运行时才确定的类型</span><br><br>        <span class="hljs-comment">// 动态创建实例</span><br>        <span class="hljs-built_in">object</span> newObject = Activator.CreateInstance(targetType);<br><br>        <span class="hljs-comment">// 将动态创建的实例转换为 MyClass 类型</span><br>        MyClass myClassInstance = newObject <span class="hljs-keyword">as</span> MyClass;<br><br>        <span class="hljs-keyword">if</span> (myClassInstance != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(myClassInstance.Value); <span class="hljs-comment">// 输出 42</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;创建实例失败&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Activator.CreateInstance</code> 创建了一个 <code>MyClass</code> 的实例，并调用了默认的无参数构造函数。</p><h3 id="2-创建带参数的构造函数的实例"><a href="#2-创建带参数的构造函数的实例" class="headerlink" title="2. 创建带参数的构造函数的实例"></a>2. 创建带参数的构造函数的实例</h3><p>如果需要调用带参数的构造函数，可以在 <code>CreateInstance</code> 中传递参数值：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Value = <span class="hljs-keyword">value</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>, <span class="hljs-built_in">int</span> value2</span>)</span><br>    &#123;<br>        Value = <span class="hljs-keyword">value</span>;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;value2&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Activator 创建带参数的实例</span><br>        <span class="hljs-comment">// 两个作用是一样得</span><br>        <span class="hljs-comment">// MyClass myObject = (MyClass)Activator.CreateInstance(typeof(MyClass), new object[] &#123; 99, 1 &#125;);</span><br>        MyClass myObject = (MyClass)Activator.CreateInstance(<span class="hljs-keyword">typeof</span>(MyClass), <span class="hljs-number">99</span>, <span class="hljs-number">1</span>);<br>        Console.WriteLine(myObject.Value); <span class="hljs-comment">// 输出 99</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>new object[] &#123; 99 &#125;</code> 用于指定构造函数的参数，<code>Activator.CreateInstance</code> 会调用匹配的带参数的构造函数。</p><h3 id="3-创建泛型类型的实例"><a href="#3-创建泛型类型的实例" class="headerlink" title="3. 创建泛型类型的实例"></a>3. 创建泛型类型的实例</h3><p>使用泛型方法 <code>Activator.CreateInstance&lt;T&gt;</code> 可以方便地创建实例：</p><ul><li>这个只能用无参构造创建<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 泛型方法创建实例</span><br>        MyClass myObject = Activator.CreateInstance&lt;MyClass&gt;();<br>        Console.WriteLine(myObject.Value); <span class="hljs-comment">// 输出 42</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>这种方式适合无参数构造函数的情况，编译器会根据泛型参数自动推断类型。</li></ul><h3 id="4-创建接口或抽象类的实例"><a href="#4-创建接口或抽象类的实例" class="headerlink" title="4. 创建接口或抽象类的实例"></a>4. 创建接口或抽象类的实例</h3><p><code>Activator.CreateInstance</code> 只能用于创建具体类型的实例，不能直接创建接口或抽象类的实例。如果尝试这样做，会抛出 <code>MissingMethodException</code>。为了通过接口或抽象类创建实例，可以使用依赖注入或工厂模式来完成。</p><h3 id="5-使用-Activator-创建私有构造函数的实例"><a href="#5-使用-Activator-创建私有构造函数的实例" class="headerlink" title="5. 使用 Activator 创建私有构造函数的实例"></a>5. 使用 <code>Activator</code> 创建私有构造函数的实例</h3><p>如果要使用 <code>Activator</code> 调用私有的构造函数，可以使用反射来设置构造函数的访问权限：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Private constructor called.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用反射调用私有构造函数</span><br>        <span class="hljs-keyword">var</span> constructor = <span class="hljs-keyword">typeof</span>(MyClass).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, <span class="hljs-literal">null</span>, Type.EmptyTypes, <span class="hljs-literal">null</span>);<br>        MyClass myObject = (MyClass)constructor.Invoke(<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这些例子可以看出，<code>Activator</code> 在动态创建对象时非常灵活，能够适应各种场景。</p><h1 id="九、-Assembly"><a href="#九、-Assembly" class="headerlink" title="九、 Assembly"></a>九、 Assembly</h1><ul><li>程序集类</li><li>主要用来加载其它程序集，加载后才能用Type来使用其它程序集中的信息</li><li>如果想要使用不是自己程序集中的内容需要先加载程序集</li><li>比如dll文件（库文件）</li><li>简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类&#x2F;&#x2F;三种加载程序集的函数</li><li>一般用来加载在同一文件下的其它程序集<ul><li>Assembly assembly2&#x3D;Assembly.Load（“程序集名称”）；</li></ul></li><li>一般用来加载不在同一文件下的其它程序集<ul><li><code>Assembly assembly=Assembly.LoadFrom(“包含程序集清单的文件的名称或路径&quot;);</code></li><li><code>Assemblyasembly3=Assembly.LoadFile(“要加载的文件的完全限定路径&quot;);</code></li></ul></li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Reflection;<br><br><span class="hljs-built_in">enum</span> Dir<br>&#123;<br>    Left,<br>    Right,<br>    Up,<br>    Down<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;无参构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> _name, <span class="hljs-built_in">int</span> _age</span>)</span><br>    &#123;<br>        name = _name;<br>        Age = _age;<br>        Console.WriteLine(<span class="hljs-string">&quot;(string _name, int _age)构造函数&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 路径/项目名 就是程序集</span><br>        Assembly assembly = Assembly.LoadFrom(<span class="hljs-string">@&quot;F:\C#\projectTest\ConsoleAppTest\bin\Debug\net8.0\ConsoleAppTest&quot;</span>);<br><br>        Type[] types = assembly.GetTypes();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; types.Length; i++)<br>        &#123;<br>            Console.WriteLine(types[i]);<br>        &#125;<br>        <span class="hljs-comment">// 命名空间.类名 这里没有命名空间，所以就不写命名空间了</span><br>        Type test = assembly.GetType(<span class="hljs-string">&quot;Test&quot;</span>);<br>        MemberInfo[] members = test.GetMembers();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> member <span class="hljs-keyword">in</span> members)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;member: <span class="hljs-subst">&#123;member&#125;</span>&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">$&quot;member Name: <span class="hljs-subst">&#123;member.Name&#125;</span>&quot;</span>);<br><br>        &#125;<br><br>        Type dir = assembly.GetType(<span class="hljs-string">&quot;Dir&quot;</span>);<br>        FieldInfo right = dir.GetField(<span class="hljs-string">&quot;Right&quot;</span>);<br>        Console.WriteLine(right.GetValue(<span class="hljs-literal">null</span>));<br><br>        <span class="hljs-comment">// 获取 Test 类型</span><br>        Type testType = assembly.GetType(<span class="hljs-string">&quot;Test&quot;</span>);<br><br>        <span class="hljs-comment">// 通过无参构造函数创建 Test 实例</span><br>        <span class="hljs-built_in">object</span> testObject = Activator.CreateInstance(testType);<br><br>        <span class="hljs-comment">// 访问 Test 对象的字段和属性</span><br>        FieldInfo nameField = testType.GetField(<span class="hljs-string">&quot;name&quot;</span>);<br>        PropertyInfo ageProperty = testType.GetProperty(<span class="hljs-string">&quot;Age&quot;</span>);<br><br>        <span class="hljs-comment">// 设置字段和属性的值</span><br>        nameField.SetValue(testObject, <span class="hljs-string">&quot;Alice&quot;</span>);<br>        ageProperty.SetValue(testObject, <span class="hljs-number">30</span>);<br><br>        <span class="hljs-comment">// 输出字段和属性的值</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;nameField.GetValue(testObject)&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Age: <span class="hljs-subst">&#123;ageProperty.GetValue(testObject)&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 也可以通过反射调用有参构造函数</span><br>        <span class="hljs-built_in">object</span> testObjectWithParams = Activator.CreateInstance(testType, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// F:\C#\projectTest\ConsoleAppTest\bin\Debug\net8.0\ConsoleAppTest</span><br></code></pre></td></tr></table></figure><h1 id="十、-特性"><a href="#十、-特性" class="headerlink" title="十、 特性"></a>十、 特性</h1><p>特性（Attributes）在 C# 中是一种强大的机制，允许开发者向程序的各种元素（如类、方法、属性、字段等）添加元数据。这些元数据可以在运行时或编译时被其他代码或框架读取和使用。特性通常用于配置、描述、验证或提供额外的信息。</p><ul><li>特性得本质是类</li><li>可以利用特性类为原数据添加额外信息</li><li>比如一个类、成员变量、成员方法等等为他们添加更多得额外信息</li><li>后续通过反射获取这些额外信息</li></ul><h3 id="特性的基本概念"><a href="#特性的基本概念" class="headerlink" title="特性的基本概念"></a>特性的基本概念</h3><ul><li><strong>定义</strong>：特性是从 <code>System.Attribute</code> 类派生的类，通常通过特性构造函数传递参数。</li><li><strong>使用</strong>：特性通过方括号 <code>[]</code> 应用在类、方法、属性等上。</li></ul><h3 id="创建自定义特性"><a href="#创建自定义特性" class="headerlink" title="创建自定义特性"></a>创建自定义特性</h3><p>要创建一个特性，需要定义一个类并继承自 <code>System.Attribute</code>。以下是一个示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义一个自定义特性，限制自定义特性得使用范围</span><br><span class="hljs-comment">// 参数一：AttrivuteTargets 特性能够用在哪些地方</span><br><span class="hljs-comment">// 参数二：AllowMultiple 是否允许多个特性用在同一个目标上</span><br><span class="hljs-comment">// 参数三：Inherited 特性是否能够被派生类和重写成员继承</span><br>[<span class="hljs-meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DeveloperAttribute</span> : <span class="hljs-title">Attribute</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Date &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeveloperAttribute</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> date</span>)</span><br>    &#123;<br>        Name = name;<br>        Date = date;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用自定义特性</span><br><span class="hljs-comment">// 在 C# 中，特性类的名称可以省略后缀 &quot;Attribute&quot;，因为编译器会自动为你加上这个后缀。</span><br><span class="hljs-comment">// 实际上，你可以将 Developer 类的名称改为 DeveloperAttribute，这两者在使用时是等效的。</span><br>[<span class="hljs-meta">Developer(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;2024-10-28&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SampleClass</span><br>&#123;<br>    [<span class="hljs-meta">Developer(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;2024-10-29&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SampleMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Sample Method Executed&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 获取类的特性</span><br>        <span class="hljs-comment">// false：仅获取当前类型（SampleClass）的特性，不包括基类的特性。</span><br>        <span class="hljs-comment">// true：不仅获取当前类型的特性，还包括所有基类的特性。</span><br>        <span class="hljs-keyword">var</span> classAttributes = <span class="hljs-keyword">typeof</span>(SampleClass).GetCustomAttributes(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> classAttributes)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (attr <span class="hljs-keyword">is</span> DeveloperAttribute developerAttribute)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">$&quot;Class Developer: <span class="hljs-subst">&#123;developerAttribute.Name&#125;</span>, Date: <span class="hljs-subst">&#123;developerAttribute.Date&#125;</span>&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取方法</span><br>        <span class="hljs-keyword">var</span> method = <span class="hljs-keyword">typeof</span>(SampleClass).GetMethod(<span class="hljs-string">&quot;SampleMethod&quot;</span>);<br>        <span class="hljs-comment">// 获取方法的特性</span><br>        <span class="hljs-keyword">var</span> methodAttributes = method.GetCustomAttributes(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> methodAttributes)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (attr <span class="hljs-keyword">is</span> DeveloperAttribute developerAttribute)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">$&quot;Method Developer: <span class="hljs-subst">&#123;developerAttribute.Name&#125;</span>, Date: <span class="hljs-subst">&#123;developerAttribute.Date&#125;</span>&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断是否使用了某个特性</span><br>        <span class="hljs-comment">// 参数一：特性得类型</span><br>        <span class="hljs-comment">// 参数二：代表是否包含基类得特性，属性和事件忽略此参数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(SampleClass).IsDefined(<span class="hljs-keyword">typeof</span>(DeveloperAttribute), <span class="hljs-literal">false</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;SampleClass应用了Developer特性&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><strong>定义特性</strong>：<ul><li><code>DeveloperAttribute</code> 类是一个自定义特性，使用 <code>[AttributeUsage]</code> 特性指定它可以应用于类和方法。</li></ul></li><li><strong>使用特性</strong>：<ul><li>在 <code>SampleClass</code> 和 <code>SampleMethod</code> 上使用 <code>DeveloperAttribute</code>，传递开发者的名字和日期。</li></ul></li><li><strong>读取特性</strong>：<ul><li>使用 <code>GetCustomAttributes</code> 方法获取应用于类和方法的特性。</li><li>检查特性的类型并输出相关信息。</li></ul></li></ol><h3 id="特性的使用场景"><a href="#特性的使用场景" class="headerlink" title="特性的使用场景"></a>特性的使用场景</h3><ul><li><strong>数据验证</strong>：在数据模型中使用特性进行输入验证（如 <code>Required</code>、<code>StringLength</code> 等）。</li><li><strong>序列化</strong>：指定序列化行为，例如在 JSON、XML 序列化中使用。</li><li><strong>框架配置</strong>：为 ASP.NET 等框架提供配置。</li><li><strong>元数据</strong>：提供有关程序元素的额外信息，以便在运行时读取和处理。</li></ul><h3 id="访问特性"><a href="#访问特性" class="headerlink" title="访问特性"></a>访问特性</h3><p>特性可以通过反射访问。使用 <code>Type.GetCustomAttributes</code> 和 <code>MemberInfo.GetCustomAttributes</code> 方法获取特性。</p><h3 id="系统自带得特性"><a href="#系统自带得特性" class="headerlink" title="系统自带得特性"></a>系统自带得特性</h3><p>在 .NET 中，有许多系统自带的特性（Attributes），这些特性提供了元数据，用于控制行为、描述特性或提供其他信息。以下是一些常用的系统自带特性及其用途：</p><h4 id="1-ObsoleteAttribute"><a href="#1-ObsoleteAttribute" class="headerlink" title="1. ObsoleteAttribute"></a>1. <code>ObsoleteAttribute</code></h4><p>表示某个类、方法、属性或字段不再推荐使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;Use NewMethod instead.&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OldMethod</span>()</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-SerializableAttribute"><a href="#2-SerializableAttribute" class="headerlink" title="2. SerializableAttribute"></a>2. <code>SerializableAttribute</code></h4><p>指示一个类可以被序列化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-NonSerializedAttribute"><a href="#3-NonSerializedAttribute" class="headerlink" title="3. NonSerializedAttribute"></a>3. <code>NonSerializedAttribute</code></h4><p>指示某个字段在序列化时不应被序列化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br><br>    [<span class="hljs-meta">NonSerialized</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TemporaryValue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-DllImportAttribute"><a href="#4-DllImportAttribute" class="headerlink" title="4. DllImportAttribute"></a>4. <code>DllImportAttribute</code></h4><p>用于调用非托管代码中的方法，通常用于 P&#x2F;Invoke。</p><ul><li>这里DllImport传入的参数是当前的C或C++文件产生的dll文件的路径，这里表示是同一个dll文件下</li><li>后面定义的MessageBox()就是被这个特性修饰，表示的就是C或C++里面的的那个函数<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MessageBox</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> hWnd, <span class="hljs-built_in">string</span> text, <span class="hljs-built_in">string</span> caption, <span class="hljs-built_in">uint</span> type</span>)</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-ThreadStaticAttribute"><a href="#5-ThreadStaticAttribute" class="headerlink" title="5. ThreadStaticAttribute"></a>5. <code>ThreadStaticAttribute</code></h4><p>指示某个字段是线程静态的，每个线程都有自己的独立字段副本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">ThreadStatic</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> ThreadLocalValue;<br></code></pre></td></tr></table></figure><h4 id="6-AttributeUsageAttribute"><a href="#6-AttributeUsageAttribute" class="headerlink" title="6. AttributeUsageAttribute"></a>6. <code>AttributeUsageAttribute</code></h4><p>指定自定义特性的使用规则。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCustomAttribute</span> : <span class="hljs-title">Attribute</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-DebuggerDisplayAttribute"><a href="#7-DebuggerDisplayAttribute" class="headerlink" title="7. DebuggerDisplayAttribute"></a>7. <code>DebuggerDisplayAttribute</code></h4><p>用于控制在调试器中显示的类或结构信息。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">DebuggerDisplay(<span class="hljs-string">&quot;Value = &#123;Value&#125;&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-GuidAttribute"><a href="#8-GuidAttribute" class="headerlink" title="8. GuidAttribute"></a>8. <code>GuidAttribute</code></h4><p>用于指定接口的全局唯一标识符 (GUID)。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Guid(<span class="hljs-string">&quot;12345678-1234-1234-1234-1234567890AB&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-FlagsAttribute"><a href="#9-FlagsAttribute" class="headerlink" title="9. FlagsAttribute"></a>9. <code>FlagsAttribute</code></h4><p>用于枚举，指示该枚举可以作为位标志进行组合。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Flags</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> MyFlags<br>&#123;<br>    None = <span class="hljs-number">0</span>,<br>    Option1 = <span class="hljs-number">1</span>,<br>    Option2 = <span class="hljs-number">2</span>,<br>    Option3 = <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-AssemblyVersionAttribute"><a href="#10-AssemblyVersionAttribute" class="headerlink" title="10. AssemblyVersionAttribute"></a>10. <code>AssemblyVersionAttribute</code></h4><p>指定程序集的版本。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">assembly: AssemblyVersion(<span class="hljs-string">&quot;1.0.0.0&quot;</span>)</span>]<br></code></pre></td></tr></table></figure><p>在 C# 中，<code>CallerFilePath</code>、<code>CallerLineNumber</code> 和 <code>CallerMemberName</code> 是三个特殊的编译器服务特性（attributes），它们可以用于方法参数，以便在运行时获取调用该方法的文件名、行号和方法名称。这些特性通常用于日志记录、调试或任何需要追踪调用上下文的场景。</p><h4 id="11-CallerFilePath"><a href="#11-CallerFilePath" class="headerlink" title="11. CallerFilePath"></a>11. CallerFilePath</h4><p><code>CallerFilePath</code> 特性提供了调用方法的源文件的完整路径。<br><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Runtime.CompilerServices;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, </span></span><br><span class="hljs-params"><span class="hljs-function">                    [CallerFilePath] <span class="hljs-built_in">string</span> filePath = <span class="hljs-string">&quot;&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                    [CallerLineNumber] <span class="hljs-built_in">int</span> lineNumber = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                    [CallerMemberName] <span class="hljs-built_in">string</span> memberName = <span class="hljs-string">&quot;&quot;</span></span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;[<span class="hljs-subst">&#123;DateTime.Now&#125;</span>] <span class="hljs-subst">&#123;message&#125;</span> (File: <span class="hljs-subst">&#123;filePath&#125;</span>, Line: <span class="hljs-subst">&#123;lineNumber&#125;</span>, Member: <span class="hljs-subst">&#123;memberName&#125;</span>)&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Logger logger = <span class="hljs-keyword">new</span> Logger();<br>        logger.Log(<span class="hljs-string">&quot;This is a log message.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[2023-10-28 12:00:00]</span> <span class="hljs-selector-tag">This</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">log</span> <span class="hljs-selector-tag">message</span>. (<span class="hljs-attribute">File</span>: <span class="hljs-attribute">C</span>:\path\to\your\file.cs, <span class="hljs-attribute">Line</span>: <span class="hljs-number">14</span>, <span class="hljs-attribute">Member</span>: Main)<br></code></pre></td></tr></table></figure><h4 id="12-CallerLineNumber"><a href="#12-CallerLineNumber" class="headerlink" title="12. CallerLineNumber"></a>12. CallerLineNumber</h4><p><code>CallerLineNumber</code> 特性提供了调用方法的源代码行号。<br><strong>示例</strong>：同上面的 <code>Logger</code> 类，行号会自动填充。</p><h4 id="13-CallerMemberName"><a href="#13-CallerMemberName" class="headerlink" title="13. CallerMemberName"></a>13. CallerMemberName</h4><p><code>CallerMemberName</code> 特性提供了调用该方法的成员名称（例如，方法或属性名）。<br><strong>示例</strong>：同上面的 <code>Logger</code> 类，成员名称会自动填充。</p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>这些特性常用于：</p><ul><li><strong>日志记录</strong>：可以记录出错信息及其来源，以便后续的调试。</li><li><strong>调试信息</strong>：在调试过程中，可以追踪函数的调用位置。</li><li><strong>错误处理</strong>：在处理异常时，可以提供更多上下文信息。</li></ul><h4 id="14-Conditional"><a href="#14-Conditional" class="headerlink" title="14. Conditional"></a>14. Conditional</h4><p><code>Conditional</code> 特性是 C# 中一个非常有用的特性，主要用于控制某个方法是否被编译器调用。通过将 <code>Conditional</code> 特性应用于方法，可以根据特定的编译符号（如条件编译符号）决定是否在编译期间包括该方法的调用。这对于调试和日志记录等场景非常有用。</p><h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><ul><li><strong>特性定义</strong>：<code>Conditional</code> 特性位于 <code>System.Diagnostics</code> 命名空间中。</li><li><strong>方法参数</strong>：特性接受一个字符串参数，该参数表示一个编译符号。当定义的符号存在时，标记为 <code>Conditional</code> 的方法会被调用；如果该符号不存在，则方法调用会被忽略。和#define配合使用</li></ul><h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Fun</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Diagnostics;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span><br>&#123;<br>    [<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;DEBUG&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Log: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 只有#define Fun采用调用下面得函数</span><br>    [<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;Fun&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Log</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message, <span class="hljs-built_in">int</span> i</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Log: <span class="hljs-subst">&#123;message&#125;</span>1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Logger logger = <span class="hljs-keyword">new</span> Logger();<br>        logger.Log(<span class="hljs-string">&quot;This is a debug message.&quot;</span>); <span class="hljs-comment">// 在DEBUG模式下会输出</span><br>        logger.Log(<span class="hljs-string">&quot;This is a debug message.&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 在#define Fun下会输出</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="编译符号"><a href="#编译符号" class="headerlink" title="编译符号"></a>编译符号</h5><ul><li>在上面的示例中，<code>Log</code> 方法使用了 <code>Conditional(&quot;DEBUG&quot;)</code> 特性。当项目在 <code>DEBUG</code> 模式下编译时，<code>Log</code> 方法的调用会被保留；而在 <code>RELEASE</code> 模式下，调用将被忽略，<code>Log</code> 方法不会执行。</li></ul><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li><strong>不支持返回值</strong>：被标记为 <code>Conditional</code> 的方法必须是 <code>void</code> 返回类型，不能返回其他类型。</li><li><strong>仅适用于方法</strong>：此特性不能用于属性、字段或其他成员，只能应用于方法。</li><li><strong>在调用方法时</strong>：即使在 <code>RELEASE</code> 模式下，调用仍会在代码中保留，但不会在运行时执行。</li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>特性是类的实例，它们在运行时被加载，因此会消耗一定的资源。</li><li>使用特性时要考虑性能，避免在性能敏感的代码中频繁访问特性。<br>特性为 C# 提供了灵活性和可扩展性，使得代码更具可读性和可维护性。</li></ul><h1 id="十一、-迭代器"><a href="#十一、-迭代器" class="headerlink" title="十一、 迭代器"></a>十一、 迭代器</h1><p>在 C# 中，可以通过实现 <code>IEnumerable&lt;T&gt;</code> 和 <code>IEnumerator&lt;T&gt;</code> 接口来自定义迭代器。下面是一个简单的示例，展示如何创建一个自定义的迭代器来遍历一个数列。</p><ul><li>using System.Collections;</li><li>关键接口：IEnumerator，IEnumerable</li><li>可以通过继承IEnumerator，IEnumerable接口实现其中得方法</li></ul><h3 id="示例：自定义迭代器"><a href="#示例：自定义迭代器" class="headerlink" title="示例：自定义迭代器"></a>示例：自定义迭代器</h3><p>假设我们想要创建一个表示斐波那契数列的类，并提供一个迭代器来遍历该数列。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FibonacciSequence</span> : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">int</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibonacciSequence</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> count</span>)</span><br>    &#123;<br>        _count = count;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 IEnumerable&lt;int&gt; 接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetEnumerator</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FibonacciEnumerator(_count);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 IEnumerable 接口</span><br>    IEnumerator IEnumerable.GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">return</span> GetEnumerator();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FibonacciEnumerator</span> : <span class="hljs-title">IEnumerator</span>&lt;<span class="hljs-title">int</span>&gt;<br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _count;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _currentIndex = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _previous = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _current = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibonacciEnumerator</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> count</span>)</span><br>        &#123;<br>            _count = count;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 就是用来返回当前的值的，也就是迭代器的当前值</span><br>        <span class="hljs-comment">// 是一个属性</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Current =&gt; _current;<br>        <span class="hljs-comment">//public int Current</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    get</span><br>        <span class="hljs-comment">//    &#123;</span><br>        <span class="hljs-comment">//        Console.WriteLine(&quot;Current被调用&quot;);</span><br>        <span class="hljs-comment">//        return _current;</span><br>        <span class="hljs-comment">//    &#125;</span><br>        <span class="hljs-comment">//&#125;</span><br><br>        <span class="hljs-built_in">object</span> IEnumerator.Current =&gt; Current;<br>        <span class="hljs-comment">// 等价于下main得代码，是属性</span><br>        <span class="hljs-comment">//object IEnumerator.Current</span><br>        <span class="hljs-comment">//&#123;</span><br>        <span class="hljs-comment">//    get &#123; return Current; &#125;</span><br>        <span class="hljs-comment">//&#125;</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (_currentIndex &gt;= _count - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">if</span> (_currentIndex == <span class="hljs-number">-1</span>)<br>            &#123;<br>                _currentIndex++;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 这里实现了斐波拉且数列的相加</span><br>            <span class="hljs-built_in">int</span> next = _previous + _current;<br>            _previous = _current;<br>            _current = next;<br>            _currentIndex++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span><br>        &#123;<br>            _currentIndex = <span class="hljs-number">-1</span>;<br>            _previous = <span class="hljs-number">0</span>;<br>            _current = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span> &#123; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> fibonacci = <span class="hljs-keyword">new</span> FibonacciSequence(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> fibonacci)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h4><ol><li><strong>FibonacciSequence 类</strong>：<ul><li>实现了 <code>IEnumerable&lt;int&gt;</code> 接口，表示可以迭代的集合。</li><li><code>GetEnumerator</code> 方法返回一个 <code>IEnumerator&lt;int&gt;</code> 类型的实例，这里返回的是 <code>FibonacciEnumerator</code>。</li></ul></li><li><strong>FibonacciEnumerator 类</strong>：<ul><li>实现了 <code>IEnumerator&lt;int&gt;</code> 接口，用于提供迭代功能。</li><li><code>_currentIndex</code> 记录当前索引，<code>_previous</code> 和 <code>_current</code> 分别存储前一个和当前的 Fibonacci 数。</li></ul></li><li><strong>MoveNext 方法</strong>：<ul><li>计算下一个 Fibonacci 数并更新状态。</li><li>如果索引超过范围，返回 <code>false</code>。</li></ul></li><li><strong>Reset 方法</strong>：<ul><li>将迭代器状态重置为初始状态。</li></ul></li><li><strong>Dispose 方法</strong>：<ul><li>实现 <code>IDisposable</code> 接口，虽然在这个例子中没有资源需要释放，但为了完整性仍然实现了这个方法。</li></ul></li><li><strong>Program 类</strong>：<ul><li>创建一个 <code>FibonacciSequence</code> 的实例并使用 <code>foreach</code> 循环遍历 Fibonacci 数列。</li></ul></li></ol><blockquote><p>这段代码定义了一个自定义的 <code>IEnumerable</code> 实现，用于生成指定数量的斐波那契数列。代码通过 <code>FibonacciSequence</code> 类生成数列，并通过嵌套的 <code>FibonacciEnumerator</code> 类逐步计算和返回斐波那契数。</p></blockquote><p>按调用流程逐步解析这段代码：</p><ol><li><strong>创建 <code>FibonacciSequence</code> 实例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> fibonacci = <span class="hljs-keyword">new</span> FibonacciSequence(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>这行代码创建一个 <code>FibonacciSequence</code> 实例，用于生成前 10 个斐波那契数。</li><li><strong>进入 <code>foreach</code> 循环</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> fibonacci)<br>&#123;<br>    Console.WriteLine(number);<br>&#125;<br></code></pre></td></tr></table></figure>这个 <code>foreach</code> 循环会隐式调用 <code>fibonacci.GetEnumerator()</code> 方法，返回一个 <code>FibonacciEnumerator</code> 对象。<code>foreach</code> 会在每次迭代时调用 <code>MoveNext()</code> 和 <code>Current</code>，直到 <code>MoveNext()</code> 返回 <code>false</code>。</li></ol><h4 id="迭代器具体调用流程"><a href="#迭代器具体调用流程" class="headerlink" title="迭代器具体调用流程"></a>迭代器具体调用流程</h4><p>以下是每个方法的作用及调用顺序：</p><ol><li><p>**调用 <code>GetEnumerator</code>**：</p><ul><li><code>fibonacci.GetEnumerator()</code> 返回一个 <code>FibonacciEnumerator</code> 实例，它是实际负责生成斐波那契数的迭代器。</li></ul></li><li><p>**进入迭代 (<code>MoveNext</code> and <code>Current</code>)**：</p><ul><li>**首次调用 <code>MoveNext()</code>**：<ul><li><code>_currentIndex</code> 初始值为 <code>-1</code>，此时更新为 <code>0</code>，然后返回 <code>true</code>。</li><li>此时 <code>Current</code> 的值为 <code>1</code>，它代表斐波那契数列的第一个值。</li></ul></li><li><strong>获取 <code>Current</code> 的值</strong>：<ul><li><code>foreach</code> 调用 <code>IEnumerator.Current</code>，返回当前的 <code>_current</code> 值（<code>1</code>），将其打印。</li></ul></li></ul></li><li><p><strong>后续迭代</strong>：</p><ul><li>每次调用 <code>MoveNext()</code> 依次计算下一个斐波那契数：<ul><li><code>next = _previous + _current</code>：计算下一个斐波那契值。</li><li>更新 <code>_previous</code> 和 <code>_current</code>，并递增 <code>_currentIndex</code>。</li></ul></li><li>调用 <code>Current</code> 时返回最新的 <code>_current</code> 值，逐个输出到控制台。</li></ul></li><li><p><strong>结束迭代</strong>：</p><ul><li>当 <code>_currentIndex &gt;= _count - 1</code> 时，<code>MoveNext()</code> 返回 <code>false</code>，<code>foreach</code> 循环结束。</li></ul></li></ol><h4 id="流程图示例"><a href="#流程图示例" class="headerlink" title="流程图示例"></a>流程图示例</h4><p>以下为每次调用的关键变量变化：</p><table><thead><tr><th>Step</th><th><code>_currentIndex</code></th><th><code>_previous</code></th><th><code>_current</code></th><th>Output</th></tr></thead><tbody><tr><td>Initial</td><td>-1</td><td>0</td><td>1</td><td></td></tr><tr><td>1st MoveNext</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>2nd MoveNext</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3rd MoveNext</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>4th MoveNext</td><td>3</td><td>2</td><td>3</td><td>3</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>Final</td><td>9</td><td>…</td><td>…</td><td>34</td></tr></tbody></table><p>当 <code>MoveNext()</code> 返回 <code>false</code>，表示序列结束。</p><h3 id="IEnumerator-接口的实现细节"><a href="#IEnumerator-接口的实现细节" class="headerlink" title="IEnumerator 接口的实现细节"></a><code>IEnumerator</code> 接口的实现细节</h3><ul><li>**<code>Current</code>**：始终返回 <code>_current</code> 值，表示当前斐波那契数。</li><li>**<code>MoveNext</code>**：更新斐波那契值并判断是否继续。</li><li>**<code>Reset</code>**：重置所有值，使迭代器可以重新开始（仅在手动调用时生效）。</li></ul><p>通过这个实现，每次调用 <code>MoveNext()</code> 都会生成新的斐波那契数，直到达到指定的数量。</p><h3 id="yield-return实现迭代器"><a href="#yield-return实现迭代器" class="headerlink" title="yield return实现迭代器"></a>yield return实现迭代器</h3><p>使用 <code>yield return</code> 可以轻松地实现迭代器，提供一种简洁的方式来返回序列中的每个元素。下面是一个示例，演示如何使用 <code>yield return</code> 创建一个生成 Fibonacci 数列的迭代器。</p><ul><li>只需要继承IEnumerable接口</li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FibonacciGenerator</span> : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">int</span>&gt;<br>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _count;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FibonacciGenerator</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> count</span>)</span><br>    &#123;<br>        _count = count;<br>    &#125;<br>    <span class="hljs-comment">// 使用迭代器生成 Fibonacci 数列</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">Generate</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> count</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>        &#123;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> a; <span class="hljs-comment">// 返回当前的 Fibonacci 数</span><br>            <span class="hljs-built_in">int</span> temp = a;    <span class="hljs-comment">// 存储当前值</span><br>            a = b;           <span class="hljs-comment">// 更新 a 为下一个 Fibonacci 数</span><br>            b = temp + b;    <span class="hljs-comment">// 更新 b 为新的 Fibonacci 数</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetEnumerator</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; _count; i++)<br>        &#123;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> a; <span class="hljs-comment">// 返回当前的 Fibonacci 数</span><br>            <span class="hljs-built_in">int</span> temp = a;    <span class="hljs-comment">// 存储当前值</span><br>            a = b;           <span class="hljs-comment">// 更新 a 为下一个 Fibonacci 数</span><br>            b = temp + b;    <span class="hljs-comment">// 更新 b 为新的 Fibonacci 数</span><br>        &#125;<br>    &#125;<br><br>    IEnumerator IEnumerable.GetEnumerator()<br>    &#123;<br>        <span class="hljs-keyword">return</span> GetEnumerator();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        FibonacciGenerator generator = <span class="hljs-keyword">new</span> FibonacciGenerator(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 生成前 10 个 Fibonacci 数</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> generator.Generate(<span class="hljs-number">10</span>))<br>        &#123;<br>            Console.WriteLine(number); <span class="hljs-comment">// 输出 Fibonacci 数</span><br>        &#125;<br><br>        <span class="hljs-comment">// 生成前 10 个 Fibonacci 数</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> generator)<br>        &#123;<br>            Console.WriteLine(number); <span class="hljs-comment">// 输出 Fibonacci 数</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h4><ol><li><strong><code>IEnumerable&lt;int&gt; Generate(int count)</code></strong>:<ul><li>这是一个返回 <code>IEnumerable&lt;int&gt;</code> 的方法，意味着它将返回一个可枚举的整数序列。</li><li><code>count</code> 参数指定要生成的 Fibonacci 数的个数。</li></ul></li><li><strong><code>yield return a;</code></strong>:<ul><li>使用 <code>yield return</code> 语句来返回当前的 Fibonacci 数。</li><li>每次调用 <code>Generate</code> 方法时，它都会返回下一个值，而不需要显式维护一个状态。</li></ul></li><li><strong><code>for</code> 循环</strong>:<ul><li>通过循环生成 Fibonacci 数，更新变量 <code>a</code> 和 <code>b</code> 来计算下一个 Fibonacci 数。</li></ul></li><li><strong><code>Main</code> 方法</strong>:<ul><li>创建 <code>FibonacciGenerator</code> 实例，并使用 <code>foreach</code> 循环遍历生成的 Fibonacci 数列，输出每个值。</li></ul></li></ol><h4 id="使用-yield-return-的好处："><a href="#使用-yield-return-的好处：" class="headerlink" title="使用 yield return 的好处："></a>使用 <code>yield return</code> 的好处：</h4><ul><li><strong>简洁性</strong>: 代码更加简洁，易于理解。</li><li><strong>状态管理</strong>: 不需要手动管理迭代状态，<code>yield</code> 关键字自动处理了。</li><li><strong>惰性求值</strong>: 值在实际需要时才会被计算和返回，有助于节省内存和计算资源。</li></ul><h1 id="十二、-空合并操作符"><a href="#十二、-空合并操作符" class="headerlink" title="十二、 空合并操作符"></a>十二、 空合并操作符</h1><p>空合并操作符（Null Coalescing Operator）在 C# 中用来处理可能为 <code>null</code> 的情况，提供一个简洁的语法来返回第一个非 <code>null</code> 的值。空合并操作符是 <code>??</code>，可以用于简化条件判断和默认值的赋值。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = value1 ?? value2;<br></code></pre></td></tr></table></figure><p>这里，如果 <code>value1</code> 不为 <code>null</code>，<code>result</code> 将等于 <code>value1</code>；否则，<code>result</code> 将等于 <code>value2</code>。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> input = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 使用空合并操作符</span><br>        <span class="hljs-built_in">string</span> output = input ?? <span class="hljs-string">&quot;默认值&quot;</span>;<br><br>        Console.WriteLine(output); <span class="hljs-comment">// 输出 &quot;默认值&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>设置默认值</strong>: 当你想要为可能为 <code>null</code> 的变量设置默认值时，使用空合并操作符是非常方便的。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> userInput = GetUserInput(); <span class="hljs-comment">// 可能返回 null</span><br><span class="hljs-built_in">string</span> displayInput = userInput ?? <span class="hljs-string">&quot;无输入&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><strong>简化条件判断</strong>: 可以减少需要写的条件语句数量，使代码更简洁。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> firstName = GetFirstName() ?? <span class="hljs-string">&quot;John&quot;</span>;<br></code></pre></td></tr></table></figure></li></ol><h3 id="结合其他操作符"><a href="#结合其他操作符" class="headerlink" title="结合其他操作符"></a>结合其他操作符</h3><ul><li><strong>空合并赋值操作符 (<code>??=</code>)</strong>: 从 C# 8.0 开始，你还可以使用空合并赋值操作符来为 <code>null</code> 的变量赋值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> username = <span class="hljs-literal">null</span>;<br>username ??= <span class="hljs-string">&quot;Guest&quot;</span>; <span class="hljs-comment">// 如果 username 为 null，则赋值为 &quot;Guest&quot;</span><br></code></pre></td></tr></table></figure>在这个例子中，<code>username</code> 仅在其为 <code>null</code> 时被赋值。</li></ul><h3 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>? intV = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 这里是因为intV是int?类型，不能赋值给int，所以需要用intV.Value进行转换</span><br>        <span class="hljs-comment">// int intI = intV == null ? 100 : intV.Value;</span><br>        <span class="hljs-comment">// 这里的int intI = intV ?? 100;的intV不需要.Value，是因为？？进行了处理</span><br>        <span class="hljs-built_in">int</span> intI = intV ?? <span class="hljs-number">100</span>;<br>        Console.WriteLine(intI);<br>        <span class="hljs-built_in">string</span> str = <span class="hljs-literal">null</span>;<br>        str = str ?? <span class="hljs-string">&quot;hahah&quot;</span>;<br>        Console.WriteLine(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十三、-结构体和类中的值和引用"><a href="#十三、-结构体和类中的值和引用" class="headerlink" title="十三、 结构体和类中的值和引用"></a>十三、 结构体和类中的值和引用</h1><h3 id="结构体中的值和引用"><a href="#结构体中的值和引用" class="headerlink" title="结构体中的值和引用"></a>结构体中的值和引用</h3><ul><li>结构体本身是值类型</li><li>前提：该结构体没有作为其他类的成员</li><li>在结构体中的值，占用存储值具体得内容</li><li>在结构体中的引用，堆中存储引用具体的内容</li></ul><h3 id="类中的值和引用"><a href="#类中的值和引用" class="headerlink" title="类中的值和引用"></a>类中的值和引用</h3><ul><li>类本身是引用类型</li><li>在类中的值，堆中存储具体的值</li><li>在类中的引用，堆中存储具体的值</li></ul><h1 id="十四、-this"><a href="#十四、-this" class="headerlink" title="十四、 this"></a>十四、 this</h1><p>在 C# 中，<code>this</code> 是一个特殊关键字，用于引用当前对象的实例。以下是 <code>this</code> 的具体用法和规则。</p><hr><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a><strong>主要用途</strong></h3><h4 id="1-引用当前实例对象："><a href="#1-引用当前实例对象：" class="headerlink" title="1. 引用当前实例对象："></a>1. <strong>引用当前实例对象：</strong></h4><pre><code class="hljs">- `this` 通常用于区分实例字段、方法或属性与局部变量或参数名称冲突的情况。</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetValue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>; <span class="hljs-comment">// 使用 this 区分实例字段和方法参数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-调用类中的其他构造函数："><a href="#2-调用类中的其他构造函数：" class="headerlink" title="2. 调用类中的其他构造函数："></a>2. <strong>调用类中的其他构造函数：</strong></h4><pre><code class="hljs">- 使用 `this` 可以在一个构造函数中调用另一个构造函数。</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>() : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">0</span></span>) <span class="hljs-comment">// 调用另一个构造函数</span></span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-作为方法或属性的返回值："><a href="#3-作为方法或属性的返回值：" class="headerlink" title="3. 作为方法或属性的返回值："></a>3. <strong>作为方法或属性的返回值：</strong></h4><pre><code class="hljs">- `this` 可以用作返回值，通常在链式调用中使用。</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Example <span class="hljs-title">SetValue</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回当前实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-在扩展方法中显式引用调用者对象："><a href="#4-在扩展方法中显式引用调用者对象：" class="headerlink" title="4. 在扩展方法中显式引用调用者对象："></a>4. <strong>在扩展方法中显式引用调用者对象：</strong></h4><pre><code class="hljs">- 扩展方法的第一个参数通常用 `this` 表示扩展的类型。</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Extensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> str</span>)</span><br>    &#123;<br>        Console.WriteLine(str); <span class="hljs-comment">// str 是调用该方法的实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-在事件或委托中作为参数传递："><a href="#5-在事件或委托中作为参数传递：" class="headerlink" title="5. 在事件或委托中作为参数传递："></a>5. <strong>在事件或委托中作为参数传递：</strong></h4><pre><code class="hljs">- 使用 `this` 表示当前对象。</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler OnClick;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Click</span>()</span><br>    &#123;<br>        OnClick?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty); <span class="hljs-comment">// 传递当前对象作为 sender</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a><strong>使用限制</strong></h3><h4 id="1-静态成员中不能使用-this："><a href="#1-静态成员中不能使用-this：" class="headerlink" title="1. 静态成员中不能使用 this："></a>1. <strong>静态成员中不能使用 <code>this</code>：</strong></h4><pre><code class="hljs">- 静态成员（字段、方法、属性）属于类本身，而不是实例。</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StaticMethod</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// this.value = 10; // 错误：静态成员不能访问实例成员</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-字段或属性的初始化中不能使用-this："><a href="#2-字段或属性的初始化中不能使用-this：" class="headerlink" title="2. 字段或属性的初始化中不能使用 this："></a>2. <strong>字段或属性的初始化中不能使用 <code>this</code>：</strong></h4><pre><code class="hljs">- 在字段或属性的初始化阶段，实例尚未完全构造，因此 `this` 不可用。</code></pre><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">this</span>.SomeMethod(); <span class="hljs-comment">// 错误：实例成员尚未初始化</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-title">SomeMethod</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-匿名方法或-lambda-表达式中的捕获："><a href="#3-匿名方法或-lambda-表达式中的捕获：" class="headerlink" title="3. 匿名方法或 lambda 表达式中的捕获："></a>3. <strong>匿名方法或 lambda 表达式中的捕获：</strong></h4><ul><li>如果匿名方法或 lambda 表达式被封装到静态上下文中，则不能使用 <code>this</code>。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span><br>    &#123;<br>        Action action = () =&gt;<br>        &#123;<br>            <span class="hljs-comment">// this.value = 10; // 错误：如果 lambda 表达式捕获的上下文是静态的</span><br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><strong>lambda 表达式或匿名方法是否能使用 <code>this</code>，取决于它的上下文是否是实例上下文</strong>。下面分几种情况来详细说明：</p></blockquote><h5 id="1-实例上下文中可以使用-this"><a href="#1-实例上下文中可以使用-this" class="headerlink" title="1. 实例上下文中可以使用 this"></a><strong>1. 实例上下文中可以使用 <code>this</code></strong></h5><p>如果 lambda 表达式定义在实例方法中，它会捕获周围实例的上下文，因此可以使用 <code>this</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span><br>    &#123;<br>        Action action = () =&gt;<br>        &#123;<br>            <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-number">10</span>; <span class="hljs-comment">// 合法，this 是当前实例</span><br>        &#125;;<br><br>        action.Invoke(); <span class="hljs-comment">// 执行 lambda 表达式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>this</code> 是指当前 <code>Example</code> 类的实例。因为 <code>Method</code> 是一个实例方法，lambda 表达式也在实例上下文中运行。</p><hr><h5 id="2-静态上下文中不能使用-this"><a href="#2-静态上下文中不能使用-this" class="headerlink" title="2. 静态上下文中不能使用 this"></a><strong>2. 静态上下文中不能使用 <code>this</code></strong></h5><p>如果 lambda 表达式定义在静态方法中，<code>this</code> 是无效的，因为静态方法不属于类的实例，而是直接属于类本身。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span><br>    &#123;<br>        Action action = () =&gt;<br>        &#123;<br>            <span class="hljs-comment">// this.value = 10; // 错误：静态方法中没有 this</span><br>        &#125;;<br><br>        action.Invoke();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>this</code> 是非法的，因为 <code>Method</code> 是静态方法，没有与任何类实例绑定。静态方法中只能访问静态成员，不能访问实例成员，也没有 <code>this</code>。</p><hr><h5 id="3-捕获上下文的行为"><a href="#3-捕获上下文的行为" class="headerlink" title="3. 捕获上下文的行为"></a><strong>3. 捕获上下文的行为</strong></h5><p>当 lambda 表达式或匿名方法捕获上下文时，它会捕获当前作用域中的变量（包括实例变量和局部变量）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> localVar = <span class="hljs-number">5</span>;<br><br>        Action action = () =&gt;<br>        &#123;<br>            Console.WriteLine(localVar); <span class="hljs-comment">// 捕获局部变量</span><br>        &#125;;<br><br>        action.Invoke(); <span class="hljs-comment">// 输出：5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>localVar</code> 是一个局部变量，lambda 表达式会捕获它，并在运行时使用。</p><hr><h5 id="4-静态上下文和捕获的结合"><a href="#4-静态上下文和捕获的结合" class="headerlink" title="4. 静态上下文和捕获的结合"></a><strong>4. 静态上下文和捕获的结合</strong></h5><p>如果 lambda 表达式在静态上下文中，不能捕获实例上下文（即不能使用 <code>this</code>），但仍然可以捕获静态成员或局部变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> staticValue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> localValue = <span class="hljs-number">5</span>;<br><br>        Action action = () =&gt;<br>        &#123;<br>            staticValue = <span class="hljs-number">10</span>; <span class="hljs-comment">// 可以访问静态成员</span><br>            Console.WriteLine(localValue); <span class="hljs-comment">// 捕获局部变量</span><br>        &#125;;<br><br>        action.Invoke(); <span class="hljs-comment">// 输出：5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 lambda 表达式虽然不能访问 <code>this</code>，但可以访问静态成员 <code>staticValue</code> 和局部变量 <code>localValue</code>。</p><hr><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a><strong>特殊情况</strong></h3><ol><li><strong>在 <code>struct</code> 中的 <code>this</code>：</strong><ul><li>在结构体（<code>struct</code>）中，<code>this</code> 是当前实例的副本，因此不能直接修改 <code>struct</code> 的成员。</li><li>可以通过调用方法或使用 <code>ref</code> 修饰的结构体参数修改实例。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Example<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ModifyValue</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.Value = <span class="hljs-number">10</span>; <span class="hljs-comment">// 合法，但修改的是副本</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ModifyWithRef</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> Example instance</span>)</span><br>    &#123;<br>        instance.Value = <span class="hljs-number">10</span>; <span class="hljs-comment">// 正确修改</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>在扩展方法中：</strong><ul><li>扩展方法中的 <code>this</code> 参数是调用者实例的引用，因此 <code>this</code> 可以用来操作调用者对象，但不能为其重新赋值。</li></ul></li></ol><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><strong>字段初始化顺序问题：</strong> Unity 或 C# 中的类字段初始化发生在构造函数运行之前，在这个阶段 <code>this</code> 尚未完全初始化。</li><li><code>this</code> 只能在类的方法（包括构造函数）或属性的 getter&#x2F;setter 中使用，而不能在字段的声明或初始化部分中使用。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/zh-cn/">MS-Learning</a><br><a href="https://www.cnblogs.com/VVStudy/p/11404300.html" title="发布于 2019-08-28 12:04">C# - 协变、逆变 看完这篇就懂了</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSharp知识整理(三)</title>
    <link href="/2024/10/26/Csharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%89)/"/>
    <url>/2024/10/26/Csharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h1 id="一、-命名空间"><a href="#一、-命名空间" class="headerlink" title="一、 命名空间"></a>一、 命名空间</h1><blockquote><p>命名空间（Namespace）是 C# 中用于组织代码的一种方式。它提供了一种机制来将相关的类、结构、接口、枚举和委托分组在一起，从而避免名称冲突，并提供更好的代码管理和结构。</p></blockquote><ul><li>命名空间中的类，默认为internal</li><li>internal表示只能在该程序集中使用，也就是只能在当前的项目中使用</li><li>不同命名空间中允许有同名类</li><li>命名空间中可以包裹命名空间</li></ul><h3 id="1-创建命名空间"><a href="#1-创建命名空间" class="headerlink" title="1. 创建命名空间"></a>1. 创建命名空间</h3><p>可以使用 <code>namespace</code> 关键字定义一个命名空间。以下是一个简单的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>        &#123;<br>            Radius = radius;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>        &#123;<br>            Width = width;<br>            Height = height;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Width * Height;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用命名空间"><a href="#2-使用命名空间" class="headerlink" title="2. 使用命名空间"></a>2. 使用命名空间</h3><p>在使用命名空间中的类时，您可以使用完整名称，或者使用 <code>using</code> 指令来引入命名空间，以便在代码中更方便地使用它们。</p><h4 id="完整名称"><a href="#完整名称" class="headerlink" title="完整名称"></a>完整名称</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Geometry.Circle circle = <span class="hljs-keyword">new</span> Geometry.Circle(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>);<br><br>        Geometry.Rectangle rectangle = <span class="hljs-keyword">new</span> Geometry.Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-using-指令"><a href="#使用-using-指令" class="headerlink" title="使用 using 指令"></a>使用 <code>using</code> 指令</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> Geometry; <span class="hljs-comment">// 引入 Geometry 命名空间</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>);<br><br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-嵌套命名空间"><a href="#3-嵌套命名空间" class="headerlink" title="3. 嵌套命名空间"></a>3. 嵌套命名空间</h3><p>C# 还支持嵌套命名空间，可以通过在命名空间中定义另一个命名空间来实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span><br>&#123;<br>    <span class="hljs-keyword">namespace</span> <span class="hljs-title">Shapes</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span><br>        &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Base &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Triangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> baseLength, <span class="hljs-built_in">double</span> height</span>)</span><br>            &#123;<br>                Base = baseLength;<br>                Height = height;<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * Base * Height;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用嵌套命名空间时，可以这样访问：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Geometry.Shapes;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Triangle triangle = <span class="hljs-keyword">new</span> Triangle(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Triangle Area: <span class="hljs-subst">&#123;triangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-在同一文件中定义命名空间"><a href="#4-在同一文件中定义命名空间" class="headerlink" title="4. 在同一文件中定义命名空间"></a>4. 在同一文件中定义命名空间</h3><p>在一个文件中定义多个类，并将它们放在同一个命名空间下。<br><strong>文件名：<code>Geometry.cs</code></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span> <span class="hljs-comment">// 命名空间</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>        &#123;<br>            Radius = radius;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>        &#123;<br>            Width = width;<br>            Height = height;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Width * Height;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> Geometry; <span class="hljs-comment">// 引入 Geometry 命名空间</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>);<br><br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-将命名空间分散到多个文件中"><a href="#5-将命名空间分散到多个文件中" class="headerlink" title="5. 将命名空间分散到多个文件中"></a>5. 将命名空间分散到多个文件中</h3><p>可以在多个文件中定义属于同一个命名空间的类。这样做有助于代码的模块化和可维护性。<br><strong>文件名：<code>Circle.cs</code></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span> <span class="hljs-comment">// 命名空间</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>        &#123;<br>            Radius = radius;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>文件名：<code>Rectangle.cs</code></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Geometry</span> <span class="hljs-comment">// 命名空间</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>        &#123;<br>            Width = width;<br>            Height = height;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Width * Height;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> Geometry; <span class="hljs-comment">// 引入 Geometry 命名空间</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>);<br><br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>命名空间</strong> 是组织代码的有力工具，帮助管理和避免名称冲突。</li><li>可以使用 <code>namespace</code> 关键字定义命名空间，并通过 <code>using</code> 指令引入命名空间。</li><li>支持嵌套命名空间，允许创建更复杂的结构以组织相关类。</li><li><strong>同一文件定义</strong>：在一个文件中定义多个类，适合小型项目或紧密相关的类。</li><li><strong>分散到多个文件</strong>：将类分散到多个文件中，每个文件定义一个类，适合较大项目，能够提高可维护性和可读性。</li></ul><h1 id="二、-Object中的方法"><a href="#二、-Object中的方法" class="headerlink" title="二、 Object中的方法"></a>二、 Object中的方法</h1><p><a href="https://imgse.com/i/pA0EdxK"><img src="https://s21.ax1x.com/2024/10/26/pA0EdxK.png" alt="pA0EdxK.png"></a><br>在 C# 中，<code>Object</code> 是所有类型的基类。每个类、结构、接口等都隐式地继承自 <code>Object</code>，因此它包含了一些通用的方法，这些方法可以在任何对象上调用。以下是 <code>Object</code> 类中的一些重要方法：</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="1-ToString"><a href="#1-ToString" class="headerlink" title="1 ToString()"></a>1 <code>ToString()</code></h4><ul><li><strong>描述</strong>: 返回对象的字符串表示形式。</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;Name&#125;</span>&quot;</span>;<br>    &#125;<br>&#125;<br><br>Person person = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>Console.WriteLine(person.ToString()); <span class="hljs-comment">// 输出: Name: Alice</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-Equals-Object-obj"><a href="#2-Equals-Object-obj" class="headerlink" title="2 Equals(Object obj)"></a>2 <code>Equals(Object obj)</code></h4><ul><li><strong>描述</strong>: 确定两个对象是否相等。默认实现比较对象的引用（即内存地址），可以在子类中重写该方法来比较对象的内容。</li><li>还有一个是静态实现的</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">//public override bool Equals(object? obj)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    if (obj is Person other)</span><br>    <span class="hljs-comment">//    &#123;</span><br>    <span class="hljs-comment">//        return Name == other.Name; // 比较名称</span><br>    <span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-comment">//    return false;</span><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person p1 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        Person p2 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        Console.WriteLine(p1.Equals(p2)); <span class="hljs-comment">// 输出: True</span><br>        <span class="hljs-comment">// 看了源码，这里如果传入的对象，Person重写了Equals方法</span><br>        <span class="hljs-comment">// 先判断两个对象的地址是否相同，相同返回True</span><br>        <span class="hljs-comment">// 上面已经判断了，两个不可能都为努力了，如果有一个为null，返回True</span><br>        <span class="hljs-comment">// 最后再调用Person重写的Equals方法</span><br>        <span class="hljs-comment">// 如果没有重写，默认判断两者引用是否相同，this == p2</span><br>        Console.WriteLine(Object.Equals(p1, p2)); <span class="hljs-comment">// 输出: True</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-GetHashCode"><a href="#3-GetHashCode" class="headerlink" title="3 GetHashCode()"></a>3 <code>GetHashCode()</code></h4><ul><li><strong>描述</strong>: 返回对象的哈希代码。通常与 <code>Equals()</code> 一起重写，以确保相等的对象具有相同的哈希值。</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? obj</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Person other)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Name == other.Name; <span class="hljs-comment">// 比较名称</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Name.GetHashCode(); <span class="hljs-comment">// 根据名称生成哈希代码</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person p1 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        Person p2 = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        Console.WriteLine(p1.Equals(p2)); <span class="hljs-comment">// 输出: True</span><br>        Console.WriteLine(Object.Equals(p1, p2));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-GetType"><a href="#4-GetType" class="headerlink" title="4 GetType()"></a>4 <code>GetType()</code></h4><ul><li><strong>描述</strong>: 获取当前实例的 <code>Type</code> 对象，该对象表示当前实例的类型。</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> PersonSpace;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">PersonSpace</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? obj</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Person other)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Name == other.Name; <span class="hljs-comment">// 比较名称</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> Name.GetHashCode(); <span class="hljs-comment">// 根据名称生成哈希代码</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        Type type = person.GetType();<br>        Console.WriteLine(type);<span class="hljs-comment">// 输出: Namespace.Person，如果没有命名空间输出Person</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-Finalize"><a href="#5-Finalize" class="headerlink" title="5 Finalize()"></a>5 <code>Finalize()</code></h4><ul><li><strong>描述</strong>: 释放对象所占用的资源。在垃圾回收过程中被调用，通常不需要手动调用。可以重写来定义释放非托管资源的逻辑。</li><li><strong>示例</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    ~Person()<br>    &#123;<br>        <span class="hljs-comment">// 清理代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="6-public-static-bool-ReferenceEquals-object-objA-object-objB"><a href="#6-public-static-bool-ReferenceEquals-object-objA-object-objB" class="headerlink" title="6 public static bool ReferenceEquals(object objA, object objB);"></a>6 <code>public static bool ReferenceEquals(object objA, object objB);</code></h4><ul><li><strong>描述</strong>: <code>Object.ReferenceEquals()</code> 是 C# 中的一个静态方法，用于比较两个对象的引用是否相同。它直接检查两个对象的内存地址，以确定它们是否指向同一个实例。这个方法与 <code>Equals</code> 方法不同， <code>Equals</code>通常用于检查对象内容是否相等（如果没有重写的话，默认还是比较引用是否相同），而 <code>ReferenceEquals</code> 专注于引用的比较。</li><li>值类型对象返回值始终是false</li></ul><h3 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ReferenceEquals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> objA, <span class="hljs-built_in">object</span> objB</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><code>objA</code>：第一个要比较的对象。</li><li><code>objB</code>：第二个要比较的对象。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回 <code>true</code> 如果 <code>objA</code> 和 <code>objB</code> 是同一个引用（即它们指向同一个对象），否则返回 <code>false</code>。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，展示了如何使用 <code>Object.ReferenceEquals</code> 方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建两个不同的对象</span><br>        <span class="hljs-built_in">object</span> obj1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>        <span class="hljs-built_in">object</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>        <span class="hljs-comment">// 创建一个指向同一对象的引用</span><br>        <span class="hljs-built_in">object</span> obj3 = obj1;<br><br>        <span class="hljs-comment">// 比较对象引用</span><br>        Console.WriteLine(Object.ReferenceEquals(obj1, obj2)); <span class="hljs-comment">// 输出: False</span><br>        Console.WriteLine(Object.ReferenceEquals(obj1, obj3)); <span class="hljs-comment">// 输出: True</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ul><li><strong>比较两个不同的对象</strong>: 在上面的示例中，<code>obj1</code> 和 <code>obj2</code> 是两个不同的对象，因此 <code>Object.ReferenceEquals(obj1, obj2)</code> 返回 <code>false</code>。</li><li><strong>比较相同的对象引用</strong>: <code>obj3</code> 是对 <code>obj1</code> 的引用，因此 <code>Object.ReferenceEquals(obj1, obj3)</code> 返回 <code>true</code>。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><code>Object.ReferenceEquals</code> 通常用于需要明确区分对象的引用时，例如在性能敏感的代码中。</li><li>它可以用于确定对象是否为 <code>null</code>，因为比较 <code>null</code> 和非 <code>null</code> 对象时，<code>ReferenceEquals</code> 会返回 <code>false</code>。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>Object.ReferenceEquals</code> 不会触发任何重写的 <code>Equals</code> 方法，所以它的比较仅仅基于对象的引用，而不涉及内容的比较。</li><li>在比较值类型时，由于值类型通常在栈上分配，它们的比较通常是基于值而不是引用。因此，使用 <code>ReferenceEquals</code> 在比较值类型的实例时，效果有限。</li></ul><h1 id="三、-System-ValueType"><a href="#三、-System-ValueType" class="headerlink" title="三、 System.ValueType"></a>三、 System.ValueType</h1><p>在 C# 中，<code>System.ValueType</code> 是所有值类型的基类。所有的结构体（<code>struct</code>）和枚举（<code>enum</code>）都隐式地继承自 <code>ValueType</code>。理解 <code>ValueType</code> 的作用有助于更好地理解 C# 中的值类型及其行为。</p><h3 id="1-值类型与引用类型"><a href="#1-值类型与引用类型" class="headerlink" title="1. 值类型与引用类型"></a>1. 值类型与引用类型</h3><ul><li><strong>值类型</strong>：包含数据本身，存储在栈上（或内联分配在堆上）。例如，基本类型如 <code>int</code>、<code>double</code>、<code>char</code>，以及用户定义的结构体和枚举都是值类型。</li><li><strong>引用类型</strong>：包含指向数据的引用，存储在堆上。例如，类（<code>class</code>）、数组（<code>array</code>）和字符串（<code>string</code>）都是引用类型。</li></ul><h4 id="内联分配在堆上"><a href="#内联分配在堆上" class="headerlink" title="内联分配在堆上"></a>内联分配在堆上</h4><p>在 C# 中，值类型通常分配在栈上，但在某些情况下，它们也可以内联分配在堆上。这里是一些详细的解释：</p><h5 id="1-值类型的基本特性"><a href="#1-值类型的基本特性" class="headerlink" title="1. 值类型的基本特性"></a>1. 值类型的基本特性</h5><ul><li><strong>栈分配</strong>：值类型通常直接存储在栈上。当一个值类型变量被声明时，它的值会被直接分配到栈内存中。例如：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// x 存储在栈上</span><br></code></pre></td></tr></table></figure></li><li><strong>堆分配</strong>：虽然值类型通常在栈上分配，但在某些情况下，它们会被分配到堆上。这种情况主要发生在以下场景中：</li><li><strong>作为引用类型的字段</strong>：当值类型作为类的字段时，该值类型的实例会存储在堆上，因为类是引用类型。例如： <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyValue; <span class="hljs-comment">// MyValue 是值类型，但它存储在堆上</span><br>&#125;<br><br>MyClass obj = <span class="hljs-keyword">new</span> MyClass(); <span class="hljs-comment">// obj 的地址在堆上</span><br>obj.MyValue = <span class="hljs-number">10</span>; <span class="hljs-comment">// MyValue 存储在 obj 所在的堆内存中</span><br></code></pre></td></tr></table></figure></li><li><strong>内联分配</strong>：在某些情况下，值类型可以被 “内联分配” 在堆上，这意味着它们的值会被直接嵌入到包含它们的对象中。这种情况通常发生在使用 <strong>结构体</strong> 作为类字段时。例如：    <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> MyStruct<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span><br>&#123;<br>    <span class="hljs-keyword">public</span> MyStruct myStruct; <span class="hljs-comment">// myStruct 是值类型，但内联存储在堆上</span><br>&#125;<br><br>Container container = <span class="hljs-keyword">new</span> Container(); <span class="hljs-comment">// container 存储在堆上</span><br>container.myStruct.Value = <span class="hljs-number">42</span>; <span class="hljs-comment">// myStruct 的数据存储在 container 的堆内存中</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-值类型在堆中的存储"><a href="#2-值类型在堆中的存储" class="headerlink" title="2. 值类型在堆中的存储"></a>2. 值类型在堆中的存储</h5><ul><li>当值类型作为类的字段或属性时，它们的实例实际上会存储在堆上。这个特性使得值类型可以在类的生命周期内存在，并且可以通过引用访问。例如，当你创建一个类实例并使用该类的字段时，字段值会在堆上分配。</li><li>在内联分配的情况下，值类型的内存布局会与引用类型相结合，以提高性能。这种内联分配允许在一个对象中组合多个值类型和引用类型，避免了不必要的内存分配。</li></ul><h5 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h5><ul><li><strong>栈分配</strong>：值类型通常直接在栈上分配。</li><li><strong>堆分配</strong>：当值类型作为类字段时，它们的值在堆上分配。</li><li><strong>内联分配</strong>：值类型可以内联到对象中，优化内存使用和性能。</li></ul><h3 id="2-ValueType-的主要特性"><a href="#2-ValueType-的主要特性" class="headerlink" title="2. ValueType 的主要特性"></a>2. <code>ValueType</code> 的主要特性</h3><ul><li><strong>封装</strong>：<code>ValueType</code> 提供了一些基本的行为实现，例如 <code>Equals()</code>、<code>GetHashCode()</code> 和 <code>ToString()</code> 方法。这些方法可以在值类型的实例上被调用。</li><li><strong>值语义</strong>：当值类型被赋值给另一个变量或作为参数传递时，整个对象的值被复制。这与引用类型不同，后者只复制引用。</li><li><strong>装箱和拆箱</strong>：值类型可以被装箱（将其转换为 <code>object</code> 类型）和拆箱（将其从 <code>object</code> 转换回值类型），这会引入额外的性能开销。</li></ul><h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><p>以下是一个简单的示例，演示了如何使用值类型和 <code>ValueType</code> 的一些特性：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">struct</span> MyStruct : IComparable<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStruct</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        Value = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CompareTo</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> MyStruct other)<br>        &#123;<br>            <span class="hljs-keyword">return</span> Value.CompareTo(other.Value);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;Object is not a MyStruct&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Value.ToString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyStruct struct1 = <span class="hljs-keyword">new</span> MyStruct(<span class="hljs-number">10</span>);<br>        MyStruct struct2 = <span class="hljs-keyword">new</span> MyStruct(<span class="hljs-number">20</span>);<br><br>        Console.WriteLine(struct1.ToString()); <span class="hljs-comment">// 输出: 10</span><br>        Console.WriteLine(struct2.ToString()); <span class="hljs-comment">// 输出: 20</span><br><br>        Console.WriteLine(struct1.Equals(struct2)); <span class="hljs-comment">// 输出: False</span><br><br>        <span class="hljs-comment">// 装箱</span><br>        <span class="hljs-built_in">object</span> boxed = struct1;<br>        <span class="hljs-comment">// 拆箱</span><br>        MyStruct unboxed = (MyStruct)boxed;<br><br>        Console.WriteLine(unboxed.ToString()); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-重要方法"><a href="#4-重要方法" class="headerlink" title="4. 重要方法"></a>4. 重要方法</h3><p><code>ValueType</code> 提供了几个重要的方法，通常被重写以支持特定的值类型：</p><ul><li><code>Equals(object obj)</code>：判断当前实例与给定对象是否相等。默认实现比较引用，通常应被重写以比较值。</li><li><code>GetHashCode()</code>：返回当前对象的哈希代码，通常应根据对象的字段重写。</li><li><code>ToString()</code>：返回当前对象的字符串表示形式，通常应被重写以提供有意义的输出。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>System.ValueType</code> 是 C# 中所有值类型的基类，提供了一些基础方法和值语义的支持。理解值类型的行为及其与引用类型的区别，对于有效地编写 C# 代码至关重要。通过实现自定义结构体和重写 <code>ValueType</code> 中的方法，可以创建更丰富的值类型功能。</p><h1 id="四、-string相关方法和操作"><a href="#四、-string相关方法和操作" class="headerlink" title="四、 string相关方法和操作"></a>四、 string相关方法和操作</h1><p>在 C# 中，<code>string</code> 是一个常用的引用类型，表示不可变的文本序列。以下是一些常用的 <code>string</code> 相关方法和操作：</p><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h3><ul><li><strong>创建字符串</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str1 = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 创建 &quot;aaaaa&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>字符串拼接</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str3 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">string</span> str4 = <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-built_in">string</span> result = str3 + <span class="hljs-string">&quot;, &quot;</span> + str4 + <span class="hljs-string">&quot;!&quot;</span>; <span class="hljs-comment">// &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>字符串格式化</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> age = <span class="hljs-number">25</span>;<br><span class="hljs-built_in">string</span> formattedString = <span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;I am &#123;0&#125; years old.&quot;</span>, age); <span class="hljs-comment">// &quot;I am 25 years old.&quot;</span><br><span class="hljs-built_in">string</span> interpolatedString = <span class="hljs-string">$&quot;I am <span class="hljs-subst">&#123;age&#125;</span> years old.&quot;</span>; <span class="hljs-comment">// 使用字符串插值</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2. 常用方法"></a>2. 常用方法</h3><ul><li><code>Length</code>：获取字符串的长度。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">int</span> length = str.Length; <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure></li><li><code>ToUpper()</code> &#x2F; <code>ToLower()</code>：将字符串转换为大写或小写。</li><li>不会改变原字符串<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> upper = str.ToUpper(); <span class="hljs-comment">// &quot;HELLO&quot;</span><br><span class="hljs-built_in">string</span> lower = str.ToLower(); <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure></li><li><code>Trim()</code> &#x2F; <code>TrimStart()</code> &#x2F; <code>TrimEnd()</code>：去除字符串开头或结尾的空白字符。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> strWithSpaces = <span class="hljs-string">&quot;  Hello  &quot;</span>;<br><span class="hljs-built_in">string</span> trimmed = strWithSpaces.Trim(); <span class="hljs-comment">// &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li><li><code>Substring(int startIndex)</code>：从指定位置开始截取后续字符串的全部。</li><li><code>Substring(int startIndex, int length)</code>：从指定位置开始截取字符串的一部分。<ul><li>Substring有第二个参数的时候会要求<code>startIndex+length</code>小于等于str长度，否则报错<code>System.ArgumentOutOfRangeException</code></li></ul></li><li>不会改变原字符串<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> subAll = str.Substring(<span class="hljs-number">1</span>); <span class="hljs-comment">// &quot;ello&quot;</span><br><span class="hljs-built_in">string</span> sub = str.Substring(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// &quot;ell&quot;</span><br></code></pre></td></tr></table></figure></li><li><code>Contains(string value)</code>：检查字符串是否包含指定的子字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> contains = str.Contains(<span class="hljs-string">&quot;ell&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><code>StartsWith(string value)</code> &#x2F; <code>EndsWith(string value)</code>：检查字符串是否以指定的子字符串开头或结尾。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> startsWith = str.StartsWith(<span class="hljs-string">&quot;He&quot;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">bool</span> endsWith = str.EndsWith(<span class="hljs-string">&quot;lo&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><code>IndexOf(string value)</code> &#x2F; <code>LastIndexOf(string value)</code>：返回指定子字符串的第一个或最后一个出现的位置。</li><li>字符可以是中文</li><li>没找到返回-1<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> index = str.IndexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">int</span> lastIndex = str.LastIndexOf(<span class="hljs-string">&quot;l&quot;</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li><li><code>Replace(string oldValue, string newValue)</code>：替换字符串中的<code>所有</code>匹配子字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> replaced = str.Replace(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>); <span class="hljs-comment">// &quot;Hexxo&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-字符串分割与连接"><a href="#3-字符串分割与连接" class="headerlink" title="3. 字符串分割与连接"></a>3. 字符串分割与连接</h3><ul><li><code>Split(char[] separator)</code>：根据指定字符分隔符分割字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span>[] words = sentence.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span> &#125;); <span class="hljs-comment">// &#123;&quot;Hello&quot;, &quot;&quot;, &quot;World!&quot;&#125;</span><br></code></pre></td></tr></table></figure></li><li><code>Join(string separator, string[] values)</code>：连接字符串数组中的元素。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>[] array = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br><span class="hljs-built_in">string</span> joined = <span class="hljs-built_in">string</span>.Join(<span class="hljs-string">&quot;, &quot;</span>, array); <span class="hljs-comment">// &quot;Hello, World&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-字符串比较"><a href="#4-字符串比较" class="headerlink" title="4. 字符串比较"></a>4. 字符串比较</h3><ul><li><code>Equals(string value)</code>：比较字符串是否相等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> isEqual = str.Equals(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><code>Compare(string strA, string strB)</code>：比较两个字符串的大小。</li><li>每个字符的比较是基于其 <code>Unicode 编码值</code>的大小。</li><li>A小于B，a小于b</li><li>A小于a<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> comparisonResult = <span class="hljs-built_in">string</span>.Compare(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;xyz&quot;</span>); <span class="hljs-comment">// 返回负数，表示 &quot;abc&quot; 小于 &quot;xyz&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5-其他操作"><a href="#5-其他操作" class="headerlink" title="5. 其他操作"></a>5. 其他操作</h3><ul><li><code>IsNullOrEmpty(string value)</code>：检查字符串是否为 <code>null</code> 或空字符串。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> isNullOrEmpty = <span class="hljs-built_in">string</span>.IsNullOrEmpty(str); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><code>IsNullOrWhiteSpace(string value)</code>：检查字符串是否为 <code>null</code>、空字符串或仅包含空白字符。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> isNullOrWhiteSpace = <span class="hljs-built_in">string</span>.IsNullOrWhiteSpace(<span class="hljs-string">&quot;   &quot;</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6-不可变性和性能"><a href="#6-不可变性和性能" class="headerlink" title="6. 不可变性和性能"></a>6. 不可变性和性能</h3><p>由于字符串是不可变的，每次执行类似于 <code>Replace</code>、<code>ToUpper</code> 等操作时，都会创建一个新的字符串对象。这会带来一些性能开销，因此如果需要大量字符串操作，建议使用 <code>StringBuilder</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Text;<br><br>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>sb.Append(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.Append(<span class="hljs-string">&quot;, &quot;</span>);<br>sb.Append(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-built_in">string</span> finalString = sb.ToString(); <span class="hljs-comment">// &quot;Hello, World&quot;</span><br></code></pre></td></tr></table></figure><p>这些方法和操作涵盖了 C# 中 <code>string</code> 类型的常用功能，有助于处理各种字符串操作需求。</p><h3 id="7-移除指定位置后的字符"><a href="#7-移除指定位置后的字符" class="headerlink" title="7. 移除指定位置后的字符"></a>7. 移除指定位置后的字符</h3><p>在 C# 中，<code>string.Remove</code> 方法用于删除字符串中的某一部分。这个方法会返回一个新的字符串，因为字符串在 C# 中是不可变的（即操作后原字符串不会被改变）。</p><h4 id="方法签名-1"><a href="#方法签名-1" class="headerlink" title="方法签名"></a>方法签名</h4><p><code>string.Remove</code> 有两个重载版本：</p><ol><li><code>Remove(int startIndex)</code>：删除从指定索引处开始的所有字符。</li><li><code>Remove(int startIndex, int count)</code>：删除从指定索引处开始的指定数量的字符。</li></ol><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>startIndex</code>：要开始删除的字符的零基索引位置。</li><li><code>count</code>（可选）：要删除的字符数。不填，则后续的所有字符都删除</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol><li><strong>删除从指定索引开始的所有字符</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> result = str.Remove(<span class="hljs-number">5</span>); <span class="hljs-comment">// 从索引 5 开始删除，即删除 &quot;, World!&quot;</span><br><br>Console.WriteLine(result); <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>删除从指定索引开始的指定数量的字符</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> result = str.Remove(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 从索引 7 开始删除 5 个字符，即删除 &quot;World&quot;</span><br><br>Console.WriteLine(result); <span class="hljs-comment">// 输出 &quot;Hello, !&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>如果 <code>startIndex</code> 超出字符串的范围，会抛出 <code>ArgumentOutOfRangeException</code>。</li><li>如果 <code>count</code> 的值导致删除的范围超出字符串的长度，也会抛出 <code>ArgumentOutOfRangeException</code>。</li><li><code>Remove</code> 方法不会修改原始字符串，而是返回一个新的字符串。</li></ul><h3 id="8-字符串分割"><a href="#8-字符串分割" class="headerlink" title="8. 字符串分割"></a>8. 字符串分割</h3><p>在 C# 中，<code>string.Split</code> 方法用于将字符串拆分为子字符串数组，基于一个或多个分隔符。分割后的子字符串不包含分隔符。</p><h4 id="方法签名-2"><a href="#方法签名-2" class="headerlink" title="方法签名"></a>方法签名</h4><p><code>string.Split</code> 有多种重载，常用的有以下几种：</p><ol><li><code>Split(char[] separator)</code> ：使用一个或多个字符作为分隔符进行分割。</li><li><code>Split(char[] separator, int count)</code> ：使用分隔符进行分割，并限定返回的子字符串的数量。</li><li><code>Split(char[] separator, StringSplitOptions options)</code> ：使用分隔符进行分割，并通过 <code>StringSplitOptions</code> 控制是否移除空字符串。</li><li><code>Split(string[] separator, StringSplitOptions options)</code>：使用字符串数组作为分隔符。</li></ol><h4 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><code>separator</code>：用于分割的字符数组或字符串数组。如果传入 <code>null</code> 或空数组，则使用空白字符（如空格、制表符）作为默认分隔符。</li><li><code>count</code>：限定返回的子字符串数量。</li><li><code>options</code>：<code>StringSplitOptions</code> 枚举，用于控制是否移除空字符串。可以为 <code>StringSplitOptions.None</code>（不移除空字符串）或 <code>StringSplitOptions.RemoveEmptyEntries</code>（移除空字符串）。</li><li>‘,’也是一个<code>char[]</code>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br><br><span class="hljs-comment">// 使用字符数组作为分隔符</span><br><span class="hljs-built_in">string</span>[] fruits1 = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27;,&#x27;</span> &#125;);<br><br><span class="hljs-comment">// 使用单个字符作为分隔符，自动转换为字符数组</span><br><span class="hljs-built_in">string</span>[] fruits2 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>);<br><br><span class="hljs-comment">// 两种方式的结果是相同的</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits1)<br>&#123;<br>    Console.WriteLine(fruit); <span class="hljs-comment">// 输出: apple, banana, orange</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><ol><li><strong>使用单个字符分隔符</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>); <span class="hljs-comment">// 使用逗号分隔</span><br><br><span class="hljs-comment">// 输出: apple, banana, orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>使用多个字符作为分隔符</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple;banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;;&#x27;</span> &#125;); <span class="hljs-comment">// 使用逗号和分号分隔</span><br><br><span class="hljs-comment">// 输出: </span><br><span class="hljs-comment">// apple</span><br><span class="hljs-comment">// banana</span><br><span class="hljs-comment">// orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>限定返回的子字符串数量</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27;,&#x27;</span> &#125;, <span class="hljs-number">2</span>); <span class="hljs-comment">// 只分割成两个子字符串</span><br><br><span class="hljs-comment">// 输出: apple, banana,orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>移除空字符串</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple,,banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27;,&#x27;</span> &#125;, StringSplitOptions.RemoveEmptyEntries); <span class="hljs-comment">// 移除空字符串</span><br><br><span class="hljs-comment">// 输出: apple, banana, orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>使用字符串作为分隔符</strong><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;apple#banana#orange&quot;</span>;<br><span class="hljs-comment">// string[] fruits = str.Split(new char[] &#123; &#x27;#&#x27; &#125;, StringSplitOptions.None); // 使用 &#x27;#&#x27; 作为分隔符一样的</span><br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;#b&quot;</span> &#125;, StringSplitOptions.None); <span class="hljs-comment">// 使用 &quot;#&quot; 作为分隔符，&quot;&quot;里面可以更长，比如&quot;#b&quot;</span><br><br><span class="hljs-comment">// 输出: apple anana#orange</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>    Console.WriteLine(fruit);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>Split</code> 返回的数组中可能包含空字符串，特别是在分隔符连续出现时。</li><li>如果需要移除结果中的空字符串，可以使用 <code>StringSplitOptions.RemoveEmptyEntries</code>。<br>  在 C# 中，<code>StringSplitOptions</code> 枚举用于控制 <code>string.Split</code> 方法的行为，它有三个可选值，分别是 <code>None</code>、<code>RemoveEmptyEntries</code> 和 <code>TrimEntries</code>，每个选项的作用如下：<h5 id="1-None"><a href="#1-None" class="headerlink" title="1. None"></a>1. <code>None</code></h5><ul><li>默认选项，值为 <code>0</code>。</li><li>当使用此选项时，<code>Split</code> 方法不会忽略空字符串，也不会去除空白字符。</li><li>返回的数组中会包含原字符串中所有的子字符串，即使其中有空字符串。</li></ul><h5 id="2-RemoveEmptyEntries"><a href="#2-RemoveEmptyEntries" class="headerlink" title="2. RemoveEmptyEntries"></a>2. <code>RemoveEmptyEntries</code></h5><ul><li>值为 <code>1</code>。</li><li>如果选择此选项，<code>Split</code> 方法会从返回的数组中移除任何空字符串。</li><li>空字符串通常出现在分隔符连续出现的情况下。</li><li>如果与 <code>TrimEntries</code> 结合使用，则仅包含空白字符的子字符串也会被移除。</li></ul><h5 id="3-TrimEntries-仅在-NET-5-及更高版本可用"><a href="#3-TrimEntries-仅在-NET-5-及更高版本可用" class="headerlink" title="3. TrimEntries (仅在 .NET 5 及更高版本可用)"></a>3. <code>TrimEntries</code> (仅在 .NET 5 及更高版本可用)</h5><ul><li>值为 <code>2</code>。</li><li>当使用此选项时，<code>Split</code> 方法会去除每个子字符串前后的空白字符。</li><li>如果与 <code>RemoveEmptyEntries</code> 结合使用，那么只包含空白字符的子字符串也会被移除。</li><li>组合使用<br>  <code>StringSplitOptions</code> 是一个带有 <code>[Flags]</code> 特性的枚举，可以组合多个选项一起使用。例如，使用 <code>RemoveEmptyEntries | TrimEntries</code> 可以同时移除空字符串并修剪子字符串中的空白字符。</li><li>示例  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot; apple , banana , , orange ,  &quot;</span>;<br><br><span class="hljs-comment">// 使用 StringSplitOptions.None，默认行为</span><br><span class="hljs-built_in">string</span>[] result1 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>, StringSplitOptions.None);<br><span class="hljs-comment">// 输出: &quot; apple &quot;, &quot; banana &quot;, &quot; &quot;, &quot; orange &quot;, &quot;  &quot;</span><br><br><span class="hljs-comment">// 使用 StringSplitOptions.RemoveEmptyEntries，移除空字符串</span><br><span class="hljs-built_in">string</span>[] result2 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>, StringSplitOptions.RemoveEmptyEntries);<br><span class="hljs-comment">// 输出: &quot; apple &quot;, &quot; banana &quot;, &quot; orange &quot;, &quot;  &quot;</span><br><br><span class="hljs-comment">// 使用 StringSplitOptions.TrimEntries，去除每个子字符串的空白</span><br><span class="hljs-built_in">string</span>[] result3 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>, StringSplitOptions.TrimEntries);<br><span class="hljs-comment">// 输出: &quot;apple&quot;, &quot;banana&quot;, &quot;&quot;, &quot;orange&quot;, &quot;&quot;</span><br><br><span class="hljs-comment">// 使用 StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries，组合行为</span><br><span class="hljs-built_in">string</span>[] result4 = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);<br><span class="hljs-comment">// 输出: &quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="五、-ArrayList"><a href="#五、-ArrayList" class="headerlink" title="五、 ArrayList"></a>五、 ArrayList</h1><p><code>ArrayList</code> 是 C# 中的一个非泛型集合类，位于 <code>System.Collections</code> 命名空间中。它可以存储任何类型的对象，并且大小是动态调整的。尽管 <code>ArrayList</code> 具有灵活性和动态性，但因为它是非泛型的，通常在现代开发中会推荐使用泛型集合（如 <code>List&lt;T&gt;</code>）以获得更好的类型安全和性能。</p><h3 id="1-ArrayList-的特点"><a href="#1-ArrayList-的特点" class="headerlink" title="1. ArrayList 的特点"></a>1. <strong>ArrayList 的特点</strong></h3><ul><li><strong>非泛型集合</strong>：<code>ArrayList</code> 可以存储不同类型的对象（<code>object</code> 类型），但这会导致类型不安全和装箱&#x2F;拆箱的开销。</li><li><strong>动态大小</strong>：不像数组那样大小固定，<code>ArrayList</code> 的大小可以根据需要自动增加。</li><li><strong>实现了 <code>IList</code>、<code>ICollection</code> 和 <code>IEnumerable</code> 接口</strong>：因此，它可以与这些接口一起使用。</li></ul><h3 id="2-常用方法和属性"><a href="#2-常用方法和属性" class="headerlink" title="2. 常用方法和属性"></a>2. <strong>常用方法和属性</strong></h3><ul><li><code>Add(object value)</code>：将对象添加到 <code>ArrayList</code> 的末尾。</li><li><code>AddRange(ICollection c)</code> 是 <code>ArrayList</code> 类中的一个方法，用于将一个集合中的元素添加到 <code>ArrayList</code> 的末尾。与 <code>Add</code> 方法不同的是，<code>AddRange</code> 可以一次性添加多个元素，而不是一个一个地添加。<ul><li><strong>支持不同的集合类型</strong>：只要实现了 <code>ICollection</code> 接口的集合，都可以使用 <code>AddRange</code> 方法添加。</li></ul></li><li><code>Insert(int index, object value)</code>：在指定索引位置插入一个元素。</li><li><code>Remove(object value)</code>：移除 <code>ArrayList</code> 中第一次出现的指定对象。</li><li><code>RemoveAt(int index)</code>：移除指定索引处的元素。</li><li><code>Clear()</code>：移除所有元素。</li><li><code>Contains(object value)</code>：确定某个对象是否在 <code>ArrayList</code> 中。</li><li><code>IndexOf(object value)</code>：返回指定对象在 <code>ArrayList</code> 中的第一个匹配项的索引。正向查找元素位置，找不到返回-1</li><li><code>LastIndexOf(object value)</code> 是 <code>ArrayList</code> 类中的一个方法，用于查找指定元素在 <code>ArrayList</code> 中最后一次出现的索引位置。这个方法从 <code>ArrayList</code> 的末尾向前搜索，返回匹配的元素的索引。<ul><li><code>LastIndexOf(object value, int startIndex)</code>：从指定的索引位置向前搜索。</li><li><code>LastIndexOf(object value, int startIndex, int count)</code>：从指定的索引位置开始，向前搜索指定数量的元素。</li></ul></li><li><code>Count</code>：获取 <code>ArrayList</code> 中的元素数量。</li><li><code>Capacity</code>：获取或设置 <code>ArrayList</code> 能够包含的元素数量。</li><li><code>Sort()</code>：对 <code>ArrayList</code> 中的元素进行排序。</li><li><code>Reverse()</code>：反转 <code>ArrayList</code> 中元素的顺序。</li></ul><h3 id="3-ArrayList-的使用示例"><a href="#3-ArrayList-的使用示例" class="headerlink" title="3. ArrayList 的使用示例"></a>3. <strong>ArrayList 的使用示例</strong></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的 ArrayList</span><br>        ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        list.Add(<span class="hljs-number">1</span>);<br>        list.Add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        list.Add(<span class="hljs-number">3.14</span>);<br>        list.Add(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 插入元素</span><br>        list.Insert(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Inserted Element&quot;</span>);<br><br>        <span class="hljs-comment">// 遍历 ArrayList</span><br>        Console.WriteLine(<span class="hljs-string">&quot;ArrayList elements:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> list)<br>        &#123;<br>            Console.WriteLine(item);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否包含某个元素</span><br>        <span class="hljs-built_in">bool</span> containsHello = list.Contains(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;\nContains &#x27;Hello&#x27;: <span class="hljs-subst">&#123;containsHello&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 获取索引</span><br>        <span class="hljs-built_in">int</span> index = list.IndexOf(<span class="hljs-number">3.14</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Index of 3.14: <span class="hljs-subst">&#123;index&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 移除元素</span><br>        list.Remove(<span class="hljs-literal">true</span>);<br>        list.RemoveAt(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 清空 ArrayList</span><br>        list.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;\nArrayList count after clearing: <span class="hljs-subst">&#123;list.Count&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-ArrayList-的缺点"><a href="#4-ArrayList-的缺点" class="headerlink" title="4. ArrayList 的缺点"></a>4. <strong>ArrayList 的缺点</strong></h3><ul><li><strong>类型安全性差</strong>：因为 <code>ArrayList</code> 是非泛型的，它可以存储不同类型的数据，这在运行时可能会导致类型转换异常。</li><li><strong>装箱和拆箱的性能开销</strong>：对于值类型（如 <code>int</code>），在添加到 <code>ArrayList</code> 时需要装箱，将其转换为 <code>object</code> 类型，而在访问时又需要拆箱，带来性能损耗。</li></ul><h3 id="5-替代方案"><a href="#5-替代方案" class="headerlink" title="5. 替代方案"></a>5. <strong>替代方案</strong></h3><p>在 C# 中，如果需要类型安全的集合，建议使用泛型集合类，如 <code>List&lt;T&gt;</code>，它在提供与 <code>ArrayList</code> 类似功能的同时还支持类型检查，并<code>避免装箱/拆箱</code>的性能开销。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; intList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>intList.Add(<span class="hljs-number">1</span>);<br>intList.Add(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><code>List&lt;T&gt;</code> 是 <code>ArrayList</code> 更加推荐的替代方案，因为它支持泛型，提供更好的性能和类型安全性。</p><h1 id="六、-栈"><a href="#六、-栈" class="headerlink" title="六、 栈"></a>六、 栈</h1><p>栈（Stack）是一种后进先出（LIFO，Last In, First Out）的数据结构，这意味着最后添加的元素最先被移除。栈具有以下几个主要特点和操作：</p><h3 id="1-栈的基本概念"><a href="#1-栈的基本概念" class="headerlink" title="1. 栈的基本概念"></a>1. <strong>栈的基本概念</strong></h3><ul><li><strong>后进先出（LIFO）</strong>：栈的特点是“后进先出”，即最后压入栈的元素最先被弹出。</li><li><strong>栈的两个主要操作</strong>：<ul><li><strong>Push()</strong> ：将元素压入栈顶。</li><li><strong>Pop()</strong> ：从栈顶移除并返回元素。</li></ul></li><li><strong>其他常见操作</strong>：<ul><li><strong>Peek()</strong> ：查看栈顶的元素但不移除它。</li><li><strong>Contains&lt;&gt;()或Contains()</strong> ：是否存在某个元素<ul><li><strong>类型安全性</strong>：在编译时检查类型，避免类型转换的错误。例如，如果 <code>List&lt;int&gt;</code> 类型的集合调用 <code>Contains</code> 方法，就只能传入 <code>int</code> 类型的值，否则会出现编译错误。</li><li><strong>性能更高</strong>：泛型集合在检查元素时不需要进行装箱和拆箱操作（适用于值类型），直接比较元素的值，因此性能较高。</li><li><strong>避免类型转换问题</strong>：由于泛型集合存储的是具体类型的元素，所以 <code>Contains</code> 方法可以直接对该类型的值进行比较，而不需要进行类型转换。</li></ul></li><li><strong>Count</strong> ：栈内元素个数</li><li><strong>Clear()</strong> ：清空栈内元素</li></ul></li></ul><h3 id="2-栈的实现"><a href="#2-栈的实现" class="headerlink" title="2. 栈的实现"></a>2. <strong>栈的实现</strong></h3><p>栈可以用数组或链表来实现。数组实现栈时，栈顶的位置随着元素的增加或移除而变化。链表实现栈时，新元素总是插入到链表的头部。</p><h3 id="3-栈在编程中的应用"><a href="#3-栈在编程中的应用" class="headerlink" title="3. 栈在编程中的应用"></a>3. <strong>栈在编程中的应用</strong></h3><ul><li><strong>函数调用栈</strong>：程序执行时，每个函数调用都会把当前执行状态（如局部变量、返回地址）压入调用栈，函数返回时，从栈顶弹出恢复状态。</li><li><strong>表达式求值和语法分析</strong>：在编译器中，栈用于解析表达式的操作顺序和括号匹配。</li><li><strong>撤销操作</strong>：应用程序（如文本编辑器）中常用栈来记录操作历史，以便进行撤销（Undo）操作。</li></ul><h3 id="4-C-中的栈"><a href="#4-C-中的栈" class="headerlink" title="4. C# 中的栈"></a>4. <strong>C# 中的栈</strong></h3><p>在 C# 中，可以使用 <code>System.Collections.Generic</code> 命名空间中的 <code>Stack&lt;T&gt;</code> 泛型类来实现栈操作。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">//************************************</span><br>        <span class="hljs-comment">// 非泛型 using System.Collections;其他操作和泛型一致</span><br>        Stack stackObj = <span class="hljs-keyword">new</span> Stack();<br><br><br>        <span class="hljs-comment">// using System.Collections.Generic;</span><br>        Stack&lt;<span class="hljs-built_in">int</span>&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// Push操作：将元素压入栈</span><br>        stack.Push(<span class="hljs-number">1</span>);<br>        stack.Push(<span class="hljs-number">2</span>);<br>        stack.Push(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 遍历一</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> item <span class="hljs-keyword">in</span> stack)<br>        &#123;<br>            Console.WriteLine(item);<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历二</span><br>        <span class="hljs-built_in">int</span>[] array = stack.ToArray();<br>        <span class="hljs-comment">// object[] array = stack.ToArray();</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>        &#123;<br>            Console.WriteLine(array[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// Peek操作：查看栈顶元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Top element is: &quot;</span> + stack.Peek());<br><br>        <span class="hljs-comment">// Pop操作：弹出栈顶元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Popped element is: &quot;</span> + stack.Pop());<br><br>        <span class="hljs-comment">// Contains操作：查看元素是否存在</span><br>        <span class="hljs-keyword">if</span> (stack.Contains(<span class="hljs-number">1</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;存在1&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 再次查看栈顶元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Top element after pop is: &quot;</span> + stack.Peek());<br><br>        <span class="hljs-comment">// 检查栈是否为空</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Is stack empty? &quot;</span> + (stack.Count == <span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">// 循环弹栈</span><br>        <span class="hljs-keyword">while</span> (stack.Count &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(stack.Pop());<br>        &#125;<br><br>        <span class="hljs-comment">// 清空栈</span><br>        stack.Clear();<br>        <span class="hljs-comment">// 查看栈的元素个数</span><br>        Console.WriteLine(stack.Count);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br>Top element <span class="hljs-keyword">is</span>: <span class="hljs-number">3</span><br>Popped element <span class="hljs-keyword">is</span>: <span class="hljs-number">3</span><br>存在<span class="hljs-number">1</span><br>Top element after pop <span class="hljs-keyword">is</span>: <span class="hljs-number">2</span><br>Is stack empty? False<br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="5-栈在内存管理中的应用"><a href="#5-栈在内存管理中的应用" class="headerlink" title="5. 栈在内存管理中的应用"></a>5. <strong>栈在内存管理中的应用</strong></h3><p>在程序运行时，栈内存用于存储函数的局部变量和参数。当函数调用时，局部变量会被压入栈，函数返回时会自动从栈中弹出这些变量。</p><ul><li><strong>栈内存</strong>：栈内存管理快速，但容量有限，适用于生命周期短的对象和变量。</li><li><strong>堆内存</strong>：用于动态分配的内存，适合存储生命周期较长或大小可变的数据。</li></ul><h3 id="6-泛型栈-Stack"><a href="#6-泛型栈-Stack" class="headerlink" title="6. 泛型栈 (Stack&lt;T&gt;)"></a>6. 泛型栈 (<code>Stack&lt;T&gt;</code>)</h3><ul><li><strong>定义</strong>：栈是一种后进先出（LIFO，Last In First Out）的数据结构。最后放入栈中的元素最先被取出。</li><li><strong>常用方法</strong>：和普通栈一样<ul><li><code>Push(T item)</code>：将元素推入栈中。</li><li><code>Pop()</code>：移除并返回栈顶的元素。</li><li><code>Peek()</code>：返回栈顶的元素，但不移除它。</li><li><code>Count</code>：获取栈中元素的数量。</li></ul></li><li><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个泛型栈</span><br>        Stack&lt;<span class="hljs-built_in">int</span>&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// 压入元素</span><br>        stack.Push(<span class="hljs-number">1</span>);<br>        stack.Push(<span class="hljs-number">2</span>);<br>        stack.Push(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 输出栈顶元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;栈顶元素: &quot;</span> + stack.Peek()); <span class="hljs-comment">// 输出 3</span><br><br>        <span class="hljs-comment">// 弹出元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;弹出元素: &quot;</span> + stack.Pop()); <span class="hljs-comment">// 输出 3</span><br><br>        <span class="hljs-comment">// 栈中剩余元素数量</span><br>        Console.WriteLine(<span class="hljs-string">&quot;栈中元素数量: &quot;</span> + stack.Count); <span class="hljs-comment">// 输出 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="七、-队列"><a href="#七、-队列" class="headerlink" title="七、 队列"></a>七、 队列</h1><p>队列（Queue）是一种先进先出（FIFO，First In, First Out）的数据结构，这意味着第一个加入队列的元素最先被移除。队列的基本操作和特点如下：</p><h3 id="1-队列的基本概念"><a href="#1-队列的基本概念" class="headerlink" title="1. 队列的基本概念"></a>1. <strong>队列的基本概念</strong></h3><ul><li><strong>先进先出（FIFO）</strong>：队列的特点是“先进先出”，即最先入队的元素最先被移出队列。</li><li><strong>队列的主要操作</strong>：<ul><li><strong>Enqueue()</strong> ：将元素添加到队列的末尾（尾部）。</li><li><strong>Dequeue()</strong> ：移除并返回队列的第一个元素（头部）。</li></ul></li><li><strong>其他常见操作</strong>：<ul><li><strong>Peek()</strong> ：查看队列的第一个元素但不移除它。</li><li><strong>Count</strong> ：查看队列元素个数,没有IsEmpty()方法</li><li><strong>Clear()</strong> ：清空队列元素</li><li><strong>Contains&lt;&gt;()或Contains()</strong> ：是否存在某个元素<ul><li><strong>类型安全性</strong>：在编译时检查类型，避免类型转换的错误。例如，如果 <code>List&lt;int&gt;</code> 类型的集合调用 <code>Contains</code> 方法，就只能传入 <code>int</code> 类型的值，否则会出现编译错误。</li><li><strong>性能更高</strong>：泛型集合在检查元素时不需要进行装箱和拆箱操作（适用于值类型），直接比较元素的值，因此性能较高。</li><li><strong>避免类型转换问题</strong>：由于泛型集合存储的是具体类型的元素，所以 <code>Contains</code> 方法可以直接对该类型的值进行比较，而不需要进行类型转换。</li></ul></li></ul></li></ul><h3 id="2-队列的实现"><a href="#2-队列的实现" class="headerlink" title="2. 队列的实现"></a>2. <strong>队列的实现</strong></h3><p>队列可以通过数组或链表来实现。用数组实现时，需要处理循环队列以节省空间。用链表实现时，新元素添加到链表的尾部，元素移除从链表的头部进行。</p><h3 id="3-队列的应用"><a href="#3-队列的应用" class="headerlink" title="3. 队列的应用"></a>3. <strong>队列的应用</strong></h3><ul><li><strong>任务调度</strong>：在操作系统中，队列用于管理任务的调度，保证先到的任务先执行。</li><li><strong>消息处理</strong>：在网络通信中，队列用于缓冲数据，按顺序处理消息。</li><li><strong>宽度优先搜索（BFS）</strong>：在图的遍历算法中，队列用于按层次遍历图中的节点。</li></ul><h3 id="4-C-中的队列"><a href="#4-C-中的队列" class="headerlink" title="4. C# 中的队列"></a>4. <strong>C# 中的队列</strong></h3><p>在 C# 中，可以使用 <code>System.Collections.Generic</code> 命名空间中的 <code>Queue&lt;T&gt;</code> 泛型类来实现队列操作。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li>遍历什么的和栈一样，方法也基本一致，只是数据结构不同<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 非泛型，就是所有的Object</span><br>        <span class="hljs-comment">// using System.Collections;</span><br>        Queue queueAll = <span class="hljs-keyword">new</span> Queue();<br>        Queue&lt;<span class="hljs-built_in">string</span>&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>        <span class="hljs-comment">// Enqueue操作：将元素添加到队列的末尾</span><br>        queue.Enqueue(<span class="hljs-string">&quot;First&quot;</span>);<br>        queue.Enqueue(<span class="hljs-string">&quot;Second&quot;</span>);<br>        queue.Enqueue(<span class="hljs-string">&quot;Third&quot;</span>);<br><br>        <span class="hljs-comment">// Peek操作：查看队列的第一个元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Front element is: &quot;</span> + queue.Peek());<br><br>        <span class="hljs-comment">// Contains：查看是否包含某个元素 也可以直接Contains,不用泛型</span><br>        Console.WriteLine(<span class="hljs-string">&quot;First element contains?&quot;</span> + queue.Contains&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;First&quot;</span>));<br><br><br>        <span class="hljs-comment">// Dequeue操作：移除并返回队列的第一个元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Dequeued element is: &quot;</span> + queue.Dequeue());<br><br>        <span class="hljs-comment">// 再次查看队列的第一个元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Front element after dequeue is: &quot;</span> + queue.Peek());<br><br><br>        <span class="hljs-comment">// 清空队列</span><br>        queue.Clear();<br>        <span class="hljs-comment">// 检查队列是否为空，队列元素个数</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Is queue empty? &quot;</span> + (queue.Count == <span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Front element <span class="hljs-keyword">is</span>: First<br>First element contains?True<br>Dequeued element <span class="hljs-keyword">is</span>: First<br>Front element after dequeue <span class="hljs-keyword">is</span>: Second<br>Is queue empty? True<br></code></pre></td></tr></table></figure><h3 id="5-双端队列（Deque）"><a href="#5-双端队列（Deque）" class="headerlink" title="5. 双端队列（Deque）"></a>5. <strong>双端队列（Deque）</strong></h3><p>双端队列是一种特殊的队列，允许从两端进行插入和删除操作。在 C# 中，可以使用 <code>System.Collections.Generic</code> 命名空间下的 <code>LinkedList&lt;T&gt;</code> 来实现双端队列的功能。</p><h3 id="6-队列在内存管理中的应用"><a href="#6-队列在内存管理中的应用" class="headerlink" title="6. 队列在内存管理中的应用"></a>6. <strong>队列在内存管理中的应用</strong></h3><p>队列通常用作任务队列或事件队列，用于按顺序处理异步事件或任务。<br>队列是一种简单而灵活的数据结构，在实际开发中广泛应用于各种场景。</p><h3 id="7-泛型队列-Queue"><a href="#7-泛型队列-Queue" class="headerlink" title="7. 泛型队列 (Queue&lt;T&gt;)"></a>7. <strong>泛型队列 (<code>Queue&lt;T&gt;</code>)</strong></h3><ul><li><strong>定义</strong>：队列是一种先进先出（FIFO，First In First Out）的数据结构。最先放入队列中的元素最先被取出。</li><li><strong>常用方法</strong>：和普通队列一样<ul><li><code>Enqueue(T item)</code>：将元素添加到队列的末尾。</li><li><code>Dequeue()</code>：移除并返回队列头部的元素。</li><li><code>Peek()</code>：返回队列头部的元素，但不移除它。</li><li><code>Count</code>：获取队列中元素的数量。</li></ul></li><li><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个泛型队列</span><br>        Queue&lt;<span class="hljs-built_in">string</span>&gt; queue = <span class="hljs-keyword">new</span> Queue&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>        <span class="hljs-comment">// 入队元素</span><br>        queue.Enqueue(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        queue.Enqueue(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        queue.Enqueue(<span class="hljs-string">&quot;Charlie&quot;</span>);<br><br>        <span class="hljs-comment">// 输出队头元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;队头元素: &quot;</span> + queue.Peek()); <span class="hljs-comment">// 输出 Alice</span><br><br>        <span class="hljs-comment">// 出队元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;出队元素: &quot;</span> + queue.Dequeue()); <span class="hljs-comment">// 输出 Alice</span><br><br>        <span class="hljs-comment">// 队列中剩余元素数量</span><br>        Console.WriteLine(<span class="hljs-string">&quot;队列中元素数量: &quot;</span> + queue.Count); <span class="hljs-comment">// 输出 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="八、-Hashtable"><a href="#八、-Hashtable" class="headerlink" title="八、 Hashtable"></a>八、 Hashtable</h1><p>在 C# 中，<code>Hashtable</code> 是一种以键-值对存储数据的集合，属于非泛型集合类，位于 <code>System.Collections</code> 命名空间中。它通过键来快速查找值，使用哈希函数来确定每个键的位置。</p><h3 id="1-基本特点"><a href="#1-基本特点" class="headerlink" title="1. 基本特点"></a>1. <strong>基本特点</strong></h3><ul><li><strong>键值对存储</strong>：<code>Hashtable</code> 存储数据时使用键-值对的形式，每个键必须是唯一的，但值可以重复。</li><li><strong>哈希表实现</strong>：通过哈希算法将键映射到特定的存储位置，从而实现快速的数据查找。</li><li><strong>非泛型集合</strong>：<code>Hashtable</code> 存储的键和值都是 <code>object</code> 类型，因此需要进行类型转换。</li><li><strong>自动调整容量</strong>：当元素数量超过某个阈值时，<code>Hashtable</code> 会自动扩展其容量，以提高性能。</li></ul><h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2. 常用操作"></a>2. <strong>常用操作</strong></h3><ul><li><strong>添加元素</strong>：使用 <code>Add()</code> 方法添加键-值对。</li><li><strong>访问元素</strong>：使用索引器 <code>[]</code> 访问或修改指定键的值。</li><li><strong>删除元素</strong>：使用 <code>Remove()</code> 方法删除指定键的键-值对。<ul><li>如果删除不存在的键，不报错，只是没反应</li></ul></li><li><strong>检查键是否存在</strong>：使用 <code>ContainsKey()</code> 方法判断某个键是否存在。<ul><li>和Contains()一样的，都是判断某个键是否存在</li></ul></li><li><strong>检查值是否存在</strong>：使用 <code>ContainsValue()</code> 方法判断某个值是否存在。</li><li><strong>清空集合</strong>：使用 <code>Clear()</code> 方法清空所有元素。</li><li><strong>键值对对数</strong>：使用<code>Count</code>字段获取键值对对数。</li><li><strong>键对</strong>：<code>Keys</code>字段获取键对</li><li><strong>值对</strong>：<code>Values</code>字段获取值对</li></ul><h3 id="3-示例代码-1"><a href="#3-示例代码-1" class="headerlink" title="3. 示例代码"></a>3. <strong>示例代码</strong></h3><p>下面是一些常用操作的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 Hashtable</span><br>        Hashtable hashtable = <span class="hljs-keyword">new</span> Hashtable();<br><br>        <span class="hljs-comment">// 添加键值对</span><br>        hashtable.Add(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">5</span>);<br>        hashtable.Add(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">3</span>);<br>        hashtable.Add(<span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-number">8</span>);<br><br>        <span class="hljs-comment">// 访问元素</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Apple count: &quot;</span> + hashtable[<span class="hljs-string">&quot;apple&quot;</span>]);<br><br>        <span class="hljs-comment">// 修改元素</span><br>        hashtable[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">10</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Banana count (updated): &quot;</span> + hashtable[<span class="hljs-string">&quot;banana&quot;</span>]);<br><br>        <span class="hljs-comment">// 检查键是否存在</span><br>        <span class="hljs-keyword">if</span> (hashtable.ContainsKey(<span class="hljs-string">&quot;orange&quot;</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Orange is in the hashtable.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 删除元素</span><br>        hashtable.Remove(<span class="hljs-string">&quot;apple&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;After removing apple, count: &quot;</span> + hashtable.Count);<br><br>        <span class="hljs-comment">// 遍历所有键,这里用var或者object都可以</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> hashtable.Keys)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + item);<br>            Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + hashtable[item]);<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历所有的值</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> hashtable.Values)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + item);<br>        &#125;<br><br>        <span class="hljs-comment">// 键值对一起遍历</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> hashtable)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + ((DictionaryEntry)item).Key);<br>            Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + ((DictionaryEntry)item).Value);<br>        &#125;<br><br>        <span class="hljs-comment">// 键值对一起遍历</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> hashtable)<br>        &#123;<br>            <span class="hljs-keyword">var</span> entry = item <span class="hljs-keyword">as</span> DictionaryEntry?;<br><br>            <span class="hljs-comment">// 判断当前对象是否为一个有效值，如果是，返回true</span><br>            <span class="hljs-comment">// 如果不是，意味着是null，返回false</span><br>            <span class="hljs-comment">// entry必须是一个可以为null的值，所以上面加了?</span><br>            <span class="hljs-keyword">if</span> (entry.HasValue)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + entry.Value.Key);<br>                Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + entry.Value.Value);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 GetEnumerator 方法遍历 Hashtable</span><br>        <span class="hljs-comment">// 迭代器遍历法</span><br>        IDictionaryEnumerator enumerator = hashtable.GetEnumerator();<br><br>        <span class="hljs-keyword">while</span> (enumerator.MoveNext())<br>        &#123;<br>            <span class="hljs-comment">// 访问当前键值对</span><br>            Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + enumerator.Key);<br>            Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + enumerator.Value);<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 LINQ 遍历 Hashtable,不建议用这种方法遍历</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        关键点</span><br><span class="hljs-comment">        类型转换：Cast&lt;DictionaryEntry&gt;() 将 Hashtable 中的每个元素转换为 DictionaryEntry 类型。</span><br><span class="hljs-comment">        这是因为 Hashtable 中的元素实际上是 DictionaryEntry 对象。</span><br><span class="hljs-comment">        LINQ 集合操作：通过将 Hashtable 转换为 IEnumerable&lt;DictionaryEntry&gt;，</span><br><span class="hljs-comment">        你可以使用 LINQ 的其他功能，例如 Where、Select、OrderBy 等，</span><br><span class="hljs-comment">        对元素进行过滤和操作。</span><br><span class="hljs-comment">        安全性：使用 Cast&lt;T&gt;() 进行类型转换时，如果集合中的元素不能转换为指定类型，</span><br><span class="hljs-comment">        将抛出异常。因此，确保 Hashtable 中的元素是 DictionaryEntry 类型是很重要的。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">var</span> entries = hashtable.Cast&lt;DictionaryEntry&gt;();<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> entries)<br>        &#123;<br>            <span class="hljs-comment">// 尝试将 item 转换为可空类型</span><br>            <span class="hljs-keyword">var</span> entry = item <span class="hljs-keyword">as</span> DictionaryEntry?;<br><br>            <span class="hljs-comment">// 检查 entry 是否有值</span><br>            <span class="hljs-keyword">if</span> (entry.HasValue)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;key: &quot;</span> + entry.Value.Key);<br>                Console.WriteLine(<span class="hljs-string">&quot;value: &quot;</span> + entry.Value.Value);<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-comment">// 清空 Hashtable</span><br>        hashtable.Clear();<br>        <span class="hljs-comment">// 得到键值对 对数</span><br>        Console.WriteLine(<span class="hljs-string">&quot;After clearing, count: &quot;</span> + hashtable.Count);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Banana <span class="hljs-title">count</span> (<span class="hljs-params">updated</span>): 10</span><br><span class="hljs-function">Orange <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the hashtable.</span><br><span class="hljs-function">After removing apple, count: 2</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">key: orange</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 8</span><br><span class="hljs-function">key: banana</span><br><span class="hljs-function"><span class="hljs-keyword">value</span>: 10</span><br><span class="hljs-function">After clearing, count: 0</span><br></code></pre></td></tr></table></figure><h3 id="4-性能和使用注意事项"><a href="#4-性能和使用注意事项" class="headerlink" title="4. 性能和使用注意事项"></a>4. <strong>性能和使用注意事项</strong></h3><ul><li><strong>性能优势</strong>：<code>Hashtable</code> 具有 O(1) 的查找、插入和删除复杂度（在理想情况下），适用于需要快速查找数据的场景。</li><li><strong>装箱&#x2F;拆箱开销</strong>：由于 <code>Hashtable</code> 是非泛型集合，存储值类型时会发生装箱和拆箱操作，可能导致性能开销。</li><li><strong>线程安全</strong>：<code>Hashtable</code> 本身不是线程安全的，如果需要在多线程环境中使用，可以使用同步方法 <code>Hashtable.Synchronized</code> 或其他线程安全的集合。</li></ul><h3 id="5-与-Dictionary-的比较"><a href="#5-与-Dictionary-的比较" class="headerlink" title="5. 与 Dictionary&lt;TKey, TValue&gt; 的比较"></a>5. <strong>与 <code>Dictionary&lt;TKey, TValue&gt;</code> 的比较</strong></h3><p><code>Hashtable</code> 是早期的非泛型集合类，现在大部分情况下推荐使用 <code>Dictionary&lt;TKey, TValue&gt;</code>，因为：</p><ul><li><strong>类型安全</strong>：<code>Dictionary&lt;TKey, TValue&gt;</code> 是泛型集合，避免了类型转换的错误。</li><li><strong>性能更高</strong>：对于值类型的数据，<code>Dictionary&lt;TKey, TValue&gt;</code> 避免了装箱&#x2F;拆箱操作。</li><li><strong>代码可读性</strong>：使用泛型时，类型信息更加明确，提高了代码的可读性和维护性。</li></ul><p><code>Hashtable</code> 适用于简单的键值存储场景，但在现代 C# 编程中，通常建议使用泛型的 <code>Dictionary&lt;TKey, TValue&gt;</code>。</p><h1 id="九、-var和object"><a href="#九、-var和object" class="headerlink" title="九、 var和object"></a>九、 var和object</h1><p>在 C# 中，<code>var</code> 和 <code>object</code> 都可以用来声明变量，但它们有不同的用法和意义：</p><ol><li><strong><code>var</code> 的特点</strong>：<ul><li><strong>类型推断</strong>：<code>var</code> 是编译时的类型推断，编译器会根据右侧赋值的类型自动推断变量的类型。例如，如果赋值是一个 <code>int</code>，<code>var</code> 就会被推断为 <code>int</code> 类型。</li><li><strong>强类型</strong>：使用 <code>var</code> 声明的变量在编译时类型是确定的，并且不能更改。虽然看起来像动态类型，但实际上是强类型的变量。</li><li><strong>优点</strong>：代码更简洁，特别是当类型名称很长或复杂时；减少显式类型声明带来的冗余。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> number = <span class="hljs-number">10</span>; <span class="hljs-comment">// 推断为 int</span><br><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 推断为 string</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong><code>object</code> 的特点</strong>：<ul><li><strong>基础类型</strong>：<code>object</code> 是所有类型的基类，意味着任何类型的变量都可以赋值给 <code>object</code>。当存储值类型时，会发生装箱操作。</li><li><strong>需要类型转换</strong>：如果使用 <code>object</code> 进行类型存储，取出时需要进行显式类型转换，并且在编译时不会检查类型安全。</li><li><strong>优点</strong>：适用于需要存储不同类型的情况或无法提前确定类型的场景。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> number = <span class="hljs-number">10</span>; <span class="hljs-comment">// 装箱为 object</span><br><span class="hljs-built_in">object</span> text = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 作为 object 类型存储</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong>区别和建议</strong>：<ul><li>使用 <code>var</code> 可以保留强类型的优势，同时简化代码，是更推荐的做法，特别是在类型明确的情况下。</li><li>使用 <code>object</code> 需要在取出时进行类型转换，可能会带来额外的性能开销和类型安全性问题。</li><li>在迭代集合时，如果知道集合的元素类型，建议使用 <code>var</code>，因为编译器会推断出正确的类型，代码更清晰且类型安全。<br>在遍历 <code>Hashtable</code> 时，<code>var</code> 会推断出 <code>item</code> 的类型为 <code>object</code>，所以在这种情况下两者都能工作。但是使用 <code>var</code> 是更好的实践，因为它让代码看起来更简洁。</li></ul></li></ol><h1 id="十、-泛型"><a href="#十、-泛型" class="headerlink" title="十、 泛型"></a>十、 泛型</h1><p>泛型（Generics）是 C# 中的一种强大功能，允许你定义类、接口和方法时使用占位符（类型参数），而不需要在定义时指定具体的类型。这样，你可以在运行时使用不同的数据类型，提升代码的复用性和类型安全性。以下是关于泛型的一些关键点及示例。</p><ul><li>如果有多个泛型占位字母，逗号分开即可</li><li>抽象类和静态类都不能作为泛型<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//泛型约束一共有6种</span><br><span class="hljs-comment">// 1.值类型                       where 泛型字母：struct</span><br><span class="hljs-comment">// 2.引用类型                     where 泛型字母：class</span><br><span class="hljs-comment">// 3.存在无参公共构造函数          where 泛型字母：new（）</span><br><span class="hljs-comment">// 4.某个类本身或者其派生类        where 泛型字母：类名</span><br><span class="hljs-comment">// 5.某个接口的派生类型            where 泛型字母：接口名</span><br><span class="hljs-comment">// 6.另一个泛型类型本身或者派生类型 where 泛型字母：另一个泛型字母</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1. 泛型类"></a>1. 泛型类</h3><p>泛型类允许你创建一个类，其中的成员可以使用类型参数。这使得类可以处理不同的数据类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GenericList</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;T&gt; items = <span class="hljs-keyword">new</span> List&lt;T&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>    &#123;<br>        items.Add(item);<br>    &#125;<br><br><span class="hljs-comment">// 泛型类中的泛型方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> items[index];<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用泛型类</span><br>        <span class="hljs-keyword">var</span> intList = <span class="hljs-keyword">new</span> GenericList&lt;<span class="hljs-built_in">int</span>&gt;();<br>        intList.Add(<span class="hljs-number">1</span>);<br>        intList.Add(<span class="hljs-number">2</span>);<br>        Console.WriteLine(intList.Get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出 1</span><br><br>        <span class="hljs-keyword">var</span> stringList = <span class="hljs-keyword">new</span> GenericList&lt;<span class="hljs-built_in">string</span>&gt;();<br>        stringList.Add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        stringList.Add(<span class="hljs-string">&quot;World&quot;</span>);<br>        Console.WriteLine(stringList.Get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 输出 World</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-泛型方法"><a href="#2-泛型方法" class="headerlink" title="2. 泛型方法"></a>2. 泛型方法</h3><p>你可以在类中定义泛型方法，这些方法可以接受不同的数据类型作为参数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utilities</span><br>&#123;<br><span class="hljs-comment">// 普通类中的泛型方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">GetMax</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a, T b</span>) <span class="hljs-keyword">where</span> T : IComparable</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> (a.CompareTo(b) &gt; <span class="hljs-number">0</span>) ? a : b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用泛型方法</span><br>        Console.WriteLine(Utilities.GetMax(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出 10</span><br>        Console.WriteLine(Utilities.GetMax(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>)); <span class="hljs-comment">// 输出 orange</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3. 泛型接口"></a>3. 泛型接口</h3><p>泛型接口允许你定义接口时使用类型参数，这使得实现该接口的类可以指定具体的类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRepository</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span>;<br>    <span class="hljs-function">T <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IRepository</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;T&gt; items = <span class="hljs-keyword">new</span> List&lt;T&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">T item</span>)</span><br>    &#123;<br>        items.Add(item);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Get</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> id</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> items[id];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用泛型接口</span><br>        <span class="hljs-keyword">var</span> repo = <span class="hljs-keyword">new</span> Repository&lt;<span class="hljs-built_in">string</span>&gt;();<br>        repo.Add(<span class="hljs-string">&quot;Item1&quot;</span>);<br>        Console.WriteLine(repo.Get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 输出 Item1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-约束（Constraints）"><a href="#4-约束（Constraints）" class="headerlink" title="4. 约束（Constraints）"></a>4. 约束（Constraints）</h3><p>泛型允许你使用约束来限制类型参数，这样你可以确保类型参数满足特定的条件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-keyword">class</span> <span class="hljs-comment">// T 必须是引用类型</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123; &#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> personExample = <span class="hljs-keyword">new</span> Example&lt;Person&gt;(<span class="hljs-keyword">new</span> Person());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 C# 中，泛型约束（Generic Constraints）用于限制类型参数的特性。这使得在使用泛型时可以确保某些条件得到满足，从而提供编译时的类型安全性。以下是关于泛型约束的详细说明及示例。</p><h4 id="常见的泛型约束类型"><a href="#常见的泛型约束类型" class="headerlink" title="常见的泛型约束类型"></a>常见的泛型约束类型</h4><h5 id="1-引用类型约束"><a href="#1-引用类型约束" class="headerlink" title="1. 引用类型约束"></a>1. 引用类型约束</h5><p>使用 <code>where T : class</code> 限制类型参数必须是引用类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-keyword">class</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">var</span> example = <span class="hljs-keyword">new</span> Example&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 合法</span><br><span class="hljs-comment">// var example2 = new Example&lt;int&gt;(5); // 不合法，int 是值类型</span><br></code></pre></td></tr></table></figure><h5 id="2-值类型约束"><a href="#2-值类型约束" class="headerlink" title="2. 值类型约束"></a>2. 值类型约束</h5><p>使用 <code>where T : struct</code> 限制类型参数必须是值类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ValueExample</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">struct</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValueExample</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">var</span> valueExample = <span class="hljs-keyword">new</span> ValueExample&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">5</span>); <span class="hljs-comment">// 合法</span><br><span class="hljs-comment">// var valueExample2 = new ValueExample&lt;string&gt;(&quot;Hello&quot;); // 不合法，string 是引用类型</span><br></code></pre></td></tr></table></figure><h5 id="3-new-约束"><a href="#3-new-约束" class="headerlink" title="3. new() 约束"></a>3. <code>new()</code> 约束</h5><p><code>new()</code> 约束用于限制泛型类型参数必须具有一个无参数的构造函数。它允许在泛型类或方法中实例化类型参数。<br><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">new</span>() <span class="hljs-comment">// T 必须有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">CreateInstance</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// 使用 new() 创建实例</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span> &#123; &#125; <span class="hljs-comment">// 无参构造函数</span><br>&#125;<br><br><span class="hljs-keyword">var</span> factory = <span class="hljs-keyword">new</span> Factory&lt;MyClass&gt;();<br>MyClass instance = factory.CreateInstance(); <span class="hljs-comment">// 合法，创建 MyClass 实例</span><br></code></pre></td></tr></table></figure><h5 id="4-基类约束"><a href="#4-基类约束" class="headerlink" title="4. 基类约束"></a>4. 基类约束</h5><p>使用 <code>where T : BaseClass</code> 限制类型参数必须是指定基类或者其的派生类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span> &#123; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span> &#123; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseExample</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseExample</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        <span class="hljs-keyword">var</span> baseExample = <span class="hljs-keyword">new</span> BaseExample&lt;DerivedClass&gt;(<span class="hljs-keyword">new</span> DerivedClass()); <span class="hljs-comment">// 合法</span><br>        <span class="hljs-keyword">var</span> baseExample2 = <span class="hljs-keyword">new</span> BaseExample&lt;BaseClass&gt;(<span class="hljs-keyword">new</span> DerivedClass());<br>        <span class="hljs-comment">// var baseExample2 = new BaseExample&lt;string&gt;(&quot;Hello&quot;); // 不合法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-接口约束"><a href="#5-接口约束" class="headerlink" title="5. 接口约束"></a>5. 接口约束</h5><p>使用 <code>where T : IMyInterface</code> 限制类型参数必须实现指定的接口或者就是接口本身。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span> &#123; &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceExample</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T Data &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InterfaceExample</span>(<span class="hljs-params">T data</span>)</span><br>    &#123;<br>        Data = data;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        <span class="hljs-keyword">var</span> interfaceExample = <span class="hljs-keyword">new</span> InterfaceExample&lt;MyClass&gt;(<span class="hljs-keyword">new</span> MyClass()); <span class="hljs-comment">// 合法</span><br>        <span class="hljs-keyword">var</span> interfaceExample2 = <span class="hljs-keyword">new</span> InterfaceExample&lt;IMyInterface&gt;(<span class="hljs-keyword">new</span> MyClass());<br>        <span class="hljs-comment">// var interfaceExample2 = new InterfaceExample&lt;string&gt;(&quot;Hello&quot;); // 不合法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-类型参数之间的约束"><a href="#6-类型参数之间的约束" class="headerlink" title="6. 类型参数之间的约束"></a>6. 类型参数之间的约束</h5><p>当你想要限制一个泛型类型参数可以是另一个泛型类型参数的类型时，可以使用 <code>where</code> 关键字结合多个约束。<br><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Pair</span>&lt;<span class="hljs-title">T1</span>, <span class="hljs-title">T2</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T1</span> : <span class="hljs-keyword">class</span> <span class="hljs-keyword">where</span> <span class="hljs-title">T2</span> : <span class="hljs-title">T1</span> <span class="hljs-comment">// T2 必须是 T1 的派生类</span><br>&#123;<br>    <span class="hljs-keyword">public</span> T1 First &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> T2 Second &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Pair</span>(<span class="hljs-params">T1 first, T2 second</span>)</span><br>    &#123;<br>        First = first;<br>        Second = second;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span> &#123; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span> &#123; &#125;<br><br><span class="hljs-keyword">var</span> pair = <span class="hljs-keyword">new</span> Pair&lt;BaseClass, DerivedClass&gt;(<span class="hljs-keyword">new</span> BaseClass(), <span class="hljs-keyword">new</span> DerivedClass()); <span class="hljs-comment">// 合法</span><br><span class="hljs-comment">// var pair2 = new Pair&lt;DerivedClass, BaseClass&gt;(new DerivedClass(), new BaseClass()); // 不合法，BaseClass 不是 DerivedClass 的派生类</span><br></code></pre></td></tr></table></figure><h5 id="7-结合-new-约束与其他约束"><a href="#7-结合-new-约束与其他约束" class="headerlink" title="7. 结合 new() 约束与其他约束"></a>7. 结合 <code>new()</code> 约束与其他约束</h5><p>可以结合 <code>new()</code> 约束与其他约束。例如，假设你希望一个类同时支持无参构造函数和基类的约束。<br><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">new</span>() <span class="hljs-comment">// T 必须是 BaseClass 的派生类，并且有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">CreateInstance</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// 使用 new() 创建实例</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DerivedClass</span>()</span> &#123; &#125; <span class="hljs-comment">// 无参构造函数</span><br>&#125;<br><br><span class="hljs-keyword">var</span> example = <span class="hljs-keyword">new</span> Example&lt;DerivedClass&gt;();<br>DerivedClass instance = example.CreateInstance(); <span class="hljs-comment">// 合法</span><br></code></pre></td></tr></table></figure><p>可以为一个类型参数指定多个约束，使用 <code>,</code> 分隔。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MultiConstraintExample</span>&lt;<span class="hljs-title">T</span>&gt; <br>    <span class="hljs-keyword">where</span> <span class="hljs-title">T</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IMyInterface</span>, <span class="hljs-title">new</span>() <span class="hljs-comment">// 需要是 BaseClass 的派生类，实现 IMyInterface，并且有无参构造函数</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">CreateInstance</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> T(); <span class="hljs-comment">// 使用 new() 约束</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="8-多个泛型有约束"><a href="#8-多个泛型有约束" class="headerlink" title="8. 多个泛型有约束"></a>8. 多个泛型有约束</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义一个泛型接口，表示实体必须有一个 ID</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEntity</span>&lt;<span class="hljs-title">TId</span>&gt;<br>&#123;<br>    TId Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个具体的实体类，实现 IEntity&lt;int&gt; 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> : <span class="hljs-title">IEntity</span>&lt;<span class="hljs-title">int</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义泛型类 Repository，带有两个泛型参数 TModel 和 TId</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">TModel</span>, <span class="hljs-title">TId</span>&gt;<br>    <span class="hljs-keyword">where</span> <span class="hljs-title">TModel</span> : <span class="hljs-keyword">class</span>, <span class="hljs-title">IEntity</span>&lt;<span class="hljs-title">TId</span>&gt;, <span class="hljs-title">new</span>() <span class="hljs-comment">// TModel 必须是类，实现 IEntity&lt;TId&gt;，且有无参构造函数</span><br>    <span class="hljs-keyword">where</span> <span class="hljs-title">TId</span> : <span class="hljs-title">struct</span> <span class="hljs-comment">// TId 必须是值类型</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TModel <span class="hljs-title">CreateNew</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 可以创建 TModel 的实例，因为有 new() 约束</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TModel();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TId <span class="hljs-title">GetId</span>(<span class="hljs-params">TModel model</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 可以访问 Id，因为 TModel 实现了 IEntity&lt;TId&gt;</span><br>        <span class="hljs-keyword">return</span> model.Id;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Repository&lt;User, int&gt; 创建对象</span><br>        <span class="hljs-keyword">var</span> userRepository = <span class="hljs-keyword">new</span> Repository&lt;User, <span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// 创建一个新的 User 实例</span><br>        User newUser = userRepository.CreateNew();<br>        newUser.Id = <span class="hljs-number">1</span>;<br>        newUser.Name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><br>        <span class="hljs-comment">// 获取 User 的 Id</span><br>        <span class="hljs-built_in">int</span> userId = userRepository.GetId(newUser);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;User ID: <span class="hljs-subst">&#123;userId&#125;</span>, Name: <span class="hljs-subst">&#123;newUser.Name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-泛型集合"><a href="#5-泛型集合" class="headerlink" title="5. 泛型集合"></a>5. 泛型集合</h3><p>C# 中有许多内置的泛型集合，如 <code>List&lt;T&gt;</code>、<code>Dictionary&lt;TKey, TValue&gt;</code> 和 <code>HashSet&lt;T&gt;</code>，这些集合类使得存储和操作不同类型的数据变得简单而安全。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">var</span> names = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;<br>&#123;<br>    &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Developer&quot;</span> &#125;,<br>    &#123; <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Manager&quot;</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-性能优势"><a href="#6-性能优势" class="headerlink" title="6. 性能优势"></a>6. 性能优势</h3><p>使用泛型可以减少装箱和拆箱操作，这对于值类型（如 <code>int</code>, <code>float</code> 等）特别重要。泛型还可以提高性能，因为它们避免了不必要的类型转换。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>复用性</strong>：泛型提供了一种创建类型安全和可复用的代码的方法。</li><li><strong>类型安全</strong>：编译器可以在编译时检查类型，从而减少运行时错误。</li><li><strong>性能</strong>：泛型可以提高性能，特别是在处理值类型时。<br>泛型是 C# 的一项重要特性，合理使用可以使代码更简洁、高效和可维护。</li></ul><h1 id="十一、-List"><a href="#十一、-List" class="headerlink" title="十一、 List"></a>十一、 List</h1><p><code>List&lt;T&gt;</code> 是 C# 中常用的泛型集合类，它位于 <code>System.Collections.Generic</code> 命名空间中，提供了动态数组的功能，可以存储类型为 <code>T</code> 的对象。与数组不同，<code>List&lt;T&gt;</code> 可以根据需要自动调整大小，并提供了一些常用的方法来操作集合中的元素。</p><h3 id="List-的基本用法"><a href="#List-的基本用法" class="headerlink" title="List&lt;T&gt; 的基本用法"></a><code>List&lt;T&gt;</code> 的基本用法</h3><ol><li><p><strong>创建 <code>List&lt;T&gt;</code></strong><br> 可以创建一个空的 <code>List&lt;T&gt;</code>，也可以通过指定初始容量或集合来初始化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">// 创建一个空的 List&lt;int&gt;</span><br>List&lt;<span class="hljs-built_in">string</span>&gt; names = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span> &#125;; <span class="hljs-comment">// 使用集合初始化</span><br></code></pre></td></tr></table></figure></li><li><p><strong>添加元素</strong><br> 使用 <code>Add</code> 方法可以将元素添加到 <code>List&lt;T&gt;</code> 的末尾，使用 <code>AddRange</code> 可以添加一个集合的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">numbers.Add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 添加一个元素</span><br>numbers.Add(<span class="hljs-number">20</span>);<br>numbers.Insert(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 在索引位置为2的地方插入值30，如果index&gt;numbers.Count会报错：System.ArgumentOutOfRangeException</span><br><br><span class="hljs-keyword">var</span> moreNumbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span> &#125;;<br>numbers.AddRange(moreNumbers); <span class="hljs-comment">// 添加多个元素 10 20 30 40 50 </span><br></code></pre></td></tr></table></figure></li><li><p><strong>访问元素</strong><br> 可以使用索引访问 <code>List&lt;T&gt;</code> 中的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> firstNumber = numbers[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 访问第一个元素</span><br>numbers[<span class="hljs-number">1</span>] = <span class="hljs-number">25</span>; <span class="hljs-comment">// 修改第二个元素的值</span><br></code></pre></td></tr></table></figure></li><li><p><strong>删除元素</strong><br> 使用 <code>Remove</code> 方法可以删除指定的元素，<code>RemoveAt</code> 可以删除指定索引位置的元素，<code>Clear</code> 可以清空列表。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">numbers.Remove(<span class="hljs-number">20</span>); <span class="hljs-comment">// 删除值为 20 的元素</span><br>numbers.RemoveAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 删除索引为 0 的元素</span><br>numbers.Clear(); <span class="hljs-comment">// 清空列表</span><br></code></pre></td></tr></table></figure></li><li><p><strong>查找元素</strong><br> 可以使用 <code>Contains</code>、<code>IndexOf</code>、<code>LastIndexOf</code> 等方法查找元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> hasTen = numbers.Contains(<span class="hljs-number">10</span>); <span class="hljs-comment">// 检查列表中是否包含 10</span><br><span class="hljs-built_in">int</span> index = numbers.IndexOf(<span class="hljs-number">30</span>); <span class="hljs-comment">// 正向查找第一个 30 的索引，找不到返回-1</span><br><span class="hljs-built_in">int</span> index2 = numbers.LastIndexOf(<span class="hljs-number">30</span>); <span class="hljs-comment">// 反向查找第一个30的索引，找不到返回-1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>排序</strong><br> 可以使用 <code>Sort</code> 方法对列表进行排序，使用 <code>Reverse</code> 方法对列表进行反转。</p><ul><li>自定义排序要继承IComparable接口，重写CompareTo类 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">numbers.Sort(); <span class="hljs-comment">// 升序排序</span><br>numbers.Reverse(); <span class="hljs-comment">// 反转列表</span><br></code></pre></td></tr></table></figure> <code>List&lt;T&gt;.Sort()</code> 方法有多个重载，允许根据不同的排序需求指定参数。以下是常见的参数选项：</li></ul><ol><li><strong><code>Sort()</code></strong><br> 使用默认的比较器对列表中的元素进行升序排序。这要求元素类型实现了 <code>IComparable&lt;T&gt;</code> 接口。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span> &#125;;<br>numbers.Sort(); <span class="hljs-comment">// 升序排序</span><br></code></pre></td></tr></table></figure></li><li><strong><code>Sort(Comparison&lt;T&gt; comparison)</code></strong><br> 通过指定一个比较委托 <code>Comparison&lt;T&gt;</code>，根据自定义的比较规则进行排序。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span> &#125;;<br>numbers.Sort((a, b) =&gt; b.CompareTo(a)); <span class="hljs-comment">// 降序排序</span><br></code></pre></td></tr></table></figure></li><li><strong><code>Sort(IComparer&lt;T&gt; comparer)</code></strong><br> 使用指定的比较器 <code>IComparer&lt;T&gt;</code> 对列表中的元素进行排序。可以通过实现 <code>IComparer&lt;T&gt;</code> 接口来定义自定义排序逻辑。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">string</span>&gt; names = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span> &#125;;<br>names.Sort(StringComparer.OrdinalIgnoreCase); <span class="hljs-comment">// 忽略大小写排序,按照Unicode 编码值排序，升序</span><br><span class="hljs-comment">// 使用自定义比较器进行降序排序，忽略大小写</span><br>names.Sort((a, b) =&gt; StringComparer.OrdinalIgnoreCase.Compare(b, a));<br></code></pre></td></tr></table></figure></li><li><strong><code>Sort(int index, int count, IComparer&lt;T&gt; comparer)</code></strong>  <ul><li>对列表的指定范围进行排序，从 <code>index</code> 开始，对接下来的 <code>count</code> 个元素进行排序。可以使用 <code>IComparer&lt;T&gt;</code> 来指定排序规则。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span> &#125;;<br>numbers.Sort(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, Comparer&lt;<span class="hljs-built_in">int</span>&gt;.Default); <span class="hljs-comment">// 对从索引 1 开始的 3 个元素排序</span><br></code></pre></td></tr></table></figure></li></ul></li><li>自定义类排序<ul><li>自定义排序要继承IComparable接口，重写CompareTo()方法 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-comment">// 定义一个 Person 类，实现 IComparable&lt;Person&gt; 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">IComparable</span>&lt;<span class="hljs-title">Person</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 重写 CompareTo 方法，根据年龄进行比较</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CompareTo</span>(<span class="hljs-params">Person other</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (other == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.Age.CompareTo(other.Age);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，方便输出</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span>, Age: <span class="hljs-subst">&#123;Age&#125;</span>&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 Person 类型的 List</span><br>        List&lt;Person&gt; people = <span class="hljs-keyword">new</span> List&lt;Person&gt;<br>        &#123;<br>            <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span>, Age = <span class="hljs-number">30</span> &#125;,<br>            <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Bob&quot;</span>, Age = <span class="hljs-number">25</span> &#125;,<br>            <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Charlie&quot;</span>, Age = <span class="hljs-number">35</span> &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 按年龄进行排序</span><br>        people.Sort();<br><br>        <span class="hljs-comment">// 输出排序结果</span><br>        Console.WriteLine(<span class="hljs-string">&quot;按年龄排序：&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> person <span class="hljs-keyword">in</span> people)<br>        &#123;<br>            Console.WriteLine(person);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p> 示例代码<br> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br>List&lt;<span class="hljs-built_in">string</span>&gt; fruits = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt; &#123; <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Cherry&quot;</span>, <span class="hljs-string">&quot;Date&quot;</span> &#125;;<br><br><span class="hljs-comment">// 使用默认排序（升序）</span><br>fruits.Sort();<br>Console.WriteLine(<span class="hljs-string">&quot;默认排序:&quot;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>Console.WriteLine(fruit);<br>&#125;<br><br><span class="hljs-comment">// 使用自定义比较器进行降序排序</span><br>fruits.Sort((a, b) =&gt; b.CompareTo(a));<br>Console.WriteLine(<span class="hljs-string">&quot;\n降序排序:&quot;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> fruit <span class="hljs-keyword">in</span> fruits)<br>&#123;<br>Console.WriteLine(fruit);<br>&#125;<br><br><span class="hljs-comment">// 使用部分排序，指定范围</span><br>List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span> &#125;;<br>numbers.Sort(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, Comparer&lt;<span class="hljs-built_in">int</span>&gt;.Default); <span class="hljs-comment">// 对从索引 1 开始的 3 个元素排序</span><br>Console.WriteLine(<span class="hljs-string">&quot;\n部分排序:&quot;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>&#123;<br>Console.WriteLine(number);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>遍历 <code>List&lt;T&gt;</code></strong><br> 可以使用 <code>foreach</code> 或 <code>for</code> 循环遍历列表中的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> number <span class="hljs-keyword">in</span> numbers)<br>&#123;<br>    Console.WriteLine(number);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>List长度</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(numbers.Count);<br></code></pre></td></tr></table></figure></li></ol><h3 id="常用方法总结"><a href="#常用方法总结" class="headerlink" title="常用方法总结"></a>常用方法总结</h3><ul><li><code>Add(T item)</code>: 将元素添加到列表的末尾。</li><li><code>AddRange(IEnumerable&lt;T&gt; collection)</code>: 将指定集合的元素添加到列表的末尾。</li><li><code>Insert(int index, T item)</code>: 在指定索引处插入元素。</li><li><code>Remove(T item)</code>: 删除列表中第一个匹配的元素。</li><li><code>RemoveAt(int index)</code>: 删除指定索引处的元素。</li><li><code>Contains(T item)</code>: 判断列表中是否包含指定元素。</li><li><code>IndexOf(T item)</code>: 查找指定元素的索引。</li><li><code>Sort()</code>: 对列表进行排序。</li><li><code>Clear()</code>: 清空列表。</li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 List&lt;int&gt;</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><br>        <span class="hljs-comment">// 添加元素</span><br>        numbers.Add(<span class="hljs-number">6</span>);<br>        numbers.AddRange(<span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> &#125;);<br><br>        <span class="hljs-comment">// 访问元素</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;第一个元素: <span class="hljs-subst">&#123;numbers[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 删除元素</span><br>        numbers.Remove(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除值为 3 的元素</span><br>        numbers.RemoveAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 删除第一个元素</span><br><br>        <span class="hljs-comment">// 查找元素</span><br>        <span class="hljs-built_in">bool</span> containsFive = numbers.Contains(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;包含 5: <span class="hljs-subst">&#123;containsFive&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 排序并遍历</span><br>        numbers.Sort();<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>List&lt;T&gt;</code> 是一种非常灵活且常用的集合类型，适合需要动态调整大小的场景。</p><h1 id="十二、-a-b-b-CompareTo-a"><a href="#十二、-a-b-b-CompareTo-a" class="headerlink" title="十二、  (a, b) &#x3D;&gt; b.CompareTo(a)"></a>十二、  (a, b) &#x3D;&gt; b.CompareTo(a)</h1><p>表达式 <code>(a, b) =&gt; b.CompareTo(a)</code> 是一个使用 Lambda 表达式定义的比较委托，用于自定义排序。</p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li><code>(a, b)</code> 是 Lambda 表达式的参数，表示要比较的两个元素。</li><li><code>b.CompareTo(a)</code> 是 Lambda 表达式的主体，它比较 <code>b</code> 和 <code>a</code> 的大小。<br>在 C# 中，<code>CompareTo</code> 方法返回一个整数值：</li><li>如果 <code>b.CompareTo(a)</code> 返回正数，表示 <code>b</code> 大于 <code>a</code>。</li><li>如果返回 0，表示 <code>b</code> 等于 <code>a</code>。</li><li>如果返回负数，表示 <code>b</code> 小于 <code>a</code>。</li></ul><h3 id="如何实现降序排序"><a href="#如何实现降序排序" class="headerlink" title="如何实现降序排序"></a>如何实现降序排序</h3><p>在 <code>List&lt;T&gt;.Sort</code> 方法中，默认的排序顺序是升序（从小到大）。通过 <code>(a, b) =&gt; b.CompareTo(a)</code>，实际上是将两个元素的比较顺序进行了调换，即比较 <code>b</code> 和 <code>a</code>，而不是 <code>a</code> 和 <code>b</code>。这样可以实现降序排序（从大到小）。</p><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下代码演示了使用自定义比较委托来对列表进行降序排序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span> &#125;;<br><br>        <span class="hljs-comment">// 使用自定义比较器进行降序排序</span><br>        numbers.Sort((a, b) =&gt; b.CompareTo(a));<br><br>        Console.WriteLine(<span class="hljs-string">&quot;降序排序后的列表:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">降序排序后的列表:</span><br>10<br>8<br>5<br>3<br>2<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>(a, b) =&gt; b.CompareTo(a)</code> 实现了降序排列，将较大的数排在前面。</p><h1 id="十三、-Lambda-表达式"><a href="#十三、-Lambda-表达式" class="headerlink" title="十三、  Lambda 表达式"></a>十三、  Lambda 表达式</h1><p>Lambda 表达式是一个匿名函数，用于创建委托或表达式树。它可以包含表达式或语句块，并且非常适合用来简化代码、实现委托、LINQ 查询和事件处理。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Lambda 表达式的基本语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">(parameters) =&gt; expression <span class="hljs-comment">//函数体只有一句，可以不用&#123;&#125;大括号</span><br></code></pre></td></tr></table></figure><ul><li><code>parameters</code>：输入参数，可以有一个或多个，用圆括号括起来。一个可以不用圆括号括起来</li><li>$&#x3D;&gt;$：Lambda 操作符，分隔参数和表达式。</li><li><code>expression</code>：Lambda 表达式的主体，通常是一个单一的表达式。<br>如果 Lambda 表达式的主体包含多条语句，则需要使用大括号：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">(parameters) =&gt; &#123; statements &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><h4 id="1-简单示例"><a href="#1-简单示例" class="headerlink" title="1. 简单示例"></a>1. 简单示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; square = x =&gt; x * x; <span class="hljs-comment">// Func是泛型委托，最后一个int表示返回值是int，第一个参数以及后的参数表示输入的参数</span><br>Console.WriteLine(square(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 输出 25</span><br></code></pre></td></tr></table></figure><p>在这个示例中，<code>x =&gt; x * x</code> 是一个 Lambda 表达式，它接受一个整数参数 <code>x</code>，并返回它的平方。</p><h4 id="2-多参数的-Lambda-表达式"><a href="#2-多参数的-Lambda-表达式" class="headerlink" title="2. 多参数的 Lambda 表达式"></a>2. 多参数的 Lambda 表达式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; a + b;<br>Console.WriteLine(<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><p>此示例中，Lambda 表达式 <code>(a, b) =&gt; a + b</code> 接受两个整数参数并返回它们的和。</p><h4 id="3-使用语句块的-Lambda-表达式"><a href="#3-使用语句块的-Lambda-表达式" class="headerlink" title="3. 使用语句块的 Lambda 表达式"></a>3. 使用语句块的 Lambda 表达式</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action&lt;<span class="hljs-built_in">string</span>&gt; greet = name =&gt;<br>&#123;<br>    <span class="hljs-built_in">string</span> greeting = <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    Console.WriteLine(greeting);<br>&#125;;<br>greet(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 输出 Hello, Alice</span><br></code></pre></td></tr></table></figure><p>此示例中的 Lambda 表达式使用了大括号，因为它包含多条语句。</p><h3 id="Lambda-表达式在-LINQ-中的使用"><a href="#Lambda-表达式在-LINQ-中的使用" class="headerlink" title="Lambda 表达式在 LINQ 中的使用"></a>Lambda 表达式在 LINQ 中的使用</h3><p>Lambda 表达式经常用于 LINQ 查询。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">var</span> evenNumbers = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToList();<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> evenNumbers)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出 2 和 4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>n =&gt; n % 2 == 0</code> 是一个 Lambda 表达式，用于过滤出偶数。</p><h3 id="使用-Lambda-表达式的优势"><a href="#使用-Lambda-表达式的优势" class="headerlink" title="使用 Lambda 表达式的优势"></a>使用 Lambda 表达式的优势</h3><ol><li><strong>简洁性</strong>：可以用更少的代码实现功能。</li><li><strong>灵活性</strong>：方便地用于创建委托、事件处理程序或表达式树。</li><li><strong>可读性</strong>：与 C# 语言的其他特性（如 LINQ）结合使用时，可以提高代码的可读性。</li></ol><h1 id="十四、-HashSet"><a href="#十四、-HashSet" class="headerlink" title="十四、 HashSet"></a>十四、 HashSet</h1><p><code>HashSet&lt;T&gt;</code> 是 C# 中的一种集合类型，它实现了集合的数学概念，特别是无序和唯一性。<code>HashSet&lt;T&gt;</code> 适合用于存储不重复的元素，并提供快速的查找、添加和删除操作。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>无序性</strong>：<code>HashSet&lt;T&gt;</code> 中的元素没有特定的顺序。</li><li><strong>唯一性</strong>：集合中的每个元素都是唯一的，不能重复添加相同的元素。</li><li><strong>快速操作</strong>：由于使用哈希表实现，<code>HashSet&lt;T&gt;</code> 提供 O(1) 的平均时间复杂度用于查找、添加和删除操作。</li></ol><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>Add(T item)</code>：向集合中添加元素。如果元素已存在，则不会添加，并返回 <code>false</code>。添加成功返回true。（如果用Console.WriteLine()输出变成了True）</li><li><code>Remove(T item)</code>：从集合中移除元素。如果元素不存在，则返回 <code>false</code>。</li><li><code>Contains(T item)</code>：检查集合中是否包含指定的元素。</li><li><code>Clear()</code>：移除集合中的所有元素。</li><li><code>Count</code>：获取集合中元素的数量。</li><li><code>UnionWith(IEnumerable&lt;T&gt; other)</code>：将当前集合与指定集合的并集合并。</li><li><code>IntersectWith(IEnumerable&lt;T&gt; other)</code>：将当前集合与指定集合的交集更新为当前集合。</li><li><code>ExceptWith(IEnumerable&lt;T&gt; other)</code>：从当前集合中移除与指定集合中相同的元素。</li></ul><h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>HashSet&lt;T&gt;</code> 的示例，展示了如何添加、查找和移除元素：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 HashSet</span><br>        HashSet&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        numbers.Add(<span class="hljs-number">1</span>);<br>        numbers.Add(<span class="hljs-number">2</span>);<br>        numbers.Add(<span class="hljs-number">3</span>);<br>        numbers.Add(<span class="hljs-number">2</span>); <span class="hljs-comment">// 不会添加重复的 2</span><br><br>        Console.WriteLine(<span class="hljs-string">&quot;HashSet 中的元素:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(num); <span class="hljs-comment">// 输出 1, 2, 3</span><br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否包含某个元素</span><br>        <span class="hljs-keyword">if</span> (numbers.Contains(<span class="hljs-number">2</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;集合中包含 2&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 移除元素</span><br>        numbers.Remove(<span class="hljs-number">3</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;移除 3 后的元素:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(num); <span class="hljs-comment">// 输出 1, 2</span><br>        &#125;<br><br>        <span class="hljs-comment">// 清空集合</span><br>        numbers.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;集合是否为空: <span class="hljs-subst">&#123;numbers.Count == <span class="hljs-number">0</span>&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>去重</strong>：存储一组唯一元素，避免重复。</li><li><strong>快速查找</strong>：快速判断某个元素是否存在于集合中。</li><li><strong>集合运算</strong>：执行并集、交集和差集等集合运算。</li></ul><h1 id="十五、-Dictionary"><a href="#十五、-Dictionary" class="headerlink" title="十五、  Dictionary"></a>十五、  Dictionary</h1><p><code>Dictionary&lt;TKey, TValue&gt;</code> 是 C# 中的一种集合类型，用于存储键值对（key-value pairs）。它是一个哈希表的实现，提供了快速的查找、添加和删除操作，适合需要快速访问和唯一键的场景。</p><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>键唯一性</strong>：每个键在字典中都是唯一的，不能重复。</li><li><strong>快速访问</strong>：通过键可以快速访问对应的值，查找、添加和删除操作的平均时间复杂度为 O(1)。</li><li><strong>动态大小</strong>：字典的大小可以动态调整，可以根据需要增加或减少存储的键值对。</li></ol><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>Add(TKey key, TValue value)</code>：向字典中添加新的键值对。如果键已存在，则抛出异常。</li><li><code>Remove(TKey key)</code>：移除指定键的键值对，并返回是否成功。</li><li><code>TryGetValue(TKey key, out TValue value)</code>：尝试获取指定键的值，返回一个布尔值指示是否成功。</li><li><code>ContainsKey(TKey key)</code>：检查字典中是否包含指定的键。</li><li><code>ContainsValue(TValue value)</code>：检查字典中是否包含指定的值。</li><li><code>Count</code>：获取字典中键值对的数量。</li><li><code>Clear()</code>：移除字典中的所有键值对。</li><li><code>Keys</code>：获取字典中所有的键。</li><li><code>Values</code>：获取字典中所有的值。</li></ul><h3 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>Dictionary&lt;TKey, TValue&gt;</code> 的示例，展示了如何添加、查找和移除元素：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 Dictionary</span><br>        Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; ages = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;();<br><br>        <span class="hljs-comment">// 添加键值对</span><br>        ages.Add(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        ages.Add(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>);<br>        ages.Add(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">35</span>);<br><br>        <span class="hljs-comment">// 输出所有的键值对</span><br>        Console.WriteLine(<span class="hljs-string">&quot;姓名和年龄:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> kvp <span class="hljs-keyword">in</span> ages)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;姓名: <span class="hljs-subst">&#123;kvp.Key&#125;</span>, 年龄: <span class="hljs-subst">&#123;kvp.Value&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否包含某个键</span><br>        <span class="hljs-keyword">if</span> (ages.ContainsKey(<span class="hljs-string">&quot;Bob&quot;</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Bob 的年龄: <span class="hljs-subst">&#123;ages[<span class="hljs-string">&quot;Bob&quot;</span>]&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否包含某个值</span><br>        <span class="hljs-keyword">if</span> (ages.ContainsValue(<span class="hljs-number">25</span>))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;存在值25&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 尝试获取值</span><br>        <span class="hljs-keyword">if</span> (ages.TryGetValue(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> charlieAge))<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Charlie 的年龄: <span class="hljs-subst">&#123;charlieAge&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 移除元素</span><br>        ages.Remove(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;移除 Alice 后的键值对:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> kvp <span class="hljs-keyword">in</span> ages)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;姓名: <span class="hljs-subst">&#123;kvp.Key&#125;</span>, 年龄: <span class="hljs-subst">&#123;kvp.Value&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 键值对一起遍历</span><br>        <span class="hljs-comment">// KeyValuePair&lt;string, int&gt;可以改为var</span><br>        <span class="hljs-keyword">foreach</span> (KeyValuePair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; kvp <span class="hljs-keyword">in</span> ages)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;姓名: <span class="hljs-subst">&#123;kvp.Key&#125;</span>, 年龄: <span class="hljs-subst">&#123;kvp.Value&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// key不存在会报错 System.Collections.Generic.KeyNotFoundException</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;修改前Bob 的年龄: <span class="hljs-subst">&#123;ages[<span class="hljs-string">&quot;Bob&quot;</span>]&#125;</span>&quot;</span>);<br>        ages[<span class="hljs-string">&quot;Bob&quot;</span>] = <span class="hljs-number">100</span>; <span class="hljs-comment">// key不存在的话，系统就会默认去创建一个</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;修改后Bob 的年龄: <span class="hljs-subst">&#123;ages[<span class="hljs-string">&quot;Bob&quot;</span>]&#125;</span>&quot;</span>);<br><br><br>        <span class="hljs-comment">// 清空字典</span><br>        ages.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;字典是否为空: <span class="hljs-subst">&#123;ages.Count == <span class="hljs-number">0</span>&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>快速查找</strong>：通过键快速获取对应的值，适用于存储和查找关联数据。</li><li><strong>频率统计</strong>：可用于统计某个元素出现的频率，如单词计数等。</li><li><strong>配置和选项</strong>：存储配置信息或选项，便于通过键快速访问。<br><code>Dictionary&lt;TKey, TValue&gt;</code> 是处理需要快速查找、存储键值对时非常有用的工具，适合多种数据管理和操作场景。</li></ul><h1 id="十六、-Dictionary和Hashtable区别"><a href="#十六、-Dictionary和Hashtable区别" class="headerlink" title="十六、  Dictionary和Hashtable区别"></a>十六、  Dictionary和Hashtable区别</h1><p><code>Dictionary&lt;TKey, TValue&gt;</code> 和 <code>Hashtable</code> 都是用于存储键值对的集合类型，但它们之间有几个重要的区别：</p><h3 id="1-类型安全"><a href="#1-类型安全" class="headerlink" title="1. 类型安全"></a>1. 类型安全</h3><ul><li><code>Dictionary&lt;TKey, TValue&gt;</code>：是泛型集合，提供类型安全，允许在编译时检查键和值的类型。例如，你可以定义 <code>Dictionary&lt;string, int&gt;</code>，这确保键是字符串，值是整数。</li><li><code>Hashtable</code>：是非泛型集合，可以存储任何类型的对象，键和值都是 <code>object</code> 类型。这意味着在运行时可能会遇到类型不匹配的问题，需要进行显式类型转换。</li></ul><h3 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h3><ul><li><code>Dictionary&lt;TKey, TValue&gt;</code>：因为它是泛型的，所以在使用时不需要进行装箱和拆箱，通常具有更好的性能。</li><li><code>Hashtable</code>：由于其使用 <code>object</code> 类型，可能需要装箱和拆箱，性能上可能会稍差。</li></ul><h3 id="3-访问方式"><a href="#3-访问方式" class="headerlink" title="3. 访问方式"></a>3. 访问方式</h3><ul><li><code>Dictionary&lt;TKey, TValue&gt;</code>：通过键访问值的方式更为简洁和直观，且支持更复杂的键类型（如自定义类型），并且提供方法如 <code>TryGetValue</code> 来尝试获取值而不抛出异常。</li><li><code>Hashtable</code>：使用 <code>ContainsKey</code> 和 <code>ContainsValue</code> 方法来检查键和值，且需要显式类型转换。</li></ul><h3 id="4-默认行为"><a href="#4-默认行为" class="headerlink" title="4. 默认行为"></a>4. 默认行为</h3><ul><li><code>Dictionary&lt;TKey, TValue&gt;</code>：在键不存在时，访问一个不存在的键会抛出 <code>KeyNotFoundException</code>。</li><li><code>Hashtable</code>：如果访问一个不存在的键，则返回 <code>null</code>。</li></ul><h3 id="5-可扩展性"><a href="#5-可扩展性" class="headerlink" title="5. 可扩展性"></a>5. 可扩展性</h3><ul><li><code>Dictionary&lt;TKey, TValue&gt;</code>：支持并发的集合，例如 <code>ConcurrentDictionary&lt;TKey, TValue&gt;</code>，适用于多线程环境。</li><li><code>Hashtable</code>：是线程安全的，但使用的同步方法可能会导致性能问题。</li></ul><h3 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是两个集合的基本用法示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Dictionary</span><br>        Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt; dictionary = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>&gt;<br>        &#123;<br>            &#123; <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span> &#125;,<br>            &#123; <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span> &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 访问值</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Alice&#x27;s age: <span class="hljs-subst">&#123;dictionary[<span class="hljs-string">&quot;Alice&quot;</span>]&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 Hashtable</span><br>        Hashtable hashtable = <span class="hljs-keyword">new</span> Hashtable<br>        &#123;<br>            &#123; <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">35</span> &#125;,<br>            &#123; <span class="hljs-string">&quot;Dave&quot;</span>, <span class="hljs-number">40</span> &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 访问值</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Charlie&#x27;s age: <span class="hljs-subst">&#123;hashtable[<span class="hljs-string">&quot;Charlie&quot;</span>]&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>在大多数情况下，建议使用 <code>Dictionary&lt;TKey, TValue&gt;</code> 而不是 <code>Hashtable</code>，因为其类型安全性、性能和功能更优越。<code>Hashtable</code> 主要是为了向后兼容，现代 C# 开发中更推荐使用泛型集合。</p><h1 id="十七、-LinkedList"><a href="#十七、-LinkedList" class="headerlink" title="十七、 LinkedList"></a>十七、 LinkedList</h1><p><code>LinkedList&lt;T&gt;</code> 是 C# 中的一种双向链表集合，提供了一种高效的方式来存储和操作数据。与数组或列表不同，链表中的元素（称为节点）是动态分配的，因此在插入和删除操作时具有更好的性能，特别是在大数据集的操作中。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>双向链表</strong>：<code>LinkedList&lt;T&gt;</code> 是一个双向链表，节点包含对前一个和后一个节点的引用，因此可以从任何节点轻松遍历链表。</li><li><strong>动态大小</strong>：可以在运行时动态添加或删除节点，无需重新分配整个集合的大小。</li><li><strong>无序存储</strong>：与数组和列表不同，<code>LinkedList&lt;T&gt;</code> 不保持元素的顺序，而是按插入顺序存储节点。</li></ol><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>以下是一些 <code>LinkedList&lt;T&gt;</code> 的常用方法：</p><ul><li><strong>添加元素</strong>：<ul><li><code>AddFirst(T value)</code>：在链表开头添加一个新节点。</li><li><code>AddLast(T value)</code>：在链表末尾添加一个新节点。</li><li><code>AddBefore(LinkedListNode&lt;T&gt; node, T value)</code>：在指定节点之前插入一个新节点。</li><li><code>AddAfter(LinkedListNode&lt;T&gt; node, T value)</code>：在指定节点之后插入一个新节点。</li></ul></li><li><strong>删除元素</strong>：<ul><li><code>Remove(T value)</code>：删除第一个匹配的节点。</li><li><code>RemoveFirst()</code>：删除链表的第一个节点。</li><li><code>RemoveLast()</code>：删除链表的最后一个节点。</li><li><code>Remove(LinkedListNode&lt;T&gt; node)</code>：删除指定的节点。</li></ul></li><li><strong>查找节点</strong>：<ul><li><code>Find(T value)</code>：查找第一个匹配的节点，未找到时返回 <code>null</code>。</li><li>没有提供找最后一个匹配的节点的方法，需要自己手动实现</li></ul></li><li><strong>遍历</strong>：<ul><li>可以使用 <code>foreach</code> 循环遍历链表中的节点。</li></ul></li><li>获取节点：<ul><li><strong><code>First</code></strong>: 获取链表的第一个节点。</li><li><strong><code>Last</code></strong>: 获取链表的最后一个节点。</li></ul></li><li>清空链表<ul><li><strong><code>Clear()</code></strong>: 清空链表中的所有节点。</li></ul></li><li>获取元素数量<ul><li><strong><code>Count</code></strong>: 获取链表中节点的数量。</li></ul></li><li>其他方法<ul><li><strong><code>Contains(T value)</code></strong>: 检查链表中是否包含指定的值。</li></ul></li></ul><h3 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>LinkedList&lt;T&gt;</code> 的简单示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 LinkedList</span><br>        LinkedList&lt;<span class="hljs-built_in">string</span>&gt; linkedList = <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-built_in">string</span>&gt;();<br><br>        <span class="hljs-comment">// 添加元素</span><br>        linkedList.AddLast(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        linkedList.AddLast(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        linkedList.AddFirst(<span class="hljs-string">&quot;Charlie&quot;</span>);<br><br>        <span class="hljs-comment">// 遍历链表</span><br>        Console.WriteLine(<span class="hljs-string">&quot;链表中的元素:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> linkedList)<br>        &#123;<br>            Console.WriteLine(name);<br>        &#125;<br><br>        <span class="hljs-comment">// 删除元素</span><br>        linkedList.Remove(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        linkedList.RemoveFirst();<br><br>        <span class="hljs-comment">// 遍历链表</span><br>        Console.WriteLine(<span class="hljs-string">&quot;\n删除 Bob 和第一个节点后的链表:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> linkedList)<br>        &#123;<br>            Console.WriteLine(name);<br>        &#125;<br><br>        <span class="hljs-comment">// 从头到尾遍历</span><br>        LinkedListNode&lt;<span class="hljs-built_in">string</span>&gt; nowNode = linkedList.First;<br>        <span class="hljs-keyword">while</span> (nowNode != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(nowNode.Value);<br>            nowNode = nowNode.Next;<br>        &#125;<br>        <span class="hljs-comment">// 从尾到头遍历</span><br>        nowNode = linkedList.Last;<br>        <span class="hljs-keyword">while</span> (nowNode != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(nowNode.Value);<br>            nowNode = nowNode.Previous;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找元素</span><br>        <span class="hljs-keyword">var</span> node = linkedList.Find(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;\n找到节点: <span class="hljs-subst">&#123;node.Value&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;\n未找到节点&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 添加元素</span><br>        linkedList.AddAfter(node, <span class="hljs-string">&quot;AddAfter&quot;</span>);<br>        linkedList.AddBefore(node, <span class="hljs-string">&quot;AddBefore&quot;</span>);<br><br>        <span class="hljs-comment">// 获取第一个和最后一个节点</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;第一个节点: <span class="hljs-subst">&#123;linkedList.First.Value&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;最后一个节点: <span class="hljs-subst">&#123;linkedList.Last.Value&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 修改</span><br>        linkedList.First.Value = <span class="hljs-string">&quot;修改了&quot;</span>;<br>        linkedList.Last.Value = <span class="hljs-string">&quot;修改了2&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">$&quot;第一个节点: <span class="hljs-subst">&#123;linkedList.First.Value&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;最后一个节点: <span class="hljs-subst">&#123;linkedList.Last.Value&#125;</span>&quot;</span>);<br>        <span class="hljs-comment">// 清空链表</span><br>        linkedList.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;链表清空后元素数量: <span class="hljs-subst">&#123;linkedList.Count&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>运行上述代码，输出将会是：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">链表中的元素:</span><br>Charlie<br>Alice<br>Bob<br><br>删除 Bob 和第一个节点后的链表:<br>Alice<br>Alice<br>Alice<br><br><span class="hljs-section">找到节点: Alice</span><br><span class="hljs-section">第一个节点: AddBefore</span><br><span class="hljs-section">最后一个节点: AddAfter</span><br><span class="hljs-section">第一个节点: 修改了</span><br><span class="hljs-section">最后一个节点: 修改了2</span><br><span class="hljs-section">链表清空后元素数量: 0</span><br><br></code></pre></td></tr></table></figure><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>频繁插入和删除</strong>：<code>LinkedList&lt;T&gt;</code> 特别适合频繁在集合的开头和中间插入和删除元素的场景，例如实现某些数据结构（如队列、栈或图）的底层逻辑。</li><li><strong>不需要随机访问</strong>：由于不支持索引访问，<code>LinkedList&lt;T&gt;</code> 不适合需要频繁随机访问的场景。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>LinkedList&lt;T&gt;</code> 提供了一个灵活且高效的方式来管理动态数据，尤其在插入和删除操作频繁的情况下表现出色。但在需要频繁随机访问的场景中，使用数组或列表可能更为合适。</p><h1 id="十八、-LinkedList和List区别"><a href="#十八、-LinkedList和List区别" class="headerlink" title="十八、  LinkedList和List区别"></a>十八、  LinkedList和List区别</h1><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><ul><li><code>List&lt;T&gt;</code> ： <ul><li>基于数组实现，是一个动态数组。</li><li>数据存储在连续的内存位置。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>基于双向链表实现，由一系列节点组成。</li><li>每个节点包含数据和指向前后节点的引用。</li></ul></li></ul><h3 id="2-存取性能"><a href="#2-存取性能" class="headerlink" title="2. 存取性能"></a>2. 存取性能</h3><ul><li><code>List&lt;T&gt;</code>：<ul><li>随机访问性能优越，索引访问（如 <code>list[0]</code>）的时间复杂度为 O(1)。</li><li>插入和删除元素的时间复杂度为 O(n)，因为可能需要移动大量元素。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>访问性能较差，索引访问的时间复杂度为 O(n)，因为必须从头部或尾部开始遍历。</li><li>插入和删除元素的时间复杂度为 O(1)，在已知节点的情况下非常高效。</li></ul></li></ul><h3 id="3-内存使用"><a href="#3-内存使用" class="headerlink" title="3. 内存使用"></a>3. 内存使用</h3><ul><li><code>List&lt;T&gt;</code>：<ul><li>内存占用相对较少，因为只需要存储元素本身。</li><li>当数组容量不足时，可能会进行扩展（复制到新数组），这会造成性能开销。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>每个节点需要额外的内存来存储前后节点的引用，因此内存使用较高。</li></ul></li></ul><h3 id="4-功能特性"><a href="#4-功能特性" class="headerlink" title="4. 功能特性"></a>4. 功能特性</h3><ul><li><code>List&lt;T&gt;</code>：<ul><li>提供了索引、排序、查找等多种方法。</li><li>适合需要频繁访问元素的场景。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>支持双向遍历，能够在任意位置高效插入和删除节点。</li><li>适合需要频繁添加和删除元素的场景，特别是在中间位置。</li></ul></li></ul><h3 id="5-适用场景"><a href="#5-适用场景" class="headerlink" title="5. 适用场景"></a>5. 适用场景</h3><ul><li><code>List&lt;T&gt;</code>：<ul><li>当数据量不频繁变化，且需要随机访问的情况，如实现栈、队列等功能。</li></ul></li><li><code>LinkedList&lt;T&gt;</code>：<ul><li>当数据量变化频繁，且需要频繁插入和删除元素的情况，如实现双向队列、最近使用缓存等功能。</li></ul></li></ul><h3 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// List&lt;T&gt; 示例</span><br>List&lt;<span class="hljs-built_in">int</span>&gt; numbersList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>numbersList.Add(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加元素</span><br><span class="hljs-built_in">int</span> secondNumber = numbersList[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 随机访问</span><br><br><span class="hljs-comment">// LinkedList&lt;T&gt; 示例</span><br>LinkedList&lt;<span class="hljs-built_in">int</span>&gt; numbersLinkedList = <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;);<br>numbersLinkedList.AddLast(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加元素</span><br>numbersLinkedList.Remove(<span class="hljs-number">2</span>); <span class="hljs-comment">// 删除元素</span><br><br></code></pre></td></tr></table></figure><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul><li>选择 <code>List&lt;T&gt;</code> 还是 <code>LinkedList&lt;T&gt;</code> 取决于具体需求。如果需要快速随机访问，使用 <code>List&lt;T&gt;</code> 更加合适；如果需要频繁的插入和删除操作，尤其是在中间位置，使用 <code>LinkedList&lt;T&gt;</code> 更加高效。</li></ul><h1 id="十九、-委托"><a href="#十九、-委托" class="headerlink" title="十九、  委托"></a>十九、  委托</h1><p>委托（Delegate）是 C# 中一种类型，代表对方法的引用，可以用于实现事件、回调和异步编程。委托允许将方法作为参数传递，并提供了一种灵活的方式来组织代码和实现解耦。</p><h3 id="1-委托的定义"><a href="#1-委托的定义" class="headerlink" title="1. 委托的定义"></a>1. 委托的定义</h3><p>委托定义了一种方法的签名（参数类型和返回类型），任何具有相同签名的方法都可以赋值给这个委托。可以理解为函数的容器，可以添加函数，不止添加一个</p><ul><li>默认的访问修饰符为public</li><li>一般写在namespace中，class中也可以写</li></ul><h3 id="2-委托的基本用法"><a href="#2-委托的基本用法" class="headerlink" title="2. 委托的基本用法"></a>2. 委托的基本用法</h3><h4 id="2-1-定义委托"><a href="#2-1-定义委托" class="headerlink" title="2.1 定义委托"></a>2.1 定义委托</h4><p>使用 <code>delegate</code> 关键字定义一个委托类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 访问修饰符 delegate 返回值 委托名(参数列表)</span><br><span class="hljs-comment">// 定义了一个返回值为void，参数为string的委托</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="2-2-实例化委托"><a href="#2-2-实例化委托" class="headerlink" title="2.2 实例化委托"></a>2.2 实例化委托</h4><p>将方法实例化为委托。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// 访问修饰符 delegate 返回值 委托名(参数列表)</span><br>    <span class="hljs-comment">// 定义了一个返回值为void，参数为string的委托</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>    <span class="hljs-comment">// 但是并没有使用这个函数</span><br>        MyDelegate del = MyMethod; <span class="hljs-comment">// 创建委托实例</span><br>        del(<span class="hljs-string">&quot;Hello, Delegates!&quot;</span>); <span class="hljs-comment">// 调用委托</span><br>        MyDelegate del2 = <span class="hljs-keyword">new</span> MyDelegate(MyMethod);<span class="hljs-comment">// 创建委托实例</span><br>        del2(<span class="hljs-string">&quot;你好，委托&quot;</span>);<span class="hljs-comment">// 调用委托</span><br>        del2.Invoke(<span class="hljs-string">&quot;你好委托2&quot;</span>);<span class="hljs-comment">// 调用委托</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-多播委托"><a href="#3-多播委托" class="headerlink" title="3. 多播委托"></a>3. 多播委托</h3><p>委托可以指向多个方法，这是所谓的多播委托。使用 <code>+=</code> 操作符可以将方法添加到委托中，使用 <code>-=</code> 操作符可以将方法从委托中移除。</p><ul><li>按顺序依次执行添加，并以依次执行</li><li>减的时候先减去后添加的</li><li>为空能加也能减</li><li>多减不会报错，无非只是不处理</li><li>委托 &#x3D; null,表示清空容器<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodA</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;MethodA: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodB</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;MethodB: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyDelegate del = MethodA; <span class="hljs-comment">// 创建委托实例，需要先初始化才行或者是del = null;</span><br>        <span class="hljs-comment">// 不可以直接用,比如</span><br>        <span class="hljs-comment">// MyDelegate del;</span><br>        del += MethodB; <span class="hljs-comment">// 添加方法</span><br><br>        del(<span class="hljs-string">&quot;Hello, Multicast Delegates!&quot;</span>); <span class="hljs-comment">// 调用所有方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-带参数和返回值的委托"><a href="#4-带参数和返回值的委托" class="headerlink" title="4. 带参数和返回值的委托"></a>4. 带参数和返回值的委托</h3><p>委托不仅可以没有返回值，也可以有返回值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MathOperation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Subtract</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x - y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MathOperation operation;<br><br>        operation = Add;<br>        Console.WriteLine(operation(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 8</span><br><br>        operation = Subtract;<br>        Console.WriteLine(operation(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-匿名方法"><a href="#5-匿名方法" class="headerlink" title="5. 匿名方法"></a>5. 匿名方法</h3><p>C# 允许使用匿名方法来创建委托，省略方法名称。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyDelegate del = <span class="hljs-built_in">delegate</span> (<span class="hljs-built_in">string</span> message)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Anonymous: &quot;</span> + message);<br>        &#125;;<br><br>        del(<span class="hljs-string">&quot;Hello, Anonymous Methods!&quot;</span>); <span class="hljs-comment">// 调用匿名方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Lambda-表达式"><a href="#6-Lambda-表达式" class="headerlink" title="6. Lambda 表达式"></a>6. Lambda 表达式</h3><p>从 C# 3.0 开始，支持使用 Lambda 表达式简化委托的创建。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyDelegate del = message =&gt; Console.WriteLine(<span class="hljs-string">&quot;Lambda: &quot;</span> + message);<br>        del(<span class="hljs-string">&quot;Hello, Lambda Expressions!&quot;</span>); <span class="hljs-comment">// 调用 Lambda 表达式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-委托作为函数参数"><a href="#7-委托作为函数参数" class="headerlink" title="7. 委托作为函数参数"></a>7. 委托作为函数参数</h3><p>在这个例子中，我们定义一个委托类型 <code>MathOperation</code>，然后创建一个接受委托作为参数的方法 <code>PerformOperation</code>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MathOperation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span>; <span class="hljs-comment">// 定义委托</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">PerformOperation</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y, MathOperation operation</span>) <span class="hljs-comment">// 委托作为参数</span></span><br>    &#123;<br>        <span class="hljs-keyword">return</span> operation(x, y); <span class="hljs-comment">// 调用委托</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x + y; <span class="hljs-comment">// 加法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Subtract</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x - y; <span class="hljs-comment">// 减法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Calculator calculator = <span class="hljs-keyword">new</span> Calculator();<br><br>        <span class="hljs-comment">// 使用委托调用加法</span><br>        <span class="hljs-built_in">int</span> resultAdd = calculator.PerformOperation(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, Add);<br>        Console.WriteLine(<span class="hljs-string">$&quot;5 + 3 = <span class="hljs-subst">&#123;resultAdd&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用委托调用减法</span><br>        <span class="hljs-built_in">int</span> resultSubtract = calculator.PerformOperation(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, Subtract);<br>        Console.WriteLine(<span class="hljs-string">$&quot;5 - 3 = <span class="hljs-subst">&#123;resultSubtract&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-委托作为类的成员"><a href="#8-委托作为类的成员" class="headerlink" title="8. 委托作为类的成员"></a>8. 委托作为类的成员</h3><p>在这个例子中，我们定义一个类 <code>Notifier</code>，其中包含一个委托类型的成员 <code>Notify</code>。这个委托可以指向任何符合签名的方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>; <span class="hljs-comment">// 定义委托</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Notifier</span><br>&#123;<br>    <span class="hljs-keyword">public</span> NotifyDelegate Notify; <span class="hljs-comment">// 委托作为类的成员</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendNotification</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Notify?.Invoke(message); <span class="hljs-comment">// 调用委托</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Notifier notifier = <span class="hljs-keyword">new</span> Notifier();<br><br>        <span class="hljs-comment">// 为委托分配方法</span><br>        notifier.Notify += message =&gt; Console.WriteLine(<span class="hljs-string">&quot;Notification: &quot;</span> + message);<br>        <br>        <span class="hljs-comment">// 发送通知</span><br>        notifier.SendNotification(<span class="hljs-string">&quot;Hello, this is a notification!&quot;</span>);<br>        <br>        <span class="hljs-comment">// 可以添加更多的订阅者</span><br>        notifier.Notify += message =&gt; Console.WriteLine(<span class="hljs-string">&quot;Another listener: &quot;</span> + message);<br>        <br>        <span class="hljs-comment">// 再次发送通知</span><br>        notifier.SendNotification(<span class="hljs-string">&quot;Another notification!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>委托作为函数参数</strong>：使得函数可以接受不同的操作，增加了灵活性。</li><li><strong>委托作为类的成员</strong>：允许类动态地调用不同的方法，方便实现事件处理或通知机制。</li></ul><h3 id="9-泛型委托"><a href="#9-泛型委托" class="headerlink" title="9. 泛型委托"></a>9. 泛型委托</h3><p>泛型委托允许在定义委托时指定一个或多个类型参数，使得委托可以支持不同的数据类型。下面是泛型委托的基本定义及其使用的示例：</p><h4 id="定义泛型委托"><a href="#定义泛型委托" class="headerlink" title="定义泛型委托"></a>定义泛型委托</h4><p>首先，定义一个泛型委托，它接受两个类型参数，并返回一个结果类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TOutput <span class="hljs-title">GenericDelegate</span>&lt;<span class="hljs-title">TInput1</span>, <span class="hljs-title">TInput2</span>, <span class="hljs-title">TOutput</span>&gt;(<span class="hljs-params">TInput1 input1, TInput2 input2</span>)</span>;<br></code></pre></td></tr></table></figure><p>这个泛型委托 <code>GenericDelegate</code> 有两个输入参数类型 <code>TInput1</code> 和 <code>TInput2</code>，返回一个结果类型 <code>TOutput</code>。</p><h4 id="使用泛型委托的示例"><a href="#使用泛型委托的示例" class="headerlink" title="使用泛型委托的示例"></a>使用泛型委托的示例</h4><p>使用上面定义的泛型委托，可以实现不同类型的操作。例如，实现一个函数，将两个数字相加并返回结果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 实例化泛型委托，传入两个int类型并返回int类型</span><br>        GenericDelegate&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (x, y) =&gt; x + y;<br>        <span class="hljs-built_in">int</span> sum = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Sum: <span class="hljs-subst">&#123;sum&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出：Sum: 7</span><br><br>        <span class="hljs-comment">// 实例化泛型委托，传入两个字符串并返回字符串的拼接结果</span><br>        GenericDelegate&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; concatenate = (s1, s2) =&gt; s1 + s2;<br>        <span class="hljs-built_in">string</span> result = concatenate(<span class="hljs-string">&quot;Hello, &quot;</span>, <span class="hljs-string">&quot;World!&quot;</span>);<br>        Console.WriteLine(result); <span class="hljs-comment">// 输出：Hello, World!</span><br><br>        <span class="hljs-comment">// 实例化泛型委托，传入int和double，返回字符串</span><br>        GenericDelegate&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">double</span>, <span class="hljs-built_in">string</span>&gt; combine = (x, y) =&gt; <span class="hljs-string">$&quot;Combined value: <span class="hljs-subst">&#123;x + y&#125;</span>&quot;</span>;<br>        <span class="hljs-built_in">string</span> combinedResult = combine(<span class="hljs-number">5</span>, <span class="hljs-number">7.5</span>);<br>        Console.WriteLine(combinedResult); <span class="hljs-comment">// 输出：Combined value: 12.5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h4><ul><li><code>add</code>：这是一个泛型委托的实例，用于将两个整数相加并返回结果。它的类型参数为 <code>&lt;int, int, int&gt;</code>，表示输入参数和返回值的类型都是 <code>int</code>。</li><li><code>concatenate</code>：用于将两个字符串拼接在一起，并返回拼接结果。其类型参数为 <code>&lt;string, string, string&gt;</code>，表示输入参数和返回值的类型都是 <code>string</code>。</li><li><code>combine</code>：用于将一个整数和一个双精度浮点数相加，并返回结果字符串。其类型参数为 <code>&lt;int, double, string&gt;</code>，表示输入参数分别是 <code>int</code> 和 <code>double</code>，返回值为 <code>string</code>。</li></ul><h3 id="10-使用场景"><a href="#10-使用场景" class="headerlink" title="10. 使用场景"></a>10. 使用场景</h3><ul><li><strong>事件处理</strong>：委托常用于事件处理机制。</li><li><strong>回调</strong>：可以用作异步方法的回调。</li><li><strong>LINQ</strong>：在 LINQ 中广泛使用委托（如 <code>Func&lt;T&gt;</code> 和 <code>Action&lt;T&gt;</code>）。</li></ul><h1 id="二十、-系统定义好的委托"><a href="#二十、-系统定义好的委托" class="headerlink" title="二十、 系统定义好的委托"></a>二十、 系统定义好的委托</h1><p>C# 提供了一些常用的系统定义的委托，用于简化和通用地表达各种方法签名。这些委托类型定义在 <code>System</code> 命名空间中，最常用的系统定义委托包括：</p><ul><li>委托的名字不能和函数一样，不然还是委托，会重复添加之前委托中所有的函数</li></ul><ol><li><strong>Action 系列</strong><br> <code>Action</code> 委托用于定义没有返回值的方法。可以有 0 到 16 个参数。<ul><li><code>Action</code>：没有参数的委托，表示不接受参数且无返回值的方法。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action action = () =&gt; Console.WriteLine(<span class="hljs-string">&quot;Hello, Action!&quot;</span>);<br>action(); <span class="hljs-comment">// 输出：Hello, Action!</span><br></code></pre></td></tr></table></figure></li><li><code>Action&lt;T1&gt;</code>：一个参数的委托。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action&lt;<span class="hljs-built_in">string</span>&gt; greet = name =&gt; Console.WriteLine(<span class="hljs-string">$&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span>);<br>greet(<span class="hljs-string">&quot;Alice&quot;</span>); <span class="hljs-comment">// 输出：Hello, Alice!</span><br></code></pre></td></tr></table></figure></li><li><code>Action&lt;T1, T2&gt;</code>：两个参数的委托。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; Console.WriteLine(a + b);<br><span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 输出：7</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong>Func 系列</strong><br> <code>Func</code> 委托用于定义有返回值的方法。它的最后一个类型参数始终表示返回类型，前面的类型参数表示输入参数。<ul><li><code>Func&lt;TResult&gt;</code>：没有参数的方法，返回一个值。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>&gt; getRandomNumber = () =&gt; <span class="hljs-keyword">new</span> Random().Next(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">int</span> randomNumber = getRandomNumber();<br>Console.WriteLine(randomNumber);<br></code></pre></td></tr></table></figure></li><li><code>Func&lt;T1, TResult&gt;</code>：一个参数的方法，返回一个值。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; square = x =&gt; x * x;<br><span class="hljs-built_in">int</span> result = square(<span class="hljs-number">5</span>); <span class="hljs-comment">// 结果为 25</span><br>Console.WriteLine(result); <br></code></pre></td></tr></table></figure></li><li><code>Func&lt;T1, T2, TResult&gt;</code>：两个参数的方法，返回一个值。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; a + b;<br><span class="hljs-built_in">int</span> sum = <span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 结果为 7</span><br>Console.WriteLine(sum);<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>Predicate 系列</strong><br> <code>Predicate&lt;T&gt;</code> 委托用于定义返回布尔值的方法，接受一个输入参数。<ul><li><code>Predicate&lt;T&gt;</code>：接受一个参数并返回 <code>bool</code> 类型的委托，用于确定某个条件是否满足。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Predicate&lt;<span class="hljs-built_in">int</span>&gt; isEven = x =&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br><span class="hljs-built_in">bool</span> check = isEven(<span class="hljs-number">4</span>); <span class="hljs-comment">// 结果为 true</span><br>Console.WriteLine(check);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul><li><code>Action</code> 系列用于不返回值的方法，可以有 0 到 16 个参数。</li><li><code>Func</code> 系列用于有返回值的方法，最后一个泛型参数表示返回值类型，其余参数表示输入参数。</li><li><code>Predicate&lt;T&gt;</code> 专门用于判断某个条件，返回 <code>bool</code> 值。</li></ul><h1 id="二十一、-事件"><a href="#二十一、-事件" class="headerlink" title="二十一、  事件"></a>二十一、  事件</h1><p>事件（Event）是 C# 中的一种特殊委托，用于通知订阅者在某个操作发生时执行相应的操作。事件通常用于实现发布&#x2F;订阅模式，使得对象可以向外界通知状态变化或某些操作的发生。</p><ul><li>事件是作为成员变量存在于类中</li><li>委托怎么用，事件怎么用</li><li>事件相对于委托的区别<ul><li>不能在类外部赋值</li><li>不能在类外部调用</li><li>可以在类外部添加或者删除函数</li><li>事件只能作为成员存在于类和接口以及结构体中</li><li>不能作为临时变量在函数中使用</li></ul></li></ul><h3 id="1-定义事件"><a href="#1-定义事件" class="headerlink" title="1. 定义事件"></a>1. 定义事件</h3><p>事件的定义基于委托类型，事件本质上是一个委托类型的实例，但增加了一些限制，以确保事件只能在事件声明的类中调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义一个委托</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-comment">// 定义一个包含事件的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-comment">// 声明事件</span><br>    <span class="hljs-comment">// 访问修饰符 event 委托类型 事件名;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> NotifyEventHandler Notify;<br><br>    <span class="hljs-comment">// 方法触发事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件，通知所有订阅者</span><br>        Notify?.Invoke(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-订阅事件"><a href="#2-订阅事件" class="headerlink" title="2. 订阅事件"></a>2. 订阅事件</h3><p>可以通过创建事件处理方法来订阅事件，当事件触发时，会调用这些处理方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 定义一个委托</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-comment">// 定义一个包含事件的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-comment">// 声明事件</span><br>    <span class="hljs-comment">// 访问修饰符 event 委托类型 事件名;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> NotifyEventHandler Notify;<br><br>    <span class="hljs-comment">// 方法触发事件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件，通知所有订阅者</span><br>        Notify?.Invoke(message);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber</span><br>&#123;<br>    <span class="hljs-comment">// 事件处理方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNotifyReceived</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Subscriber received: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br>        Subscriber subscriber = <span class="hljs-keyword">new</span> Subscriber();<br><br>        <span class="hljs-comment">// 订阅事件,添加了两次</span><br>        publisher.Notify += subscriber.OnNotifyReceived;<br>        publisher.Notify += subscriber.OnNotifyReceived;<br><br>        <span class="hljs-comment">// 触发事件，会调用所有添加的事件</span><br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Hello, Event!&quot;</span>);<br><br>        <span class="hljs-comment">// 取消订阅事件</span><br>        publisher.Notify -= subscriber.OnNotifyReceived;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-代码解释"><a href="#3-代码解释" class="headerlink" title="3. 代码解释"></a>3. 代码解释</h3><ul><li><strong>定义委托</strong>：<code>NotifyEventHandler</code> 是一个接受 <code>string</code> 类型参数并返回 <code>void</code> 的委托类型。</li><li><strong>定义事件</strong>：<code>Notify</code> 是一个基于 <code>NotifyEventHandler</code> 委托类型的事件，声明在 <code>Publisher</code> 类中。</li><li><strong>触发事件</strong>：通过调用 <code>TriggerEvent</code> 方法来触发 <code>Notify</code> 事件，并使用 <code>?.Invoke</code> 语法安全地调用事件订阅者。</li><li><strong>订阅和取消订阅事件</strong>：<code>+=</code> 操作符用于订阅事件，<code>-=</code> 操作符用于取消订阅。</li></ul><h3 id="4-多播事件"><a href="#4-多播事件" class="headerlink" title="4. 多播事件"></a>4. 多播事件</h3><p>事件可以有多个订阅者，这些订阅者的方法会按顺序被调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber2</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnotherEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Subscriber2 received: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br>        Subscriber subscriber1 = <span class="hljs-keyword">new</span> Subscriber();<br>        Subscriber2 subscriber2 = <span class="hljs-keyword">new</span> Subscriber2();<br><br>        <span class="hljs-comment">// 订阅多个事件处理器</span><br>        publisher.Notify += subscriber1.OnNotifyReceived;<br>        publisher.Notify += subscriber2.AnotherEventHandler;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Hello, Multicast Event!&quot;</span>);<br><br>        <span class="hljs-comment">// 输出两个订阅者的消息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-使用内置的-EventHandler"><a href="#5-使用内置的-EventHandler" class="headerlink" title="5. 使用内置的 EventHandler"></a>5. 使用内置的 <code>EventHandler</code></h3><p>C# 提供了一个标准的 <code>EventHandler</code> 委托类型以及泛型的 <code>EventHandler&lt;TEventArgs&gt;</code>，它们用来更简洁地定义事件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PublisherWithEventHandler</span><br>&#123;<br>    <span class="hljs-comment">// 使用 EventHandler&lt;TEventArgs&gt; 定义事件</span><br>    <span class="hljs-comment">// public delegate void EventHandler(object? sender, EventArgs e);</span><br>    <span class="hljs-comment">// public delegate void EventHandler&lt;TEventArgs&gt;(object? sender, TEventArgs e);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;CustomEventArgs&gt; Notify;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Notify?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> CustomEventArgs &#123; Message = message &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        PublisherWithEventHandler publisher = <span class="hljs-keyword">new</span> PublisherWithEventHandler();<br>        publisher.Notify += (sender, e) =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Received message: <span class="hljs-subst">&#123;e.Message&#125;</span>&quot;</span>);<br>        &#125;;<br><br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Using EventHandler!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>以下是对代码的详细解释：</li></ul><h4 id="1-CustomEventArgs-类"><a href="#1-CustomEventArgs-类" class="headerlink" title="1. CustomEventArgs 类"></a>1. <code>CustomEventArgs</code> 类</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>CustomEventArgs</code> 是一个自定义的事件参数类，继承自 <code>EventArgs</code>，这符合 .NET 事件处理的惯例。</li><li>它包含一个 <code>Message</code> 属性，用于传递事件的附加信息。</li></ul><h4 id="2-PublisherWithEventHandler-类"><a href="#2-PublisherWithEventHandler-类" class="headerlink" title="2. PublisherWithEventHandler 类"></a>2. <code>PublisherWithEventHandler</code> 类</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PublisherWithEventHandler</span><br>&#123;<br>    <span class="hljs-comment">// 使用 EventHandler&lt;TEventArgs&gt; 定义事件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;CustomEventArgs&gt; Notify;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Notify?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> CustomEventArgs &#123; Message = message &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>PublisherWithEventHandler</code> 是发布事件的类，包含一个名为 <code>Notify</code> 的事件，使用 <code>EventHandler&lt;CustomEventArgs&gt;</code> 泛型委托来定义。<ul><li><code>EventHandler&lt;TEventArgs&gt;</code> 是一个内置的事件委托，允许指定一个类型 <code>TEventArgs</code> 来传递事件数据。在这里，<code>TEventArgs</code> 被替换为自定义的 <code>CustomEventArgs</code> 类型。</li></ul></li><li><code>TriggerEvent</code> 方法用于触发事件，并传递一个消息字符串作为事件数据。<ul><li><code>Notify?.Invoke(this, new CustomEventArgs &#123; Message = message &#125;)</code> 这行代码用于触发事件，其中 <code>this</code> 表示事件的发送者，<code>new CustomEventArgs &#123; Message = message &#125;</code> 创建了一个新的 <code>CustomEventArgs</code> 对象，将 <code>Message</code> 属性设为传入的 <code>message</code> 参数。</li></ul></li></ul><h4 id="3-订阅和触发事件-Main-方法"><a href="#3-订阅和触发事件-Main-方法" class="headerlink" title="3. 订阅和触发事件 (Main 方法)"></a>3. 订阅和触发事件 (<code>Main</code> 方法)</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        PublisherWithEventHandler publisher = <span class="hljs-keyword">new</span> PublisherWithEventHandler();<br><br>        <span class="hljs-comment">// 订阅事件，使用 Lambda 表达式作为事件处理程序</span><br>        publisher.Notify += (sender, e) =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Received message: <span class="hljs-subst">&#123;e.Message&#125;</span>&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Using EventHandler!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建了一个 <code>PublisherWithEventHandler</code> 类的实例 <code>publisher</code>。</li><li>使用 <code>+=</code> 运算符订阅 <code>Notify</code> 事件，将一个 Lambda 表达式作为事件处理程序。<ul><li>该 Lambda 表达式接受两个参数：<code>sender</code>（事件的发送者）和 <code>e</code>（事件数据），这里的 <code>e</code> 类型为 <code>CustomEventArgs</code>。</li><li>处理程序中打印了 <code>e.Message</code> 的值，从而输出事件传递的消息内容。</li></ul></li><li>调用 <code>TriggerEvent</code> 方法触发事件，传递字符串 <code>&quot;Using EventHandler!&quot;</code>，这会导致事件处理程序被调用，并输出 <code>Received message: Using EventHandler!</code>。</li></ul><h4 id="4-代码的工作原理"><a href="#4-代码的工作原理" class="headerlink" title="4. 代码的工作原理"></a>4. 代码的工作原理</h4><ol><li>定义了一个自定义的事件参数类 <code>CustomEventArgs</code>，包含一个 <code>Message</code> 属性。</li><li><code>PublisherWithEventHandler</code> 类通过 <code>EventHandler&lt;CustomEventArgs&gt;</code> 定义了一个事件 <code>Notify</code>，并提供 <code>TriggerEvent</code> 方法来触发事件。</li><li>在 <code>Main</code> 方法中，创建发布者对象并订阅 <code>Notify</code> 事件。</li><li>当事件被触发时，订阅的处理程序会被调用，并接收到传递的消息。</li></ol><h4 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h4><ul><li><strong>事件</strong>用于通知订阅者某个动作发生。</li><li><strong>事件的定义基于委托类型</strong>，可以有多个订阅者。</li><li><strong>事件触发时</strong>，会通知所有已订阅的方法。</li><li><strong><code>EventHandler</code> 和 <code>EventHandler&lt;TEventArgs&gt;</code></strong> 是内置的委托类型，用于更方便地定义事件。<br>事件机制非常适合处理用户输入、状态变化以及异步通知等场景。</li></ul><h1 id="二十二、-EventArgs"><a href="#二十二、-EventArgs" class="headerlink" title="二十二、  EventArgs"></a>二十二、  EventArgs</h1><p><code>EventArgs</code> 是 .NET 中定义的一个基类，用于传递事件相关的信息。它位于 <code>System</code> 命名空间中，并且是所有事件参数类的基类。<code>EventArgs</code> 的作用是为事件处理程序提供一个基础类型，可以在事件被触发时传递事件的相关数据。</p><ul><li>也即是说所有的事件都可以继承EventArgs，类似object</li></ul><h3 id="1-EventArgs-的定义"><a href="#1-EventArgs-的定义" class="headerlink" title="1. EventArgs 的定义"></a>1. <code>EventArgs</code> 的定义</h3><p>在 .NET 框架中，<code>EventArgs</code> 定义如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> EventArgs Empty;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>EventArgs</code> 是一个空类，不包含任何属性或方法。它的主要作用是作为事件参数的基类，或在事件不需要传递额外数据时使用。</li><li><code>EventArgs.Empty</code> 是一个静态只读字段，表示没有数据的 <code>EventArgs</code> 实例，可以用于不需要传递数据的事件。</li><li><code>readonly</code> 是 C# 中的一个关键字，用于在字段声明中指明字段的值在对象的整个生命周期中只能被赋值一次。<code>readonly</code> 关键字可以确保字段一旦被初始化，就不会再被修改，这种特性适用于对数据的安全性和稳定性有要求的场景。<ul><li><code>readonly</code> 字段可以在声明时初始化，也可以在构造函数中赋值。</li><li>一旦在构造函数或字段声明中赋值后，<code>readonly</code> 字段的值就不能再被更改。</li><li><code>readonly</code> 字段的值在运行时确定，而不是编译时（与 <code>const</code> 相比）。</li><li>在静态字段中使用 <code>readonly</code>，可以在静态构造函数中赋值。</li><li>示例代码<ul><li>示例1：声明时初始化  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span><br>&#123;<br>    <span class="hljs-comment">// readonly 字段，在声明时赋值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">double</span> Pi = <span class="hljs-number">3.14159</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintPi</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Pi: <span class="hljs-subst">&#123;Pi&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Circle circle = <span class="hljs-keyword">new</span> Circle();<br>        circle.PrintPi(); <span class="hljs-comment">// 输出：Pi: 3.14159</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，<code>Pi</code> 是一个 <code>readonly</code> 字段，在声明时就被赋值为 <code>3.14159</code>，并且在对象生命周期内不会改变。<br>  示例2：在构造函数中赋值  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// readonly 字段，未在声明时初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> Name;<br><br>    <span class="hljs-comment">// 构造函数中赋值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintName</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;Name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        person.PrintName(); <span class="hljs-comment">// 输出：Name: Alice</span><br><br>        <span class="hljs-comment">// person.Name = &quot;Bob&quot;; // 编译错误：无法为 readonly 字段赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，<code>Name</code> 是一个 <code>readonly</code> 字段，通过构造函数进行初始化，一旦对象被创建后，该字段的值就不能被更改。</li><li>示例3：静态 <code>readonly</code> 字段  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Config</span><br>&#123;<br>    <span class="hljs-comment">// 静态 readonly 字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> AppName;<br><br>    <span class="hljs-comment">// 静态构造函数中初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Config</span>()</span><br>    &#123;<br>        AppName = <span class="hljs-string">&quot;MyApplication&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintAppName</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;App Name: <span class="hljs-subst">&#123;AppName&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Config.PrintAppName(); <span class="hljs-comment">// 输出：App Name: MyApplication</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个示例中，<code>AppName</code> 是一个静态 <code>readonly</code> 字段，在静态构造函数中初始化，这样在整个程序生命周期中该字段的值都是固定的。</li></ul></li></ul></li></ul><h3 id="2-使用-EventArgs-的场景"><a href="#2-使用-EventArgs-的场景" class="headerlink" title="2. 使用 EventArgs 的场景"></a>2. 使用 <code>EventArgs</code> 的场景</h3><p><code>EventArgs</code> 通常在定义事件时作为参数类型。如果一个事件不需要额外的参数，就可以使用 <code>EventArgs</code>。如果需要传递额外的信息，可以创建一个自定义的类，继承自 <code>EventArgs</code>。</p><h4 id="示例1：不传递任何数据的事件"><a href="#示例1：不传递任何数据的事件" class="headerlink" title="示例1：不传递任何数据的事件"></a>示例1：不传递任何数据的事件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个事件，使用 EventArgs 作为参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler SimpleEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件时使用 EventArgs.Empty 传递</span><br>        SimpleEvent?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        publisher.SimpleEvent += (sender, e) =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;SimpleEvent triggered&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.TriggerEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个例子中，<code>SimpleEvent</code> 使用 <code>EventArgs</code> 作为事件参数，因为不需要传递额外的信息。</li><li>触发事件时使用 <code>EventArgs.Empty</code>，表示不需要任何附加数据。</li><li><code>EventHandler</code> 是 C# 中的一个委托类型，用于定义事件处理方法的标准签名。它是事件机制的核心，用来指定事件处理方法的参数格式。<code>EventHandler</code> 提供了一种标准的方式来处理事件，使事件的声明和使用变得简单和一致。</li><li><code>EventHandler</code> 是一个预定义的委托类型，表示事件处理方法不需要自定义事件数据时的标准签名。</li><li>它的标准方法签名是：<code>void EventHandler(object sender, EventArgs e)</code>。<ul><li><code>sender</code>：事件的发送者，即引发事件的对象。</li><li><code>e</code>：事件数据的对象，通常是 <code>EventArgs</code> 或其派生类的实例。</li></ul></li></ul><h3 id="3-自定义-EventArgs-类"><a href="#3-自定义-EventArgs-类" class="headerlink" title="3. 自定义 EventArgs 类"></a>3. 自定义 <code>EventArgs</code> 类</h3><p>当需要传递附加的事件数据时，可以创建一个继承自 <code>EventArgs</code> 的自定义类。</p><h4 id="示例2：传递额外数据的事件"><a href="#示例2：传递额外数据的事件" class="headerlink" title="示例2：传递额外数据的事件"></a>示例2：传递额外数据的事件</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 自定义的 EventArgs 类，继承自 EventArgs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CustomEventArgs</span> : <span class="hljs-title">EventArgs</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PublisherWithEventArgs</span><br>&#123;<br>    <span class="hljs-comment">// 使用自定义的 EventArgs 类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler&lt;CustomEventArgs&gt; CustomEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerCustomEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件，传递 CustomEventArgs 实例</span><br>        CustomEvent?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> CustomEventArgs &#123; Message = message &#125;);<br>        <span class="hljs-comment">//new CustomEventArgs &#123; Message = message &#125; 这段代码做了以下工作：</span><br>        <span class="hljs-comment">//new CustomEventArgs：创建了一个新的 CustomEventArgs 类型的实例。</span><br>        <span class="hljs-comment">//&#123; Message = message &#125;：使用对象初始化器对 Message 属性进行赋值，将传入的 message 值赋给该属性。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        PublisherWithEventArgs publisher = <span class="hljs-keyword">new</span> PublisherWithEventArgs();<br><br>        <span class="hljs-comment">// 订阅事件，处理传递的自定义事件参数</span><br>        <span class="hljs-comment">// 这边的e是自定义的一个EventArgs的事件，可以使用里面的Message参数</span><br>        publisher.CustomEvent += (sender, e) =&gt;<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;Custom event triggered with message: <span class="hljs-subst">&#123;e.Message&#125;</span>&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">// 触发事件，传递消息</span><br>        publisher.TriggerCustomEvent(<span class="hljs-string">&quot;Hello, EventArgs!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在这个示例中，<code>CustomEventArgs</code> 继承自 <code>EventArgs</code>，增加了一个 <code>Message</code> 属性。</li><li>当触发事件时，将 <code>CustomEventArgs</code> 实例作为事件参数传递，以便处理程序使用。</li></ul><h3 id="4-EventArgs-的作用"><a href="#4-EventArgs-的作用" class="headerlink" title="4. EventArgs 的作用"></a>4. <code>EventArgs</code> 的作用</h3><ul><li><code>EventArgs</code> 提供了一种标准化的方式来定义事件参数。</li><li>通过继承 <code>EventArgs</code>，可以创建自定义事件参数类，添加额外的数据属性，以适应具体的事件需求。</li><li><code>EventHandler&lt;TEventArgs&gt;</code> 泛型委托与自定义的 <code>EventArgs</code> 类结合使用，使得事件处理程序可以获得类型安全的事件数据。<br>总结来说，<code>EventArgs</code> 是事件处理系统的一个基础元素，为事件参数提供了一个统一的基类，同时支持自定义扩展，满足不同事件的数据需求。</li></ul><h1 id="二十三、-对象初始化器"><a href="#二十三、-对象初始化器" class="headerlink" title="二十三、 对象初始化器"></a>二十三、 对象初始化器</h1><p>对象初始化器是一种简洁的语法，用于在创建对象的同时设置其公共属性或字段的值。它允许在对象实例化的过程中，使用花括号 <code>&#123;&#125;</code> 来指定属性或字段的初始值，而不必通过构造函数逐个进行赋值。</p><h3 id="使用对象初始化器的语法"><a href="#使用对象初始化器的语法" class="headerlink" title="使用对象初始化器的语法"></a>使用对象初始化器的语法</h3><p>基本语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> objectName = <span class="hljs-keyword">new</span> ClassName<br>&#123;<br>    Property1 = value1,<br>    Property2 = value2,<br>    <span class="hljs-comment">// ...其他属性</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方式在创建对象的同时，通过初始化列表的形式赋值给对象的属性或字段。</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><h4 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1. 类的定义"></a>1. 类的定义</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用对象初始化器来创建对象"><a href="#2-使用对象初始化器来创建对象" class="headerlink" title="2. 使用对象初始化器来创建对象"></a>2. 使用对象初始化器来创建对象</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person<br>&#123;<br>    Name = <span class="hljs-string">&quot;Alice&quot;</span>,<br>    Age = <span class="hljs-number">25</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码做了以下操作：</p><ul><li>使用 <code>new Person</code> 创建了一个新的 <code>Person</code> 类型的对象。</li><li>使用 <code>&#123; Name = &quot;Alice&quot;, Age = 25 &#125;</code> 初始化了 <code>Name</code> 和 <code>Age</code> 两个属性。<br>这种写法等价于以下代码，但更加简洁：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br>person.Name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>person.Age = <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="对象初始化器的优点"><a href="#对象初始化器的优点" class="headerlink" title="对象初始化器的优点"></a>对象初始化器的优点</h3><ol><li><strong>简洁</strong>：减少了代码量，使代码更加简洁易读。</li><li><strong>易于维护</strong>：在对象创建时可以同时初始化多个属性的值，避免后续的逐个赋值。</li><li><strong>灵活性</strong>：可以用于各种引用类型对象的初始化，包括类、结构、集合等。</li></ol><h3 id="使用对象初始化器与集合初始化器结合"><a href="#使用对象初始化器与集合初始化器结合" class="headerlink" title="使用对象初始化器与集合初始化器结合"></a>使用对象初始化器与集合初始化器结合</h3><p>对象初始化器也可以与集合初始化器结合使用，方便地初始化集合中的对象。</p><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> people = <span class="hljs-keyword">new</span> List&lt;Person&gt;<br>&#123;<br>    <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span>, Age = <span class="hljs-number">25</span> &#125;,<br>    <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Bob&quot;</span>, Age = <span class="hljs-number">30</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>people</code> 是一个 <code>List&lt;Person&gt;</code> 类型的集合，通过集合初始化器直接初始化了多个 <code>Person</code> 对象。</p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>对象初始化器不仅适用于类的属性初始化，也可以用于匿名类型、结构、集合等场景。</p><h1 id="二十四、-委托和事件的区别"><a href="#二十四、-委托和事件的区别" class="headerlink" title="二十四、  委托和事件的区别"></a>二十四、  委托和事件的区别</h1><p>委托和事件是 C# 中用于实现事件驱动编程的重要概念。虽然它们有许多相似之处，但它们之间也存在一些关键的区别。下面是委托和事件的定义、用途以及它们之间的区别。</p><h3 id="1-委托-Delegate"><a href="#1-委托-Delegate" class="headerlink" title="1. 委托 (Delegate)"></a>1. 委托 (Delegate)</h3><p><strong>定义</strong>：委托是一种类型安全的函数指针，可以引用具有特定参数列表和返回类型的方法。委托可以用来定义回调方法。<br><strong>用法</strong>：</p><ul><li>委托可以直接调用。</li><li>可以通过委托实例添加或移除方法。</li><li>委托可以被多播，即一个委托可以指向多个方法。<br><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Notify notifyDelegate = ShowMessage;<br>        notifyDelegate(<span class="hljs-string">&quot;Hello, Delegates!&quot;</span>); <span class="hljs-comment">// 调用委托</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-事件-Event"><a href="#2-事件-Event" class="headerlink" title="2. 事件 (Event)"></a>2. 事件 (Event)</h3><p><strong>定义</strong>：事件是基于委托的，专门用于处理事件通知的机制。它提供了一种在对象之间发布和订阅消息的方式。<br><strong>用法</strong>：</p><ul><li>事件通常是由类定义的，使用委托作为事件的类型。</li><li>事件通常只能被类的内部代码触发，外部代码只能订阅或取消订阅。</li><li>使用事件可以防止外部代码直接调用事件的处理方法，从而保护对象的状态。<br><strong>示例</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Notify</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Notify NotifyEvent; <span class="hljs-comment">// 声明事件</span><br>    <span class="hljs-keyword">public</span> Notify NotifyDelegate; <span class="hljs-comment">// 声明事件</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        NotifyEvent?.Invoke(message); <span class="hljs-comment">// 触发事件</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br><br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br><br>        publisher.NotifyEvent += ShowMessage; <span class="hljs-comment">// 订阅事件</span><br>        publisher.NotifyDelegate += ShowMessage; <span class="hljs-comment">// 订阅事件</span><br>        <span class="hljs-comment">// publisher.NotifyEvent(&quot;111&quot;); // 报错,不可以在类外调用</span><br>        publisher.NotifyDelegate(<span class="hljs-string">&quot;111&quot;</span>);<br>        publisher.TriggerEvent(<span class="hljs-string">&quot;Hello, Events!&quot;</span>); <span class="hljs-comment">// 触发事件</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-委托和事件的区别"><a href="#3-委托和事件的区别" class="headerlink" title="3. 委托和事件的区别"></a>3. 委托和事件的区别</h3><table><thead><tr><th>特征</th><th>委托</th><th>事件</th></tr></thead><tbody><tr><td>定义</td><td>委托是一种类型，可以直接调用。</td><td>事件是基于委托的，专门用于处理事件通知的机制。</td></tr><tr><td>访问修饰符</td><td>委托可以具有公共或私有修饰符。</td><td>事件通常使用 <code>public</code> 修饰符，但可以通过 <code>add</code> 和 <code>remove</code> 访问器限制访问。</td></tr><tr><td>触发</td><td>可以直接调用委托的方法。</td><td>事件只能由其定义的类内部触发。</td></tr><tr><td>订阅和取消</td><td>委托没有内置的订阅和取消机制。</td><td>事件支持订阅和取消机制，使用 <code>+=</code> 和 <code>-=</code> 操作符。</td></tr><tr><td>事件处理方法</td><td>委托可以直接存储任何匹配其签名的方法。</td><td>事件处理方法不能被外部代码直接调用。</td></tr><tr><td>多播支持</td><td>委托可以多播（即引用多个方法）。</td><td>事件通常是多播的，但它们的处理方法在内部进行管理。</td></tr></tbody></table><h4 id="事件通常使用-public-修饰符，但可以通过-add-和-remove-访问器限制访问。"><a href="#事件通常使用-public-修饰符，但可以通过-add-和-remove-访问器限制访问。" class="headerlink" title="事件通常使用 public 修饰符，但可以通过 add 和 remove 访问器限制访问。"></a>事件通常使用 <code>public</code> 修饰符，但可以通过 <code>add</code> 和 <code>remove</code> 访问器限制访问。</h4><p>在 C# 中，事件可以通过 <code>public</code> 修饰符声明，但其访问级别可以通过 <code>add</code> 和 <code>remove</code> 访问器进行限制。这种机制提供了更好的封装性，允许开发者控制谁可以订阅或取消订阅事件。其实就是在添加或者删除事件的时候提前进行处理。</p><h4 id="访问器的用法"><a href="#访问器的用法" class="headerlink" title="访问器的用法"></a>访问器的用法</h4><ul><li><strong><code>add</code> 访问器</strong>：用于添加事件处理程序。</li><li><strong><code>remove</code> 访问器</strong>：用于移除事件处理程序。</li></ul><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>以下是一个使用 <code>add</code> 和 <code>remove</code> 访问器限制访问的事件示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个私有字段来存储事件处理程序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">event</span> EventHandler _notify;<br><br>    <span class="hljs-comment">// 公开的事件，使用 add 和 remove 访问器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler Notify<br>    &#123;<br><br>        <span class="hljs-comment">// 在 C# 中，value 是一个关键字，用于 add 和 remove 访问器中的参数，</span><br>        <span class="hljs-comment">// 它代表即将被添加或移除的事件处理程序（即方法）。</span><br>        <span class="hljs-comment">// 当你使用 += 或 -= 操作符来订阅或取消订阅事件时，value 充当被传递的委托（delegate）。</span><br>        <span class="hljs-keyword">add</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Subscribing to the event.&quot;</span>);<br>            _notify += <span class="hljs-keyword">value</span>; <span class="hljs-comment">// 订阅事件 // 这里的 value 是传入的事件处理程序</span><br>        &#125;<br>        <span class="hljs-keyword">remove</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Unsubscribing from the event.&quot;</span>);<br>            _notify -= <span class="hljs-keyword">value</span>; <span class="hljs-comment">// 取消订阅事件 // 这里的 value 是要取消订阅的事件处理程序</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TriggerEvent</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 触发事件</span><br>        _notify?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Subscribe</span>(<span class="hljs-params">Publisher publisher</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 订阅事件,给订阅者订阅，让发布者发布消息的时候给订阅者，每次都调用订阅者里面的方法</span><br>        publisher.Notify += OnNotify;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Unsubscribe</span>(<span class="hljs-params">Publisher publisher</span>)</span><br>    &#123;<br>        publisher.Notify -= OnNotify; <span class="hljs-comment">// 取消订阅事件</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNotify</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Event received!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Publisher publisher = <span class="hljs-keyword">new</span> Publisher();<br>        Subscriber subscriber = <span class="hljs-keyword">new</span> Subscriber();<br><br>        <span class="hljs-comment">// 订阅事件</span><br>        subscriber.Subscribe(publisher);<br><br>        <span class="hljs-comment">// 触发事件</span><br>        publisher.TriggerEvent();<br><br>        <span class="hljs-comment">// 取消订阅事件</span><br>        subscriber.Unsubscribe(publisher);<br><br>        <span class="hljs-comment">// 再次触发事件（不会输出任何内容，因为已经取消订阅）</span><br>        publisher.TriggerEvent();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><ol><li><strong>事件定义</strong>：<ul><li><code>private event EventHandler _notify;</code>：这是一个私有事件字段，用于存储实际的事件处理程序。</li><li><code>public event EventHandler Notify</code>：公开的事件，使用 <code>add</code> 和 <code>remove</code> 访问器。</li></ul></li><li><strong><code>add</code> 访问器</strong>：<ul><li>在订阅事件时，输出 “Subscribing to the event.”，并将新的事件处理程序添加到 <code>_notify</code> 字段。</li></ul></li><li><strong><code>remove</code> 访问器</strong>：<ul><li>在取消订阅事件时，输出 “Unsubscribing from the event.”，并将事件处理程序从 <code>_notify</code> 字段中移除。</li></ul></li><li><strong>触发事件</strong>：<ul><li>使用 <code>_notify?.Invoke(this, EventArgs.Empty);</code> 触发事件，调用所有订阅的事件处理程序。</li></ul></li><li><strong>Subscriber 类</strong>：<ul><li>提供 <code>Subscribe</code> 和 <code>Unsubscribe</code> 方法来管理事件的订阅。</li></ul></li></ol><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>委托</strong> 是一种函数指针，允许方法作为参数传递，并可以被直接调用。</li><li><strong>事件</strong> 是基于委托的，用于在对象之间发布和订阅消息，通常用于实现事件驱动编程。事件提供了更多的封装和安全性，防止外部代码直接调用事件处理方法。<br>使用事件的主要原因是它们能够更好地支持事件驱动的设计模式，并提供了更好的封装和可维护性。</li></ul><h1 id="二十五、-Notify-Invoke-message-什么意思"><a href="#二十五、-Notify-Invoke-message-什么意思" class="headerlink" title="二十五、  Notify?.Invoke(message); 什么意思"></a>二十五、  Notify?.Invoke(message); 什么意思</h1><p>在 C# 中，<code>Notify?.Invoke(message);</code> 是一种使用空条件运算符（null-conditional operator）来安全调用委托的方法。这个表达式可以拆分为两部分进行理解：</p><ol><li><strong>空条件运算符 (<code>?.</code>)</strong> ：这是一个安全访问运算符，允许你在调用成员（如方法、属性）之前检查对象是否为 <code>null</code>。如果对象为 <code>null</code>，则整个表达式返回 <code>null</code>，而不会引发 <code>NullReferenceException</code>。</li><li>?[ ] 只判断整个数组是否为空,不判断这个位置,所有数组不为空而调用位置太长时还是会报错</li><li><strong><code>Invoke(message)</code></strong> ：这是用于调用委托的方法。通常，调用委托可以直接使用 <code>Notify(message)</code>，但是在这里我们使用 <code>Invoke</code> 也是有效的。</li></ol><h3 id="整体理解"><a href="#整体理解" class="headerlink" title="整体理解"></a>整体理解</h3><ul><li><code>Notify?.Invoke(message);</code> 意味着：<ul><li>如果 <code>Notify</code> 委托不为 <code>null</code>，则调用 <code>Notify</code> 并传递 <code>message</code> 参数。</li><li>如果 <code>Notify</code> 为 <code>null</code>，则不执行任何操作。</li></ul></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>考虑以下代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NotifyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>; <span class="hljs-comment">// 委托定义</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Notifier</span><br>&#123;<br>    <span class="hljs-keyword">public</span> NotifyDelegate Notify; <span class="hljs-comment">// 委托作为类的成员</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendNotification</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Notify?.Invoke(message); <span class="hljs-comment">// 安全调用委托</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 <code>SendNotification</code> 方法中，使用 <code>Notify?.Invoke(message)</code> 确保只有在 <code>Notify</code> 委托不为 <code>null</code> 时才会调用它。这避免了在 <code>Notify</code> 为 <code>null</code> 时尝试调用会导致程序崩溃。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这种写法可以帮助避免潜在的 <code>NullReferenceException</code>，使代码更健壮。在处理委托和事件时，常常会使用这种模式，因为委托可以在运行时动态分配或取消，从而可能会为 <code>null</code>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/zh-cn/">MS-Learning</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSharp知识整理(二)</title>
    <link href="/2024/10/25/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%BA%8C)/"/>
    <url>/2024/10/25/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="22-运算符重载"><a href="#22-运算符重载" class="headerlink" title="22. 运算符重载"></a>22. 运算符重载</h1><p>  在C#中，运算符重载允许为用户自定义的类型（如类或结构体）定义或重载运算符的行为。这使得用户可以对自定义类型使用标准的运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>相等</code>, <code>!=</code> 等），就像对内置类型操作一样。</p><h3 id="运算符重载的基本规则"><a href="#运算符重载的基本规则" class="headerlink" title="运算符重载的基本规则"></a>运算符重载的基本规则</h3><ol><li><strong>必须是 <code>static</code> 方法</strong>：重载的运算符方法必须声明为静态的。</li><li><strong>通常为 <code>public</code> 访问修饰符</strong>：以便在外部使用。</li><li><strong>参数数量</strong>：一元运算符（如 <code>++</code>, <code>--</code>, <code>!</code>）只有一个参数，二元运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>）只有两个参数。</li><li><strong>返回类型</strong>：可以是任何类型，不一定要与操作数类型相同。</li><li>运算符的参数必须是包含当前类的类型</li><li>不能使用ref和out修饰参数，ref和out参数在此上下文中无效</li></ol><h3 id="重载一元运算符的示例"><a href="#重载一元运算符的示例" class="headerlink" title="重载一元运算符的示例"></a>重载一元运算符的示例</h3><p>一元运算符重载允许你为自定义类型定义操作符（如 <code>++</code>、<code>--</code>、<code>-</code>、<code>!</code> 等）的行为。与二元运算符重载相似，在C#中，一元运算符的重载也必须是静态方法，且通常只需要一个参数，且该参数通常是包含运算符重载方法的类型。</p><ul><li>C#中的++和–重载部分前缀和后缀，具体看下面的第二个例子</li><li>不管前置后置运算，程序只执行唯一的重载运算符函数，其实C#不分前缀和后缀的写法，和Cpp不一样。C#对++&#x2F;–运算符重载的要求：<ul><li>参数必须是一个，而且只能是包含它的类型，也就是它的所在类类型</li><li>返回值，必须是所在类类型或其派生类</li><li>所有重载的运算符必须是 public 和 static的，这是编译时要求</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>以下是一个示例，展示如何重载一元运算符 <code>++</code> 和 <code>--</code>，以及负号运算符 <code>-</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br><span class="hljs-comment">// 不可以用ref或者out修饰int</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialValue</span>)</span><br>    &#123;<br>        Value = initialValue;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载前缀 ++ 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> ++(Counter c)<br>    &#123;<br>        c.Value++;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 重载前缀 -- 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> --(Counter c)<br>    &#123;<br>        c.Value--;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载负号运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> -(Counter c)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(-c.Value);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，以便输出格式化的计数器值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Value.ToString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Counter counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 使用重载的 ++ 运算符</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Initial Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Increment: <span class="hljs-subst">&#123;++counter&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Decrement: <span class="hljs-subst">&#123;--counter&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用重载的负号运算符</span><br>        Counter negativeCounter = -counter;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Negative Value: <span class="hljs-subst">&#123;negativeCounter&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重载<code>++</code>和<code>--</code>的另一个例子<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>()</span> &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialValue</span>)</span><br>    &#123;<br>        Value = initialValue;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载前缀和后缀 ++ 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> ++(Counter c)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;operator++&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">1</span> + c.Value);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载前缀和后缀 -- 运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> --(Counter c)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;operator--&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(c.Value - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载负号运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Counter <span class="hljs-keyword">operator</span> -(Counter c)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter(-c.Value);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，以便输出格式化的计数器值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Value.ToString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Counter counter = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 使用重载的 ++ 和 -- 运算符</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Initial Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Prefix Increment: <span class="hljs-subst">&#123;++counter.Value&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Prefix Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Postfix Increment: <span class="hljs-subst">&#123;(counter++).Value&#125;</span>&quot;</span>);<br>        <span class="hljs-comment">// 上面一行等价于下面两行，不一定是+=1，实际看返回的new Counter(1 + c.Value);是怎么操作的，也可以+2</span><br>        <span class="hljs-comment">// Console.WriteLine($&quot;After Postfix Increment: &#123;counter.Value&#125;&quot;); // 输出当前值</span><br>        <span class="hljs-comment">// counter.Value += 1; // 实际上增1操作是直接对原对象进行修改的</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Postfix Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Prefix Decrement: <span class="hljs-subst">&#123;--counter.Value&#125;</span>&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;After Prefix Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Postfix Decrement: <span class="hljs-subst">&#123;(counter--).Value&#125;</span>&quot;</span>);<br>        <span class="hljs-comment">// 上面一行等价于下面两行，不一定是-=1，实际看返回的new Counter(c.Value - 1);是怎么操作的，也可以-2</span><br>        <span class="hljs-comment">// Console.WriteLine($&quot;After Postfix Increment: &#123;counter.Value&#125;&quot;); // 输出当前值</span><br>        <span class="hljs-comment">// counter.Value -= 1; // 实际上增1操作是直接对原对象进行修改的</span><br>        <span class="hljs-comment">// 查看最终计数器值</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;After Postfix Value: <span class="hljs-subst">&#123;counter&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 使用重载的负号运算符</span><br>        Counter negativeCounter = -counter;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Negative Value: <span class="hljs-subst">&#123;negativeCounter&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">//Initial Value: 5</span><br><span class="hljs-comment">//After Prefix Increment: 6</span><br><span class="hljs-comment">//After Prefix Value: 6</span><br><span class="hljs-comment">//operator ++</span><br><span class="hljs-comment">//After Postfix Increment: 6</span><br><span class="hljs-comment">//After Postfix Value: 7</span><br><span class="hljs-comment">//After Prefix Decrement: 6</span><br><span class="hljs-comment">//After Prefix Value: 6</span><br><span class="hljs-comment">//operator--</span><br><span class="hljs-comment">//After Postfix Decrement: 6</span><br><span class="hljs-comment">//After Postfix Value: 5</span><br><span class="hljs-comment">//Negative Value: -5</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><strong>访问修饰符</strong>：重载运算符的方法必须是 <code>public</code> 和 <code>static</code>。</li><li><strong>返回类型</strong>：重载运算符的方法返回一个新对象或修改后的对象。</li><li>一元运算符的参数必须是包含类型</li></ol><h3 id="重载二元运算符的示例"><a href="#重载二元运算符的示例" class="headerlink" title="重载二元运算符的示例"></a>重载二元运算符的示例</h3><p>以下是一个重载加法运算符的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ComplexNumber</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Real &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Imaginary &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComplexNumber</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> real, <span class="hljs-built_in">double</span> imaginary</span>)</span><br>    &#123;<br>        Real = real;<br>        Imaginary = imaginary;<br>    &#125;<br><br>    <span class="hljs-comment">// 重载加法运算符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ComplexNumber <span class="hljs-keyword">operator</span> +(ComplexNumber c1, ComplexNumber c2)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ComplexNumber(c1.Real + c2.Real, c1.Imaginary + c2.Imaginary);<br>    &#125;<br><br>    <span class="hljs-comment">// 重写 ToString 方法，以便输出格式化的复数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Real&#125;</span> + <span class="hljs-subst">&#123;Imaginary&#125;</span>i&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        ComplexNumber c1 = <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>);<br>        ComplexNumber c2 = <span class="hljs-keyword">new</span> ComplexNumber(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);<br>        ComplexNumber sum = c1 + c2; <span class="hljs-comment">// 使用重载的加法运算符</span><br><br>        Console.WriteLine(<span class="hljs-string">$&quot;c1 + c2 = <span class="hljs-subst">&#123;sum&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><ul><li><code>ComplexNumber</code> 类表示一个复数，包含两个字段：<code>Real</code> 和 <code>Imaginary</code>。</li><li>加法运算符 <code>+</code> 被重载，使得可以对两个 <code>ComplexNumber</code> 实例进行相加操作。</li><li><code>operator +</code> 方法返回一个新的 <code>ComplexNumber</code> 对象，其 <code>Real</code> 和 <code>Imaginary</code> 分别是两个操作数相加的结果。</li><li>在 <code>Main</code> 方法中，<code>c1</code> 和 <code>c2</code> 被相加，并输出相加的结果。</li></ul><h3 id="支持重载的运算符列表"><a href="#支持重载的运算符列表" class="headerlink" title="支持重载的运算符列表"></a>支持重载的运算符列表</h3><p>C# 支持重载的运算符包括：</p><ul><li>算术运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></li><li>比较运算符：<code>相等</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li><li>位运算符：<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li><li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li><li>自增、自减运算符：<code>++</code>, <code>--</code></li></ul><h3 id="不支持重载的运算符列表"><a href="#不支持重载的运算符列表" class="headerlink" title="不支持重载的运算符列表"></a>不支持重载的运算符列表</h3><ul><li><strong>成员访问运算符</strong>：<code>.</code>（点运算符）<ul><li>用于访问类型的成员（字段、属性、方法等）。</li></ul></li><li><strong>条件运算符</strong>：<code>?:</code>（三元运算符）<ul><li>用于条件表达式。</li></ul></li><li><strong>委托运算符</strong>：<code>delegate</code><ul><li>用于声明委托。</li></ul></li><li><strong>指针运算符</strong>：<code>*</code>（指针解引用运算符）和<code>&amp;</code>（地址运算符）<ul><li>用于处理指针。</li></ul></li><li><strong>类型测试运算符</strong>：<code>is</code> 和 <code>as</code><ul><li>用于检查对象类型和进行类型转换。</li></ul></li><li><strong>数组下标运算符</strong>：<code>[]</code><ul><li>用于数组索引访问。</li></ul></li><li><strong>new 关键字</strong><ul><li>用于对象的创建。</li></ul></li><li><strong>default 关键字</strong><ul><li>用于获取类型的默认值。</li></ul></li><li><strong>sizeof 关键字</strong><ul><li>用于获取类型的大小。</li></ul></li><li>赋值符号&#x3D;</li><li>强转运算符()</li></ul><h3 id="重载运算符的注意事项"><a href="#重载运算符的注意事项" class="headerlink" title="重载运算符的注意事项"></a>重载运算符的注意事项</h3><ul><li>条件运算符需要成对实现<ul><li>如果重载 <code>相等</code> 运算符，通常也需要重载 <code>!=</code> 运算符。</li><li>如果重载比较运算符（如 <code>&lt;</code> 和 <code>&gt;</code>），还需要重载其相应的 <code>&lt;=</code> 和 <code>&gt;=</code> 运算符。</li></ul></li><li>二元运算符的参数之一必须是包含类型</li><li>为了更好地实现运算符的语义，一般还需要重写 <code>Equals()</code> 和 <code>GetHashCode()</code> 方法。<ul><li><ol><li><code>Equals()</code> 方法<br>  <code>Equals()</code> 用于比较两个对象是否相等。它通常用于判断两个对象的内容是否相等，而不仅仅是它们是否是同一个对象（即是否是同一个内存地址）。</li></ol><ul><li><strong>重写场景：</strong> 当你定义了一个自定义类型并且想要比较两个实例的内容是否相等时，就需要重写 <code>Equals()</code> 方法。默认的 <code>Equals()</code> 比较的是引用相等性（即对象的地址），但是如果你希望比较的是对象的实际内容（例如 <code>Counter</code> 类中的 <code>Value</code>），就需要重写它。<br>  <strong>重写 <code>Equals()</code> 时应遵循以下规则：</strong><ul><li>自反性：<code>a.Equals(b)</code> 和 <code>b.Equals(a)</code> 都应返回相同的结果。</li><li>对称性：如果 <code>a.Equals(b)</code> 返回 <code>true</code>，那么 <code>b.Equals(a)</code> 也应返回 <code>true</code>。</li><li>传递性：如果 <code>a.Equals(b)</code> 返回 <code>true</code> 且 <code>b.Equals(c)</code> 返回 <code>true</code>，那么 <code>a.Equals(c)</code> 应该返回 <code>true</code>。</li><li>一致性：多次调用相同的对象对比应始终返回相同的结果，除非对象的状态改变。</li></ul></li></ul></li><li><ol start="2"><li><code>GetHashCode()</code> 方法<br>  <code>GetHashCode()</code> 方法用于为对象提供一个哈希值，哈希值通常用于哈希表（如 <code>Dictionary</code> 或 <code>HashSet</code>）中，以便在查找、插入或删除时快速定位对象。哈希值应该尽量均匀地分布，以减少冲突。</li></ol><ul><li><strong>重写场景：</strong> 当你重写 <code>Equals()</code> 方法时，通常也需要重写 <code>GetHashCode()</code> 方法，以确保相等的对象有相同的哈希值。这样才能确保在哈希集合（如 <code>HashSet</code> 或 <code>Dictionary</code>）中，比较相等的对象能够正确地存储和查找。<br>  <strong>重写 <code>GetHashCode()</code> 时的一些建议：</strong><ul><li>如果两个对象相等（通过 <code>Equals()</code> 判断），那么它们的哈希值必须相同。</li><li>如果两个对象不相等，它们的哈希值不必不同，但尽量避免大量哈希冲突，以提高性能。</li><li><code>GetHashCode()</code> 生成的哈希值应该基于对象的“值”，而不是其引用地址。</li></ul></li><li>为什么重写这两个方法<br>  在许多场景中，特别是在使用集合类（如 <code>Dictionary</code>、<code>HashSet</code>）时，<code>Equals()</code> 和 <code>GetHashCode()</code> 起着关键作用。集合会利用哈希值来高效地存储和查找对象，因此正确地重写这两个方法能确保自定义类型在这些集合中的正常使用。</li><li>示例：<br>  假设你有一个 <code>Counter</code> 类，你想要通过值来判断两个计数器是否相等，并将它们作为键存储在 <code>Dictionary</code> 中。你需要重写 <code>Equals()</code> 和 <code>GetHashCode()</code> 方法。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialValue</span>)</span><br>&#123;<br>Value = initialValue;<br>&#125;<br><br><span class="hljs-comment">// 重载 Equals 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> Counter otherCounter)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.Value == otherCounter.Value;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 重载 GetHashCode 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetHashCode</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> Value.GetHashCode();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>&#123;<br><span class="hljs-keyword">var</span> dict = <span class="hljs-keyword">new</span> Dictionary&lt;Counter, <span class="hljs-built_in">string</span>&gt;();<br><span class="hljs-keyword">var</span> counter1 = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> counter2 = <span class="hljs-keyword">new</span> Counter(<span class="hljs-number">5</span>);<br><br>dict[counter1] = <span class="hljs-string">&quot;First&quot;</span>;<br>Console.WriteLine(dict[counter2]); <span class="hljs-comment">// 输出 &quot;First&quot;，因为 counter1 和 counter2 的值相等，且哈希值相同</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，如果没有重写 <code>Equals()</code> 和 <code>GetHashCode()</code>，<code>counter1</code> 和 <code>counter2</code> 将被认为是不同的对象（基于引用），即使它们的 <code>Value</code> 相同。但通过重写这两个方法，我们确保了它们在比较时是基于 <code>Value</code> 属性的。<br>  运算符重载使自定义类型在运算时可以更符合直观的数学表示，提高代码的可读性和易用性。</li></ul></li></ul></li></ul><h3 id="强转运算符（类型转换运算符）特定的重载方式"><a href="#强转运算符（类型转换运算符）特定的重载方式" class="headerlink" title="强转运算符（类型转换运算符）特定的重载方式"></a>强转运算符（类型转换运算符）特定的重载方式</h3><ul><li><strong>类型转换运算符</strong>：C# 允许你定义类型转换运算符，但不是通过传统的运算符重载语法。你可以通过定义显式或隐式转换运算符来实现类型转换的行为。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 显式转换运算符，如果隐式使用，会报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-keyword">value</span> &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 隐式转换运算符,如果显式的使用，不会报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">MyClass myClass</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> myClass.Value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = (MyClass)<span class="hljs-number">5</span>; <span class="hljs-comment">// 显式转换</span><br>        <span class="hljs-comment">// MyClass myObject2 = 5; // 隐式转换，报错</span><br>        <span class="hljs-built_in">int</span> number = myObject;          <span class="hljs-comment">// 隐式转换</span><br>        <span class="hljs-built_in">int</span> number2 = (<span class="hljs-built_in">int</span>)myObject;          <span class="hljs-comment">// 显式转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="23-explicit-implicit"><a href="#23-explicit-implicit" class="headerlink" title="23. explicit implicit"></a>23. explicit implicit</h1><p>在C#中，<code>explicit</code> 和 <code>implicit</code> 是用来定义类型转换运算符的关键字，它们决定了类型转换的方式和使用场景。下面是对这两个关键字的详细解释以及它们的区别。</p><h3 id="1-implicit（隐式转换）"><a href="#1-implicit（隐式转换）" class="headerlink" title="1. implicit（隐式转换）"></a>1. <code>implicit</code>（隐式转换）</h3><ul><li><strong>定义</strong>：隐式转换运算符允许自动转换类型，无需显式地进行类型转换。</li><li><strong>使用场景</strong>：当你希望一个类型可以被安全地转换为另一个类型，并且这种转换不可能导致数据丢失或异常时，可以使用隐式转换。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 隐式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-keyword">value</span> &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = <span class="hljs-number">10</span>; <span class="hljs-comment">// 隐式转换</span><br>        Console.WriteLine(myObject.Value); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-explicit（显式转换）"><a href="#2-explicit（显式转换）" class="headerlink" title="2. explicit（显式转换）"></a>2. <code>explicit</code>（显式转换）</h3><ul><li><strong>定义</strong>：显式转换运算符需要使用强制类型转换符进行转换，不能隐式转换。</li><li><strong>使用场景</strong>：当你希望转换可能导致数据丢失或需要显式指明时，可以使用显式转换。这样可以防止意外的类型转换。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 显式转换运算符</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>(<span class="hljs-params">MyClass myClass</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> myClass.Value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyClass myObject = <span class="hljs-keyword">new</span> MyClass &#123; Value = <span class="hljs-number">10</span> &#125;;<br>        <span class="hljs-built_in">int</span> number = (<span class="hljs-built_in">int</span>)myObject; <span class="hljs-comment">// 显式转换</span><br>        Console.WriteLine(number); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>implicit</code>：允许类型自动转换，适用于安全且无损的转换。</li><li><code>explicit</code>：要求使用强制转换，适用于可能导致数据丢失或不安全的转换。</li></ul><h1 id="24-内部类"><a href="#24-内部类" class="headerlink" title="24. 内部类"></a>24. 内部类</h1><p>在C#中，内部类是定义在另一个类中的类，也称为嵌套类。内部类可以用来组织代码，使外部类更紧凑，同时为外部类提供额外的功能。以下是关于C#内部类的一些关键点：</p><h3 id="1-内部类的定义"><a href="#1-内部类的定义" class="headerlink" title="1. 内部类的定义"></a>1. 内部类的定义</h3><p>内部类可以定义在外部类的任何地方（类体内），并且可以访问外部类的私有成员。内部类本身也可以有自己的成员和方法。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是内部类的方法.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 外部类的方法可以创建内部类的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass();<br>        inner.Display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-访问外部类的成员"><a href="#2-访问外部类的成员" class="headerlink" title="2. 访问外部类的成员"></a>2. 访问外部类的成员</h3><p>内部类可以访问外部类的所有成员，包括私有成员。</p><ul><li>C#中的内部类要访问外部类的成员（包括私有成员），需要持有外部类的实例的引用。这是因为内部类与外部类是两个不同的对象，要访问外部类的成员，必须通过外部类的实例进行访问。通常，可以通过构造函数传递外部类的实例，然后使用该实例访问外部类的成员。</li></ul><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> OuterClass outer;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> pubInt;<br><br>        <span class="hljs-comment">// 构造函数接收外部类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClass</span>(<span class="hljs-params">OuterClass outer</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.outer = outer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayOuterValue</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 访问外部类的私有字段</span><br>            <span class="hljs-comment">// 访问外部类的私有字段,必须使用接收的实例才能够使用其中的变量，不然无法直接使用outerValue</span><br>            Console.WriteLine(<span class="hljs-string">&quot;外部类的值是: &quot;</span> + outer.outerValue);<br>        &#125;<br><br>        <span class="hljs-comment">// 给外部类提供访问内部类的公共方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayInnerInfo</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是内部类的方法&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass(<span class="hljs-keyword">this</span>);<br>        inner.DisplayOuterValue();<br>        inner.DisplayInnerInfo();  <span class="hljs-comment">// 外部类可以访问内部类的公共方法</span><br>        inner.pubInt = <span class="hljs-number">42</span>;<br>        Console.WriteLine(<span class="hljs-string">$&quot;内部类的pubInt的值是:<span class="hljs-subst">&#123;inner.pubInt&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 内部类可以访问外部类的私有成员，不过也必须传入外部类到构造函数</span><br>        <span class="hljs-comment">// 外部类无法直接访问内部类的私有成员，但是可以通过公共方法或者属性来访问。</span><br>        OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();<br>        outer.CreateInner();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-内部类的访问修饰符"><a href="#3-内部类的访问修饰符" class="headerlink" title="3. 内部类的访问修饰符"></a>3. 内部类的访问修饰符</h3><p>内部类可以具有自己的访问修饰符，比如<code>public</code>、<code>private</code>、<code>protected</code>、<code>internal</code>等，这决定了内部类在外部类之外的可见性。</p><ul><li><code>private</code>：内部类只能被外部类访问。</li><li><code>public</code>：内部类可以被外部类之外的代码访问。</li><li><code>protected</code>：内部类只能被外部类及其派生类访问。</li><li><code>internal</code>：内部类可以被同一个程序集中的其他代码访问。程序集的理解就是一个解决方案中的项目<ul><li>在C#中，“程序集”（Assembly）是指一个已编译的代码库，通常是一个 <code>.exe</code> 或 <code>.dll</code> 文件。它是 .NET 中的基本部署单元，包含可执行代码、资源文件和元数据。</li><li>元数据的意思就是描述数据的数据</li><li><a href="https://imgse.com/i/pAwb64s"><img src="https://s21.ax1x.com/2024/10/26/pAwb64s.png" alt="pAwb64s.png"></a></li></ul></li></ul><h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul><li><strong>封装相关功能</strong>：内部类可以作为外部类的辅助类，帮助封装某些复杂的功能。</li><li><strong>访问控制</strong>：通过嵌套类的访问修饰符，可以严格控制类的访问权限。</li><li><strong>代码组织</strong>：将相关的类组织在一起，使代码更整洁。</li></ul><h3 id="5-示例：使用访问修饰符"><a href="#5-示例：使用访问修饰符" class="headerlink" title="5. 示例：使用访问修饰符"></a>5. 示例：使用访问修饰符</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 私有内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是私有的内部类.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass();<br>        inner.Display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>InnerClass</code>是<code>private</code>的，因此只能在<code>OuterClass</code>中使用，不能在外部类之外的地方访问。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>内部类</strong>用于在类中嵌套另一个类，具有封装性和灵活性。</li><li>可以通过访问修饰符控制内部类的访问权限。</li><li>内部类可以访问外部类的所有成员，包括私有成员。</li></ul><h1 id="25-OuterClass-outer-new-OuterClass-和OuterClass-outer2-区别"><a href="#25-OuterClass-outer-new-OuterClass-和OuterClass-outer2-区别" class="headerlink" title="25. OuterClass outer &#x3D; new OuterClass();和OuterClass outer2;区别"></a>25. OuterClass outer &#x3D; new OuterClass();和OuterClass outer2;区别</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> outerValue = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 定义一个内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> OuterClass outer;<br><br>        <span class="hljs-comment">// 构造函数接收外部类实例</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InnerClass</span>(<span class="hljs-params">OuterClass outer</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.outer = outer;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayOuterValue</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 访问外部类的私有字段</span><br>            Console.WriteLine(<span class="hljs-string">&quot;外部类的值是: &quot;</span> + outer.outerValue);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateInner</span>()</span><br>    &#123;<br>        InnerClass inner = <span class="hljs-keyword">new</span> InnerClass(<span class="hljs-keyword">this</span>);<br>        inner.DisplayOuterValue();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();<br>        OuterClass outer2;<br>        outer.CreateInner();<br>        <span class="hljs-comment">// outer2.CreateInner(); //CS0165 使用了未赋值的局部变量&quot;outer2&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在C#中，这两个声明的确有区别：</p><ol><li><code>OuterClass outer = new OuterClass();</code><ul><li>这里声明了一个名为 <code>outer</code> 的变量，并且通过 <code>new OuterClass()</code> 创建了一个 <code>OuterClass</code> 类型的实例，然后将这个实例的引用赋值给变量 <code>outer</code>。</li><li>这样，<code>outer</code> 就指向了一个已经被实例化的对象，可以访问对象的成员。</li></ul></li><li><code>OuterClass outer2;</code><ul><li>这里声明了一个名为 <code>outer2</code> 的变量，但没有初始化它，即没有创建对象实例。</li><li>此时，<code>outer2</code> 只是一个未赋值的变量，如果尝试使用它（如访问成员），会导致编译错误，因为变量尚未初始化。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><code>OuterClass outer = new OuterClass();</code>：创建了一个 <code>OuterClass</code> 对象，并将其赋值给 <code>outer</code>。</li><li><code>OuterClass outer2;</code>：仅声明了变量 <code>outer2</code>，但并未指向任何对象。使用前需要先进行初始化，例如：<code>outer2 = new OuterClass();</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;test:show&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Test* test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>();<br>Test test2;<br>test-&gt;<span class="hljs-built_in">show</span>();<br>test<span class="hljs-number">2.</span><span class="hljs-built_in">show</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>在C++中，这两种声明方式有明显的区别：</li></ul><ol><li><code>Test* test = new Test();</code><ul><li>这会创建一个指向<code>Test</code>对象的指针，并且该对象是在堆上分配的。使用<code>new</code>关键字会动态分配内存，这时需要手动管理内存，在合适的时候使用<code>delete test</code>释放内存，否则会导致内存泄漏。</li></ul></li><li><code>Test test2;</code><ul><li>这会在栈上创建一个<code>Test</code>对象实例。当该对象的作用域结束时，会自动销毁，不需要手动管理内存。<br>第一种方式适用于需要在当前作用域之外持续存在的对象，而第二种方式在对象生命周期较短时效率更高。</li></ul></li></ol><h1 id="26-分部类"><a href="#26-分部类" class="headerlink" title="26. 分部类"></a>26. 分部类</h1><p>在C#中，<strong>分部类（Partial Class）</strong> 允许将一个类的定义分散到多个文件中。这在大型项目中很有用，特别是当多个开发者需要同时对同一个类进行修改，或者自动生成的代码和手写的代码需要分开时。</p><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ol><li><strong>使用 <code>partial</code> 关键字</strong>：分部类的定义需要使用 <code>partial</code> 关键字来标识。每个部分都必须使用 <code>partial</code> 声明，并且具有相同的类名。</li><li><strong>文件位于同一个命名空间下</strong>：分部类的各部分可以在不同的文件中定义，但它们必须在同一个命名空间下。</li><li><strong>编译时合并</strong>：在编译时，所有分部类会被合并为一个完整的类。因此，分部类的所有方法、属性和成员变量在使用时是共享的。</li><li><strong>访问修饰符一致性</strong>：分部类的各个部分可以有不同的访问修饰符（如 <code>public</code>、<code>internal</code>），但最终编译后的类只能具有一种可见性。</li><li>分部类中不能有重复成员，可以重载</li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>文件 <code>Person1.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintName</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;FirstName&#125;</span> <span class="hljs-subst">&#123;LastName&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件 <code>Person2.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintAge</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Age: <span class="hljs-subst">&#123;Age&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>Person</code> 类被拆分到了两个文件 <code>Person1.cs</code> 和 <code>Person2.cs</code> 中。在编译时，这两个部分会被合并成一个完整的 <code>Person</code> 类，拥有所有的属性和方法。</p><h3 id="分部类的用途："><a href="#分部类的用途：" class="headerlink" title="分部类的用途："></a>分部类的用途：</h3><ul><li><strong>自动生成代码</strong>：比如在一些工具（如Visual Studio设计器或Entity Framework）中，自动生成的代码和用户手写的代码可以放在不同的分部类中，方便管理。</li><li><strong>模块化开发</strong>：团队开发时，可以将一个类分割成不同部分，方便不同开发人员同时修改。</li><li><strong>代码组织</strong>：对于大类，可以将不同功能放在不同的文件中，提高代码的可读性和可维护性。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在C#的分部类中，<strong>访问修饰符一致性</strong>的意思是：虽然你可以在不同的分部类定义中使用不同的访问修饰符（如 <code>public</code> 或 <code>internal</code>），但是编译器最终会将所有部分合并为一个完整的类，这个类只能有一个最终的可见性（即访问级别）。</p><p>具体来说，编译器会根据以下规则来确定最终的访问修饰符：</p><ol><li><strong>如果所有分部类都指定了相同的访问修饰符</strong>，那么最终类的访问修饰符就是这个一致的修饰符。例如，如果所有部分都是 <code>public</code>，那么合并后的类也是 <code>public</code>。</li><li><strong>如果有的部分指定了访问修饰符，而有的没有指定</strong>，编译器会选择访问级别最高的修饰符。例如，如果一个部分是 <code>public</code>，而另一个部分没有指定修饰符（默认是 <code>internal</code>），那么最终类的可见性将是 <code>public</code>。</li><li><strong>如果不同部分的修饰符不一致</strong>，并且存在冲突（如一个部分是 <code>public</code>，另一个部分是 <code>internal</code>），编译器会报错，因为访问修饰符必须在所有部分中一致，或者必须选择可以合并的修饰符。</li></ol><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>文件 <code>Person1.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件 <code>Person2.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>Person1.cs</code> 中的 <code>Person</code> 类是 <code>public</code> 的，而 <code>Person2.cs</code> 中的 <code>Person</code> 类是 <code>internal</code> 的。这会导致编译错误，因为编译器不知道该选择 <code>public</code> 还是 <code>internal</code> 作为最终类的可见性。<br>要解决这个问题，你可以确保所有分部类都使用相同的访问修饰符，或者明确指定某一种修饰符，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-comment">// 修改为 public</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就保证了所有部分的访问修饰符一致，编译器就能确定 <code>Person</code> 类的可见性是 <code>public</code>。</p><h3 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h3><p>在C#中，<strong>分部方法（Partial Methods）</strong> 是一种特殊的方法，可以在分部类（<code>partial</code>）中使用。分部方法的定义可以分成两个部分<strong>声明</strong>和<strong>实现</strong>，它们可以分别位于分部类的不同部分中。</p><h4 id="分部方法的特点"><a href="#分部方法的特点" class="headerlink" title="分部方法的特点"></a>分部方法的特点</h4><ol><li><strong>必须定义在分部类或结构中</strong> ： 分部方法只能在使用了<code>partial</code>关键字的分部类或结构中定义。</li><li><strong>必须是<code>void</code>类型</strong> ： 分部方法不能有返回值，必须是<code>void</code>类型。</li><li><strong>隐式<code>private</code></strong> ： 分部方法默认为私有（<code>private</code>），不能使用访问修饰符，因为它只能在当前类中使用。</li><li><strong>可选实现</strong> ： 分部方法的实现是可选的。如果没有提供实现，则在编译时，声明将被忽略，不会生成任何代码。因此，调用未实现的分部方法不会产生任何影响。</li><li><strong>不支持输出参数（<code>out</code>）</strong> ： 分部方法不能使用<code>out</code>修饰符，但可以使用<code>ref</code>修饰符。</li></ol><h4 id="分部方法的语法"><a href="#分部方法的语法" class="headerlink" title="分部方法的语法"></a>分部方法的语法</h4><ol><li><strong>声明</strong>： 在一个分部类中声明分部方法，使用<code>partial</code>关键字。</li><li><strong>实现</strong>： 可以在类的另一个分部文件中实现这个方法，也可以不实现。</li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下示例演示了分部方法的声明和实现。<br>文件 <code>Person1.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person1.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-comment">// 分部方法的声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNameChanged</span>()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            name = <span class="hljs-keyword">value</span>;<br>            <span class="hljs-comment">// 调用分部方法</span><br>            OnNameChanged();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件 <code>Person2.cs</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// Person2.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// 分部方法的实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">partial</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNameChanged</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Name changed to: <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>OnNameChanged</code>方法在<code>Person1.cs</code>中进行了声明，并在<code>Person2.cs</code>中进行了实现。如果不提供实现，编译器会忽略它的声明。如果调用了声明但没有定义的方法也没事，直接忽略了。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><strong>在生成代码中扩展功能</strong>：分部方法常用于自动生成的代码中，比如工具生成的类中声明分部方法，用户可以选择性地在另外的文件中实现它们。</li><li><strong>模块化设计</strong>：通过将方法拆分为不同的文件，可以更好地管理和维护大型项目。<br>分部方法提供了一种灵活的方式来设计和实现方法，同时保持代码的模块化和清晰性。</li></ul><h1 id="27-类的继承"><a href="#27-类的继承" class="headerlink" title="27. 类的继承"></a>27. 类的继承</h1><p>在C#中，<strong>类的继承</strong>是一种面向对象编程的机制，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。通过继承，可以实现代码重用、扩展类的功能以及多态性。</p><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><p>在C#中使用<code>:</code>符号来表示继承关系，语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-comment">// 子类的成员</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>BaseClass</code>是基类或父类，提供了一些基本功能。</li><li><code>DerivedClass</code>是子类或派生类，它继承了<code>BaseClass</code>的所有公有和受保护的成员（字段、方法、属性等）。</li></ul><h3 id="2-继承的特点"><a href="#2-继承的特点" class="headerlink" title="2. 继承的特点"></a>2. 继承的特点</h3><ul><li><strong>单继承</strong>：C#只支持单继承，一个类只能有一个直接的父类。但是，一个类可以实现多个接口。</li><li>传递性：子类可以继承父类的父类</li><li><strong>成员访问</strong>：子类可以访问父类的<code>public</code>和<code>protected</code>成员，但不能直接访问父类的<code>private</code>成员。</li><li><strong>构造函数的调用</strong>：子类的构造函数会首先调用父类的构造函数，在调用子类得构造函数。可以使用<code>base</code>关键字来指定调用父类的哪个构造函数。</li><li>类中会默认提供默认构造函数（无参），如果定义了有参构造函数，那么默认构造函数就不会提供</li><li>子类不会自动继承父类的特性。如果子类需要使用相同的特性，必须显式地在子类上再次应用特性。<ul><li>有些特性允许被继承，这取决于特性的定义</li><li><code>[AttributeUsage(AttributeTargets.Class, Inherited = true)]</code> &#x2F;&#x2F; 表示特性可以被继承</li><li><strong><code>Inherited = false</code> 的特性</strong>：如果特性声明时未设置 <code>Inherited = true</code>（默认值是 <code>false</code>），则子类不会继承该特性。</li></ul></li></ul><h3 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h3><p>以下是一个简单的继承示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Animal&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal 默认构造函数&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Dog&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is barking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog(); <span class="hljs-comment">//Animal 默认构造函数 Dog 默认构造函数</span><br>        dog.Name = <span class="hljs-string">&quot;Buddy&quot;</span>;<br>        dog.Eat(); <span class="hljs-comment">// 调用从父类继承的方法</span><br>        dog.Bark(); <span class="hljs-comment">// 调用子类的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Animal 默认构造函数<br>Dog 默认构造函数<br>Buddy <span class="hljs-keyword">is</span> eating.<br>Buddy <span class="hljs-keyword">is</span> barking.<br></code></pre></td></tr></table></figure><h4 id="改变父类的成员的访问修饰符的权限"><a href="#改变父类的成员的访问修饰符的权限" class="headerlink" title="改变父类的成员的访问修饰符的权限"></a>改变父类的成员的访问修饰符的权限</h4><h5 id="1-如何将继承的-public-改为-protected-或者-protected-改为-public"><a href="#1-如何将继承的-public-改为-protected-或者-protected-改为-public" class="headerlink" title="1. 如何将继承的 public 改为 protected 或者 protected 改为 public"></a>1. <strong>如何将继承的 <code>public</code> 改为 <code>protected</code> 或者 <code>protected</code> 改为 <code>public</code></strong></h5><ul><li><code>public</code> 成员可以在任何地方访问，包括子类和外部代码。</li><li><code>protected</code> 成员只能在当前类和其子类中访问，外部代码无法访问。<br>如果你希望将继承的 <code>public</code> 改为 <code>protected</code>，或者将 <code>protected</code> 改为 <code>public</code>，你可以在子类中通过访问修饰符的修改来实现。比如：</li></ul><h6 id="将-public-成员改为-protected："><a href="#将-public-成员改为-protected：" class="headerlink" title="将 public 成员改为 protected："></a>将 <code>public</code> 成员改为 <code>protected</code>：</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 修改继承的 Name 属性为 protected</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Dog&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 子类独有的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is barking.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="将-protected-成员改为-public："><a href="#将-protected-成员改为-public：" class="headerlink" title="将 protected 成员改为 public："></a>将 <code>protected</code> 成员改为 <code>public</code>：</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 将 protected 的 Name 改为 public</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Animal&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal 默认构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        Name = <span class="hljs-string">&quot;Dog&quot;</span>; <span class="hljs-comment">// 访问父类的公开 Name 属性</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is barking.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-父类有-private-成员能继承吗？"><a href="#2-父类有-private-成员能继承吗？" class="headerlink" title="2. 父类有 private 成员能继承吗？"></a>2. <strong>父类有 <code>private</code> 成员能继承吗？</strong></h5><ul><li><code>private</code> 成员 <strong>不能</strong> 被子类直接访问或继承。它只能在父类的内部被访问。</li><li>但是，子类可以继承父类的 <code>private</code> 成员 <strong>通过公有或保护的访问方法</strong>，例如父类提供公共的 <code>getter</code> 和 <code>setter</code> 方法来访问这些私有成员。</li></ul><h6 id="示例：父类的-private-成员如何通过-protected-或-public-方法访问"><a href="#示例：父类的-private-成员如何通过-protected-或-public-方法访问" class="headerlink" title="示例：父类的 private 成员如何通过 protected 或 public 方法访问"></a>示例：父类的 <code>private</code> 成员如何通过 <code>protected</code> 或 <code>public</code> 方法访问</h6><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// private 成员</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> privateName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>()</span><br>    &#123;<br>        privateName = <span class="hljs-string">&quot;Animal Private&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal 默认构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 提供公共方法来访问 private 成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetPrivateName</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> privateName;<br>    &#125;<br><br>    <span class="hljs-comment">// 提供公共方法来修改 private 成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetPrivateName</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        privateName = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Eating...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 无法直接访问父类的 private 成员</span><br>        <span class="hljs-comment">// privateName = &quot;Dog&quot;;  // 编译错误：无法访问</span><br>        SetPrivateName(<span class="hljs-string">&quot;Dog&quot;</span>); <span class="hljs-comment">// 使用父类提供的公共方法</span><br>        Console.WriteLine(<span class="hljs-string">&quot;Dog 默认构造函数&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Barking...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        <span class="hljs-comment">// 无法直接访问 private 成员</span><br>        <span class="hljs-comment">// Console.WriteLine(dog.privateName);  // 编译错误</span><br>        Console.WriteLine(dog.GetPrivateName()); <span class="hljs-comment">// 通过父类的公共方法访问 private 成员</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul><li><strong><code>public</code> 成员</strong>：可以直接在子类和外部访问。</li><li><strong><code>protected</code> 成员</strong>：只能在子类和父类中访问，外部代码无法访问。</li><li><strong><code>private</code> 成员</strong>：只能在父类内部访问，不能直接在子类中访问，但可以通过父类提供的公共方法进行访问。</li><li><strong>改变访问修饰符</strong>：子类可以通过 <code>new</code> 关键字隐藏父类的成员，或者通过修改继承的成员的访问修饰符来改变访问权限。</li></ul><h3 id="4-base关键字"><a href="#4-base关键字" class="headerlink" title="4. base关键字"></a>4. <code>base</code>关键字</h3><ul><li><code>base</code>关键字用于在子类中访问父类的成员。</li><li>它可以用来调用父类的构造函数或方法。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br><span class="hljs-comment">// 无默认构造函数，如果new Animal()会报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> makes a noise.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 如果父类中没有默认构造函数，使用下面得构造函数会报错</span><br>    <span class="hljs-comment">//public Dog(string name)</span><br>    <span class="hljs-comment">//&#123; &#125;</span><br>    <span class="hljs-comment">// 否则需要显示调用父类得构造函数，因为总是会先调用父类得构造函数，然后调用子类得构造函数，如果子类没有写构造函数，会提供一个子类得默认构造函数，而不是使用父类得默认构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.Speak(); <span class="hljs-comment">// 调用父类的Speak方法</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> barks.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-方法重写（override）"><a href="#5-方法重写（override）" class="headerlink" title="5. 方法重写（override）"></a>5. 方法重写（<code>override</code>）</h3><ul><li><p>如果子类需要修改父类的方法行为，可以使用<code>override</code>关键字重写父类的方法。</p></li><li><p>父类的方法必须使用<code>virtual</code>关键字进行标记。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">//public virtual两种顺序都行</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果不使用virtual关键字</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> i</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a noise=1.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-comment">// 如果是有意隐藏父类中的相同的方法，需要加new，否则会警告</span><br>    <span class="hljs-comment">// 但是和Cpp不一样，父类中其他同名的还是可以用，重载的都可以用，不会全部隐藏。Cpp里面叫名字遮蔽</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        dog.Speak();<br>        dog.Speak(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-继承的限制"><a href="#6-继承的限制" class="headerlink" title="6. 继承的限制"></a>6. 继承的限制</h3><ul><li><strong>不能继承<code>sealed</code>类</strong>：如果一个类被标记为<code>sealed</code>，则不能被继承。</li><li><strong><code>static</code>类不能被继承</strong>：静态类不能被继承或实例化。</li></ul><h3 id="7-里氏替换原则"><a href="#7-里氏替换原则" class="headerlink" title="7. 里氏替换原则"></a>7. 里氏替换原则</h3><p>可以将子类对象赋值给父类引用（基类类型的引用可以指向派生类对象），这样可以利用多态实现灵活的代码设计。<br>继承提供了一种强大的代码复用和扩展功能的方式，在设计类的层次结构时需要合理使用。<br>在C#中，可以将子类对象赋值给父类引用，这种行为称为<strong>多态</strong>。通过这种方式，可以利用父类引用来处理不同子类的对象，从而实现灵活的代码设计。下面是一个简单的示例来展示这一点。</p><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal speaks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类：Dog</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类：Cat</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Cat meows.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 Dog 和 Cat 的实例</span><br>        Animal myDog = <span class="hljs-keyword">new</span> Dog();<br>        Animal myCat = <span class="hljs-keyword">new</span> Cat();<br><br>        <span class="hljs-comment">// 调用 Speak 方法，实际调用的是派生类的方法</span><br>        myDog.Speak(); <span class="hljs-comment">// 输出: Dog barks.</span><br>        myCat.Speak(); <span class="hljs-comment">// 输出: Cat meows.</span><br><br>        <span class="hljs-comment">// 使用多态的集合</span><br>        Animal[] animals = &#123; myDog, myCat &#125;;<br><br>        <span class="hljs-comment">// 遍历集合并调用 Speak 方法</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> animal <span class="hljs-keyword">in</span> animals)<br>        &#123;<br>            animal.Speak();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Dog barks.<br>Cat meows.<br>Dog barks.<br>Cat meows.<br></code></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol><li><strong>基类 <code>Animal</code></strong> ：<ul><li>定义了一个虚方法 <code>Speak()</code>，这个方法可以在派生类中被重写。</li></ul></li><li><strong>派生类 <code>Dog</code> 和 <code>Cat</code></strong> ：<ul><li>分别重写了 <code>Speak()</code> 方法，提供了特定的实现。</li><li><code>Dog</code> 类输出 <code>&quot;Dog barks.&quot;</code>，而 <code>Cat</code> 类输出 <code>&quot;Cat meows.&quot;</code></li></ul></li><li><strong>多态</strong> ：<ul><li>在 <code>Main</code> 方法中，创建了 <code>Dog</code> 和 <code>Cat</code> 的实例，并将它们赋值给 <code>Animal</code> 类型的引用 <code>myDog</code> 和 <code>myCat</code>。</li><li>通过调用 <code>Speak()</code> 方法，尽管引用类型是 <code>Animal</code>，实际调用的是子类 <code>Dog</code> 和 <code>Cat</code> 的实现。</li></ul></li><li><strong>集合与多态</strong> ：<ul><li>使用 <code>Animal</code> 数组存储不同类型的动物，通过遍历数组调用 <code>Speak()</code> 方法，展现了多态的灵活性和可扩展性。</li></ul></li></ol><h3 id="子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数"><a href="#子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数" class="headerlink" title="子类的构造函数会首先调用父类的构造函数。可以使用base关键字来指定调用父类的哪个构造函数"></a>子类的构造函数会首先调用父类的构造函数。可以使用<code>base</code>关键字来指定调用父类的哪个构造函数</h3><p>在C#中，子类的构造函数在创建对象时会首先调用父类的构造函数。这可以确保父类的初始化逻辑在子类的初始化之前执行。使用<code>base</code>关键字可以指定调用父类的特定构造函数。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个简单的示例，展示了如何在子类构造函数中调用父类构造函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 父类的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        Name = name;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> has been created.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Breed &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 子类的构造函数，调用父类的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> breed</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>)</span><br>    &#123;<br>        Breed = breed;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is a <span class="hljs-subst">&#123;Breed&#125;</span>.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Dog myDog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-string">&quot;Golden Retriever&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Buddy has been created.<br>Buddy <span class="hljs-keyword">is</span> a Golden Retriever.<br></code></pre></td></tr></table></figure><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><ol><li><strong>父类构造函数</strong>：<code>Animal</code>类有一个构造函数，接收一个参数<code>name</code>，用于初始化<code>Name</code>属性，并打印消息。</li><li><strong>子类构造函数</strong>：<code>Dog</code>类的构造函数接收两个参数：<code>name</code>和<code>breed</code>。在构造函数的参数列表中，使用<code>base(name)</code>调用父类<code>Animal</code>的构造函数，将<code>name</code>传递给它。</li><li><strong>实例化对象</strong>：在<code>Main</code>方法中，创建了一个<code>Dog</code>类的实例<code>myDog</code>，传递了<code>&quot;Buddy&quot;</code>和<code>&quot;Golden Retriever&quot;</code>。创建对象时，首先调用<code>Animal</code>类的构造函数，然后再执行<code>Dog</code>类的构造函数。<br>这个例子展示了如何在子类中通过<code>base</code>关键字调用父类构造函数，确保父类的初始化逻辑被正确执行。</li></ol><h1 id="28-is和as"><a href="#28-is和as" class="headerlink" title="28. is和as"></a>28. is和as</h1><blockquote><p>在C#中，<code>is</code> 和 <code>as</code> 是两个用于类型检查和类型转换的关键字</p></blockquote><h3 id="is-关键字"><a href="#is-关键字" class="headerlink" title="is 关键字"></a><code>is</code> 关键字</h3><p><code>is</code> 用于检查一个对象是否是某个特定类型或是否实现了某个接口。它返回一个布尔值，指示对象是否可以安全地转换为指定的类型。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-comment">// 使用 is 检查 obj 是否是字符串类型</span><br>        <span class="hljs-comment">// “模式匹配”（Pattern Matching）</span><br>        <span class="hljs-comment">// obj is string str 的意思是：</span><br>        <span class="hljs-comment">// 检查 obj 是否是 string 类型。</span><br>        <span class="hljs-comment">// 如果 obj 是 string 类型，则将 obj 转换为 string 类型，并赋值给新的局部变量 str。</span><br>        <span class="hljs-comment">// 这个str只能在if的作用域内使用，只是一个局部变量</span><br>        <span class="hljs-comment">// 如果类型检查成功（即 obj 是 string 类型），表达式的值为 true，并且可以在之后的代码中使用 str 变量。</span><br>        <span class="hljs-comment">// 否则表达式的值为false，那么 str 不会被定义，也无法在 if 语句块外使用 str。</span><br>        <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> str)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;The object is a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The object is not a string.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">The <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> a <span class="hljs-built_in">string</span>: Hello, World!<br></code></pre></td></tr></table></figure><h3 id="as-关键字"><a href="#as-关键字" class="headerlink" title="as 关键字"></a><code>as</code> 关键字</h3><p><code>as</code> 用于尝试将一个<code>对象</code>转换为指定的类型，值类型不可以。如果转换成功，它会返回转换后的对象；如果失败，它会返回 <code>null</code>，而不会抛出异常。这在需要进行类型转换时非常有用，可以避免潜在的运行时错误。</p><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-comment">// 使用 as 尝试将 obj 转换为字符串类型</span><br>        <span class="hljs-built_in">string</span> str = obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>;<br><br>        <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;The object was successfully converted to a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The object could not be converted to a string.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">The <span class="hljs-selector-tag">object</span> was successfully converted <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">a</span> string: Hello, World!<br></code></pre></td></tr></table></figure><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><ol><li><strong>用途</strong>：<ul><li><code>is</code>：用于检查对象的类型，返回一个布尔值。</li><li><code>as</code>：用于进行安全的类型转换，返回转换后的对象或 <code>null</code>。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>is</code> 返回 <code>true</code> 或 <code>false</code>。</li><li><code>as</code> 返回转换后的对象或 <code>null</code>。</li></ul></li><li><strong>异常处理</strong>：<ul><li>使用 <code>is</code> 进行类型检查时，不会抛出异常。</li><li>使用 <code>as</code> 进行类型转换时，如果转换失败，不会抛出异常，而是返回 <code>null</code>。</li></ul></li></ol><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>使用 <code>is</code> 当你只需要知道一个对象的类型时。</li><li>使用 <code>as</code> 当你希望将一个对象转换为特定类型，并且希望在失败时得到 <code>null</code> 而不是异常时。</li></ul><h1 id="29-模式匹配（Pattern-Matching）"><a href="#29-模式匹配（Pattern-Matching）" class="headerlink" title="29. 模式匹配（Pattern Matching）"></a>29. 模式匹配（Pattern Matching）</h1><p><strong>模式匹配</strong>（Pattern Matching）是C#中的一种特性，用于检查某个对象是否符合指定的类型或条件，并在匹配成功时将其转换为相应类型或结构。这种特性可以简化类型检查和转换的代码，使代码更加简洁和可读。</p><h3 id="模式匹配的常见用法"><a href="#模式匹配的常见用法" class="headerlink" title="模式匹配的常见用法"></a>模式匹配的常见用法</h3><h4 id="1-类型模式匹配（Type-Pattern-Matching）"><a href="#1-类型模式匹配（Type-Pattern-Matching）" class="headerlink" title="1. 类型模式匹配（Type Pattern Matching）"></a>1. <strong>类型模式匹配（Type Pattern Matching）</strong></h4><ul><li>用于检查一个对象是否属于某种类型，并在成功时将其转换为该类型。这种模式在<code>is</code>关键字后面使用。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-built_in">string</span> str)<br>&#123;<br>    <span class="hljs-comment">// str 现在是一个 string 类型</span><br>    Console.WriteLine(<span class="hljs-string">$&quot;The object is a string: <span class="hljs-subst">&#123;str&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is not a string.&quot;</span>);<br><br></code></pre></td></tr></table></figure>在这个示例中，如果<code>obj</code>是<code>string</code>类型，则将其转换为<code>str</code>，并可以在<code>if</code>语句块中使用。</li></ul><h4 id="2-常量模式匹配（Constant-Pattern-Matching）"><a href="#2-常量模式匹配（Constant-Pattern-Matching）" class="headerlink" title="2. 常量模式匹配（Constant Pattern Matching）"></a>2. <strong>常量模式匹配（Constant Pattern Matching）</strong></h4><ul><li>可以用于比较对象是否与某个常量相等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (number <span class="hljs-keyword">is</span> <span class="hljs-number">10</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The number is 10.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The number is not 10.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>这里通过<code>is</code>来检查<code>number</code>是否等于常量10。</li><li>上面的例子太简单，看这个<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">42</span>;<br><br><span class="hljs-comment">// 使用常量模式匹配</span><br><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">is</span> <span class="hljs-number">42</span>)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is 42&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用==操作符</span><br><span class="hljs-keyword">if</span> (obj.Equals(<span class="hljs-number">42</span>))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The object is also 42&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-表达式模式匹配（Expression-Pattern-Matching）"><a href="#3-表达式模式匹配（Expression-Pattern-Matching）" class="headerlink" title="3. 表达式模式匹配（Expression Pattern Matching）"></a>3. <strong>表达式模式匹配（Expression Pattern Matching）</strong></h4><ul><li>允许在<code>switch</code>表达式中使用模式匹配。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">42</span>;<br><br><span class="hljs-keyword">switch</span> (obj)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &gt; <span class="hljs-number">0</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Positive integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &lt; <span class="hljs-number">0</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Negative integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">string</span> s:<br>        Console.WriteLine(<span class="hljs-string">$&quot;String: <span class="hljs-subst">&#123;s&#125;</span>&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Unknown type or condition.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>在这里，<code>switch</code>表达式结合<code>when</code>条件可以对对象的不同模式进行匹配并处理。</li></ul><h5 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h5><p>这个<code>switch</code>语句使用了模式匹配的功能来处理不同类型和条件的<code>obj</code>值，<code>when</code>关键字用于指定额外的条件约束。具体解释如下：</p><ol><li><code>case int i when i &gt; 0</code>：<ul><li>这里的<code>case</code>语句匹配<code>obj</code>的类型，如果<code>obj</code>是一个整数（<code>int</code>），定义一个局部变量<code>i</code>，<code>i</code>就是<code>obj</code>转换为<code>int</code>的变量，进行下一步判断。</li><li><code>when i &gt; 0</code> 表示只有当<code>i</code>大于0时，这个<code>case</code>才会匹配，输出“Positive integer.”。</li></ul></li><li><code>case int i when i &lt; 0</code>：<ul><li>同样，这个分支首先检查<code>obj</code>的类型是否为整数（<code>int</code>），然后判断这个整数是否小于0。</li><li>当<code>i &lt; 0</code>时，匹配成功，输出“Negative integer.”。</li></ul></li><li><code>case string s</code>：<ul><li>如果前面的条件都不满足，则检查<code>obj</code>是否为字符串（<code>string</code>）类型。</li><li>如果是，则匹配成功，并输出字符串内容，例如“String: …”。</li></ul></li><li><code>default</code>：<ul><li>如果<code>obj</code>的类型不匹配前面的任何一个<code>case</code>，则执行<code>default</code>分支，输出“Unknown type or condition.”。</li></ul></li></ol><h5 id="when关键字的作用"><a href="#when关键字的作用" class="headerlink" title="when关键字的作用"></a><code>when</code>关键字的作用</h5><p><code>when</code>用于在匹配类型的基础上添加条件约束。即使类型匹配成功，也要满足<code>when</code>后面的条件，才能执行该分支。它可以用于进一步筛选具体的情况，使模式匹配更灵活和精确。</p><h4 id="4-位置模式匹配（Positional-Pattern-Matching）"><a href="#4-位置模式匹配（Positional-Pattern-Matching）" class="headerlink" title="4. 位置模式匹配（Positional Pattern Matching）"></a>4. <strong>位置模式匹配（Positional Pattern Matching）</strong></h4><ul><li>用于解构对象，匹配对象的属性或字段。这在C# 8.0及更高版本中得到支持。</li><li>位置模式匹配用于检查元组或某些类型的值是否与指定的模式匹配。这里的<code>(3, 4)</code>是一个位置模式，它表示检查元组中的每个元素是否与指定的值匹配。</li><li>例如，<code>point is (3, 4)</code>意味着检查<code>point</code>是否是一个有两个元素的元组，并且第一个元素的值为<code>3</code>，第二个元素的值为<code>4</code>。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-function">point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>))</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The point is (3, 4).&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>这个例子检查一个元组是否具有指定的值。</li></ul><h4 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h4><ol><li><strong>元组的定义</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>这里定义了一个元组<code>point</code>，它有两个元素<code>X</code>和<code>Y</code>，分别赋值为<code>3</code>和<code>4</code>。这个元组的类型是<code>(int X, int Y)</code>，表示一个包含两个整型值的元组。</li><li><strong>模式匹配检查</strong>:<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">if</span> (<span class="hljs-function">point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>))</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;The point is (3, 4).&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>这段代码中的<code>point is (3, 4)</code>使用了<strong>位置模式匹配（Positional Pattern Matching）</strong> 来检查<code>point</code>的值是否为<code>(3, 4)</code>。</li></ol><ul><li><code>point is (3, 4)</code>表示检查<code>point</code>是否是一个元组，并且其第一个元素的值为<code>3</code>，第二个元素的值为<code>4</code>。</li><li>如果<code>point</code>的值确实为<code>(3, 4)</code>，则条件成立，执行<code>Console.WriteLine(&quot;The point is (3, 4).&quot;);</code>。</li></ul><h4 id="元组和模式匹配"><a href="#元组和模式匹配" class="headerlink" title="元组和模式匹配"></a>元组和模式匹配</h4><ul><li>C#中的元组可以用来存储一组相关的数据，并且可以通过模式匹配来对元组的值进行检查。</li><li>在<code>if</code>语句中使用<code>is</code>关键字进行模式匹配时，会将元组的值与指定的常量进行比较。</li><li>这种方法可以用于简洁地检查多个值是否匹配特定的组合。</li></ul><h4 id="代码运行结果"><a href="#代码运行结果" class="headerlink" title="代码运行结果"></a>代码运行结果</h4><p>如果<code>point</code>的值为<code>(3, 4)</code>，那么程序会输出：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">The point <span class="hljs-title">is</span> (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>).</span><br></code></pre></td></tr></table></figure><p>如果<code>point</code>的值不同，比如<code>(5, 6)</code>，则不会输出任何内容。</p><h3 id="模式匹配的优势"><a href="#模式匹配的优势" class="headerlink" title="模式匹配的优势"></a>模式匹配的优势</h3><ul><li><strong>简洁性</strong>：无需额外的类型转换代码。</li><li><strong>安全性</strong>：通过类型检查和转换结合，减少显式类型转换带来的潜在错误。</li><li><strong>灵活性</strong>：可以根据不同的条件和类型编写简洁的控制流。<br>模式匹配在C# 7.0及更高版本中引入，并在后续版本中不断扩展，使得类型检查、条件分支处理更加直观。</li></ul><h1 id="30-when的使用场景"><a href="#30-when的使用场景" class="headerlink" title="30. when的使用场景"></a>30. when的使用场景</h1><p><code>when</code>关键字主要用于<code>switch</code>表达式和<code>case</code>语句中，提供对模式匹配的额外条件约束。常见的使用场景包括：</p><h3 id="1-精确控制匹配条件"><a href="#1-精确控制匹配条件" class="headerlink" title="1. 精确控制匹配条件"></a>1. <strong>精确控制匹配条件</strong></h3><ul><li>当对类型匹配不够时，<code>when</code>可以进一步限定匹配的条件。例如，在类型匹配的基础上，还可以检查数值范围、字符串内容等。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">switch</span> (obj)<br>&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &gt; <span class="hljs-number">100</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Large number.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> i <span class="hljs-keyword">when</span> i &lt;= <span class="hljs-number">100</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Small number.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Not an integer.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-处理多个条件的组合"><a href="#2-处理多个条件的组合" class="headerlink" title="2. 处理多个条件的组合"></a>2. <strong>处理多个条件的组合</strong></h3><ul><li>适用于多个条件的组合场景。比如同时对类型和某些属性进行匹配时，可以用<code>when</code>来增加逻辑判断。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">switch</span> (person)<br>&#123;<br>    <span class="hljs-keyword">case</span> Employee e <span class="hljs-keyword">when</span> e.YearsOfService &gt; <span class="hljs-number">10</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Senior Employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Employee e <span class="hljs-keyword">when</span> e.YearsOfService &lt;= <span class="hljs-number">10</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Junior Employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;Not an employee.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-在异常处理中的使用"><a href="#3-在异常处理中的使用" class="headerlink" title="3. 在异常处理中的使用"></a>3. <strong>在异常处理中的使用</strong></h3><ul><li>可以在<code>catch</code>语句中结合<code>when</code>条件处理特定的异常情况。例如，在捕获异常时，根据异常的某个属性来判断是否执行该捕获块。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">// Some code that might throw exceptions</span><br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) <span class="hljs-keyword">when</span> (ex.Message.Contains(<span class="hljs-string">&quot;disk&quot;</span>))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Disk-related error.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;General I/O error.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-筛选集合中的元素"><a href="#4-筛选集合中的元素" class="headerlink" title="4. 筛选集合中的元素"></a>4. <strong>筛选集合中的元素</strong></h3><ul><li>在处理集合数据时，使用<code>when</code>可以根据元素的条件筛选匹配的元素。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>&#123;<br>    <span class="hljs-keyword">switch</span> (number)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> n <span class="hljs-keyword">when</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;n&#125;</span> is even.&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">int</span> n:<br>            Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;n&#125;</span> is odd.&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="31-var"><a href="#31-var" class="headerlink" title="31. var"></a>31. var</h1><p><code>var</code> 是 C# 中的一种隐式类型声明方式，用于让编译器自动推断变量的类型。在使用 <code>var</code> 时，编译器会根据赋值的表达式确定变量的具体类型。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>var</code> 可以在以下情况下使用：</p><ol><li><strong>局部变量的类型推断</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> number = <span class="hljs-number">10</span>; <span class="hljs-comment">// 编译器推断为 int 类型</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 编译器推断为 string 类型</span><br><span class="hljs-keyword">var</span> isCompleted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 编译器推断为 bool 类型</span><br></code></pre></td></tr></table></figure></li><li><strong>集合或复杂对象</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">// 编译器推断为 List&lt;int&gt; 类型</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span>, Age = <span class="hljs-number">30</span> &#125;; <span class="hljs-comment">// 匿名类型</span><br></code></pre></td></tr></table></figure></li><li><strong>LINQ 查询结果</strong>：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> numbers<br>             <span class="hljs-keyword">where</span> n &gt; <span class="hljs-number">5</span><br>             <span class="hljs-keyword">select</span> n;<br></code></pre></td></tr></table></figure></li></ol><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 <code>var</code> 时，必须立即对变量进行初始化，因为编译器需要根据赋值来推断类型。</li><li>一旦类型推断完成，变量的类型在编译时就已经确定，不能改变。</li></ul><h3 id="var-的优缺点"><a href="#var-的优缺点" class="headerlink" title="var 的优缺点"></a><code>var</code> 的优缺点</h3><p><strong>优点</strong>：</p><ul><li>代码更简洁，避免重复声明类型。</li><li>适合处理匿名类型和复杂类型。<br><strong>缺点</strong>：</li><li>可能会降低代码的可读性，尤其是在类型不明显时。</li></ul><h3 id="C-的var和C-的auto"><a href="#C-的var和C-的auto" class="headerlink" title="C#的var和C++的auto"></a>C#的var和C++的auto</h3><h4 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h4><ol><li><strong>类型自动推断</strong>：在两者中，编译器根据右侧的表达式来推断变量的类型。例如：<ul><li><strong>C#</strong> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 编译器推断为 int</span><br></code></pre></td></tr></table></figure></li><li><strong>C++</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 编译器推断为 int</span><br></code></pre></td></tr></table></figure></li></ul></li><li><strong>简化代码</strong>：使用 <code>var</code> 或 <code>auto</code> 可以减少重复的类型声明，使代码更简洁。</li><li><strong>必须初始化</strong>：两者在声明时都必须立即进行初始化，因为编译器需要根据赋值来确定类型。</li></ol><h4 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h4><ol><li><strong>使用场景</strong>：<ul><li>在 C# 中，<code>var</code> 只能用于局部变量的类型推断，而不能用于方法参数、返回类型或字段。</li><li>在 C++ 中，<code>auto</code> 可以用于函数的返回类型推断（C++14 起支持），也可以在循环中使用 <code>auto</code> 来自动推断迭代器的类型。</li></ul></li><li><strong>类型推断的时间点</strong>：<ul><li>C# 的类型推断是在编译时进行的，变量的类型一旦确定，就无法更改。</li><li>C++ 中的 <code>auto</code> 也是在编译时进行类型推断，但由于 C++ 支持模板和类型推断的多样性，<code>auto</code> 可以用于更复杂的场景，如模板编程。</li></ul></li><li><strong>类型推断的灵活性</strong>：<ul><li>C++ 中的 <code>auto</code> 还可以和 <code>const</code>、<code>&amp;</code>（引用）等结合使用，来推断更复杂的类型，如常量引用。</li><li>C# 中的 <code>var</code> 不支持这样的组合用法。</li></ul></li></ol><h1 id="32-元组"><a href="#32-元组" class="headerlink" title="32. 元组"></a>32. 元组</h1><p>在 C# 中，元组（Tuple）是一种数据结构，可以存储多个不同类型的值。元组的主要特点是简单、轻量，可以快速创建和传递多个相关的数据。以下是对 C# 中元组的详细介绍：</p><h3 id="1-定义和创建元组"><a href="#1-定义和创建元组" class="headerlink" title="1. 定义和创建元组"></a>1. <strong>定义和创建元组</strong></h3><p>在 C# 中，你可以使用 <code>Tuple</code> 类或更简洁的语法来创建元组。C# 7.0 引入了更简化的元组语法，使用小括号和命名元素。</p><h4 id="使用-Tuple-类"><a href="#使用-Tuple-类" class="headerlink" title="使用 Tuple 类"></a><strong>使用 <code>Tuple</code> 类</strong></h4><p><code>Tuple</code> 类可以包含最多 <strong>8</strong> 个元素。如果需要更多的元素，可以嵌套使用元组。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = <span class="hljs-keyword">new</span> Tuple&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">double</span>, <span class="hljs-built_in">char</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>Console.WriteLine(tuple.Item1); <span class="hljs-comment">// 输出: 1</span><br>Console.WriteLine(tuple.Item2); <span class="hljs-comment">// 输出: Hello</span><br>Console.WriteLine(tuple.Item3); <span class="hljs-comment">// 输出: 3.14</span><br>Console.WriteLine(tuple.Item4); <span class="hljs-comment">// 输出: A</span><br></code></pre></td></tr></table></figure><h4 id="使用-C-7-0-及以上的元组简化语法"><a href="#使用-C-7-0-及以上的元组简化语法" class="headerlink" title="使用 C# 7.0 及以上的元组简化语法"></a><strong>使用 C# 7.0 及以上的元组简化语法</strong></h4><p>C# 7.0 引入了更简洁的元组语法，可以轻松创建和使用多个元素的元组：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = (Id: <span class="hljs-number">1</span>, Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>, Height: <span class="hljs-number">1.75</span>, IsStudent: <span class="hljs-literal">false</span>);<br>Console.WriteLine(tuple.Id);      <span class="hljs-comment">// 输出: 1</span><br>Console.WriteLine(tuple.Name);     <span class="hljs-comment">// 输出: Alice</span><br>Console.WriteLine(tuple.Age);      <span class="hljs-comment">// 输出: 30</span><br>Console.WriteLine(tuple.Height);   <span class="hljs-comment">// 输出: 1.75</span><br>Console.WriteLine(tuple.IsStudent); <span class="hljs-comment">// 输出: False</span><br></code></pre></td></tr></table></figure><h4 id="嵌套元组"><a href="#嵌套元组" class="headerlink" title="嵌套元组"></a><strong>嵌套元组</strong></h4><p>如果需要更多的元素，可以通过嵌套元组的方式来实现：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> tuple = (Person: (Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>), Coordinates: (X: <span class="hljs-number">10</span>, Y: <span class="hljs-number">20</span>));<br>        Console.WriteLine(tuple.Person); <span class="hljs-comment">// 输出: (Alice, 30)</span><br>        Console.WriteLine(tuple.Coordinates.X); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-访问元组元素"><a href="#2-访问元组元素" class="headerlink" title="2. 访问元组元素"></a>2. <strong>访问元组元素</strong></h3><p>可以通过属性（对于 <code>Tuple</code> 类）或直接使用字段（对于简化语法）来访问元组的元素。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tuple = (X: <span class="hljs-number">10</span>, Y: <span class="hljs-number">20</span>);<br>Console.WriteLine(tuple.X); <span class="hljs-comment">// 输出: 10</span><br>Console.WriteLine(tuple.Y); <span class="hljs-comment">// 输出: 20</span><br></code></pre></td></tr></table></figure><h3 id="3-元组的解构"><a href="#3-元组的解构" class="headerlink" title="3. 元组的解构"></a>3. <strong>元组的解构</strong></h3><p>C# 支持元组解构，可以将元组的元素赋值给多个变量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> point = (X: <span class="hljs-number">3</span>, Y: <span class="hljs-number">4</span>);<br><span class="hljs-keyword">var</span> (x, y) = point;<br>Console.WriteLine(x); <span class="hljs-comment">// 输出: 3</span><br>Console.WriteLine(y); <span class="hljs-comment">// 输出: 4</span><br></code></pre></td></tr></table></figure><h3 id="4-元组的用途"><a href="#4-元组的用途" class="headerlink" title="4. 元组的用途"></a>4. <strong>元组的用途</strong></h3><p>元组通常用于以下场景：</p><ul><li>返回多个值：可以用元组来返回多个相关的值，而不需要创建一个新的类或结构体。</li><li>临时数据存储：在不需要定义一个完整的类的情况下，快速存储和处理小规模的数据。</li></ul><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h3><ul><li>元组的元素类型可以不同，但元组本身是不可变的，这意味着一旦创建，元组的元素值不能被改变。</li><li>对于需要更多功能和可读性的场景，建议使用自定义类或结构体。</li></ul><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><p>下面是一个完整的示例，演示了如何使用元组：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> person = (Name: <span class="hljs-string">&quot;Alice&quot;</span>, Age: <span class="hljs-number">30</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;person.Name&#125;</span>, Age: <span class="hljs-subst">&#123;person.Age&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 解构元组</span><br>        <span class="hljs-keyword">var</span> (name, age) = person;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;name&#125;</span>, Age: <span class="hljs-subst">&#123;age&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="33-LINQ"><a href="#33-LINQ" class="headerlink" title="33. LINQ"></a>33. LINQ</h1><p>LINQ（Language Integrated Query）是 C# 中的一种用于处理数据的查询语言。它使开发人员能够使用类似于 SQL 的语法来查询和操作数据，而不需要具体了解数据的存储方式。LINQ 可以用于多种数据源，包括数组、集合、XML、数据库等。</p><ul><li>只是简单记录，以后用到再说</li></ul><h3 id="LINQ-的主要特点"><a href="#LINQ-的主要特点" class="headerlink" title="LINQ 的主要特点"></a>LINQ 的主要特点</h3><ol><li><strong>集成查询</strong>：LINQ 提供了一种将查询逻辑直接嵌入 C# 代码中的方式。</li><li><strong>强类型</strong>：LINQ 查询是强类型的，编译时会检查类型安全。</li><li><strong>可读性</strong>：LINQ 语法简洁易读，类似于 SQL，使得代码更容易理解。</li><li><strong>延迟执行</strong>：LINQ 查询支持延迟执行，即查询直到实际需要结果时才会执行。</li></ol><h3 id="LINQ-的基本用法"><a href="#LINQ-的基本用法" class="headerlink" title="LINQ 的基本用法"></a>LINQ 的基本用法</h3><p>以下是 LINQ 的一些常见用法示例：</p><h4 id="1-LINQ-to-Objects"><a href="#1-LINQ-to-Objects" class="headerlink" title="1. LINQ to Objects"></a>1. <strong>LINQ to Objects</strong></h4><p>查询集合中的数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<br><br>        <span class="hljs-comment">// 查询所有大于 3 的数字</span><br>        <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> numbers<br>                     <span class="hljs-keyword">where</span> n &gt; <span class="hljs-number">3</span><br>                     <span class="hljs-keyword">select</span> n;<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>        &#123;<br>            Console.WriteLine(number); <span class="hljs-comment">// 输出: 4, 5, 6</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-LINQ-to-SQL"><a href="#2-LINQ-to-SQL" class="headerlink" title="2. LINQ to SQL"></a>2. <strong>LINQ to SQL</strong></h4><p>查询数据库中的数据。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> YourDataContext())<br>&#123;<br>    <span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> c <span class="hljs-keyword">in</span> context.Customers<br>                <span class="hljs-keyword">where</span> c.City == <span class="hljs-string">&quot;London&quot;</span><br>                <span class="hljs-keyword">select</span> c;<br><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> customer <span class="hljs-keyword">in</span> query)<br>    &#123;<br>        Console.WriteLine(customer.Name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-方法语法"><a href="#3-方法语法" class="headerlink" title="3. 方法语法"></a>3. <strong>方法语法</strong></h4><p>LINQ 支持两种语法：查询语法和方法语法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = numbers.Where(n =&gt; n &gt; <span class="hljs-number">3</span>); <span class="hljs-comment">// 方法语法</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出: 4, 5, 6</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-组合查询"><a href="#4-组合查询" class="headerlink" title="4. 组合查询"></a>4. <strong>组合查询</strong></h4><p>你可以将多个 LINQ 查询组合在一起。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> result = numbers<br>    .Where(n =&gt; n &gt; <span class="hljs-number">2</span>)<br>    .Select(n =&gt; n * <span class="hljs-number">2</span>); <span class="hljs-comment">// 先过滤，然后乘以 2</span><br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> result)<br>&#123;<br>    Console.WriteLine(number); <span class="hljs-comment">// 输出: 6, 8, 10, 12</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-进一步处理，不仅仅是LINQ可以用"><a href="#5-进一步处理，不仅仅是LINQ可以用" class="headerlink" title="5. 进一步处理，不仅仅是LINQ可以用"></a>5. 进一步处理，不仅仅是LINQ可以用</h4><p>除了 <code>ToList()</code>，LINQ 查询结果还可以通过其他方法进行转换或进一步处理。常用的 LINQ 转换方法包括：</p><ol><li><strong><code>ToArray()</code></strong><br> 将查询结果转换为数组。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersArray = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToArray();<br></code></pre></td></tr></table></figure></li><li><strong><code>ToDictionary()</code></strong><br> 将查询结果转换为字典，需要指定键和值的选择器。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersDictionary = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                                   .ToDictionary(n =&gt; n, n =&gt; n.ToString());<br><span class="hljs-comment">// 这里键是数字本身，值是对应的字符串表示</span><br></code></pre></td></tr></table></figure></li><li><strong><code>ToHashSet()</code></strong><br> 将查询结果转换为 <code>HashSet</code>，去除重复项。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> evenNumbersSet = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToHashSet();<br></code></pre></td></tr></table></figure></li><li><strong><code>First()</code> &#x2F; <code>FirstOrDefault()</code></strong><br> 返回第一个符合条件的元素，<code>FirstOrDefault()</code> 如果没有找到元素会返回类型的默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> firstEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).First();<br><span class="hljs-keyword">var</span> firstEvenOrDefault = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).FirstOrDefault();<br></code></pre></td></tr></table></figure></li><li><strong><code>Last()</code> &#x2F; <code>LastOrDefault()</code></strong><br> 返回最后一个符合条件的元素，<code>LastOrDefault()</code> 如果没有找到元素会返回类型的默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> lastEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Last();<br><span class="hljs-keyword">var</span> lastEvenOrDefault = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).LastOrDefault();<br></code></pre></td></tr></table></figure></li><li><strong><code>Single()</code> &#x2F; <code>SingleOrDefault()</code></strong><br> 返回唯一一个符合条件的元素，如果有多个或没有找到则抛出异常，<code>SingleOrDefault()</code> 在没有找到时返回默认值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> singleEven = numbers.Where(n =&gt; n == <span class="hljs-number">2</span>).Single();<br><span class="hljs-keyword">var</span> singleEvenOrDefault = numbers.Where(n =&gt; n == <span class="hljs-number">2</span>).SingleOrDefault();<br></code></pre></td></tr></table></figure></li><li><strong><code>Count()</code></strong><br> 计算符合条件的元素个数。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> evenCount = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Count();<br></code></pre></td></tr></table></figure></li><li><strong><code>Any()</code></strong><br> 判断是否有任何元素符合条件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> hasEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Any();<br></code></pre></td></tr></table></figure></li><li><strong><code>All()</code></strong><br> 判断是否所有元素都符合条件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">bool</span> allEven = numbers.All(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><strong><code>Max()</code> &#x2F; <code>Min()</code></strong><br>查找最大或最小值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> maxEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Max();<br><span class="hljs-built_in">int</span> minEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Min();<br></code></pre></td></tr></table></figure></li><li><strong><code>Sum()</code> &#x2F; <code>Average()</code></strong><br>计算总和或平均值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> sumEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Sum();<br><span class="hljs-built_in">double</span> avgEven = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).Average();<br><br></code></pre></td></tr></table></figure></li><li><strong><code>ToList()</code></strong><br>将查询结果转换为List。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 示例列表</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> &#125;;<br><br>        <span class="hljs-comment">// 使用 LINQ 查询筛选出所有偶数，并转换为 List&lt;int&gt;</span><br>        List&lt;<span class="hljs-built_in">int</span>&gt; evenNumbers = numbers.Where(n =&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).ToList();<br><br>        <span class="hljs-comment">// 输出结果</span><br>        Console.WriteLine(<span class="hljs-string">&quot;偶数列表:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> num <span class="hljs-keyword">in</span> evenNumbers)<br>        &#123;<br>            Console.WriteLine(num);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="LINQ-的常用操作"><a href="#LINQ-的常用操作" class="headerlink" title="LINQ 的常用操作"></a>LINQ 的常用操作</h3><ul><li><strong>Where</strong>：过滤数据。</li><li><strong>Select</strong>：投影数据。</li><li><strong>OrderBy</strong> 和 <strong>OrderByDescending</strong>：排序。</li><li><strong>GroupBy</strong>：分组。</li><li><strong>Join</strong>：连接多个数据源。</li><li><strong>Count</strong>、<strong>Sum</strong>、<strong>Average</strong>、<strong>Max</strong>、<strong>Min</strong>：聚合操作。</li></ul><h1 id="34-C-中的Object，装箱和拆箱"><a href="#34-C-中的Object，装箱和拆箱" class="headerlink" title="34. C#中的Object，装箱和拆箱"></a>34. C#中的Object，装箱和拆箱</h1><p>在C#中，<strong>装箱</strong>（Boxing）和<strong>拆箱</strong>（Unboxing）是指值类型和引用类型之间的转换过程。理解这两个概念有助于掌握C#中的内存管理和类型转换。</p><h3 id="装箱（Boxing）"><a href="#装箱（Boxing）" class="headerlink" title="装箱（Boxing）"></a>装箱（Boxing）</h3><p>装箱是将一个值类型转换为对象类型（引用类型）的过程。此过程会在堆上分配内存，并将值类型的值复制到该内存位置。<br><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 值类型</span><br><span class="hljs-built_in">object</span> boxedNumber = number; <span class="hljs-comment">// 装箱</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>number</code> 是一个值类型的 <code>int</code>，当我们将它赋值给 <code>object</code> 类型的 <code>boxedNumber</code> 时，发生了装箱。<code>number</code> 的值被复制到堆上一个新的对象中。</p><h3 id="拆箱（Unboxing）"><a href="#拆箱（Unboxing）" class="headerlink" title="拆箱（Unboxing）"></a>拆箱（Unboxing）</h3><p>拆箱是将一个已装箱的对象转换回值类型的过程。此过程会将对象的值复制回值类型变量。<br><strong>示例：</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> boxedNumber = <span class="hljs-number">42</span>; <span class="hljs-comment">// 装箱</span><br><span class="hljs-built_in">int</span> unboxedNumber = (<span class="hljs-built_in">int</span>)boxedNumber; <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>boxedNumber</code> 是一个对象，它包含了一个整型值。通过将其强制转换为 <code>int</code>，我们执行了拆箱操作。</p><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>性能开销</strong>：装箱和拆箱会导致额外的性能开销，因为它们涉及内存分配和数据复制。因此，尽量避免频繁的装箱和拆箱。<br>装箱和拆箱会导致性能开销的原因主要在于它们涉及<strong>内存分配</strong>和<strong>数据复制</strong>。具体来说：</li></ol><ul><li>装箱的性能开销<br>  装箱是将一个<strong>值类型</strong>转换为<strong>引用类型</strong>（对象）的过程。这个过程涉及以下几个步骤：<ul><li><strong>在堆上分配内存</strong>：装箱时，值类型的值需要被封装到一个对象中，而这个对象是在堆上分配的。堆上的内存分配比栈上的内存分配要慢，因为它涉及到更多的管理工作（如内存分配、垃圾回收等）。</li><li><strong>复制数据</strong>：在装箱的过程中，需要将值类型的数据复制到堆上分配的对象中。这意味着需要额外的内存操作。</li></ul></li><li>拆箱的性能开销<br>  拆箱是将一个已装箱的对象转换回值类型的过程。拆箱操作也会带来一定的开销，原因如下：<ul><li><strong>类型检查</strong>：拆箱时，C#运行时会进行类型检查，以确保对象的类型与要转换的值类型匹配。如果类型不匹配，会引发 <code>InvalidCastException</code> 异常。这种类型检查会有一定的性能开销。</li><li><strong>数据复制</strong>：拆箱时，需要将对象中的数据复制回值类型变量。这也意味着会有额外的内存操作。</li></ul></li><li>垃圾回收的影响<ul><li>由于装箱会在堆上创建新的对象，这些对象可能在将来需要被垃圾回收。当堆上分配了大量装箱产生的对象时，会增加垃圾回收的频率和负担，从而进一步影响性能。</li></ul></li><li>为什么栈上的分配更快？<ul><li>栈上的内存分配只需调整栈指针即可，非常高效。而堆上的内存分配涉及复杂的内存管理，例如查找适合的内存块、记录内存使用状态、处理垃圾回收等，因此要慢得多。</li></ul></li></ul><ol start="2"><li><strong>类型安全</strong>：拆箱时，如果对象不包含相应的值类型，程序将抛出 <code>InvalidCastException</code>。</li><li><strong>值类型与引用类型</strong>：值类型（如 <code>int</code>、<code>float</code>、<code>struct</code>）直接存储在栈上，而引用类型（如 <code>object</code>、<code>string</code>）则存储在堆上。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>理解装箱和拆箱是C#中的一个重要概念，特别是在处理集合或需要多态时。尽量减少不必要的装箱和拆箱可以提高程序性能。</p><h1 id="35-值类型和引用类型的内存分配"><a href="#35-值类型和引用类型的内存分配" class="headerlink" title="35. 值类型和引用类型的内存分配"></a>35. 值类型和引用类型的内存分配</h1><p>在C#中，<strong>值类型</strong>和<strong>引用类型</strong>的内存分配方式有所不同：</p><h3 id="值类型的内存分配"><a href="#值类型的内存分配" class="headerlink" title="值类型的内存分配"></a>值类型的内存分配</h3><ul><li><strong>值类型</strong>（如 <code>int</code>、<code>float</code>、<code>struct</code> 等）通常分配在<strong>栈</strong>上。这意味着它们的内存是在方法调用时分配，并在方法返回时释放。</li><li>栈上的内存分配非常快，因为它按照顺序管理，只需调整栈指针即可。</li><li>值类型直接包含其数据，这意味着访问值类型时没有间接性。</li><li><strong>例外情况</strong>：如果值类型是某个对象的一部分（例如，作为类的字段），那么这个值类型的实例将存储在堆上，因为包含它的对象位于堆上。</li></ul><h3 id="引用类型的内存分配"><a href="#引用类型的内存分配" class="headerlink" title="引用类型的内存分配"></a>引用类型的内存分配</h3><ul><li><strong>引用类型</strong>（如 <code>class</code>、<code>array</code>、<code>string</code> 等）通常分配在<strong>堆</strong>上。堆内存适用于动态分配，内存分配和回收由垃圾收集器管理。</li><li>引用类型的变量实际上是一个指向堆上对象的<strong>引用</strong>，它本身存储在栈上。引用指向的对象实际存储在堆中。</li><li>当引用类型的对象不再被引用时，垃圾收集器会回收它所占用的堆内存。</li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 值类型，分配在栈上</span><br><br>MyClass obj = <span class="hljs-keyword">new</span> MyClass(); <span class="hljs-comment">// 引用类型，obj的引用存储在栈上，对象本身分配在堆上</span><br><br><span class="hljs-keyword">struct</span> MyStruct<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> y;<br>    <span class="hljs-keyword">public</span> MyStruct myStruct; <span class="hljs-comment">// myStruct存储在堆上，因为它是对象的一部分</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>a</code> 是一个值类型变量，分配在栈上。<code>obj</code> 是一个引用类型变量，指向堆上分配的 <code>MyClass</code> 实例。<code>MyClass</code> 的实例包含 <code>MyStruct</code> 类型的字段 <code>myStruct</code>，由于它是对象的一部分，因此也存储在堆上。</p><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>值类型直接包含数据，存储在栈上（或在某些情况下存储在堆上，比如作为类的字段）。常见的值类型包括：</p><ol><li><strong>基本数据类型</strong>：<ul><li><code>int</code></li><li><code>float</code></li><li><code>double</code></li><li><code>char</code></li><li><code>bool</code></li><li><code>byte</code>, <code>sbyte</code></li><li><code>short</code>, <code>ushort</code></li><li><code>long</code>, <code>ulong</code></li><li><code>decimal</code></li></ul></li><li><strong>结构体</strong>（<code>struct</code>）：C#中的结构体是值类型。<ul><li>自定义的<code>struct</code></li><li>预定义的结构体，如 <code>DateTime</code>, <code>TimeSpan</code>, <code>Guid</code></li></ul></li><li><strong>枚举</strong>（<code>enum</code>）：在C#中，枚举也是值类型。</li></ol><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型的变量存储在栈上，但它们指向存储在堆上的实际数据。常见的引用类型包括：</p><ol><li><strong>类</strong>（<code>class</code>）<ul><li>自定义的类</li><li>预定义的类，如 <code>string</code>, <code>ArrayList</code>, <code>List&lt;T&gt;</code></li></ul></li><li><strong>接口</strong>（<code>interface</code>）：实现接口的类型也是引用类型。</li><li><strong>数组</strong>：无论是 <code>int[]</code>, <code>string[]</code>，还是自定义类型的数组，都是引用类型。</li><li><strong>委托</strong>（<code>delegate</code>）：委托类型也是引用类型。</li><li><strong>字符串</strong>（<code>string</code>）：尽管字符串表现得像值类型（不可变），但它是引用类型。</li></ol><h4 id="值类型与引用类型的主要区别"><a href="#值类型与引用类型的主要区别" class="headerlink" title="值类型与引用类型的主要区别"></a>值类型与引用类型的主要区别</h4><ul><li><strong>内存分配</strong>：值类型通常在栈上分配，而引用类型在堆上分配。</li><li><strong>赋值操作</strong>：值类型赋值时会复制值，引用类型赋值时会复制引用（地址）。</li><li><strong>默认值</strong>：值类型的默认值是类型本身的默认值（如 <code>int</code> 的默认值为 <code>0</code>），而引用类型的默认值是 <code>null</code>。</li></ul><h1 id="36-类型转换"><a href="#36-类型转换" class="headerlink" title="36. 类型转换"></a>36. 类型转换</h1><p>在C#中，<strong>类型转换</strong>是将一个数据类型的值转换为另一个数据类型的过程。根据转换的方式和适用的场景，类型转换可以分为几种类型：<strong>隐式转换</strong>、<strong>显式转换</strong>、<strong>装箱和拆箱</strong>、以及<strong>类型转换方法</strong>。</p><h3 id="1-隐式转换"><a href="#1-隐式转换" class="headerlink" title="1. 隐式转换"></a>1. 隐式转换</h3><ul><li>隐式转换是一种<strong>自动进行</strong>的转换，不需要显式地使用类型转换运算符。</li><li>这种转换通常在<strong>不会丢失数据</strong>的情况下进行，例如从较小范围的数值类型转换为较大范围的数值类型。</li><li>常见的隐式转换示例：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">double</span> b = a; <span class="hljs-comment">// int 隐式转换为 double</span><br>```   <br>在上述示例中，`<span class="hljs-built_in">int</span>` 转换为 `<span class="hljs-built_in">double</span>` 是安全的，因为 `<span class="hljs-built_in">double</span>` 的范围比 `<span class="hljs-built_in">int</span>` 大，不会丢失精度。<br><span class="hljs-meta">### 2. 显式转换（强制转换）</span><br>- 显式转换要求使用**强制转换运算符**，即 `(目标类型)`，因为这种转换可能会**丢失数据**或导致异常。<br>- 这种转换用于从大范围的数值类型转换为小范围的数值类型，或者从一种兼容的类型转换为另一种。<br>- 示例：<br>```csharp<br><span class="hljs-built_in">double</span> a = <span class="hljs-number">9.78</span>;<br><span class="hljs-built_in">int</span> b = (<span class="hljs-built_in">int</span>)a; <span class="hljs-comment">// 显式转换，结果为 9</span><br></code></pre></td></tr></table></figure>在这个例子中，将 <code>double</code> 显式转换为 <code>int</code> 会导致小数部分丢失。</li></ul><h3 id="3-装箱和拆箱"><a href="#3-装箱和拆箱" class="headerlink" title="3. 装箱和拆箱"></a>3. 装箱和拆箱</h3><ul><li><strong>装箱（Boxing）</strong>：将<strong>值类型</strong>转换为<strong>引用类型</strong>（对象）的过程。会在堆上分配一个新的对象来存储该值类型的值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">object</span> obj = num; <span class="hljs-comment">// 装箱</span><br></code></pre></td></tr></table></figure></li><li><strong>拆箱（Unboxing）</strong>：将已装箱的<strong>对象</strong>转换回<strong>值类型</strong>的过程。这需要显式地进行转换。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">int</span> num = (<span class="hljs-built_in">int</span>)obj; <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-使用类型转换方法"><a href="#4-使用类型转换方法" class="headerlink" title="4. 使用类型转换方法"></a>4. 使用类型转换方法</h3><p>C#提供了一些用于类型转换的内置方法和类，如 <code>Convert</code> 类、<code>Parse</code> 方法和 <code>TryParse</code> 方法。</p><ul><li><strong>Convert类</strong>：可用于将基本数据类型之间进行转换。如果转换失败会抛出异常。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-built_in">int</span> num = Convert.ToInt32(str); <span class="hljs-comment">// 将字符串转换为整数</span><br></code></pre></td></tr></table></figure></li><li><strong>Parse方法</strong>：用于将字符串转换为对应的数值类型。如果转换失败会抛出异常。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-built_in">double</span> num = <span class="hljs-built_in">double</span>.Parse(str); <span class="hljs-comment">// 将字符串转换为 double</span><br></code></pre></td></tr></table></figure></li><li><strong>TryParse方法</strong>：与 <code>Parse</code> 类似，但在转换失败时不会抛出异常，而是返回 <code>false</code>。</li><li>为什么 <code>TryParse</code> 使用 <code>out</code><br>  <code>TryParse</code> 方法的设计初衷是尝试将字符串解析为数值类型（例如 <code>double</code>、<code>int</code> 等），并返回一个布尔值，表示转换是否成功。<code>out</code> 参数用于接收解析后的数值。<ul><li><strong>如果解析成功</strong>：<code>TryParse</code> 返回 <code>true</code>，并且通过 <code>out</code> 参数将解析后的结果赋值给调用者定义的变量。</li><li><strong>如果解析失败</strong>：<code>TryParse</code> 返回 <code>false</code>，<code>out</code> 参数的值不会被赋给任何有效的数值（可能是类型的默认值，如 <code>0.0</code>）。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123.45&quot;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">double</span>.TryParse(str, <span class="hljs-keyword">out</span> <span class="hljs-built_in">double</span> result))<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">$&quot;转换成功，值为 <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;转换失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-类型转换的注意事项"><a href="#5-类型转换的注意事项" class="headerlink" title="5. 类型转换的注意事项"></a>5. 类型转换的注意事项</h3><ul><li><strong>兼容性</strong>：转换前要确保类型兼容，不兼容的类型转换会导致编译错误或运行时异常。</li><li><strong>数据丢失</strong>：从大范围类型转换为小范围类型可能会丢失数据（例如，浮点数转换为整数会丢失小数部分）。</li><li><strong>异常处理</strong>：使用显式转换时，建议进行异常处理以防止转换失败导致程序崩溃。</li></ul><h3 id="as呢"><a href="#as呢" class="headerlink" title="as呢"></a>as呢</h3><p><code>as</code> 关键字在C#中也用于类型转换，但它的用法和普通的显式类型转换有一些区别。虽然它也可以实现类型转换的功能，但它的工作方式与传统的强制转换有所不同。</p><h4 id="as-关键字的特点"><a href="#as-关键字的特点" class="headerlink" title="as 关键字的特点"></a><code>as</code> 关键字的特点</h4><ol><li><strong>用于引用类型和可空类型的转换</strong>：<code>as</code> 关键字只能用于将一个<strong>引用类型</strong>或<strong>可空类型</strong>转换为另一种引用类型或可空类型。对于值类型的转换，不能使用 <code>as</code>。</li><li><strong>安全的类型转换</strong>：<code>as</code> 是一种<strong>安全的类型转换</strong>方法，如果转换失败，它会返回 <code>null</code>，而不是抛出异常。传统的强制转换在转换失败时会抛出 <code>InvalidCastException</code> 异常。</li><li><strong>转换失败返回 null</strong>：当类型转换无法进行时，<code>as</code> 会返回 <code>null</code>，这意味着你可以通过检查转换结果是否为 <code>null</code> 来判断转换是否成功。</li></ol><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> obj = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-built_in">string</span> str = obj <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 成功转换，str 现在是 &quot;Hello, World!&quot;</span><br><br><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str2 = num <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 转换失败，str2 为 null</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>obj</code> 是一个字符串，因此可以使用 <code>as</code> 转换为 <code>string</code> 类型。而 <code>num</code> 是一个整数，不能转换为 <code>string</code>，所以 <code>as</code> 返回 <code>null</code>。</p><h4 id="与强制转换的对比"><a href="#与强制转换的对比" class="headerlink" title="与强制转换的对比"></a>与强制转换的对比</h4><ul><li><strong>强制转换</strong>（<code>(目标类型)obj</code>）在转换失败时会抛出异常：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str = (<span class="hljs-built_in">string</span>)num; <span class="hljs-comment">// 运行时会抛出 InvalidCastException</span><br></code></pre></td></tr></table></figure></li><li><strong><code>as</code> 转换</strong>则会返回 <code>null</code>，而不会抛出异常：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> num = <span class="hljs-number">123</span>;<br><span class="hljs-built_in">string</span> str = num <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 转换失败，str 为 null</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>当你不确定转换是否会成功时，使用 <code>as</code> 可以避免异常，并通过 <code>null</code> 检查来判断转换的结果。</li><li><code>as</code> 只能用于引用类型的转换，如果需要对值类型进行安全转换，可以结合 <code>Nullable&lt;T&gt;</code> 或使用其他方法（如 <code>TryParse</code>）。</li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><code>as</code> 可以看作是一种特殊的类型转换方式，主要用于引用类型的安全转换。它的主要特点是在转换失败时返回 <code>null</code> 而不是抛出异常，因此适合在不确定转换是否能成功的情况下使用。</p><h1 id="37-密封类（sealed-class）"><a href="#37-密封类（sealed-class）" class="headerlink" title="37. 密封类（sealed class）"></a>37. 密封类（sealed class）</h1><p>在C#中，<strong>密封类</strong>（<code>sealed class</code>）是一种不允许被继承的类。通过使用 <code>sealed</code> 关键字修饰类，可以防止其他类从该类派生。这样做的目的是增强安全性、提高性能或限制类的使用方式。</p><h3 id="密封类的特点"><a href="#密封类的特点" class="headerlink" title="密封类的特点"></a>密封类的特点</h3><ol><li><strong>不能被继承</strong>：密封类禁止其他类从它派生。这意味着你无法创建该类的子类。</li><li><strong>可以实例化</strong>：虽然密封类不能被继承，但它仍然可以像普通类一样被实例化并使用。</li><li><strong>提高性能</strong>：对于某些虚方法，JIT编译器可以针对密封类进行优化，因为它知道该方法不会被重写，从而减少方法调用的开销。</li></ol><h3 id="密封类的定义示例"><a href="#密封类的定义示例" class="headerlink" title="密封类的定义示例"></a>密封类的定义示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySealedClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is a sealed class.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 下面的代码会导致编译错误，因为 MySealedClass 是密封的，不能被继承</span><br><span class="hljs-comment">// class DerivedClass : MySealedClass</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MySealedClass</code> 是一个密封类，禁止其他类从它派生。如果尝试继承这个类，会导致编译错误。</p><h3 id="使用密封类的场景"><a href="#使用密封类的场景" class="headerlink" title="使用密封类的场景"></a>使用密封类的场景</h3><ol><li><strong>安全性需求</strong>：当你希望某个类的功能不被扩展或修改时，可以将其声明为密封类。这样可以确保类的行为在使用时不会被子类改变。</li><li><strong>性能优化</strong>：密封类在某些情况下可以提高性能，因为编译器可以针对它们进行优化，特别是方法调用。</li><li><strong>设计限制</strong>：有时，设计一个不可扩展的类是必要的，例如一些工具类或帮助类，这些类的行为应该是固定的。</li></ol><h3 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h3><p>除了密封类，C#还允许在继承类中将<strong>方法</strong>标记为密封。密封方法使用 <code>sealed</code> 关键字，并且必须是<strong>重写</strong>的（即继承自父类的虚方法或抽象方法）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Base class display method.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Derived class sealed display method.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 不能进一步重写 Display 方法</span><br><span class="hljs-comment">// class AnotherDerivedClass : DerivedClass</span><br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// 如果关键字override变成new或者删除override，不会编译报错，这个是会隐藏DerivedClass的Display()方法</span><br><span class="hljs-comment">//     public override void Display() // 这会导致编译错误</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         Console.WriteLine(&quot;Another derived class display method.&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>DerivedClass</code> 重写了 <code>BaseClass</code> 的 <code>Display</code> 方法并将其密封，防止进一步的重写。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>密封类</strong>：通过 <code>sealed</code> 关键字修饰的类，不能被继承，用于提高安全性和性能。</li><li><strong>密封方法</strong>：用 <code>sealed</code> 修饰的重写方法，防止其在子类中被进一步重写。</li><li>使用密封类和方法有助于控制类层次结构和优化性能。</li></ul><h1 id="38-多态"><a href="#38-多态" class="headerlink" title="38. 多态"></a>38. 多态</h1><p><strong>多态</strong>（Polymorphism）是面向对象编程中的一个重要概念，它指的是<strong>同一个方法或属性在不同的对象中可以有不同的实现</strong>。多态性允许程序在不同的类中定义相同的接口或方法名称，并根据具体对象的类型来调用适当的方法。这种特性增强了代码的灵活性和可维护性。</p><h3 id="多态的类型"><a href="#多态的类型" class="headerlink" title="多态的类型"></a>多态的类型</h3><p>在C#中，多态可以通过<strong>编译时多态（静态多态）</strong> 和<strong>运行时多态（动态多态）</strong> 来实现。</p><h4 id="1-编译时多态（静态多态）"><a href="#1-编译时多态（静态多态）" class="headerlink" title="1. 编译时多态（静态多态）"></a>1. 编译时多态（静态多态）</h4><p>编译时多态通常通过<strong>方法重载</strong>和<strong>运算符重载</strong>来实现。</p><ul><li><strong>方法重载（Method Overloading）</strong>：同一个类中可以定义多个具有相同名称但参数不同的方法。这些方法会根据传入的参数来决定调用哪个具体的实现。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MathOperations</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> a, <span class="hljs-built_in">double</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>MathOperations math = <span class="hljs-keyword">new</span> MathOperations();<br>Console.WriteLine(math.Add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));       <span class="hljs-comment">// 调用 Add(int, int)</span><br>Console.WriteLine(math.Add(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>));   <span class="hljs-comment">// 调用 Add(double, double)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-运行时多态（动态多态）"><a href="#2-运行时多态（动态多态）" class="headerlink" title="2. 运行时多态（动态多态）"></a>2. 运行时多态（动态多态）</h4><p>运行时多态通过<strong>继承</strong>和<strong>虚方法</strong>、<strong>抽象类</strong>或<strong>接口</strong>来实现。最常见的实现方式是<strong>方法重写（Method Overriding）</strong>。</p><ul><li><p><strong>虚方法和重写</strong>：在基类中定义一个方法为 <code>virtual</code>，然后在派生类中使用 <code>override</code> 关键字重写这个方法。调用时根据对象的实际类型来决定执行哪个版本的方法。</p></li><li><p>当然，virtual虚函数也可以不重写，这样调用的就是父类的虚函数了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Some generic animal sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Bark&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span><br>&#123;<br><span class="hljs-comment">// 不重写父类的MakeSound()虚函数</span><br>    <span class="hljs-comment">//public override void MakeSound()</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    Console.WriteLine(&quot;Meow&quot;);</span><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        Animal myAnimal;<br>        myAnimal = <span class="hljs-keyword">new</span> Dog();<br>        myAnimal.MakeSound(); <span class="hljs-comment">// 输出 &quot;Bark&quot;</span><br><br>        myAnimal = <span class="hljs-keyword">new</span> Cat();<br>        myAnimal.MakeSound(); <span class="hljs-comment">// 输出 &quot;Some generic animal sound&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MakeSound</code> 方法在基类 <code>Animal</code> 中是虚方法，允许派生类 <code>Dog</code>  重写它。当我们调用 <code>MakeSound</code> 时，实际执行的是对象所属类型（<code>Dog</code>）的具体实现。</p></li><li><p><strong>接口</strong>与重写：在C#中，<strong>接口</strong>（Interface）是一种定义类和结构应遵循的契约。接口可以包含方法、属性、事件和索引器，但不能包含字段或实现。任何实现接口的类或结构都必须提供接口中定义的所有成员的实现。</p></li><li><p>接口不包含成员变量</p></li><li><p>接口包含的成员不能被实现</p></li><li><p>接口包含的成员访问修饰符可以不写，默认是public，但是不能写成私有</p></li><li><p>接口不能继承类，但是可以继承另一个接口</p></li><li><p>接口不能被实例化，但是可以作为容器存储对象</p></li><li><p>继承了接口，必须是public方式实现</p></li><li><p>接口也遵循历史转换原则</p><ul><li>接口的基本定义  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span>;      <span class="hljs-comment">// 定义一个方法，计算面积</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;       <span class="hljs-comment">// 定义一个方法，绘制形状</span><br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，我们定义了一个名为 <code>IShape</code> 的接口，它包含两个方法：<code>Area</code> 和 <code>Draw</code>。继承结构的类，必须实现这两个方法，否则报错</li><li>实现接口的类<br>  多个类可以实现同一个接口，并提供各自的实现。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius; <span class="hljs-comment">// 圆的面积公式</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Circle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>    &#123;<br>        Width = width;<br>        Height = height;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Width * Height; <span class="hljs-comment">// 矩形的面积公式</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Rectangle&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  在这个例子中，<code>Circle</code> 和 <code>Rectangle</code> 类实现了 <code>IShape</code> 接口。它们都提供了 <code>Area</code> 和 <code>Draw</code> 方法的具体实现。</li><li>使用接口的示例<br>  通过接口类型，可以编写更灵活的代码，处理不同的实现。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        IShape circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        IShape rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area()&#125;</span>&quot;</span>); <span class="hljs-comment">// 调用圆的面积方法</span><br>        circle.Draw(); <span class="hljs-comment">// 绘制圆</span><br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area()&#125;</span>&quot;</span>); <span class="hljs-comment">// 调用矩形的面积方法</span><br>        rectangle.Draw(); <span class="hljs-comment">// 绘制矩形</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>输出结果  <figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Circle</span> <span class="hljs-built_in">Area</span><span class="hljs-operator">:</span> <span class="hljs-number">78.53981633974483</span><br><span class="hljs-variable">Drawing</span> <span class="hljs-variable">a</span> <span class="hljs-built_in">Circle</span><br><span class="hljs-built_in">Rectangle</span> <span class="hljs-built_in">Area</span><span class="hljs-operator">:</span> <span class="hljs-number">24</span><br><span class="hljs-variable">Drawing</span> <span class="hljs-variable">a</span> <span class="hljs-built_in">Rectangle</span><br></code></pre></td></tr></table></figure></li><li>其他示例  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义接口 IShape</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-comment">// 方法声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br><br>    <span class="hljs-comment">// 属性声明</span><br>    <span class="hljs-built_in">double</span> Area &#123; <span class="hljs-keyword">get</span>; &#125;<br><br>    <span class="hljs-comment">// 事件声明</span><br>    <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器声明</span><br>    <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index] &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Circle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Draw 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Drawing a circle with radius: <span class="hljs-subst">&#123;Radius&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Area 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Area =&gt; Math.PI * Radius * Radius;<br><br>    <span class="hljs-comment">// 事件的实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Radius;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                Radius = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 触发 ShapeChanged 事件的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShapeChanged</span>()</span><br>    &#123;<br>        ShapeChanged?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Rectangle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Width &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Height &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> width, <span class="hljs-built_in">double</span> height</span>)</span><br>    &#123;<br>        Width = width;<br>        Height = height;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Draw 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Drawing a rectangle with width: <span class="hljs-subst">&#123;Width&#125;</span> and height: <span class="hljs-subst">&#123;Height&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Area 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Area =&gt; Width * Height;<br><br>    <span class="hljs-comment">// 事件的实现 </span><br>    <span class="hljs-comment">// EventHandler是自带的事件</span><br>    <span class="hljs-comment">// public delegate void EventHandler(object? sender, EventArgs e);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler ShapeChanged;<br><br>    <span class="hljs-comment">// 索引器实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Width;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> Height;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)<br>            &#123;<br>                Width = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>)<br>            &#123;<br>                Height = <span class="hljs-keyword">value</span>;<br>                OnShapeChanged(); <span class="hljs-comment">// 触发事件</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfRangeException(<span class="hljs-string">&quot;Index out of range&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 触发 ShapeChanged 事件的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShapeChanged</span>()</span><br>    &#123;<br>        ShapeChanged?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主程序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        IShape circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">5</span>);<br>        circle.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a circle with radius: 5&quot;</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Circle Area: <span class="hljs-subst">&#123;circle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出圆的面积</span><br><br>        IShape rectangle = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>        rectangle.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a rectangle with width: 4 and height: 6&quot;</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Rectangle Area: <span class="hljs-subst">&#123;rectangle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出矩形的面积</span><br><br>        <span class="hljs-comment">// 使用索引器</span><br>        circle[<span class="hljs-number">0</span>] = <span class="hljs-number">7</span>; <span class="hljs-comment">// 修改半径</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Updated Circle Area: <span class="hljs-subst">&#123;circle.Area&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出更新后的面积</span><br><br>        <span class="hljs-comment">// 订阅事件</span><br>        rectangle.ShapeChanged += (sender, e) =&gt; Console.WriteLine(<span class="hljs-string">&quot;Rectangle shape changed!&quot;</span>);<br>        rectangle[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>; <span class="hljs-comment">// 修改宽度，触发事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>如果两个接口中存在同名方法时，需要显式实现接口</li><li>显式实现接口时，不能写访问修饰符  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义接口 IShape</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>; <span class="hljs-comment">// 方法声明</span><br>&#125;<br><br><span class="hljs-comment">// 定义接口 IFigure</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IFigure</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>; <span class="hljs-comment">// 方法声明</span><br>&#125;<br><br><span class="hljs-comment">// 实现接口的类 Circle</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span>, <span class="hljs-title">IFigure</span><br>&#123;<br>    <span class="hljs-comment">// 显式实现 IShape 的 Draw 方法</span><br>    <span class="hljs-keyword">void</span> IShape.Draw()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a shape as IShape.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 显式实现 IFigure 的 Draw 方法</span><br>    <span class="hljs-keyword">void</span> IFigure.Draw()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a shape as IFigure.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 Circle 的实例</span><br>        Circle circle = <span class="hljs-keyword">new</span> Circle();<br><br>        <span class="hljs-comment">// 使用 IShape 接口调用 Draw 方法</span><br>        IShape shape = circle;<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a shape as IShape.&quot;</span><br><br>        <span class="hljs-comment">// 使用 IFigure 接口调用 Draw 方法</span><br>        IFigure figure = circle;<br>        figure.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a shape as IFigure.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>接口的优点<ol><li><strong>松耦合</strong>：接口允许类之间松散耦合，方便替换和扩展。你可以在不修改现有代码的情况下，引入新的实现。</li><li><strong>多态</strong>：通过接口可以实现多态性，允许不同的对象以相同的方式进行处理。</li><li><strong>强制实现</strong>：接口强制实现类遵循特定的协议，从而确保一致性。</li></ol></li><li>继承多个接口<br>  C#允许一个类实现多个接口，从而支持多重继承的特性。  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDrawable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IColorable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Color</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ColoredCircle</span> : <span class="hljs-title">IShape</span>, <span class="hljs-title">IDrawable</span>, <span class="hljs-title">IColorable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColoredCircle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>    &#123;<br>        Radius = radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Area</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a Colored Circle&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Color</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> color</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Coloring the circle with <span class="hljs-subst">&#123;color&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>抽象类和抽象方法</strong>：如果一个类中有抽象方法（没有方法体的方法），该类必须被声明为抽象类，不能被直接实例化，必须由派生类实现抽象方法。</p></li><li><p>抽象类不可以被实例化，但是遵循里氏转换原则，可以作为父类接受子类</p></li><li><p>抽象类需要用abstract关键字声明，放在class前面</p></li><li><p>抽象类可以没有抽象方法，但是抽象方法必须在抽象类里面</p></li><li><p>抽象方法不能是私有的，不然无法继承后重写。抽象方法一定是没有函数体的。且必须在抽象类中</p></li><li><p>如果继承了抽象类，子类不是抽象类，则必须实现抽象类，否则可以不实现</p></li><li><p>如果某个子类，继承的父类已经实现了抽象函数，那么可以直接继承，不继续实现。如果实现，用的是override，和普通的实现抽象函数一样，多态。如果使用的是new，则是和普通的重载规则一样，具体下面注释写了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape2</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Shape2&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果不实现抽象类Shape中的Draw方法，也必须声明为abstract类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a rectangle&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果这里继承实现了Draw，使用new关键字，下面是用Shape接受，那么会使用Rectangle的方法，输出&quot;Drawing a rectangle&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle2</span> : <span class="hljs-title">Rectangle</span><br>&#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle3</span> : <span class="hljs-title">Shape2</span><br>&#123; &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用示例</span><br>        Shape shape;<br>        shape = <span class="hljs-keyword">new</span> Circle();<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a circle&quot;</span><br><br>        shape = <span class="hljs-keyword">new</span> Rectangle2();<br>        shape.Draw(); <span class="hljs-comment">// 输出 &quot;Drawing a rectangle&quot;</span><br><br>        Shape2 shape2;<br>        shape2 = <span class="hljs-keyword">new</span> Rectangle3();<br>        shape2.Draw(); <span class="hljs-comment">//输出 &quot;Shape2&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ol><li><strong>代码可维护性高</strong>：多态可以让程序在不修改现有代码的情况下，方便地扩展新的功能。例如，新增一种 <code>Shape</code> 类型的子类只需实现 <code>Draw</code> 方法，不影响其他代码。</li><li><strong>提高代码的灵活性和可扩展性</strong>：通过接口或基类编程，可以编写通用的代码，这些代码可以应用于各种具体的对象。</li><li><strong>面向接口编程</strong>：多态性鼓励面向接口编程，而不是面向实现编程，从而提高系统的可扩展性。</li></ol><h3 id="多态的实现注意事项"><a href="#多态的实现注意事项" class="headerlink" title="多态的实现注意事项"></a>多态的实现注意事项</h3><ul><li>当使用虚方法或抽象方法时，子类应使用 <code>override</code> 关键字重写基类方法。</li><li>接口方法在实现时也类似于虚方法，可以实现多态。</li></ul><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p>抽象类和接口在面向对象编程中用于定义抽象的类型成员，帮助实现多态性，但它们有不同的特点和使用场景。以下是抽象类和接口之间的主要区别：</p><h4 id="1-定义方式"><a href="#1-定义方式" class="headerlink" title="1. 定义方式"></a>1. <strong>定义方式</strong></h4><ul><li><strong>抽象类</strong>：使用 <code>abstract</code> 关键字定义，允许包含抽象方法（没有实现）和非抽象方法（有实现）。</li><li><strong>接口</strong>：使用 <code>interface</code> 关键字定义，不能包含任何方法的实现（从 C# 8.0 开始，接口可以包含默认实现）。<ul><li>如果接口是类的唯一父类，如果用这个父类接收，可以调用其中原有的方法</li><li>接口中的方法，只能是public，不能是private，protected的话不可以在类外使用，也不可以用virtual  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">Itest</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;interface Itest 的默认实现&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> : <span class="hljs-title">Itest</span><br>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        <span class="hljs-comment">//test.show();// 报错</span><br><br>        <span class="hljs-comment">// 通过接口引用来调用默认实现的方法</span><br>        Itest itest = test;<br>        itest.show(); <span class="hljs-comment">// 输出: interface Itest 的默认实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-继承关系"><a href="#2-继承关系" class="headerlink" title="2. 继承关系"></a>2. <strong>继承关系</strong></h4><ul><li><strong>抽象类</strong>：支持单继承，即一个类只能继承一个抽象类。</li><li><strong>接口</strong>：支持多继承，一个类可以实现多个接口。</li><li>如果是抽象类和接口都继承，也就是一个类继承了单个类和多个接口，那么其中的父类，只能调用自己相关的方法，而不能调用其他接口或者类的方法  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BaseMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method from BaseClass&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title">IInterface1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InterfaceMethod</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">BaseClass</span>, <span class="hljs-title">IInterface1</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InterfaceMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Method from IInterface1&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        DerivedClass derivedClass = <span class="hljs-keyword">new</span> DerivedClass();<br>        derivedClass.BaseMethod();        <span class="hljs-comment">// 输出: Method from BaseClass</span><br>        derivedClass.InterfaceMethod();   <span class="hljs-comment">// 输出: Method from IInterface1</span><br><br><br>        BaseClass derivedClass2 = <span class="hljs-keyword">new</span> DerivedClass();<br>        derivedClass2.BaseMethod();        <span class="hljs-comment">// 输出: Method from BaseClass</span><br>        <span class="hljs-comment">// derivedClass2.InterfaceMethod();   // 报错</span><br><br>        IInterface1 derivedClass3 = <span class="hljs-keyword">new</span> DerivedClass();<br>        <span class="hljs-comment">// derivedClass3.BaseMethod();        // 报错</span><br>        derivedClass3.InterfaceMethod();   <span class="hljs-comment">// 输出: Method from IInterface1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-成员类型"><a href="#3-成员类型" class="headerlink" title="3. 成员类型"></a>3. <strong>成员类型</strong></h4><ul><li><strong>抽象类</strong>：可以包含字段、属性、方法、构造函数、事件等成员，可以有访问修饰符（如 <code>public</code>、<code>protected</code>）。</li><li><strong>接口</strong>：不能包含字段或构造函数，成员默认是 <code>public</code>，且只能包含方法、属性、事件和索引器的声明（在 C# 8.0 之前）。从 C# 8.0 开始，接口可以包含静态方法、默认实现、属性和事件。(这个8.0之前和之后的属性和事件没区别，只是允许有默认实现了)</li></ul><h4 id="4-实现方式"><a href="#4-实现方式" class="headerlink" title="4. 实现方式"></a>4. <strong>实现方式</strong></h4><ul><li><strong>抽象类</strong>：子类继承抽象类并实现其抽象方法，可以使用 <code>override</code> 关键字来实现父类的抽象方法。</li><li><strong>接口</strong>：实现接口的类必须实现接口中定义的所有成员，不能使用 <code>override</code> 关键字。</li></ul><h4 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5. 构造函数"></a>5. <strong>构造函数</strong></h4><ul><li><strong>抽象类</strong>：可以有构造函数，用于初始化抽象类的字段。不能创建抽象类的实例。</li><li><strong>接口</strong>：不能有构造函数，不能创建接口的实例。</li></ul><h4 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. <strong>使用场景</strong></h4><ul><li><strong>抽象类</strong>：适用于描述具有相似属性和行为的类，并且需要在基类中提供一些默认实现时。</li><li><strong>接口</strong>：适用于定义一组不相关类的行为约定，或者需要多重继承时。</li></ul><h4 id="7-字段支持"><a href="#7-字段支持" class="headerlink" title="7. 字段支持"></a>7. <strong>字段支持</strong></h4><ul><li><strong>抽象类</strong>：可以定义字段。</li><li><strong>接口</strong>：不能定义字段，接口的成员只能是方法、属性、事件或索引器的签名。</li></ul><h4 id="8-访问修饰符"><a href="#8-访问修饰符" class="headerlink" title="8. 访问修饰符"></a>8. <strong>访问修饰符</strong></h4><ul><li><strong>抽象类</strong>：可以为成员指定不同的访问修饰符（<code>public</code>、<code>protected</code>、<code>private</code>）。</li><li><strong>接口</strong>：接口成员默认是 <code>public</code>，不能使用其他访问修饰符。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>; <span class="hljs-comment">// 抽象方法，没有实现</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>() <span class="hljs-comment">// 非抽象方法，有实现</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;Name&#125;</span> is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>() <span class="hljs-comment">// 必须实现抽象方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Woof!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMovable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>()</span>; <span class="hljs-comment">// 接口成员没有实现</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ISpeakable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Robot</span> : <span class="hljs-title">IMovable</span>, <span class="hljs-title">ISpeakable</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Move</span>() <span class="hljs-comment">// 实现接口方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Robot is moving.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>() <span class="hljs-comment">// 实现接口方法</span></span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Beep beep!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ul><li>抽象类适合有默认行为的基类，而接口适合定义无关类的契约。</li><li>使用抽象类可以提供部分实现，而接口更注重行为规范的定义和多继承的支持。</li></ul><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>多态是面向对象编程的核心概念之一，它可以通过方法重载、方法重写、抽象类和接口等多种方式实现。编译时多态主要通过方法重载和运算符重载实现，而运行时多态通过继承、虚方法、抽象类和接口实现。它使得代码更加灵活、易于扩展和维护。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/zh-cn/">MS-Learning</a><br><a href="https://blog.csdn.net/zjzzjzzjzzjzzjz/article/details/8984057">解决方案、项目、程序集、命名空间之间的联系与区别</a><br><a href="https://zhidao.baidu.com/question/1446226042843310700.html?qbl=relate_question_0">c# 重载++（前后）</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>知识点一_inline, const, static</title>
    <link href="/2024/10/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80_inline,%20const,%20static/"/>
    <url>/2024/10/24/%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80_inline,%20const,%20static/</url>
    
    <content type="html"><![CDATA[<h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><p>C++将内联函数的代码组合到程序中，可以提高程序运行的速度。<br>语法：在函数声明和定义前加上关键字 inline。<br><code>通常的做法是将函数声明和定义都写在头文件（当然都写在源文件也行）。目的是为了避免函数重定义的问题</code></p><h3 id="正确的-inline-例子"><a href="#正确的-inline-例子" class="headerlink" title="正确的 inline 例子"></a>正确的 inline 例子</h3><ul><li><p>文件结构如图所示<br><a href="https://imgse.com/i/pAwMuMq"><img src="https://s21.ax1x.com/2024/10/24/pAwMuMq.png" alt="pAwMuMq.png"></a></p></li><li><p>代码示例<br>my_inline.h</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from version 1!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">sayHello</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>my_inline.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空的</span><br></code></pre></td></tr></table></figure><h3 id="错误的-inline-例子"><a href="#错误的-inline-例子" class="headerlink" title="错误的 inline 例子"></a>错误的 inline 例子</h3><blockquote><p>内联函数就是编译器将函数体（{…}之间的内容）在函数调用处展开，其实可以类比于#define 宏定义那种替换，来免去函数调用的开销。如果普通函数定义在头文件中，所有 include 该头文件的编译单元都可以正确找到函数定义。然而，如果内联函数 fun()定义在某个编译单元 A 中，那么其他编译单元中调用 fun()的地方将无法解析该符号，因为在编译单元 A 生成目标文件 A.obj 后，内联函数 fun()已经被替换掉，A.obj 中不再有 fun 这个符号，链接器自然无法解析。<br>上面的意思我的理解为是，下面的 sayHello 在 my_inline.cpp 中编译后，就不叫 sayHello()了，而 main 函数中仍然需要链接这个 sayHello()函数体，找不到，所以报错。具体不管，反正意思就是不能分开写</p></blockquote><p>代码示例<br>my_inline.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">sayHello</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>my_inline.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from version 1!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译期间报错<br><a href="https://imgse.com/i/pAwMKs0"><img src="https://s21.ax1x.com/2024/10/24/pAwMKs0.png" alt="pAwMKs0.png"></a></p><h3 id="正确的普通函数例子"><a href="#正确的普通函数例子" class="headerlink" title="正确的普通函数例子"></a>正确的普通函数例子</h3><ul><li>代码示例<br>my_inline.h</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">sayHello</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>my_inline.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_inline.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from version 1!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>内联函数节省时间，但消耗内存。</li><li>如果函数过大，编译器可能不将其作为内联函数。</li><li>内联函数不能递归。我试了可以写递归，估计被优化成普通函数了</li></ul><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h3 id="1-修饰普通变量"><a href="#1-修饰普通变量" class="headerlink" title="1. 修饰普通变量"></a>1. <strong>修饰普通变量</strong></h3><ul><li>当<code>const</code>修饰一个变量时，该变量在声明时需要初始化，并且在之后的程序执行过程中，其值不能被改变。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxValue = <span class="hljs-number">100</span>;<br><span class="hljs-comment">// maxValue = 200; // 错误，无法修改const变量的值</span><br></code></pre></td></tr></table></figure><ul><li>使用<code>const</code>修饰变量可以增强代码的安全性，防止在无意中修改不应该更改的值。</li></ul><h3 id="2-修饰指针"><a href="#2-修饰指针" class="headerlink" title="2. 修饰指针"></a>2. <strong>修饰指针</strong></h3><p><code>const</code>在指针声明中可以有多种组合方式，分别用于不同的用途：</p><ul><li><strong>指向常量的指针</strong>（<code>const T*</code> 或 <code>T const*</code>）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* ptr = &amp;maxValue; <span class="hljs-comment">// 或 int const* ptr = &amp;maxValue;</span><br><span class="hljs-comment">// *ptr = 10; // 错误，无法通过ptr修改指向的值</span><br>ptr = &amp;anotherValue; <span class="hljs-comment">// 可以修改指针本身，指向不同地址</span><br></code></pre></td></tr></table></figure><ul><li><strong>常量指针</strong>（<code>T* const</code>）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;value;<br>*ptr = <span class="hljs-number">20</span>; <span class="hljs-comment">// 可以修改指向的值</span><br><span class="hljs-comment">// ptr = &amp;anotherValue; // 错误，不能修改指针本身</span><br></code></pre></td></tr></table></figure><ul><li><strong>指向常量的常量指针</strong>（<code>const T* const</code> 或 <code>T const* const</code>）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> ptr = &amp;maxValue;<br><span class="hljs-comment">// *ptr = 20; // 错误，无法修改指向的值</span><br><span class="hljs-comment">// ptr = &amp;anotherValue; // 错误，无法修改指针本身</span><br></code></pre></td></tr></table></figure><h3 id="3-修饰函数参数"><a href="#3-修饰函数参数" class="headerlink" title="3. 修饰函数参数"></a>3. <strong>修饰函数参数</strong></h3><ul><li>当函数参数是一个指针或引用时，<code>const</code>可以保证在函数内部不修改该参数的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; value)</span> </span>&#123;<br>    <span class="hljs-comment">// value = 10; // 错误，无法修改值</span><br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-修饰函数返回值"><a href="#4-修饰函数返回值" class="headerlink" title="4. 修饰函数返回值"></a>4. <strong>修饰函数返回值</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 这个返回的是临时变量，函数调用完成后</span><br><span class="hljs-comment">// tempValue会被释放，指向的内存行为不定，但是不好测试出来</span><br><span class="hljs-comment">//int&amp; getTempValue() &#123;</span><br><span class="hljs-comment">//int tempValue = 1;</span><br><span class="hljs-comment">//return tempValue;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">// 这个不会报错，返回的是右值，和地址无关</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getTempValue</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br><span class="hljs-type">int</span> tempValue = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> tempValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getTempValue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> tempValue = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> tempValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回一个可修改的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">getConstValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 返回一个不可修改的引用</span><br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 生命周期和实例化对象的生命周期一样，所以如果不想要外部修改value</span><br><span class="hljs-comment">// 返回value的引用时，需要加const</span><br><span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>MyClass obj;<br>obj.<span class="hljs-built_in">getValue</span>() = <span class="hljs-number">20</span>;       <span class="hljs-comment">// 允许，修改了value</span><br>cout &lt;&lt; obj.<span class="hljs-built_in">getValue</span>() &lt;&lt; endl; <span class="hljs-comment">//20</span><br><span class="hljs-comment">//obj.getConstValue() = 30;  // 错误，返回的引用是const，无法修改</span><br><span class="hljs-comment">// const int 和 int的值可以互相转换，所以返回值是否有const作为等号的右边不会影响等号左边的情况</span><br><span class="hljs-comment">// 也就是返回值是const，赋给的变量不是const的，那就不是const的</span><br><span class="hljs-comment">// 反之，如果返回值不是const的，赋给的变量是const，那就是const的</span><br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-修饰类的成员函数"><a href="#5-修饰类的成员函数" class="headerlink" title="5. 修饰类的成员函数"></a>5. <strong>修饰类的成员函数</strong></h3><ul><li>当<code>const</code>修饰成员函数时，表示该函数不会修改类的成员变量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">// value = 190; // 报错，不允许修改，const去掉可以修改</span><br><span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>MyClass obj;<br><span class="hljs-comment">// obj.getValue() = 20;       // 错误，const去掉可以修改，同时需要将上面的int getValue()函数改为int&amp; getValue()</span><br>cout &lt;&lt; obj.<span class="hljs-built_in">getValue</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-如果引用的数据对象类型不匹配，当引用为-const-时，C-将创建临时变量，让引用指向临时变量"><a href="#6-如果引用的数据对象类型不匹配，当引用为-const-时，C-将创建临时变量，让引用指向临时变量" class="headerlink" title="6. 如果引用的数据对象类型不匹配，当引用为 const 时，C++将创建临时变量，让引用指向临时变量"></a>6. 如果引用的数据对象类型不匹配，当引用为 const 时，C++将创建临时变量，让引用指向临时变量</h3><ul><li>先看最下面的例子</li><li><code>int&amp;</code>定义一个变量 ra，赋值为 8。但是报错。这是因为引用(reference，表现就是&amp;表示引用)必须绑定到一个有效的变量（左值），而不能绑定到右值上。</li><li>在 C++中，引用是一种<strong>别名</strong>，它需要指向一个<strong>已存在的变量</strong>（左值），而不是一个<strong>临时的或字面值的常量</strong>（右值）。像<code>8</code>这样的字面值属于右值，没有实际的内存地址，因此不能为其创建引用【引用本质还就是指针】</li><li>正确的做法<br>引用应该绑定到一个变量，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>&amp; ra = x; <span class="hljs-comment">// 正确，引用ra绑定到变量x</span><br></code></pre></td></tr></table></figure>这样，<code>ra</code>成为<code>x</code>的别名，通过<code>ra</code>可以读取或修改<code>x</code>的值。</li><li>特例：<code>const</code>引用<br>如果需要引用一个字面值（右值），可以使用<code>const</code>引用，因为 C++允许<code>const</code>引用绑定到右值。这样做是安全的，因为<code>const</code>引用不能修改右值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = <span class="hljs-number">8</span>; <span class="hljs-comment">// 正确，const引用可以绑定到字面值</span><br></code></pre></td></tr></table></figure>在这种情况下，编译器会创建一个临时对象来存储字面值<code>8</code>，然后<code>const</code>引用<code>ra</code>绑定到这个临时对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// int&amp; ra = 8;// 报错</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = <span class="hljs-number">8</span>; <span class="hljs-comment">// 正常</span><br><span class="hljs-comment">// 等价于下面两行</span><br><span class="hljs-type">int</span> tmp = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = tmp;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>来，升级一下</li><li>原理和上面一样，不过变成了函数的参数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; no)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;no:&quot;</span> &lt;&lt; no &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; no)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;no:&quot;</span> &lt;&lt; no &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// func2(1); 报错</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下 word 中的三句话<br>什么时候将创建临时变量呢？</p><ul><li><ol><li>引用是 const<br>就是上面的例子，不再解释啦</li></ol></li><li><ol start="2"><li>数据对象的类型是正确的，但不是左值。<br>就是上面的例子，不再解释啦<br>解释一下什么叫正确的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// int&amp; ra = 8;// 报错</span><br><span class="hljs-comment">// const int&amp; ra = &quot;123&quot;; // const char* 类型不能够给const int&amp;赋值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = <span class="hljs-number">1</span>;<span class="hljs-comment">// 可以</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><ol start="3"><li>数据对象的类型不正确，但可以转换为正确的类型</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ra = <span class="hljs-string">&#x27;X&#x27;</span>; <span class="hljs-comment">// char可以转换为int类型，char可以理解为无符号的1字节整数</span><br>cout &lt;&lt; ra &lt;&lt; endl;<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">int</span> temp = <span class="hljs-string">&#x27;X&#x27;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> rs = temp;<br>cout &lt;&lt; rs &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li>只解释下面两句话，其他的看 word 吧<ul><li>在静态成员函数中，只能访问静态成员，不能访问非静态成员</li><li>静态成员函数中没有 this 指针</li></ul></li></ul><blockquote><p>在 C++中，静态成员函数只能访问静态成员，不能直接访问非静态成员。这是因为静态成员函数属于类本身，而不是类的某个对象。静态成员函数没有 <code>this</code> 指针，因此无法访问特定对象的成员变量或调用非静态成员函数。</p></blockquote><h3 id="解释原因："><a href="#解释原因：" class="headerlink" title="解释原因："></a>解释原因：</h3><ol><li><strong>静态成员函数与类关联，而非对象关联</strong>：<ul><li>静态成员函数是属于类本身的，不需要创建类的对象就可以调用。因为它不属于任何对象实例，所以在静态成员函数中无法访问与对象实例相关的非静态成员。</li></ul></li><li><strong>没有 <code>this</code> 指针</strong>：<ul><li>非静态成员函数隐式地包含了一个指向调用对象的 <code>this</code> 指针，可以用来访问该对象的成员。而静态成员函数没有 <code>this</code> 指针，因为它与具体的对象实例无关，无法获取或操作非静态成员。</li></ul></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> nonStaticMember; <span class="hljs-comment">// 非静态成员变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> staticMember; <span class="hljs-comment">// 静态成员变量</span><br><br><span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">nonStaticMember</span>(val) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticFunction</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// std::cout &lt;&lt; nonStaticMember; // 错误：无法访问非静态成员</span><br><span class="hljs-comment">// this只能用于非静态成员函数内部</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Static member: &quot;</span> &lt;&lt; staticMember &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nonStaticFunction</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 可以访问静态和非静态成员</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Non-static member: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;nonStaticMember &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Static member: &quot;</span> &lt;&lt; staticMember &lt;&lt; std::endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 初始化静态成员变量</span><br><span class="hljs-type">int</span> MyClass::staticMember = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>MyClass::<span class="hljs-built_in">staticFunction</span>(); <span class="hljs-comment">// 调用静态成员函数</span><br>obj.<span class="hljs-built_in">nonStaticFunction</span>();   <span class="hljs-comment">// 调用非静态成员函数</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">Static</span> <span class="hljs-keyword">member</span>: <span class="hljs-number">10</span><br>Non<span class="hljs-operator">-</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">member</span>: <span class="hljs-number">5</span><br><span class="hljs-keyword">Static</span> <span class="hljs-keyword">member</span>: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>在 <code>staticFunction</code> 中，尝试访问 <code>nonStaticMember</code> 会导致编译错误，因为它是非静态成员。</li><li>在 <code>nonStaticFunction</code> 中，可以同时访问静态成员和非静态成员，因为此函数属于某个对象实例，有 <code>this</code> 指针。<br>静态成员函数的主要用途是与类相关的操作，而非对象的具体状态</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="1-宏定义的位置"><a href="#1-宏定义的位置" class="headerlink" title="1. 宏定义的位置"></a>1. 宏定义的位置</h3><blockquote><p>宏定义建议写在头文件，源文件也没事，和普通函数一样</p></blockquote><h3 id="2-如何调用不同的重载，const-和非-const"><a href="#2-如何调用不同的重载，const-和非-const" class="headerlink" title="2. 如何调用不同的重载，const 和非 const"></a>2. 如何调用不同的重载，const 和非 const</h3><p>有下面的类，如何调用不同的重载呢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>        <span class="hljs-keyword">return</span> data[index]; <span class="hljs-comment">// 返回可修改的引用</span><br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> data[index]; <span class="hljs-comment">// 返回只读引用</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">10</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><p><strong>调用第一个版本（返回可修改引用）</strong>：</p><ul><li>当对象是<strong>非<code>const</code>类型</strong>时，将调用第一个<code>operator[]</code>，即返回一个可修改的引用。</li><li>这种情况下，调用者可以通过返回的引用来修改数组中的元素。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Array arr;<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// 非const对象，调用第一个operator[]，可以修改元素</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>调用第二个版本（返回只读引用）</strong>：</p><ul><li>当对象是**<code>const</code>类型**时，将调用第二个<code>operator[]</code>，即返回一个只读的引用。</li><li>在这种情况下，调用者只能读取数组中的元素，而不能对其进行修改。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Array arr;<br><span class="hljs-type">int</span> value = arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// const对象，调用第二个operator[]，只能读取元素</span><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">20</span>;        <span class="hljs-comment">// 错误，无法修改const对象的元素</span><br></code></pre></td></tr></table></figure><h4 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h4><ul><li><strong>编译器根据对象的类型（是否为<code>const</code>）自动选择合适的<code>operator[]</code>重载</strong>：<ul><li>如果对象是<code>const</code>，则只能调用<code>const</code>成员函数，因此会选择<code>const int&amp; operator[](size_t index) const</code>。</li><li>如果对象是非<code>const</code>，则会优先选择<code>int&amp; operator[](size_t index)</code>，因为它允许修改数据。</li></ul></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>下面是完整的示例代码来展示这两种情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) &#123;<br>        <span class="hljs-keyword">return</span> data[index]; <span class="hljs-comment">// 返回可修改的引用</span><br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> index) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> data[index]; <span class="hljs-comment">// 返回只读引用</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Array arr;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>; <span class="hljs-comment">// 非const对象，调用第一个operator[]，可以修改元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;arr[0] = &quot;</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 输出：arr[0] = 42</span><br><br>    <span class="hljs-type">const</span> Array constArr;<br>    <span class="hljs-type">int</span> value = constArr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// const对象，调用第二个operator[]，只能读取元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;constArr[0] = &quot;</span> &lt;&lt; value &lt;&lt; std::endl; <span class="hljs-comment">// 输出：constArr[0] = 0</span><br><br>    <span class="hljs-comment">// constArr[0] = 100; // 错误，无法修改const对象的元素</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>arr[0] = 42</code>修改了非<code>const</code>对象的元素，而<code>constArr[0]</code>只读取了<code>const</code>对象的元素。</p><h3 id="3-左值和右值"><a href="#3-左值和右值" class="headerlink" title="3. 左值和右值"></a>3. 左值和右值</h3><p>左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针。也就是可以出现在等于号左边，或者可以用&amp;取地址</p><p>非左值(右值)包括字面常量（用双引号包含的字符串除外）和包含多项的表达式。也就是不可以出现在等于号左边，或者不可以用&amp;取地址</p><p><code>字符串常量</code>（例如 <code>&quot;Hello, world!&quot;</code>）在 C++中是一个<strong>右值</strong>。它是存储在只读内存中的字符数组的地址，表示一个不可修改的字符序列。</p><h3 id="4-为什么字符串常量是右值？"><a href="#4-为什么字符串常量是右值？" class="headerlink" title="4. 为什么字符串常量是右值？"></a>4. 为什么<code>字符串常量</code>是右值？</h3><ul><li><strong>右值</strong>通常是指无法在程序中获取其内存地址的值或者在求值过程中生成的临时值，而字符串常量就是这样。它是一个临时的、不可修改的对象，其类型是 <code>const char[N]</code>，其中 <code>N</code> 是字符串的长度加上终止符 <code>\0</code>。</li><li>字符串常量本质上存储在只读内存区域，因此不能被修改，这是右值的典型特征。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>这里，字符串常量 <code>&quot;Hello, world!&quot;</code> 是一个右值，它的地址被赋值给了指针 <code>str</code>。虽然可以通过 <code>str</code> 访问字符串数据，但字符串本身是不可修改的。</p><h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h4><p>在某些情况下，字符串常量可以被视为<strong>左值</strong>，例如，当它被作为数组来使用时，字符串常量可以退化为指针（指向它的第一个字符），从而在一些表达式中可以像左值一样使用。但本质上，它仍然是只读的。</p><h5 id="举例子"><a href="#举例子" class="headerlink" title="举例子"></a>举例子</h5><p>字符串常量在某些表达式中可以表现得像左值，这是因为它会<strong>退化为指针</strong>，指向字符串的第一个字符。尽管如此，字符串常量本身仍然是不可修改的（即指针指向的内容是只读的）。下面是一些可以表现得像左值的例子：</p><h6 id="示例-1：作为数组的首地址使用"><a href="#示例-1：作为数组的首地址使用" class="headerlink" title="示例 1：作为数组的首地址使用"></a>示例 1：作为数组的首地址使用</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = <span class="hljs-string">&quot;Hello, world!&quot;</span>; <span class="hljs-comment">// &quot;Hello, world!&quot; 退化为指针，指向字符串的首地址</span><br>    std::cout &lt;&lt; p &lt;&lt; std::endl;     <span class="hljs-comment">// 输出整个字符串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，字符串常量 <code>&quot;Hello, world!&quot;</code> 退化为指针 <code>const char*</code>，其值是字符串的首地址，因此可以像左值那样使用 <code>p</code>，但字符串的内容是不可修改的。</p><h6 id="示例-2：作为数组元素的首地址"><a href="#示例-2：作为数组元素的首地址" class="headerlink" title="示例 2：作为数组元素的首地址"></a>示例 2：作为数组元素的首地址</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>    std::cout &lt;&lt; str[<span class="hljs-number">0</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 输出 &#x27;H&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>str[0]</code> 表达式访问的是字符串常量中第一个字符 <code>&#39;H&#39;</code>，字符串常量退化为指针后表现得像一个数组的首地址，可以使用数组下标访问字符。</p><h6 id="示例-3：传递给函数"><a href="#示例-3：传递给函数" class="headerlink" title="示例 3：传递给函数"></a>示例 3：传递给函数</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span> </span>&#123;<br>    std::cout &lt;&lt; s &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printString</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>); <span class="hljs-comment">// 字符串常量退化为指针传递给函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，字符串常量 <code>&quot;Hello, world!&quot;</code> 退化为指针并作为参数传递给函数 <code>printString</code>，在函数内表现得像一个指针的左值。</p><h3 id="5-利用-static-的特性，实现单例-多线程需要-C-11"><a href="#5-利用-static-的特性，实现单例-多线程需要-C-11" class="headerlink" title="5. 利用 static 的特性，实现单例(多线程需要 C++11)"></a>5. 利用 static 的特性，实现单例(多线程需要 C++11)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 由于静态局部变量只会在第一次进入其所在的函数时被初始化一次，后续的函数调用会直接返回已经初始化的 `instance`，这就是为什么 `static Singleton instance` 只会执行一次。这样可以确保类始终只有一个实例，从而实现单例模式。也是延迟加载，因为只会在第一次进入其所在的函数时被初始化一次</span><br>        <span class="hljs-type">static</span> Singleton instance; <span class="hljs-comment">// 静态局部变量，只会初始化一次</span><br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Singleton instance is working!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125; <span class="hljs-comment">// 构造函数私有化，防止外部创建实例</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 删除拷贝构造函数</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 删除赋值运算符</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Singleton&amp; s1 = Singleton::<span class="hljs-built_in">getInstance</span>();<br>    Singleton&amp; s2 = Singleton::<span class="hljs-built_in">getInstance</span>();<br><br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">showMessage</span>();<br><br>    <span class="hljs-keyword">if</span> (&amp;s1 == &amp;s2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;s1 and s2 are the same instance.&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;s1 and s2 are different instances.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-11-的改进：线程安全的静态局部变量"><a href="#C-11-的改进：线程安全的静态局部变量" class="headerlink" title="C++11 的改进：线程安全的静态局部变量"></a>C++11 的改进：线程安全的静态局部变量</h4><p>在 C++11 之前，静态局部变量的初始化在多线程环境下并不保证线程安全，这意味着在多个线程同时访问时，可能会导致静态变量被初始化多次。然而，C++11 对这一特性进行了改进，使得静态局部变量的初始化在多线程环境下变得线程安全，这样可以确保静态局部变量仅被初始化一次。<br>因此，在 C++11 及以上的版本中，<code>static</code>局部变量的单例模式实现无需额外的锁机制即可保证线程安全。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/tonywearme/article/details/7097910">inline 函数必须在头文件中定义吗？</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSharp知识整理(一)</title>
    <link href="/2024/10/19/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%80)/"/>
    <url>/2024/10/19/CSharp%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h1><table><thead><tr><th>数据类型</th><th>占用字节数</th><th>数据范围</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>true 或 false</td><td>布尔类型，表示真或假</td><td>bool isActive &#x3D; true;</td></tr><tr><td>byte</td><td>1</td><td>0 到 255</td><td>无符号 8 位整数</td><td>byte age &#x3D; 25;</td></tr><tr><td>sbyte</td><td>1</td><td>-128 到 127</td><td>有符号 8 位整数</td><td>sbyte temperature &#x3D; -10;</td></tr><tr><td>char</td><td>2</td><td>‘\u0000’ (0) 到 ‘\uffff’ (65535)</td><td>Unicode 字符（16 位）</td><td>char letter &#x3D; ‘A’;</td></tr><tr><td>short</td><td>2</td><td>-32,768 到 32,767</td><td>有符号 16 位整数</td><td>short distance &#x3D; -32000;</td></tr><tr><td>ushort</td><td>2</td><td>0 到 65,535</td><td>无符号 16 位整数</td><td>ushort width &#x3D; 60000;</td></tr><tr><td>int</td><td>4</td><td>-2,147,483,648 到 2,147,483,647</td><td>有符号 32 位整数</td><td>int score &#x3D; 100;</td></tr><tr><td>uint</td><td>4</td><td>0 到 4,294,967,295</td><td>无符号 32 位整数</td><td>uint population &#x3D; 3000000000;</td></tr><tr><td>long</td><td>8</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td>有符号 64 位整数</td><td>long distanceToSun &#x3D; 150000000000L;</td></tr><tr><td>ulong</td><td>8</td><td>0 到 18,446,744,073,709,551,615</td><td>无符号 64 位整数</td><td>ulong starsInGalaxy &#x3D; 1000000000000UL;</td></tr><tr><td>float</td><td>4</td><td>±1.5 × 10^−45 到 ±3.4 × 10^38</td><td>单精度浮点数（32 位）</td><td>float price &#x3D; 19.99F;</td></tr><tr><td>double</td><td>8</td><td>±5.0 × 10^−324 到 ±1.7 × 10^308</td><td>双精度浮点数（64 位）</td><td>double pi &#x3D; 3.14159265359;</td></tr><tr><td>decimal</td><td>16</td><td>±1.0 × 10^−28 到 ±7.9228 × 10^28</td><td>高精度小数（128 位）</td><td>decimal balance &#x3D; 1000.75M;</td></tr><tr><td>string</td><td>不固定</td><td>根据字符数量变化</td><td>一组 Unicode 字符（文本）</td><td>string name &#x3D; “John Doe”;</td></tr></tbody></table><h2 id="char是2字节"><a href="#char是2字节" class="headerlink" title="char是2字节"></a>char是2字节</h2><p>在 C# 中，<code>char</code> 数据类型使用 2 字节（16 位）是因为它表示一个 Unicode 字符。Unicode 字符集比传统的 ASCII 字符集要大得多，能够表示全球范围内的各种字符和符号。为了支持这一广泛的字符集，C# 采用了 UTF-16 编码格式，其中每个 <code>char</code> 类型的字符占用 2 字节。</p><ul><li>但是如果是某些生僻字，需要先将这两个 char 放到一个 char[] 数组中，然后通过 new string(char[]) 创建一个 string 来输出。<ul><li><code>char[] surrogatePair = new char[] &#123; &#39;\uD840&#39;, &#39;\uDC8E&#39; &#125;; // &quot;𠜎&quot; 的代理对表示</code></li><li><code>string str = new string(surrogatePair);</code> &#x2F;&#x2F; 将代理对转化为字符串</li><li><code>Console.WriteLine(str);</code> &#x2F;&#x2F; 输出：𠜎</li></ul></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br><br>        <span class="hljs-built_in">char</span> c = <span class="hljs-string">&#x27;中&#x27;</span>;<br>        Console.WriteLine(c);<br>        Console.WriteLine(<span class="hljs-string">$&quot;一个char字符占用字节数:<span class="hljs-subst">&#123;<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">char</span>)&#125;</span>&quot;</span>); <span class="hljs-comment">// 1</span><br>        <span class="hljs-comment">// 对于更复杂的类型（包括结构和类实例），可以使用</span><br>        <span class="hljs-comment">// System.Runtime.InteropServices.Marshal.SizeOf方法</span><br>        <span class="hljs-built_in">int</span> size = Marshal.SizeOf(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">char</span>));<br>        Console.WriteLine(<span class="hljs-string">$&quot;一个char字符占用字节数:<span class="hljs-subst">&#123;size&#125;</span>&quot;</span>); <span class="hljs-comment">// 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里控制台还是无法显示，先不管了<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 设置控制台输出编码为 UTF-8</span><br>        Console.OutputEncoding = System.Text.Encoding.UTF8;<br><br>        <span class="hljs-comment">// 输出包含生僻字的字符串</span><br>        <span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;这是一个生僻字: 龘𠜎&quot;</span>;<br>        <span class="hljs-comment">//&quot;这&quot;（1个字符）</span><br>        <span class="hljs-comment">//&quot;是&quot;（1个字符）</span><br>        <span class="hljs-comment">//&quot;一&quot;（1个字符）</span><br>        <span class="hljs-comment">//&quot;个&quot;（1个字符）</span><br>        <span class="hljs-comment">//&quot;生&quot;（1个字符）</span><br>        <span class="hljs-comment">//&quot;僻&quot;（1个字符）</span><br>        <span class="hljs-comment">//&quot;字&quot;（1个字符）</span><br>        <span class="hljs-comment">//&quot;:&quot;（1个字符）</span><br>        <span class="hljs-comment">//&quot;龘&quot;（2个字符，代理对）</span><br>        <span class="hljs-comment">//&quot;𠜎&quot;（2个字符，代理对）</span><br>        Console.WriteLine(str.Length);  <span class="hljs-comment">// 12</span><br>        Console.WriteLine(str);  <span class="hljs-comment">// 在控制台显示，生僻字&quot;𠜎&quot;无法显示</span><br><br>        <span class="hljs-comment">// 或者通过 Debug 输出</span><br>        System.Diagnostics.Debug.WriteLine(str); <span class="hljs-comment">// 通过 Visual Studio 输出窗口</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><a href="https://imgse.com/i/pAsq64U"><img src="https://s21.ax1x.com/2024/11/06/pAsq64U.png" alt="pAsq64U.png"></a></p><table><thead><tr><th></th><th><strong>x64</strong></th><th><strong>x86</strong></th></tr></thead><tbody><tr><td></td><td>Marshal.</td><td>Marshal.</td></tr><tr><td>Primitive</td><td>SizeOf<T>()          sizeof(T)</td><td>SizeOf<T>()          sizeof(T)</td></tr><tr><td>Boolean</td><td>4     &lt;-&gt;    1</td><td>4    &lt;-&gt;    1</td></tr><tr><td>Byte</td><td>1            1</td><td>1            1</td></tr><tr><td>SByte</td><td>1            1</td><td>1           1</td></tr><tr><td>Int16</td><td>2            2</td><td>2           2</td></tr><tr><td>UInt16</td><td>2            2</td><td>2            2</td></tr><tr><td>Int32</td><td>4            4</td><td>4            4</td></tr><tr><td>UInt32</td><td>4            4</td><td>4            4</td></tr><tr><td>Int64</td><td>8            8</td><td>8            8</td></tr><tr><td>UInt64</td><td>8            8</td><td>8            8</td></tr><tr><td>IntPtr</td><td>8            8</td><td>4           4</td></tr><tr><td>UIntPtr</td><td>8            8</td><td>4           4</td></tr><tr><td>Char</td><td>1     &lt;-&gt;    2</td><td>1     &lt;-&gt;    2</td></tr><tr><td>Double</td><td>8            8</td><td>8            8</td></tr><tr><td>Single</td><td>4            4</td><td>4            4</td></tr></tbody></table><h2 id="使用char变量，Marshal-SizeOf-和sizeof-不一样"><a href="#使用char变量，Marshal-SizeOf-和sizeof-不一样" class="headerlink" title="使用char变量，Marshal.SizeOf()和sizeof()不一样"></a>使用char变量，Marshal.SizeOf()和sizeof()不一样</h2><p>在C#中，<code>sizeof</code>和<code>Marshal.SizeOf</code>在处理<code>char</code>类型时确实会有差异。</p><ol><li><p><code>sizeof(char)</code>：<br><code>sizeof(char)</code>会返回<code>2</code>，因为在.NET中，<code>char</code>类型使用UTF-16编码，每个字符占用2个字节。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> sizeOfChar = <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">char</span>); <span class="hljs-comment">// 结果是2</span><br></code></pre></td></tr></table></figure></li><li><p><code>Marshal.SizeOf(typeof(char))</code><br><code>Marshal.SizeOf</code>在处理<code>char</code>类型时会返回<code>1</code>，因为它假定在非托管代码中<code>char</code>的大小是1个字节，这种情况通常出现在Interop或P&#x2F;Invoke场景中。因此它会计算为1字节，这也是.NET和非托管环境的一个差异。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> marshalSizeOfChar = Marshal.SizeOf(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">char</span>)); <span class="hljs-comment">// 结果是1</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="非托管代码"><a href="#非托管代码" class="headerlink" title="非托管代码"></a>非托管代码</h2><p>在C#和.NET中，<strong>非托管代码（Unmanaged Code）</strong>指的是不受.NET运行时（CLR）管理的代码。这通常包括用C、C++等语言编写的代码或直接与操作系统交互的代码。非托管代码不会自动享受.NET提供的垃圾回收、内存管理和类型安全等功能，开发者需要手动处理内存管理。</p><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ol><li><strong>托管代码（Managed Code）</strong>：<ul><li><code>由.NET运行时管理</code>，运行时负责内存分配、垃圾回收和异常处理。</li><li>大部分C#代码属于托管代码。<ul><li><strong>P&#x2F;Invoke（平台调用）</strong>: 通过 P&#x2F;Invoke，C# 代码可以调用 Windows API 或其他操作系统提供的本地库（例如 <code>.dll</code> 文件）。这些调用直接与操作系统交互，属于非托管代码。<br>   例如，使用 <code>DllImport</code> 特性调用本地 C&#x2F;C++ 库：   <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;kernel32.dll&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Beep</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> frequency, <span class="hljs-built_in">int</span> duration</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Beep(<span class="hljs-number">800</span>, <span class="hljs-number">500</span>);  <span class="hljs-comment">// 调用 Windows API 发出声音</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>与 C++ 编写的本地代码交互</strong>: 通过 <strong>C++&#x2F;CLI</strong> 或其他方法，C# 可以调用直接通过 C++ 编写的本地代码，这些代码通常需要手动进行内存管理，并且不由 CLR 管理。例如，使用 C++ 编写的高性能计算或直接与硬件交互的代码。</li><li><strong>Unsafe 代码</strong>: C# 允许通过 <strong><code>unsafe</code></strong> 关键字编写非托管代码。这些代码不受 CLR 的管理，可以直接操作内存、指针等。这些操作通常用于需要高性能的场景，或者与硬件、操作系统的直接交互。<br>  例如，使用指针和内存操作：  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">unsafe</span><br>&#123;<br>    <span class="hljs-built_in">int</span>* ptr = &amp;myVar;<br>    *ptr = <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>COM Interop</strong>: COM（组件对象模型）是微软的一个底层技术，用于不同编程语言之间的交互。通过 COM Interop，C# 可以与使用 COM 的应用程序或组件进行交互，这些 COM 对象通常是非托管的。</li><li><strong>内存映射文件（Memory-mapped files）</strong>: 在某些情况下，C# 代码可能需要与操作系统的内存直接交互，例如使用内存映射文件（<code>MemoryMappedFile</code>）。尽管这些代码在托管环境下执行，但它们通常依赖于非托管的操作系统服务来处理大规模数据。<ul><li>在托管代码中，不用担心手动释放内存，因为.NET会自动回收不再使用的对象。</li></ul></li></ul></li><li><strong>非托管代码（Unmanaged Code）</strong>：<ul><li><code>不由.NET运行时管理</code>，通常通过直接访问底层系统资源或外部库实现。</li><li>开发者需要手动管理内存分配和释放，否则会导致内存泄漏。</li><li>例如通过P&#x2F;Invoke机制调用Windows API、C++库或与硬件直接交互的代码。</li></ul></li></ol><h3 id="非托管代码的典型使用场景"><a href="#非托管代码的典型使用场景" class="headerlink" title="非托管代码的典型使用场景"></a>非托管代码的典型使用场景</h3><p>在C#应用中有时需要调用非托管代码，例如：</p><ul><li><strong>性能需求</strong>：某些情况下，直接调用C或C++代码可以提高性能。</li><li><strong>平台依赖功能</strong>：如调用操作系统的API或驱动程序，特别是在需要与硬件交互时。</li><li><strong>第三方库</strong>：如果需要使用某些特定的C&#x2F;C++库，可以通过非托管代码集成。</li></ul><h3 id="如何调用非托管代码"><a href="#如何调用非托管代码" class="headerlink" title="如何调用非托管代码"></a>如何调用非托管代码</h3><p>在C#中，可以通过<strong>P&#x2F;Invoke（Platform Invocation Services）</strong>机制来调用非托管代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Runtime.InteropServices;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// P/Invoke示例：调用Windows API函数MessageBox</span><br>    [<span class="hljs-meta">DllImport(<span class="hljs-string">&quot;user32.dll&quot;</span>, CharSet = CharSet.Unicode)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MessageBox</span>(<span class="hljs-params">IntPtr hWnd, <span class="hljs-built_in">string</span> text, <span class="hljs-built_in">string</span> caption, <span class="hljs-built_in">int</span> type</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用非托管的MessageBox函数</span><br>        MessageBox(IntPtr.Zero, <span class="hljs-string">&quot;Hello, world!&quot;</span>, <span class="hljs-string">&quot;Message&quot;</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>DllImport</code>特性用于声明并调用Windows API中的<code>MessageBox</code>函数。</p><h1 id="2-原始字面量的使用"><a href="#2-原始字面量的使用" class="headerlink" title="2. 原始字面量的使用 @"></a>2. 原始字面量的使用 @</h1><p>在 C# 中，原始字面量的表示方式使用的是 <code>@</code> 符号，而不是 C++ 中的 <code>R</code>。这种方式主要用于字符串字面量，使得字符串中的反斜杠 <code>\</code> 和双引号 <code>&quot;</code> 不会被转义。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br><br>        <span class="hljs-built_in">string</span> path = <span class="hljs-string">@&quot;C:\Program Files\MyApp\config.json&quot;</span>;<br>        Console.WriteLine(path); <span class="hljs-comment">// C:\Program Files\MyApp\config.json</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-枚举"><a href="#3-枚举" class="headerlink" title="3. 枚举"></a>3. 枚举</h1><ul><li>声明位置<ul><li>namespace语句块中(常用)</li><li>class语句块中，struct语句块中</li><li>但不能声明在语句块中（Main函数也不行）</li></ul></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-built_in">enum</span> E_number<br>    &#123;<br>        one = <span class="hljs-number">1</span>, <span class="hljs-comment">// 默认从0开始</span><br>        two = <span class="hljs-number">2</span>, <span class="hljs-comment">// 后面依次+1</span><br>        three, <span class="hljs-comment">// 3</span><br>        four, <span class="hljs-comment">// 4</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        E_number one = E_number.one;<br>        <span class="hljs-comment">// 枚举-&gt;int</span><br>        <span class="hljs-comment">// Color color = 2;  // int 隐式转换为 Color Cpp</span><br>        <span class="hljs-comment">// int x = Red;  // Color 隐式转换为 int Cpp</span><br>        <span class="hljs-comment">// 不强制转会报错，在Cpp中的C++11之前的弱类型枚举，可以隐式转换</span><br>        <span class="hljs-built_in">int</span> oneNum = (<span class="hljs-built_in">int</span>)one;<br>        Console.WriteLine(oneNum);<br>        <span class="hljs-comment">// int-&gt;枚举</span><br>        E_number two = (E_number)(<span class="hljs-number">2</span>);<br>        Console.WriteLine(two);<br>        <span class="hljs-comment">// 枚举-&gt;string</span><br>        <span class="hljs-built_in">string</span> oneStr = one.ToString();<br>        Console.WriteLine(oneStr);<br>        <span class="hljs-comment">// string-&gt;枚举</span><br>        one = (E_number)Enum.Parse(<span class="hljs-keyword">typeof</span>(E_number), oneStr);<br>        Console.WriteLine(one);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-string"><a href="#4-string" class="headerlink" title="4. string"></a>4. string</h1><p>在 C# 中，<code>string</code> 是一个用于表示文本的基本数据类型，属于引用类型。它是 .NET 中的 <code>System.String</code> 类的别名，并且是不可变（immutable）的。这意味着一旦创建了字符串对象，其内容就不能再修改。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>    <span class="hljs-comment">// `System.String` 和 `string` 是等价的，它们没有本质的区别。`string` 是 `System.String` 的别名</span><br>        System.String str1 = <span class="hljs-string">&quot;123&quot;</span>;<br>        <span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;2343&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, str1, str2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>不可变性</strong>：每当对字符串进行操作（如拼接、替换、截取等），都会生成一个新的字符串对象，而不是修改原有的字符串。</li><li><strong>引用类型</strong>：<code>string</code> 是一个引用类型，虽然它在使用上像值类型一样简单。</li><li><strong>支持字符串插值和格式化</strong>：C# 支持字符串插值（<code>$</code>）和格式化操作。</li><li><strong>可以为 <code>null</code></strong> ：<code>string</code> 可以被赋值为 <code>null</code>，表示没有任何文本。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 格式化字符串</span><br>        <span class="hljs-comment">// &#123; 0:D&#125;：将参数作为日期格式化。</span><br>        <span class="hljs-comment">// &#123; 0:N&#125;：将数字格式化为带千位分隔符的格式。</span><br>        <span class="hljs-comment">// &#123; 0:F2&#125;：将浮动小数格式化为带两位小数的固定点表示。</span><br><br>        DateTime date = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2024</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// Tuesday, November 6, 2024</span><br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0:D&#125;&quot;</span>, date);<br><br>        <span class="hljs-built_in">int</span> number = <span class="hljs-number">1234567</span>;<br>        <span class="hljs-comment">// 1,234,567.00</span><br>        <span class="hljs-comment">// N 格式说明符会在数字中插入千位分隔符，并且默认为显示两位小数。如果希望控制小数的位数，可以使用类似 &#123;0:N3&#125; 来控制显示三位小数。</span><br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0:N&#125;&quot;</span>, number);<br><br>        <span class="hljs-built_in">double</span> price = <span class="hljs-number">12345.6789</span>;<br>        <span class="hljs-comment">// 12345.68</span><br>        <span class="hljs-comment">// F2 表示将浮动小数格式化为两位小数的固定点表示，四舍五入至两位</span><br>        Console.WriteLine(<span class="hljs-string">&quot;&#123;0:F2&#125;&quot;</span>, price);<br><br>        <span class="hljs-comment">// 定义字符串</span><br>        <span class="hljs-built_in">string</span> greeting = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-comment">// 字符串拼接</span><br>        <span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>        <span class="hljs-built_in">string</span> message = greeting + <span class="hljs-string">&quot; My name is &quot;</span> + name + <span class="hljs-string">&quot;.&quot;</span>;<br>        <span class="hljs-comment">// Hello, World! My name is Alice.</span><br>        Console.WriteLine(message);<br><br>        <span class="hljs-comment">// 使用字符串插值</span><br>        <span class="hljs-built_in">string</span> interpolatedMessage = <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;greeting&#125;</span> My name is <span class="hljs-subst">&#123;name&#125;</span>.&quot;</span>;<br>        <span class="hljs-comment">// Hello, World! My name is Alice.</span><br>        Console.WriteLine(interpolatedMessage);<br><br>        <span class="hljs-comment">// 字符串长度</span><br>        <span class="hljs-built_in">int</span> length = greeting.Length;<br>        <span class="hljs-comment">// Length of greeting: 13</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Length of greeting: <span class="hljs-subst">&#123;length:N&#125;</span>&quot;</span>);<br><br>        <span class="hljs-comment">// 字符串替换</span><br>        <span class="hljs-built_in">string</span> newGreeting = greeting.Replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;C#&quot;</span>);<br>        <span class="hljs-comment">// Hello, C#!</span><br>        Console.WriteLine(newGreeting);<br><br>        <span class="hljs-comment">// 空字符串和 null</span><br>        <span class="hljs-built_in">string</span> emptyString = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">string</span>? nullString = <span class="hljs-literal">null</span>;<span class="hljs-comment">//表示可以是null的string类型</span><br>        <span class="hljs-comment">// True</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Is empty string empty? <span class="hljs-subst">&#123;<span class="hljs-built_in">string</span>.IsNullOrEmpty(emptyString)&#125;</span>&quot;</span>);<br>        <span class="hljs-comment">// True</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Is null string null? <span class="hljs-subst">&#123;nullString == <span class="hljs-literal">null</span>&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li><strong>定义字符串</strong>：可以使用双引号定义字符串，如 <code>&quot;Hello, World!&quot;</code>。</li><li><strong>拼接字符串</strong>：使用 <code>+</code> 运算符或字符串插值（<code>$</code>）来拼接字符串。</li><li><strong>字符串长度</strong>：通过 <code>Length</code> 属性可以获取字符串的字符数。</li><li><strong>字符串替换</strong>：使用 <code>Replace</code> 方法替换字符串中的某些内容。</li><li><strong>空字符串和 <code>null</code></strong> ：C# 提供了 <code>string.IsNullOrEmpty</code> 方法来检查字符串是否为空或 <code>null</code>。</li></ul><h3 id="不可变性示例"><a href="#不可变性示例" class="headerlink" title="不可变性示例"></a>不可变性示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> original = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">string</span> modified = original.Replace(<span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>);<br><br>Console.WriteLine(original); <span class="hljs-comment">// 输出: Hello</span><br>Console.WriteLine(modified); <span class="hljs-comment">// 输出: Jello</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Replace</code> 方法不会修改 <code>original</code>，而是创建一个新的字符串 <code>modified</code>。</p><h1 id="5-StringBuilder"><a href="#5-StringBuilder" class="headerlink" title="5. StringBuilder"></a>5. StringBuilder</h1><p><code>StringBuilder</code> 是 C# 中用于处理可变字符串的类。与 <code>string</code> 不同，<code>StringBuilder</code> 允许在不创建新对象的情况下修改字符串内容，从而在频繁拼接、追加或插入操作时提高性能。</p><h3 id="为什么使用-StringBuilder"><a href="#为什么使用-StringBuilder" class="headerlink" title="为什么使用 StringBuilder"></a>为什么使用 <code>StringBuilder</code></h3><p>由于 <code>string</code> 是不可变的，每次修改字符串都会创建一个新的 <code>string</code> 对象。在大量拼接操作时，这种重复的创建和销毁会导致性能下降和内存浪费。而 <code>StringBuilder</code> 可以动态地修改字符串内容，不会创建多个字符串对象，能够显著提升性能。</p><ul><li>using System.Text;</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个 StringBuilder 对象</span><br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>        <span class="hljs-comment">// 追加字符串</span><br>        sb.Append(<span class="hljs-string">&quot;, World! World!&quot;</span>);<br>        Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出: Hello, World! World!</span><br><br>        <span class="hljs-comment">// 插入字符串</span><br>        sb.Insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot; C#&quot;</span>);<br>        Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出: Hello C#, World! World!</span><br><br>        <span class="hljs-comment">// 替换所有符合的字符串</span><br>        sb.Replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;StringBuilder&quot;</span>);<br>        Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出: Hello C#, StringBuilder! StringBuilder!!</span><br><br>        <span class="hljs-comment">// 删除字符串</span><br>        sb.Remove(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 删除从索引5开始的3个字符</span><br>        Console.WriteLine(sb.ToString()); <span class="hljs-comment">// 输出: Hello, StringBuilder! StringBuilder!</span><br><br>        <span class="hljs-comment">// 清空 StringBuilder</span><br>        sb.Clear();<br>        Console.WriteLine(<span class="hljs-string">$&quot;Length after clearing: <span class="hljs-subst">&#123;sb.Length&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Length after clearing: 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><code>StringBuilder</code> 是 C# 中用于高效构建和修改字符串的类，因为它能避免频繁创建新的字符串实例。以下是 <code>StringBuilder</code> 常用的方法：</p><h4 id="1-Append"><a href="#1-Append" class="headerlink" title="1. Append"></a>1. <strong>Append</strong></h4><ul><li>将指定的字符串或对象附加到当前 <code>StringBuilder</code> 实例的末尾。</li><li>支持多种重载，可以附加字符串、字符、对象、数字等。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br>        &#123;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        sb.Append(<span class="hljs-string">&quot;, World!&quot;</span>);<br>        Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, World!</span><br><br>        sb.Append(<span class="hljs-string">&#x27;+&#x27;</span>);<br>        Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, World!+</span><br><br>        sb.Append(<span class="hljs-keyword">new</span> Test());<br>        Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, World!+Program+Test</span><br><br>        sb.Append(<span class="hljs-number">123</span>);<br>        Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, World!+Program+Test123</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-AppendLine"><a href="#2-AppendLine" class="headerlink" title="2. AppendLine"></a>2. <strong>AppendLine</strong></h4><ul><li>在当前 <code>StringBuilder</code> 实例的末尾追加一个字符串，<code>并添加一个换行符</code>。</li><li>可用于追加多行文本。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        sb.Append(<span class="hljs-string">&quot;, World!\n&quot;</span>);<br>        sb.AppendLine(<span class="hljs-string">&quot;This is the first line.&quot;</span>);<br>        sb.AppendLine(<span class="hljs-string">&quot;This is the second line.&quot;</span>);<br>        Console.WriteLine(sb);<br>        <span class="hljs-comment">// 输出:</span><br>        <span class="hljs-comment">// Hello, World!</span><br>        <span class="hljs-comment">// This is the first line.</span><br>        <span class="hljs-comment">// This is the second line.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-Insert"><a href="#3-Insert" class="headerlink" title="3. Insert"></a>3. <strong>Insert</strong></h4><ul><li>在指定位置插入一个字符串或字符。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.Insert(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;Beautiful &quot;</span>);<br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, Beautiful World!</span><br></code></pre></td></tr></table></figure><h4 id="4-Remove"><a href="#4-Remove" class="headerlink" title="4. Remove"></a>4. <strong>Remove</strong></h4><ul><li>从 <code>StringBuilder</code> 中删除指定索引处的字符，指定要删除的字符数。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.Remove(<span class="hljs-number">7</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 从索引 7 开始删除 10 个字符</span><br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure><h4 id="5-Replace"><a href="#5-Replace" class="headerlink" title="5. Replace"></a>5. <strong>Replace</strong></h4><ul><li>将 <code>StringBuilder</code> 实例中的所有匹配的字符串或字符替换为指定的值。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<span class="hljs-comment">//也可以直接单个字符改</span><br>sb.Replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;C#&quot;</span>);<br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello, C#!</span><br></code></pre></td></tr></table></figure><h4 id="6-Clear"><a href="#6-Clear" class="headerlink" title="6. Clear"></a>6. <strong>Clear</strong></h4><ul><li>清空 <code>StringBuilder</code> 实例中的所有内容。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.Clear();<br>Console.WriteLine(sb.Length); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure><h4 id="7-ToString"><a href="#7-ToString" class="headerlink" title="7. ToString"></a>7. <strong>ToString</strong></h4><ul><li>将 <code>StringBuilder</code> 实例转换为 <code>string</code>。</li><li>可以指定一个索引和长度，从而将特定范围内的字符转换为字符串。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(str);<br>sb.Append(<span class="hljs-string">&quot;Hello, C#!&quot;</span>);<br><span class="hljs-built_in">string</span> str = sb.ToString();<br>Console.WriteLine(str); <span class="hljs-comment">// 输出: Hello, C#!</span><br></code></pre></td></tr></table></figure><h4 id="8-Length"><a href="#8-Length" class="headerlink" title="8. Length"></a>8. <strong>Length</strong></h4><ul><li>获取或设置 <code>StringBuilder</code> 实例中的字符数。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(sb.Length); <span class="hljs-comment">// 输出: 10</span><br>sb.Length = <span class="hljs-number">5</span>; <span class="hljs-comment">// 将长度设为 5，多余的字符将被截断</span><br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Hello</span><br></code></pre></td></tr></table></figure><h4 id="9-Capacity"><a href="#9-Capacity" class="headerlink" title="9. Capacity"></a>9. <strong>Capacity</strong></h4><ul><li>获取或设置当前实例能够容纳的字符数。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> capacity = sb.Capacity;<br>sb.Capacity = <span class="hljs-number">50</span>; <span class="hljs-comment">// 设置容量</span><br></code></pre></td></tr></table></figure><h4 id="10-EnsureCapacity"><a href="#10-EnsureCapacity" class="headerlink" title="10. EnsureCapacity"></a>10. <strong>EnsureCapacity</strong></h4><ul><li>确保 <code>StringBuilder</code> 的容量至少为指定的值，如果小于该值，则会增加容量。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">sb.EnsureCapacity(<span class="hljs-number">100</span>); <span class="hljs-comment">// 确保容量至少为 100，如果本来就大于100，则不变</span><br></code></pre></td></tr></table></figure><h4 id="11-AppendFormat"><a href="#11-AppendFormat" class="headerlink" title="11. AppendFormat"></a>11. <strong>AppendFormat</strong></h4><ul><li>该方法用于将格式化字符串追加到 <code>StringBuilder</code> 实例的末尾，类似于 <code>string.Format</code> 的功能。</li><li>适用于需要将格式化的内容插入到字符串中的情况。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>sb.AppendFormat(<span class="hljs-string">&quot;Name: &#123;0&#125;, Age: &#123;1&#125;&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);<br>Console.WriteLine(sb); <span class="hljs-comment">// 输出: Name: Alice, Age: 25</span><br></code></pre></td></tr></table></figure><ul><li><code>AppendFormat</code> 支持标准格式化和自定义格式化，因此非常适合在文本拼接时插入动态数据。</li></ul><h4 id="12-Equals"><a href="#12-Equals" class="headerlink" title="12. Equals"></a>12. <strong>Equals</strong></h4><ul><li><code>StringBuilder</code> 的 <code>Equals</code> 方法用于比较当前实例和另一个 <code>StringBuilder</code> 实例是否相等。</li><li>相等的条件是：两个实例的字符内容和长度必须相同。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Text;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        StringBuilder sb1 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        StringBuilder sb2 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        StringBuilder sb3 = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;World&quot;</span>);<br>        StringBuilder sb = sb1;<br><br>        Console.WriteLine(sb1.Equals(sb2)); <span class="hljs-comment">// 输出: True，因为内容相同</span><br>        Console.WriteLine(sb1.Equals(sb3)); <span class="hljs-comment">// 输出: False，因为内容不同</span><br>        Console.WriteLine(sb1 == sb); <span class="hljs-comment">// 输出: True，因为引用相同</span><br>        Console.WriteLine(sb1 == sb2); <span class="hljs-comment">// 输出: False，因为引用不同</span><br>        Console.WriteLine(ReferenceEquals(sb1, sb));  <span class="hljs-comment">// 输出 True，因为它们是相同的对象</span><br>        Console.WriteLine(ReferenceEquals(sb1, sb2));  <span class="hljs-comment">// 输出 false，因为它们是不同的对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><ul><li><strong><code>string</code> 拼接</strong>:</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> result = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>    result += <span class="hljs-string">&quot;Hello &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次循环都会创建一个新的 <code>string</code>，性能较差。</p><ul><li><strong>使用 <code>StringBuilder</code></strong>:</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>    sb.Append(<span class="hljs-string">&quot;Hello &quot;</span>);<br>&#125;<br><span class="hljs-built_in">string</span> result = sb.ToString();<br></code></pre></td></tr></table></figure><p>这种方式性能更好，因为 <code>StringBuilder</code> 可以动态地扩展内存，减少不必要的对象创建。</p><h3 id="初始化容量"><a href="#初始化容量" class="headerlink" title="初始化容量"></a>初始化容量</h3><p>可以通过指定初始容量来提高性能：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">100</span>); <span class="hljs-comment">// 预分配100个字符的空间</span><br></code></pre></td></tr></table></figure><h1 id="6-ref和out的使用"><a href="#6-ref和out的使用" class="headerlink" title="6. ref和out的使用"></a>6. ref和out的使用</h1><p>在 C# 中，<code>ref</code> 和 <code>out</code> 是两种用于参数传递的关键字，它们允许方法通过引用传递参数，而不是通过值传递。虽然这两者的作用相似，但在使用和语义上有一些重要的区别。</p><h3 id="1-ref-关键字"><a href="#1-ref-关键字" class="headerlink" title="1. ref 关键字"></a>1. <code>ref</code> 关键字</h3><ul><li><strong>定义</strong>: <code>ref</code> 关键字用于将参数作为引用传递给方法。这样在方法内对参数的任何修改都会影响到原始变量。</li><li><strong>要求</strong>: 在调用方法之前，必须先为参数赋值。</li><li><strong>用法</strong>:<ul><li>在方法定义中需要加上 <code>ref</code>。</li><li>在调用方法时也需要加上 <code>ref</code>。</li></ul></li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ModifyValue</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> number</span>)</span><br>    &#123;<br>        number += <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改原始变量</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> myNumber = <span class="hljs-number">5</span>;<br>        ModifyValue(<span class="hljs-keyword">ref</span> myNumber);<br>        Console.WriteLine(myNumber); <span class="hljs-comment">// 输出 15</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-out-关键字"><a href="#2-out-关键字" class="headerlink" title="2. out 关键字"></a>2. <code>out</code> 关键字</h3><ul><li><strong>定义</strong>: <code>out</code> 关键字也用于将参数作为引用传递，但在方法内部，<code>out</code> 参数必须在方法返回之前进行赋值。</li><li><strong>要求</strong>: 在调用方法之前，无需为参数赋值（即使未赋值，也能正常工作）。但在方法内部，<code>out</code> 参数必须在方法返回之前进行赋值</li><li><strong>用法</strong>:<ul><li>在方法定义中需要加上 <code>out</code>。</li><li>在调用方法时也需要加上 <code>out</code>。</li></ul></li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetValues</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> number</span>)</span><br>    &#123;<br>        number = <span class="hljs-number">42</span>; <span class="hljs-comment">// 必须在返回之前赋值</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> myNumber; <span class="hljs-comment">// 无需初始化</span><br>        GetValues(<span class="hljs-keyword">out</span> myNumber);<br>        Console.WriteLine(myNumber); <span class="hljs-comment">// 输出 42</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要区别-1"><a href="#主要区别-1" class="headerlink" title="主要区别"></a>主要区别</h3><table><thead><tr><th>特性</th><th><code>ref</code></th><th><code>out</code></th></tr></thead><tbody><tr><td>初始值要求</td><td>需要在调用前初始化</td><td>不需要初始化</td></tr><tr><td>赋值要求</td><td>可以在方法内修改，也可以不修改</td><td>必须在方法内赋值</td></tr><tr><td>语义</td><td>表示方法可能修改参数值</td><td>表示方法将输出一个值</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>使用 <code>ref</code> 可以在方法中修改传入的参数，并且调用方法之前需要初始化。</li><li>使用 <code>out</code> 适合用于返回多个值的场景，调用前不需要初始化，但必须在方法中赋值。</li><li>ref和out可以作为重载的条件，但是两个不能同时用<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用带有 params 参数的方法</span><br>        <span class="hljs-built_in">float</span> f = <span class="hljs-number">1.0f</span>;<br>        CalcSum(<span class="hljs-keyword">ref</span> f, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CalcSum</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">float</span> f, <span class="hljs-built_in">int</span> a</span>)</span><br>    &#123;<br>        Console.WriteLine(f + a);<br>        <span class="hljs-comment">// 确保显示一位小数</span><br>        Console.WriteLine((f + a).ToString(<span class="hljs-string">&quot;F1&quot;</span>));<span class="hljs-comment">//3.0</span><br><br>    &#125;<br><br>    <span class="hljs-comment">// 两者ref和out不可以同时出现</span><br>    <span class="hljs-comment">//static void CalcSum(out float f, int a)</span><br>    <span class="hljs-comment">//&#123;</span><br>    <span class="hljs-comment">//    Console.WriteLine(f + a);</span><br><br>    <span class="hljs-comment">//&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// 定义方法，使用out参数返回商和余数</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Divide</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> dividend, <span class="hljs-built_in">int</span> divisor, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> quotient, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> remainder</span>)</span><br>    &#123;<br>        quotient = dividend / divisor;<br>        remainder = dividend % divisor;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> dividend = <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">int</span> divisor = <span class="hljs-number">3</span>;<br>        <span class="hljs-built_in">int</span> quotient;   <span class="hljs-comment">// 无需初始化</span><br>        <span class="hljs-built_in">int</span> remainder;  <span class="hljs-comment">// 无需初始化</span><br><br>        <span class="hljs-comment">// 调用方法时使用out参数</span><br>        Divide(dividend, divisor, <span class="hljs-keyword">out</span> quotient, <span class="hljs-keyword">out</span> remainder);<br><br>        <span class="hljs-comment">// 输出结果</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;Quotient: <span class="hljs-subst">&#123;quotient&#125;</span>, Remainder: <span class="hljs-subst">&#123;remainder&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Quotient:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">Remainder:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>quotient</code>和<code>remainder</code>作为<code>out</code>参数传入方法<code>Divide</code>，不需要初始化。调用后，方法将计算结果赋值给这两个参数，供调用者使用。</p><ul><li>C++中&amp;可以作为重载的标准，const int&amp; 指的是常数，int 和int&amp;都可以指变量，用的时候会报错</li></ul><p><code>ref</code> 和 <code>out</code> 是两个英文单词的缩写，具体含义如下：</p><ol><li><code>ref</code>：是 <strong>“reference”</strong> 的缩写，表示引用。在参数传递中，<code>ref</code> 表示该参数是通过引用传递的，这意味着方法内部对参数的修改会影响到原始变量。</li><li><code>out</code>：是 <strong>“output”</strong> 的缩写，表示输出。<code>out</code> 参数用于方法输出结果，表示该参数用于返回值，方法内部必须对其进行赋值。</li></ol><h3 id="为什么不需要-ref-或-out？"><a href="#为什么不需要-ref-或-out？" class="headerlink" title="为什么不需要 ref 或 out？"></a><strong>为什么不需要 <code>ref</code> 或 <code>out</code>？</strong></h3><p><code>ref</code> 和 <code>out</code> 主要用于修改值类型或需要替换引用本身的情况，但对于引用类型的内容修改，直接操作即可生效。例如：</p><h4 id="示例：引用类型无需-ref-的修改"><a href="#示例：引用类型无需-ref-的修改" class="headerlink" title="示例：引用类型无需 ref 的修改"></a><strong>示例：引用类型无需 <code>ref</code> 的修改</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ModifyList</span>(<span class="hljs-params">List&lt;<span class="hljs-built_in">int</span>&gt; list</span>)</span><br>&#123;<br>    list.Clear();        <span class="hljs-comment">// 修改了 list 的内容</span><br>    list.Add(<span class="hljs-number">1</span>);         <span class="hljs-comment">// 修改了 list 的内容</span><br>&#125;<br><br>List&lt;<span class="hljs-built_in">int</span>&gt; myList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;<br><span class="hljs-comment">// List&lt;T&gt; 是引用类型，在方法内部修改它的内容会直接反映到调用方</span><br>ModifyList(myList);      <span class="hljs-comment">// myList 被直接修改</span><br>Console.WriteLine(myList.Count); <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><h4 id="示例：需要-ref-替换引用本身"><a href="#示例：需要-ref-替换引用本身" class="headerlink" title="示例：需要 ref 替换引用本身"></a><strong>示例：需要 <code>ref</code> 替换引用本身</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ReplaceList</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> List&lt;<span class="hljs-built_in">int</span>&gt; list</span>)</span><br>&#123;<br>    list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 替换了 list 的引用</span><br>&#125;<br><br>List&lt;<span class="hljs-built_in">int</span>&gt; myList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;<br>ReplaceList(<span class="hljs-keyword">ref</span> myList);             <span class="hljs-comment">// 替换了 myList 的引用</span><br>Console.WriteLine(myList.Count);     <span class="hljs-comment">// 输出 3</span><br></code></pre></td></tr></table></figure><p>在 <code>GetComponents&lt;T&gt;(List&lt;T&gt; list)</code> 中，Unity 不需要替换 <code>list</code> 的引用，仅修改其内容，所以无需 <code>ref</code> 或 <code>out</code>。</p><h1 id="7-params"><a href="#7-params" class="headerlink" title="7. params"></a>7. params</h1><p>在 C# 中，<code>params</code> 关键字用于允许方法接受可变数量的参数。这使得可以将多个参数作为数组传递给方法，而无需明确地创建一个数组。这在需要处理不确定数量的参数时非常方便。</p><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>以下是一个使用 <code>params</code> 的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用带有 params 参数的方法</span><br>        PrintNumbers(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        PrintNumbers(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        <span class="hljs-comment">// 优先调用非可变参数的函数</span><br>        PrintNumbers(); <span class="hljs-comment">// 空</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;空&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 这里static不能省略，static的Main不能调用非static函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintNumbers</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> <span class="hljs-built_in">int</span>[] numbers</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Numbers received:&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.WriteLine(number);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li>在这个示例中，<code>PrintNumbers</code> 方法可以接受任意数量的整数作为参数。</li><li><code>params</code> 参数必须是方法参数列表中的最后一个参数。</li><li>可以在调用 <code>PrintNumbers</code> 方法时传入任意数量的整数，包括零个。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 <code>params</code> 时，方法可以接收一个数组作为参数，或者可以接收单个值而不需要手动创建数组。</li><li>方法内部会将所有传入的参数封装为一个数组。</li><li>可变参数可以作为重载的条件，但优先调用非可变参数的函数</li></ul><h1 id="8-C-的结构体和C-结构体区别"><a href="#8-C-的结构体和C-结构体区别" class="headerlink" title="8. C++的结构体和C#结构体区别"></a>8. C++的结构体和C#结构体区别</h1><p>C++ 中的结构体和 C# 中的结构体有许多相似之处，但也有一些重要的区别。以下是对这两种语言中结构体的比较，涵盖定义、特性、构造函数、继承、访问控制等方面。</p><h3 id="C-中的结构体"><a href="#C-中的结构体" class="headerlink" title="C++ 中的结构体"></a>C++ 中的结构体</h3><ol><li><strong>定义</strong>：<ul><li>使用 <code>struct</code> 关键字定义结构体，可以包含成员变量和成员函数。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Point(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>访问控制</strong>：<ul><li>默认情况下，C++ 中结构体的成员是 <code>public</code>，可以从外部访问。</li></ul></li><li><strong>构造函数和析构函数</strong>：<ul><li>C++ 结构体可以有构造函数和析构函数，用于初始化和清理资源。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xCoord, <span class="hljs-type">int</span> yCoord) : <span class="hljs-built_in">x</span>(xCoord), <span class="hljs-built_in">y</span>(yCoord) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br>    ~<span class="hljs-built_in">Point</span>() &#123;&#125; <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>继承和多态</strong>：<ul><li>C++ 中的结构体支持继承和多态，结构体可以继承自其他结构体或类。</li></ul></li><li><strong>存储方式</strong>：<ul><li>C++ 中的结构体通常在栈上分配，但也可以通过指针在堆上动态分配。</li></ul></li><li>其他<ul><li>变量的定义不能是自己的结构体</li></ul></li></ol><h3 id="C-中的结构体-1"><a href="#C-中的结构体-1" class="headerlink" title="C# 中的结构体"></a>C# 中的结构体</h3><ul><li>结构体可以继承接口interface</li></ul><ol><li><strong>定义</strong>：<ul><li>使用 <code>struct</code> 关键字定义结构体。结构体是值类型，不能继承自其他结构体或类，但可以实现接口。</li></ul></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> xCoord, <span class="hljs-built_in">int</span> yCoord</span>) <span class="hljs-comment">// 可以有参数化构造函数</span></span><br>    &#123;<br>        x = xCoord;<br>        y = yCoord;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Point(<span class="hljs-subst">&#123;x&#125;</span>, <span class="hljs-subst">&#123;y&#125;</span>)&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>访问控制</strong>：<ul><li>C# 中结构体的成员默认是 <code>private</code>，需要显式声明为 <code>public</code> 才能从外部访问。</li></ul></li><li><strong>构造函数</strong>：<ul><li>C# 结构体可以有参数化构造函数，但不能有无参数的构造函数。</li></ul></li><li><strong>继承</strong>：<ul><li>C# 中的结构体不能继承其他结构体或类，但可以实现接口。</li></ul></li><li><strong>存储方式</strong>：<ul><li>C# 中的结构体是值类型，存储在栈上，而引用类型（如类）则存储在堆上。</li></ul></li><li>其他<ul><li>变量的定义不能是自己的结构体</li><li>结构体中的变量不能直接初始化，否则初始化后，调用默认构造函数，之前的直接初始化还是没用</li></ul></li></ol><h3 id="主要区别总结"><a href="#主要区别总结" class="headerlink" title="主要区别总结"></a>主要区别总结</h3><table><thead><tr><th>特性</th><th>C++ 结构体</th><th>C# 结构体</th></tr></thead><tbody><tr><td>定义</td><td>使用<code>struct</code> 关键字</td><td>使用<code>struct</code> 关键字</td></tr><tr><td>默认访问修饰符</td><td><code>public</code></td><td><code>private</code></td></tr><tr><td>构造函数</td><td>可以有参数化和无参数构造函数</td><td>可以有参数化构造函数，不能有无参数构造函数</td></tr><tr><td>继承</td><td>支持继承和多态</td><td>不支持继承，但可以实现接口</td></tr><tr><td>存储方式</td><td>通常在栈上，支持动态分配</td><td>是值类型，通常在栈上</td></tr><tr><td>成员函数</td><td>可以有成员函数</td><td>可以有方法</td></tr><tr><td>其他</td><td>变量的定义不能是自己的结构体，最后有一个分号</td><td>变量的定义不能是自己的结构体，结构体中的变量不能直接初始化</td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="C-结构体示例"><a href="#C-结构体示例" class="headerlink" title="C++ 结构体示例"></a>C++ 结构体示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xCoord, <span class="hljs-type">int</span> yCoord) : <span class="hljs-built_in">x</span>(xCoord), <span class="hljs-built_in">y</span>(yCoord) &#123;&#125; <span class="hljs-comment">// 构造函数</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Point(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>; <span class="hljs-comment">// 创建结构体实例</span><br>    p.<span class="hljs-built_in">display</span>();   <span class="hljs-comment">// 输出: Point(1, 2)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="C-结构体示例-1"><a href="#C-结构体示例-1" class="headerlink" title="C# 结构体示例"></a>C# 结构体示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> y;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> xCoord, <span class="hljs-built_in">int</span> yCoord</span>) <span class="hljs-comment">// 构造函数</span></span><br>    &#123;<br>        x = xCoord;<br>        y = yCoord;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Point(<span class="hljs-subst">&#123;x&#125;</span>, <span class="hljs-subst">&#123;y&#125;</span>)&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Point p = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 创建结构体实例</span><br>        p.Display(); <span class="hljs-comment">// 输出: Point(1, 2)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-默认值"><a href="#9-默认值" class="headerlink" title="9. 默认值"></a>9. 默认值</h1><ul><li>数字类型<ul><li>默认值为0</li></ul></li><li>bool<ul><li>默认值为false</li></ul></li><li>引用类型<ul><li>默认值为null</li></ul></li><li>查看默认值<ul><li>default(数据类型)</li><li>default(int)</li></ul></li></ul><h1 id="10-class"><a href="#10-class" class="headerlink" title="10. class"></a>10. class</h1><p>在 C# 中，类（<code>class</code>）是用于创建对象的模板，它封装了数据和行为。类可以包含字段（成员变量）、属性、方法和事件。以下是对 C# 中类的基本概念、特性和示例的详细介绍：</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>定义</strong>：类是自定义数据类型的蓝图，可以包含状态（字段）和行为（方法）。</li><li><strong>实例化</strong>：通过类创建对象实例，每个实例都可以独立地持有状态。</li></ul><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ol><li><strong>封装</strong>：<ul><li>类可以将数据和方法组合在一起，通过访问修饰符（如 <code>public</code>、<code>private</code>、<code>protected</code>）来控制对类成员的访问。</li></ul></li><li><strong>继承</strong>：<ul><li>类可以通过继承从其他类派生，复用代码并创建层次结构。</li><li>子类可以重写父类的方法，实现多态性。</li></ul></li><li><strong>多态性</strong>：<ul><li>通过虚方法（<code>virtual</code>）和重写方法（<code>override</code>），可以实现不同类对同一方法的不同实现。</li></ul></li><li><strong>抽象</strong>：<ul><li>抽象类（<code>abstract class</code>）可以定义一组方法，但不能直接实例化。</li></ul></li><li><strong>接口</strong>：<ul><li>接口（<code>interface</code>）定义了一组方法，但不实现它们。类可以实现多个接口。</li></ul></li></ol><ul><li>不能够将方法的声明和定义分离，必须放在一起。当然，抽象类和接口可以单独声明函数，然后继承的时候再重写</li></ul><h3 id="类的定义和使用示例"><a href="#类的定义和使用示例" class="headerlink" title="类的定义和使用示例"></a>类的定义和使用示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 定义一个简单的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><br>&#123;<br>    <span class="hljs-comment">// 字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> make;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> model;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> year;<br><br>    <span class="hljs-comment">// 属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Make<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> make; &#125;<br>        <span class="hljs-keyword">set</span> &#123; make = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Model<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> model; &#125;<br>        <span class="hljs-keyword">set</span> &#123; model = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Year<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> year; &#125;<br>        <span class="hljs-keyword">set</span> &#123; year = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> make, <span class="hljs-built_in">string</span> model, <span class="hljs-built_in">int</span> year</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.make = make;<br>        <span class="hljs-keyword">this</span>.model = model;<br>        <span class="hljs-keyword">this</span>.year = year;<br>    &#125;<br><br>    <span class="hljs-comment">// 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayInfo</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Car Info: <span class="hljs-subst">&#123;Year&#125;</span> <span class="hljs-subst">&#123;Make&#125;</span> <span class="hljs-subst">&#123;Model&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建 Car 类的实例</span><br>        Car myCar = <span class="hljs-keyword">new</span> Car(<span class="hljs-string">&quot;Toyota&quot;</span>, <span class="hljs-string">&quot;Camry&quot;</span>, <span class="hljs-number">2021</span>);<br>        myCar.DisplayInfo(); <span class="hljs-comment">// 输出: Car Info: 2021 Toyota Camry</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重要概念说明"><a href="#重要概念说明" class="headerlink" title="重要概念说明"></a>重要概念说明</h3><ul><li><strong>构造函数</strong>：<ul><li>特殊方法，在创建对象时被调用。可以用于初始化对象的状态。</li></ul></li><li><strong>析构函数</strong>：<ul><li>用于清理资源，类在不再需要时被销毁时调用（在 C# 中，通常使用 <code>IDisposable</code> 接口和 <code>using</code> 语句进行资源管理）。</li></ul></li><li><strong>静态成员</strong>：<ul><li>使用 <code>static</code> 修饰符定义的成员属于类本身，而不是类的实例。</li></ul></li></ul><h3 id="静态成员示例"><a href="#静态成员示例" class="headerlink" title="静态成员示例"></a>静态成员示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathUtility</span><br>&#123;<br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用静态方法</span><br>        <span class="hljs-built_in">int</span> result = MathUtility.Add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;Result: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Result: 15</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数，析构函数示例"><a href="#构造函数，析构函数示例" class="headerlink" title="构造函数，析构函数示例"></a>构造函数，析构函数示例</h3><ul><li>~MyClass() 是终结器（finalizer 或 Finalize 方法），不是析构方法。语义上和析构接近的是 Dispose 方法。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-comment">// 字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-comment">// 无参构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>        name = <span class="hljs-string">&quot;Default Name&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;无参构造函数被调用: &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> newName</span>)</span><br>    &#123;<br>        name = newName;<br>        Console.WriteLine(<span class="hljs-string">&quot;带参数的构造函数被调用: &quot;</span> + name);<br>    &#125;<br><br>    <span class="hljs-comment">// 终结器（finalizer 或 Finalize 方法）</span><br>    ~MyClass()<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;析构函数被调用，清理资源...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用无参构造函数创建对象</span><br>        MyClass obj1 = <span class="hljs-keyword">new</span> MyClass();<br><br>        <span class="hljs-comment">// 使用带参数的构造函数创建对象</span><br>        MyClass obj2 = <span class="hljs-keyword">new</span> MyClass(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br>        <span class="hljs-comment">// 程序结束时，析构函数会自动被调用</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 无参构造函数被调用: Default Name </span><br><span class="hljs-comment">// 带参数的构造函数被调用: Hello, World! </span><br><span class="hljs-comment">// =====析构函数不一定会调用，不用管下面的</span><br><span class="hljs-comment">// 析构函数被调用，清理资源... </span><br><span class="hljs-comment">// 析构函数被调用，清理资源...</span><br></code></pre></td></tr></table></figure><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><table><thead><tr><th>访问修饰符</th><th>访问范围</th></tr></thead><tbody><tr><td><code>public</code></td><td>可以在任何地方访问</td></tr><tr><td><code>private</code></td><td>只能在定义它的类内部访问(默认)</td></tr><tr><td><code>protected</code></td><td>可以在定义它的类及其派生类中访问</td></tr><tr><td><code>internal</code></td><td>可以在同一程序集内访问</td></tr><tr><td><code>protected internal</code></td><td>可以在同一程序集或派生类中访问</td></tr></tbody></table><h3 id="C-构造函数特殊写法，通过this重用构造函数代码"><a href="#C-构造函数特殊写法，通过this重用构造函数代码" class="headerlink" title="C#构造函数特殊写法，通过this重用构造函数代码"></a>C#构造函数特殊写法，通过this重用构造函数代码</h3><p>在 C# 中，可以通过使用 <code>this</code> 关键字在一个构造函数内部调用另一个构造函数，以重用构造函数的代码。这种写法被称为构造函数重载或构造函数链。它允许你在不同的构造函数中共享初始化逻辑，从而减少代码重复。</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>以下是一个示例，展示了如何通过 <code>this</code> 关键字在 C# 中重用构造函数代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 主构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 另一个构造函数，通过 this 关键字调用主构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>) : <span class="hljs-title">this</span>(<span class="hljs-params">name, <span class="hljs-number">0</span></span>) <span class="hljs-comment">// 默认年龄设为 0</span></span><br>    &#123;<br>        <span class="hljs-comment">// 这里可以添加其他初始化逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 另一个构造函数，通过 this 关键字调用主构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>() : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-string">&quot;Unknown&quot;</span>, <span class="hljs-number">0</span></span>) <span class="hljs-comment">// 默认姓名设为 &quot;Unknown&quot;，年龄为 0</span></span><br>    &#123;<br>        <span class="hljs-comment">// 这里可以添加其他初始化逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p1.Name&#125;</span>, <span class="hljs-subst">&#123;p1.Age&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Alice, 30</span><br><br>        Person p2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Bob&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p2.Name&#125;</span>, <span class="hljs-subst">&#123;p2.Age&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Bob, 0</span><br><br>        Person p3 = <span class="hljs-keyword">new</span> Person();<br>        Console.WriteLine(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;p3.Name&#125;</span>, <span class="hljs-subst">&#123;p3.Age&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: Unknown, 0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><strong>主构造函数</strong>：<code>Person(string name, int age)</code> 是主要的构造函数，用于初始化 <code>Name</code> 和 <code>Age</code> 属性。</li><li><strong>重载构造函数</strong>：<ul><li><code>Person(string name)</code> 通过 <code>: this(name, 0)</code> 调用主构造函数，设定默认的 <code>Age</code> 为 <code>0</code>。</li><li><code>Person()</code> 通过 <code>: this(&quot;Unknown&quot;, 0)</code> 调用主构造函数，设定默认的 <code>Name</code> 为 <code>&quot;Unknown&quot;</code>，<code>Age</code> 为 <code>0</code>。</li></ul></li></ol><h1 id="11-类与结构体区别（C-）"><a href="#11-类与结构体区别（C-）" class="headerlink" title="11. 类与结构体区别（C#）"></a>11. 类与结构体区别（C#）</h1><p>在 C# 中，类（<code>class</code>）和结构体（<code>struct</code>）都是用于封装数据和行为的复合数据类型，但它们在多个方面存在显著的区别。以下是它们的主要区别：</p><h3 id="主要区别-2"><a href="#主要区别-2" class="headerlink" title="主要区别"></a>主要区别</h3><table><thead><tr><th>特性</th><th>类 (Class)</th><th>结构体 (Struct)</th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>引用类型</td><td>值类型</td></tr><tr><td><strong>存储方式</strong></td><td>存储在堆上</td><td>存储在栈上</td></tr><tr><td><strong>继承</strong></td><td>支持继承</td><td>不支持继承</td></tr><tr><td><strong>构造函数</strong></td><td>可以有无参数和有参数构造函数</td><td>只能有参数构造函数，不能有无参数构造函数</td></tr><tr><td><strong>默认构造函数</strong></td><td>有默认构造函数</td><td>没有默认构造函数，编译器自动提供一个隐式的默认构造函数，该构造函数会将结构体的所有字段初始化为其类型的默认值（如<code>0</code>、<code>false</code>、<code>null</code> 等）</td></tr><tr><td><strong>访问修饰符</strong></td><td>默认是<code>private</code></td><td>默认是<code>private</code></td></tr><tr><td><strong>接口实现</strong></td><td>可以实现接口</td><td>可以实现接口</td></tr><tr><td><strong>实例化</strong></td><td>通过<code>new</code> 创建</td><td>通过<code>new</code> 创建</td></tr><tr><td><strong>赋值行为</strong></td><td>赋值时复制引用</td><td>赋值时复制值</td></tr><tr><td><strong>内存管理</strong></td><td>垃圾回收（GC）管理</td><td>垃圾回收（GC）管理</td></tr><tr><td><strong>性能</strong></td><td>对于小对象，性能开销较大</td><td>对于小对象，性能开销较小</td></tr></tbody></table><h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ol><li><strong>类型</strong>：<ul><li><strong>类</strong>是引用类型，意味着它们的实例在内存中是通过引用来访问的。</li><li><strong>结构体</strong>是值类型，意味着它们的实例直接包含数据。</li></ul></li><li><strong>存储方式</strong>：<ul><li>类的对象存储在堆上，结构体的实例通常存储在栈上（如果是局部变量），因此结构体在内存分配和释放上更加高效。</li></ul></li><li><strong>继承</strong>：<ul><li>类支持继承，可以派生出子类。结构体不支持继承，因此不能从其他结构体或类继承。</li></ul></li><li><strong>构造函数</strong>：<ul><li>类可以有无参数构造函数和有参数构造函数，而结构体只能有有参数构造函数，不能有无参数构造函数。结构体会自动提供一个默认构造函数，该构造函数将所有字段设置为其默认值。</li><li>类如果声明了有参构造函数，默认的无参构造函数会消失；结构体声明有参构造函数后，无参构造仍然存在</li></ul></li><li><strong>赋值行为</strong>：<ul><li>当类的对象被赋值给另一个变量时，实际上是复制了引用，而不是对象本身。因此，修改一个对象会影响所有引用它的变量。</li><li>结构体的赋值操作会复制整个数据，因此修改一个结构体不会影响另一个结构体的值。</li></ul></li><li>访问修饰符:<ul><li>结构体成员不可以用protected访问修饰符，类可以</li></ul></li><li>初始值</li></ol><ul><li>结构体成员变量不能指定初始值，类可以</li><li>但结构体需要在构造函数中初始化所有成员变量，类随意</li></ul><ol start="8"><li>析构函数（指终结器）</li></ol><ul><li>结构体不能声明析构函数，类可以</li></ul><ol start="9"><li>static修饰</li></ol><ul><li>结构体不能够被静态static修饰（不存在静态结构体），类可以</li></ul><ol start="10"><li>嵌套包含</li></ol><ul><li>结构体不能在自己内部声明和自己一样的结构体变量，类可以</li></ul><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="类的示例"><a href="#类的示例" class="headerlink" title="类的示例"></a>类的示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>) <span class="hljs-comment">// 构造函数</span></span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        Person person2 = person1; <span class="hljs-comment">// 复制引用</span><br>        person2.Name = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 修改 person2 的 Name</span><br><br>        Console.WriteLine(person1.Name); <span class="hljs-comment">// 输出: Bob</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结构体的示例"><a href="#结构体的示例" class="headerlink" title="结构体的示例"></a>结构体的示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>) <span class="hljs-comment">// 构造函数</span></span><br>    &#123;<br>        Name = name;<br>        Age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>        Person person2 = person1; <span class="hljs-comment">// 复制引用</span><br>        person2.Name = <span class="hljs-string">&quot;Bob&quot;</span>; <span class="hljs-comment">// 修改 person2 的 Name</span><br><br>        Console.WriteLine(person1.Name); <span class="hljs-comment">// 输出: Bob</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如何选择结构体和类"><a href="#如何选择结构体和类" class="headerlink" title="如何选择结构体和类"></a>如何选择结构体和类</h3><ul><li>想要用继承和多态时，选择类，比如玩家，怪物等</li><li>对象是数据集合时，优先考虑结构体，比如位置，坐标等</li><li>从值类型和引用类型赋值时区别上考虑，如果经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着改变时，使用结构体，比如坐标，向量，旋转等</li></ul><h1 id="12-C-垃圾回收机制"><a href="#12-C-垃圾回收机制" class="headerlink" title="12. C#垃圾回收机制"></a>12. C#垃圾回收机制</h1><p>C#的垃圾回收机制（Garbage Collection，简称GC）是一种自动内存管理机制，用于释放不再使用的对象和回收内存资源，从而避免手动管理内存。它在.NET框架中由CLR（Common Language Runtime）负责执行，确保应用程序在运行期间高效地使用内存。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li><strong>自动内存管理</strong>：不需要开发人员手动释放对象的内存，GC会自动检测并释放不再使用的对象。</li><li><strong>内存压缩</strong>：GC不仅会回收无用的对象，还会对内存进行压缩，把存活的对象移动到内存的开头，减少碎片。</li><li><strong>分代回收</strong>：采用分代（Generational）回收机制，根据对象的生命周期将内存划分为不同的代。</li></ol><h3 id="分代回收机制"><a href="#分代回收机制" class="headerlink" title="分代回收机制"></a>分代回收机制</h3><p>GC将托管堆中的对象分为三代：</p><ul><li><strong>第0代（Gen 0）</strong>：短期对象，如临时变量。GC最频繁地回收这部分对象。</li><li><strong>第1代（Gen 1）</strong>：较长时间的对象或从Gen 0晋升的对象。适用于中等寿命的对象。</li><li><strong>第2代（Gen 2）</strong>：长期对象或从Gen 1晋升的对象，如全局静态变量。GC最不频繁地回收这部分对象。</li></ul><p>在进行垃圾回收时，GC会优先处理Gen 0，如果清理不够再继续回收Gen 1和Gen 2。这样可以减少不必要的回收操作，提升性能。</p><h3 id="晋升的规则"><a href="#晋升的规则" class="headerlink" title="晋升的规则"></a>晋升的规则</h3><p>对象的晋升主要发生在垃圾回收的过程中，规则如下：</p><ol><li><p><strong>第0代（Gen 0）到第1代（Gen 1）的晋升</strong>：</p><ul><li>当第0代进行垃圾回收时，如果某个对象存活（即仍被引用），则这个对象将晋升到第1代。</li><li>如果一个对象在Gen 0的垃圾回收后依然存活，它通常被认为是一个较为持久的对象，因此被晋升到Gen 1，减少它在以后的垃圾回收中被频繁扫描的次数。</li></ul></li><li><p><strong>第1代（Gen 1）到第2代（Gen 2）的晋升</strong>：</p><ul><li>当第1代进行垃圾回收时，仍然存活的Gen 1对象将被晋升到Gen 2。</li><li>Gen 2被认为是“老年代”，也就是说，这些对象的生命周期较长，可能会存活很长时间。因此，GC会对Gen 2对象进行更少的回收操作，以减少垃圾回收的开销。</li></ul></li><li><p><strong>第2代（Gen 2）对象的处理</strong>：</p><ul><li>Gen 2的对象在垃圾回收后仍然存活，不会再晋升，因为Gen 2已经是最高代。</li></ul></li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><strong>标记阶段</strong>：GC扫描所有的对象，标记出哪些是存活的，哪些是不再使用的。</li><li><strong>回收阶段</strong>：对不再使用的对象进行回收，释放它们的内存。</li><li><strong>压缩阶段</strong>：把存活的对象移动到内存的开头，减少内存碎片，并更新对象引用。</li></ol><h3 id="什么时候进行垃圾回收？"><a href="#什么时候进行垃圾回收？" class="headerlink" title="什么时候进行垃圾回收？"></a>什么时候进行垃圾回收？</h3><ul><li>内存不足时。</li><li>分配了大量对象，Gen 0空间不足。</li><li>显式调用<code>GC.Collect()</code>方法（不建议频繁使用）。</li></ul><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建大量对象，强制触发GC</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">string</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1000</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 手动调用GC（不推荐）</span><br>        GC.Collect();<br>        Console.WriteLine(<span class="hljs-string">&quot;手动垃圾回收完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="需要注意的事项"><a href="#需要注意的事项" class="headerlink" title="需要注意的事项"></a>需要注意的事项</h3><ol><li><strong>GC.Collect()的使用</strong>：尽量避免手动调用GC，因为GC会自动管理内存。手动调用会导致性能下降。</li><li><strong>非托管资源的清理</strong>：对于非托管资源（如文件句柄、数据库连接等），需要实现<code>IDisposable</code>接口，并在<code>Dispose</code>方法中释放资源。</li><li><strong>Finalize和Dispose</strong>：实现<code>Dispose</code>方法或使用<code>using</code>语句来清理资源，避免依赖GC进行非托管资源的回收。<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/finalizers">GC终结器性能看这个，</a>不过Finalize还是可以用来释放非托管资源，如文件句柄、数据库连接等。但还是最好用IDisposable接口来实现。</li><li>析构函数（也称为终结器）只有在垃圾回收器（GC）回收对象时才会被调用</li></ol><h3 id="实现IDisposable接口来清理非托管资源的示例"><a href="#实现IDisposable接口来清理非托管资源的示例" class="headerlink" title="实现IDisposable接口来清理非托管资源的示例"></a>实现<code>IDisposable</code>接口来清理非托管资源的示例</h3><p>示例将展示如何使用<code>Dispose</code>方法和析构函数（<code>Finalize</code>）来处理非托管资源的清理</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceHolder</span> : <span class="hljs-title">IDisposable</span><br>&#123;<br>    <span class="hljs-comment">// 模拟的非托管资源</span><br>    <span class="hljs-keyword">private</span> IntPtr unmanagedResource;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> disposed = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 用来跟踪对象是否已被释放</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ResourceHolder</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 分配非托管资源</span><br>        unmanagedResource = <span class="hljs-keyword">new</span> IntPtr(<span class="hljs-number">123</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;ResourceHolder: 非托管资源已分配.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现IDisposable接口的Dispose方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>    &#123;<br>        Dispose(<span class="hljs-literal">true</span>);<br>        GC.SuppressFinalize(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 防止析构函数重复释放资源</span><br>    &#125;<br><br>    <span class="hljs-comment">// 受保护的Dispose方法，真正的资源释放逻辑在这里执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> disposing</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (!disposed)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (disposing)<br>            &#123;<br>                <span class="hljs-comment">// 释放托管资源（如果有）</span><br>                Console.WriteLine(<span class="hljs-string">&quot;ResourceHolder: 释放托管资源.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// 释放非托管资源</span><br>            <span class="hljs-keyword">if</span> (unmanagedResource != IntPtr.Zero)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;ResourceHolder: 释放非托管资源.&quot;</span>);<br>                unmanagedResource = IntPtr.Zero;<br>            &#125;<br><br>            disposed = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数（Finalize），在Dispose没有被调用时释放资源，确保我们只释放非托管资源。</span><br>    ~ResourceHolder()<br>    &#123;<br>        Dispose(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">using</span> (ResourceHolder resource = <span class="hljs-keyword">new</span> ResourceHolder())<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;使用ResourceHolder对象.&quot;</span>);<br>        &#125; <span class="hljs-comment">// using语句结束后自动调用Dispose方法</span><br><br>        Console.WriteLine(<span class="hljs-string">&quot;程序结束.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ResourceHolder: 非托管资源已分配.</span><br><span class="hljs-comment">// 使用ResourceHolder对象.</span><br><span class="hljs-comment">// ResourceHolder: 释放托管资源.</span><br><span class="hljs-comment">// ResourceHolder: 释放非托管资源.</span><br><span class="hljs-comment">// 程序结束.</span><br></code></pre></td></tr></table></figure><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><ol><li><strong><code>IDisposable</code>接口</strong>：<code>ResourceHolder</code>类实现了<code>IDisposable</code>接口，提供<code>Dispose</code>方法来释放资源。</li><li><strong><code>Dispose</code>方法</strong>：实现<code>Dispose</code>方法，用于释放托管和非托管资源。调用<code>GC.SuppressFinalize(this)</code>避免在垃圾回收时调用析构函数。</li><li><strong>析构函数（<code>Finalize</code>）</strong>：析构函数用于在<code>Dispose</code>方法未被显式调用时释放非托管资源。</li><li><strong><code>using</code>语句</strong>：<code>using</code>语句会在代码块结束时自动调用<code>Dispose</code>方法，确保资源被及时释放。</li></ol><h1 id="13-代码解析using-ResourceHolder-resource-new-ResourceHolder-Console-WriteLine-“使用ResourceHolder对象-”"><a href="#13-代码解析using-ResourceHolder-resource-new-ResourceHolder-Console-WriteLine-“使用ResourceHolder对象-”" class="headerlink" title="13. 代码解析using (ResourceHolder resource &#x3D; new ResourceHolder()) { Console.WriteLine(“使用ResourceHolder对象.”); }"></a>13. 代码解析using (ResourceHolder resource &#x3D; new ResourceHolder()) { Console.WriteLine(“使用ResourceHolder对象.”); }</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> (ResourceHolder resource = <span class="hljs-keyword">new</span> ResourceHolder())<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;使用ResourceHolder对象.&quot;</span>);<br>&#125; <span class="hljs-comment">// using语句结束后自动调用Dispose方法</span><br></code></pre></td></tr></table></figure><h4 id="1-ResourceHolder-类"><a href="#1-ResourceHolder-类" class="headerlink" title="1. ResourceHolder 类"></a>1. <code>ResourceHolder</code> 类</h4><p>假设 <code>ResourceHolder</code> 是一个实现了 <code>IDisposable</code> 接口的类。<code>IDisposable</code> 接口定义了一个 <code>Dispose</code> 方法，用于显式地释放非托管资源。实现 <code>IDisposable</code> 是处理非托管资源或需要手动释放的资源（如文件句柄、数据库连接等）的一种常见做法。</p><h4 id="2-using-语句的作用"><a href="#2-using-语句的作用" class="headerlink" title="2. using 语句的作用"></a>2. <code>using</code> 语句的作用</h4><ul><li><code>using</code> 语句可以自动管理实现了 <code>IDisposable</code> 接口的对象的生命周期。</li><li>在进入 <code>using</code> 块时，会创建一个 <code>ResourceHolder</code> 对象并将其分配给 <code>resource</code> 变量。</li><li>当 <code>using</code> 语句结束时，无论是否发生异常，都会自动调用 <code>resource.Dispose()</code> 方法，以确保资源被正确释放。</li></ul><h4 id="3-代码的执行流程"><a href="#3-代码的执行流程" class="headerlink" title="3. 代码的执行流程"></a>3. 代码的执行流程</h4><ul><li>创建 <code>ResourceHolder</code> 对象，并分配给 <code>resource</code>。</li><li>执行 <code>using</code> 块内的代码，输出 “使用ResourceHolder对象.”</li><li>当 <code>using</code> 块结束时，<code>Dispose</code> 方法被自动调用，释放资源。</li></ul><p>等价于下面的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ResourceHolder resource = <span class="hljs-keyword">new</span> ResourceHolder();<br><span class="hljs-keyword">try</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;使用ResourceHolder对象.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">finally</span><br>&#123;<br>    <span class="hljs-comment">// 确保 Dispose 方法在 using 块结束时被调用</span><br>    <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>)<br>    &#123;<br>        resource.Dispose();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IDisposable-接口和-Dispose-方法的作用"><a href="#IDisposable-接口和-Dispose-方法的作用" class="headerlink" title="IDisposable 接口和 Dispose 方法的作用"></a><code>IDisposable</code> 接口和 <code>Dispose</code> 方法的作用</h3><p><code>IDisposable</code> 接口定义了一个 <code>Dispose</code> 方法，用于释放资源。典型的实现方式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ResourceHolder</span> : <span class="hljs-title">IDisposable</span><br>&#123;<br>    <span class="hljs-comment">// 实现 Dispose 方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Dispose</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 释放资源的代码，如关闭文件句柄或断开数据库连接</span><br>        Console.WriteLine(<span class="hljs-string">&quot;ResourceHolder 的 Dispose 方法被调用.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Dispose</code> 方法释放资源，而 <code>using</code> 语句确保在使用完对象后自动调用 <code>Dispose</code>。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><code>using</code> 语句用于自动管理实现了 <code>IDisposable</code> 接口的对象的生命周期，确保资源在使用后被正确释放。</li><li>在 <code>using</code> 块结束时，会自动调用 <code>Dispose</code> 方法，释放资源，避免内存泄漏或资源占用。</li></ul><h1 id="14-IntPtr解释"><a href="#14-IntPtr解释" class="headerlink" title="14. IntPtr解释"></a>14. IntPtr解释</h1><p><code>IntPtr</code> 是 C# 中表示指针或句柄的平台相关类型。它的主要用途是处理非托管资源、与操作系统交互时的指针或句柄、以及在托管代码和非托管代码之间传递指针。以下是 <code>IntPtr</code> 的几个关键点：</p><ol><li><strong>平台相关大小</strong>：<code>IntPtr</code> 的大小取决于当前运行的平台。在 32 位平台上，<code>IntPtr</code> 是 4 字节（32 位），而在 64 位平台上，它是 8 字节（64 位）。这使得它非常适合用来表示指针或句柄的大小。</li><li><strong>表示指针或句柄</strong>：<code>IntPtr</code> 通常用于存储指针（如内存地址）或操作系统资源的句柄（如窗口句柄、文件句柄）。它可以存储一个整数值，表示内存地址或某种非托管资源的标识符。</li><li><strong>用于非托管代码交互</strong>：在与非托管代码交互时（例如，通过 P&#x2F;Invoke 调用 Win32 API），<code>IntPtr</code> 常被用来表示指针参数。它可以与 C&#x2F;C++ 中的 <code>void*</code> 类型类似，适合用来传递内存地址。</li><li><strong>转换和比较</strong>：<code>IntPtr</code> 支持从整数类型（<code>int</code> 或 <code>long</code>）进行隐式或显式转换，也可以与整数进行比较或相互赋值。</li></ol><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><p>下面是一个使用 <code>IntPtr</code> 来表示一个非托管资源句柄的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 模拟一个非托管资源的句柄（假设资源的句柄值为123）</span><br>        IntPtr unmanagedResource = <span class="hljs-keyword">new</span> IntPtr(<span class="hljs-number">123</span>);<br><br>        <span class="hljs-comment">// 打印 IntPtr 的值</span><br>        Console.WriteLine(<span class="hljs-string">&quot;非托管资源句柄: &quot;</span> + unmanagedResource);<br><br>        <span class="hljs-comment">// 检查 IntPtr 是否为零</span><br>        <span class="hljs-keyword">if</span> (unmanagedResource != IntPtr.Zero)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;资源已分配.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;资源未分配.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 将 IntPtr 转换为 long 类型</span><br>        <span class="hljs-built_in">long</span> handleValue = unmanagedResource.ToInt64();<br>        Console.WriteLine(<span class="hljs-string">&quot;句柄的长整型值: &quot;</span> + handleValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">非托管资源句柄: 123</span><br>资源已分配.<br><span class="hljs-section">句柄的长整型值: 123</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>IntPtr</code> 被用来模拟表示一个非托管资源的句柄值，并可以进行检查和转换。通过使用 <code>IntPtr</code>，代码可以适应不同的平台（32 位或 64 位），确保指针或句柄的大小能够正确匹配。</p><h3 id="IntPtr-Zero的解释"><a href="#IntPtr-Zero的解释" class="headerlink" title="IntPtr.Zero的解释"></a>IntPtr.Zero的解释</h3><p><code>IntPtr.Zero</code> 是 .NET 中 <code>IntPtr</code> 结构的一个静态只读字段，表示一个空指针或指针值为零的情况。它的作用类似于 C&#x2F;C++ 中的 <code>NULL</code> 或 <code>nullptr</code>，用于表示一个未分配的指针或句柄。<code>IntPtr</code> 是一种平台相关的类型，用于存储指针或句柄的值。</p><h3 id="IntPtr-结构"><a href="#IntPtr-结构" class="headerlink" title="IntPtr 结构"></a><code>IntPtr</code> 结构</h3><ul><li><code>IntPtr</code> 是一个可以存储内存地址（指针）或操作系统句柄的平台无关类型。</li><li>它的大小是平台相关的：在 32 位系统上是 4 字节，在 64 位系统上是 8 字节。</li></ul><h3 id="IntPtr-Zero-的用途"><a href="#IntPtr-Zero-的用途" class="headerlink" title="IntPtr.Zero 的用途"></a><code>IntPtr.Zero</code> 的用途</h3><ul><li><code>IntPtr.Zero</code> 可以用来检查指针或句柄是否为空，例如在调用非托管代码或处理操作系统资源时，判断一个指针是否已经被分配。</li><li>作为默认值，表示未初始化的指针或句柄。</li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>在使用 P&#x2F;Invoke 或与非托管代码交互时，可以用 <code>IntPtr.Zero</code> 来表示空指针：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">IntPtr handle = IntPtr.Zero; <span class="hljs-comment">// 初始化为一个空指针</span><br><br><span class="hljs-comment">// 检查指针是否为空</span><br><span class="hljs-keyword">if</span> (handle == IntPtr.Zero)<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Handle 未被初始化.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Handle 已初始化.&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>IntPtr.Zero</code> 用来判断 <code>handle</code> 是否为未分配的空指针。</p><h3 id="句柄的解释"><a href="#句柄的解释" class="headerlink" title="句柄的解释"></a>句柄的解释</h3><p>在计算机编程中，<strong>句柄</strong>（Handle）是用于引用系统资源的一个抽象标识符。它可以看作是一个间接指向资源的指针，通过句柄可以对资源进行操作，而不需要直接访问资源的内存地址。句柄通常用于操作系统提供的资源管理，例如文件、内存、窗口、线程、数据库连接等。</p><h3 id="句柄的作用"><a href="#句柄的作用" class="headerlink" title="句柄的作用"></a>句柄的作用</h3><ul><li><strong>间接引用</strong>：句柄为资源提供了一个间接的访问方式，使得程序不需要知道资源的具体内存地址，只需使用句柄进行操作。</li><li><strong>资源管理</strong>：操作系统或库使用句柄来管理资源的分配和释放。句柄由操作系统分配，当资源不再需要时，程序员可以释放句柄来回收资源。</li><li><strong>类型安全</strong>：通过句柄访问资源可以防止程序直接操作资源的内存地址，提高了系统的安全性和稳定性。</li></ul><h3 id="常见的句柄类型"><a href="#常见的句柄类型" class="headerlink" title="常见的句柄类型"></a>常见的句柄类型</h3><ul><li><strong>文件句柄</strong>：用于打开和操作文件，如读取或写入文件数据。</li><li><strong>窗口句柄（HWND）</strong>：在图形用户界面编程中，用于标识窗口。</li><li><strong>进程或线程句柄</strong>：用于操作系统中标识进程或线程的标识符。</li><li><strong>数据库句柄</strong>：用于连接到数据库或执行查询。</li></ul><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><p>在 C# 中，使用句柄来操作系统资源，如文件句柄：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> (FileStream fileStream = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;example.txt&quot;</span>, FileMode.Open))<br>&#123;<br>    <span class="hljs-comment">// fileStream.SafeFileHandle 是一个文件句柄</span><br>    <span class="hljs-keyword">if</span> (!fileStream.SafeFileHandle.IsInvalid)<br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;文件句柄有效.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>fileStream.SafeFileHandle</code> 是文件句柄，用于管理文件资源。句柄让操作系统跟踪文件的状态，并在使用完毕后释放资源。</p><h1 id="15-类中的属性"><a href="#15-类中的属性" class="headerlink" title="15. 类中的属性"></a>15. 类中的属性</h1><p>在 C# 中，类的属性是用于封装字段（成员变量）并提供对这些字段的访问的机制。属性使得对类内部数据的访问更加安全和灵活，可以控制对字段的读取和写入。</p><h3 id="属性的基本定义"><a href="#属性的基本定义" class="headerlink" title="属性的基本定义"></a>属性的基本定义</h3><p>属性通常由两个部分组成：</p><ol><li><strong>get 访问器</strong>：用于获取属性的值。get必须有返回值</li><li><strong>set 访问器</strong>：用于设置属性的值。set可以不设置赋值</li></ol><p>以下是一个简单的示例，展示了如何在类中定义属性：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// 私有字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br><br>    <span class="hljs-comment">// 公共属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;   <span class="hljs-comment">// 获取name字段的值</span><br>        <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;  <span class="hljs-comment">// 设置name字段的值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> age; &#125;    <span class="hljs-comment">// 获取age字段的值</span><br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-comment">// 可以添加逻辑，例如确保年龄不能为负数</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">&quot;年龄不能为负数&quot;</span>);<br>            &#125;<br>            age = <span class="hljs-keyword">value</span>;         <span class="hljs-comment">// 设置age字段的值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用属性"><a href="#使用属性" class="headerlink" title="使用属性"></a>使用属性</h3><p>可以通过实例化类并直接访问属性来使用它们：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person();<br>        person.Name = <span class="hljs-string">&quot;Alice&quot;</span>; <span class="hljs-comment">// 设置属性值</span><br>        person.Age = <span class="hljs-number">30</span>;       <span class="hljs-comment">// 设置属性值</span><br><br>        Console.WriteLine(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;person.Name&#125;</span>, Age: <span class="hljs-subst">&#123;person.Age&#125;</span>&quot;</span>); <span class="hljs-comment">// 获取属性值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h3><p>C# 还提供了自动属性的功能，可以简化属性的定义，编译器会为这些属性创建一个私有的匿名字段。我们只需要使用Name或者Age获取或者修改值即可。下面是一个使用自动属性的例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span><br>&#123;<br>    <span class="hljs-comment">// 自动属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只读和只写属性"><a href="#只读和只写属性" class="headerlink" title="只读和只写属性"></a>只读和只写属性</h3><p>属性也可以设置为只读或只写：</p><ul><li><strong>只读属性</strong>：只有 <code>get</code> 访问器，没有 <code>set</code> 访问器，不能直接修改。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReadOnlyPerson</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReadOnlyPerson</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125; <span class="hljs-comment">// 只读属性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>只写属性</strong>：只有 <code>set</code> 访问器，没有 <code>get</code> 访问器，不能直接读取。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WriteOnlyPerson</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>    &#123;<br>        <span class="hljs-keyword">set</span> &#123; age = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 只写属性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="get，set的访问修饰符的规定"><a href="#get，set的访问修饰符的规定" class="headerlink" title="get，set的访问修饰符的规定"></a>get，set的访问修饰符的规定</h3><p>在 C# 中，属性的 <code>get</code> 和 <code>set</code> 访问修饰符可以单独定义，允许你对属性的读取和写入操作分别控制访问权限。这种灵活性使得你能够根据需要来限制对类成员的访问。</p><h3 id="访问修饰符-1"><a href="#访问修饰符-1" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><p>C# 提供了以下几种常用的访问修饰符：</p><ol><li><strong>public</strong>：可以被任何其他代码访问。</li><li><strong>private</strong>：只能在定义该成员的类内部访问。</li><li><strong>protected</strong>：只能在定义该成员的类及其子类中访问。</li><li><strong>internal</strong>：只能在同一程序集（项目）中访问。</li><li><strong>protected internal</strong>：可以在同一程序集或从其子类中访问。</li></ol><h3 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h3><p>以下是一些示例，展示了如何为 <code>get</code> 和 <code>set</code> 分别指定不同的访问修饰符：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name; <span class="hljs-comment">// 私有字段</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br><br>    <span class="hljs-comment">// 只读属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;  <span class="hljs-comment">// 公开的get方法</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;  <span class="hljs-comment">// 仅在类内部可设置</span><br>    &#125;<br><br>    <span class="hljs-comment">// 只写属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age<br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> age; &#125; <span class="hljs-comment">// 仅在类内部可读取</span><br>        <span class="hljs-comment">// 注释掉下面一行，会报错</span><br>        <span class="hljs-keyword">set</span> &#123; age = <span class="hljs-keyword">value</span>; &#125;  <span class="hljs-comment">// 公开的set方法</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span><br>    &#123;<br>        Name = name;  <span class="hljs-comment">// 通过公共set方法设置</span><br>        Age = age;    <span class="hljs-comment">// 通过公共set方法设置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>    <br>        <span class="hljs-comment">// 访问Name属性</span><br>        Console.WriteLine(person.Name); <span class="hljs-comment">// 公开的get方法可以访问</span><br><br>        <span class="hljs-comment">// 不能直接设置Name属性，因为set是私有的</span><br>        <span class="hljs-comment">// person.Name = &quot;Bob&quot;; // 这行代码会产生编译错误</span><br><br>        <span class="hljs-comment">// 访问和修改Age属性</span><br>        <span class="hljs-comment">// Console.WriteLine(person.Age); // 编译错误，因为get是私有的</span><br>        person.Age = <span class="hljs-number">35</span>; <span class="hljs-comment">// 公开的set方法可以访问</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问修饰符的规则"><a href="#访问修饰符的规则" class="headerlink" title="访问修饰符的规则"></a>访问修饰符的规则</h3><ul><li><p><strong>访问修饰符可以单独定义</strong>：<code>get</code> 和 <code>set</code> 访问修饰符可以不同。例如，<code>get</code> 可以是 <code>public</code>，而 <code>set</code> 可以是 <code>private</code>。</p></li><li><p><strong>当未指定访问修饰符时</strong>：如果没有明确指定 <code>get</code> 和 <code>set</code> 的访问修饰符，则默认情况下：</p><ul><li><code>get</code> 默认为 属性声明时的访问权限。</li><li><code>set</code> 默认为  属性声明时的访问权限（如果是自动属性，或类内部没有定义）。</li></ul></li><li><p><strong>构造函数和方法</strong>：构造函数和其他方法可以访问私有属性的 <code>set</code> 访问器，从而在对象创建时初始化值。</p></li><li><p>仅当属性或索引器同时具有 <code>set</code> 和 <code>get</code> 访问器时，才能使用访问器修饰符。 这种情况下，只允许对其中一个访问器使用修饰符。</p></li><li><p>访问器的可访问性级别必须比属性或索引器本身的可访问性级别具有更严格的限制。如果属性本身就是private，get和set均不可以使用访问修饰符。如果是public的属性，不可以对get或者set使用public，只能更严格</p></li></ul><h1 id="16-索引器"><a href="#16-索引器" class="headerlink" title="16. 索引器"></a>16. 索引器</h1><p>C#中的索引器是一种特殊的属性，允许对象像数组一样通过索引访问其元素。索引器使得类的实例能够使用“[]”语法来访问其内部数据，使得代码更加简洁和直观。索引器的定义通常涉及到 <code>this</code> 关键字，后面跟随一个或多个参数。</p><ul><li>索引器可以重载，中括号里面的参数不一样就可以</li><li>结构体也支持索引器</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>索引器的基本语法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 内部数组</span><br><br>    <span class="hljs-comment">// 定义索引器</span><br>    <span class="hljs-comment">// 访问修饰符 返回值 this[参数类型 参数名, 参数类型 参数名, ...]</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>    <span class="hljs-comment">// 内部书写和属性相同</span><br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[index]; &#125; <span class="hljs-comment">// 获取元素</span><br>        <span class="hljs-keyword">set</span> &#123; data[index] = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 设置元素</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass myClass = <span class="hljs-keyword">new</span> MyClass();<br>    <br>        <span class="hljs-comment">// 使用索引器设置元素</span><br>        myClass[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>        myClass[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br><br>        <span class="hljs-comment">// 使用索引器获取元素</span><br>        Console.WriteLine(myClass[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出: 10</span><br>        Console.WriteLine(myClass[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出: 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><p>以下是一个使用索引器的完整示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 内部数组</span><br><br>    <span class="hljs-comment">// 定义索引器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[index]; &#125; <span class="hljs-comment">// 获取元素</span><br>        <span class="hljs-keyword">set</span> &#123; data[index] = <span class="hljs-keyword">value</span>; &#125; <span class="hljs-comment">// 设置元素</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass myClass = <span class="hljs-keyword">new</span> MyClass();<br>    <br>        <span class="hljs-comment">// 使用索引器设置元素</span><br>        myClass[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>        myClass[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br><br>        <span class="hljs-comment">// 使用索引器获取元素</span><br>        Console.WriteLine(myClass[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出: 10</span><br>        Console.WriteLine(myClass[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出: 20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>简洁性</strong>：索引器提供了一种方便的方式来访问对象的内部数据，语法类似于数组的访问方式。</li><li><strong>可以重载</strong>：索引器可以有多个重载形式，以支持不同类型和数量的参数。</li><li><strong>访问修饰符</strong>：索引器的 <code>get</code> 和 <code>set</code> 访问修饰符可以独立设置，可以是 <code>public</code>、<code>private</code>、<code>protected</code> 等。</li><li><strong>类型安全</strong>：索引器可以返回任何类型，而不仅限于基本数据类型。</li></ol><h3 id="访问修饰符示例"><a href="#访问修饰符示例" class="headerlink" title="访问修饰符示例"></a>访问修饰符示例</h3><p>下面的示例演示了如何设置不同的访问修饰符：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-comment">// 只允许内部访问的索引器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[index]; &#125;<br>        <span class="hljs-keyword">set</span> &#123; data[index] = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 公开的索引器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">string</span> index]<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> data[<span class="hljs-built_in">int</span>.Parse(index)]; &#125;<br>        <span class="hljs-keyword">set</span> &#123; data[<span class="hljs-built_in">int</span>.Parse(index)] = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 公共方法可以通过私有索引器来间接访问数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetDataAt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; data.Length)<br>        &#123;<br>            <span class="hljs-keyword">this</span>[index] = <span class="hljs-keyword">value</span>;  <span class="hljs-comment">// 使用私有索引器设置值</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetDataAt</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; data.Length)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[index];  <span class="hljs-comment">// 使用私有索引器获取值</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Index out of bounds&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        MyCollection collection = <span class="hljs-keyword">new</span> MyCollection();<br><br>        <span class="hljs-comment">// 通过公共方法间接访问私有索引器</span><br>        collection.SetDataAt(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        collection.SetDataAt(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>);<br><br>        Console.WriteLine(collection.GetDataAt(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 输出 100</span><br>        Console.WriteLine(collection.GetDataAt(<span class="hljs-number">1</span>));  <span class="hljs-comment">// 输出 200</span><br>        Console.WriteLine(collection[<span class="hljs-string">&quot;0&quot;</span>]);  <span class="hljs-comment">// 输出 100</span><br>        Console.WriteLine(collection[<span class="hljs-string">&quot;1&quot;</span>]);  <span class="hljs-comment">// 输出 200</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><strong>越界检查</strong>：在 <code>get</code> 和 <code>set</code> 访问器中可以添加越界检查，以避免访问数组外的元素。</li><li><strong>性能</strong>：索引器与普通方法的性能基本相同，但使用索引器的代码通常更加简洁。</li><li><strong>适用性</strong>：索引器适用于需要通过索引访问集合或数组的场景，例如自定义集合类。</li></ul><p>索引器为C#提供了一种直观且强大的方式来操作类的内部数据，使得编写清晰易读的代码变得更加容易。</p><h1 id="17-static的使用"><a href="#17-static的使用" class="headerlink" title="17. static的使用"></a>17. static的使用</h1><p>在C#中，<code>static</code>关键字用于定义静态成员或静态类。静态成员属于类本身，而不是属于类的某个实例，因此可以在不创建类对象的情况下访问。<code>static</code>的主要用途包括定义静态字段、方法、属性、构造函数、类和操作符等。以下是C#中<code>static</code>的具体使用情况：</p><h3 id="1-静态字段（Static-Fields）"><a href="#1-静态字段（Static-Fields）" class="headerlink" title="1. 静态字段（Static Fields）"></a>1. 静态字段（Static Fields）</h3><p>静态字段在类级别定义，对于该类的所有实例共享同一个字段。可以通过类名来访问静态字段，而不需要创建对象实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态字段</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Counter</span>()</span><br>    &#123;<br>        Count++; <span class="hljs-comment">// 每创建一个实例，Count加1</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(Counter.Count); <span class="hljs-comment">// 输出: 0</span><br><br>        Counter c1 = <span class="hljs-keyword">new</span> Counter();<br>        Counter c2 = <span class="hljs-keyword">new</span> Counter();<br><br>        Console.WriteLine(Counter.Count); <span class="hljs-comment">// 输出: 2，因为创建了两个实例</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-静态方法（Static-Methods）"><a href="#2-静态方法（Static-Methods）" class="headerlink" title="2. 静态方法（Static Methods）"></a>2. 静态方法（Static Methods）</h3><ul><li>静态方法可以在没有创建对象实例的情况下被调用。静态方法中不能访问非静态成员，因为它们没有绑定到任何实例。静态方法属于类本身，而不是某个具体的实例对象。我记得C++中，还有一个角度是static是在编译阶段确定，而非static是在运行阶段确定，所以无法访问未定义的变量，C#也可以这么理解。</li><li>在 C# 中，静态方法无法访问非静态成员的原因与 C++ 类似。静态方法属于类本身，而非某个具体的对象，因此它没有 <code>this</code> 引用，因为 <code>this</code> 只在实例方法中才有意义。非静态成员需要特定的对象实例来调用，而静态方法在类的上下文中调用，无法使用 <code>this</code> 来访问非静态成员。</li><li>而非静态方法，是可以使用静态成员的</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections.Specialized;<br><span class="hljs-keyword">using</span> System.Runtime.CompilerServices;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathUtils</span><br>&#123;<br>    <span class="hljs-built_in">int</span> c = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>) <span class="hljs-comment">// 静态方法</span></span><br>    &#123;<br>        <span class="hljs-comment">// this.c // 报错</span><br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-keyword">this</span>.c);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> result = MathUtils.Add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 调用静态方法</span><br>        Console.WriteLine(result); <span class="hljs-comment">// 输出: 8</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-静态属性（Static-Properties）"><a href="#3-静态属性（Static-Properties）" class="headerlink" title="3. 静态属性（Static Properties）"></a>3. 静态属性（Static Properties）</h3><p>静态属性用于封装静态字段的访问，类似于静态字段，但通过<code>get</code>和<code>set</code>访问器来访问或修改值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Settings</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _volume = <span class="hljs-number">5</span>; <span class="hljs-comment">// 静态字段</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Volume <span class="hljs-comment">// 静态属性</span><br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _volume; &#125;<br>        <span class="hljs-keyword">set</span> &#123; _volume = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(Settings.Volume); <span class="hljs-comment">// 输出: 5</span><br>        Settings.Volume = <span class="hljs-number">10</span>;<br>        Console.WriteLine(Settings.Volume); <span class="hljs-comment">// 输出: 10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-静态构造函数（Static-Constructors）"><a href="#4-静态构造函数（Static-Constructors）" class="headerlink" title="4. 静态构造函数（Static Constructors）"></a>4. 静态构造函数（Static Constructors）</h3><p>静态构造函数用于初始化静态字段或执行只需要运行一次的操作。它在类的第一次使用之前自动调用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> LogFilePath;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Logger</span>() <span class="hljs-comment">// 静态构造函数，C++不允许静态构造函数，会报错</span></span><br>    &#123;<br>        LogFilePath = <span class="hljs-string">&quot;log.txt&quot;</span>;<br>        Console.WriteLine(<span class="hljs-string">&quot;静态构造函数被调用&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(Logger.LogFilePath); <span class="hljs-comment">// 输出: log.txt</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态构造函数的主要作用是在类的第一次使用之前自动执行一次，无论是否创建了该类的实例。它通常用于初始化静态字段或执行只需运行一次的操作。</p><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol><li><strong>只执行一次</strong>：静态构造函数只会在第一次访问类时自动调用一次，无论你创建了多少个实例。</li><li><strong>自动调用</strong>：你不需要显式调用静态构造函数。它会在类的静态成员或方法首次被访问时自动执行。</li><li><strong>实例化无关</strong>：即使没有实例化类，静态构造函数也会在类的静态成员被访问时调用。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>以下是一个 C# 中静态构造函数的示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> StaticValue;<br><br>    <span class="hljs-comment">// 静态构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        StaticValue = <span class="hljs-number">42</span>; <span class="hljs-comment">// 初始化静态字段，但只会被调用一次</span><br>        Console.WriteLine(<span class="hljs-string">&quot;静态构造函数被调用。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;实例构造函数被调用。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;访问静态成员之前。&quot;</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;StaticValue: &quot;</span> + Example.StaticValue); <span class="hljs-comment">// 触发静态构造函数</span><br>        Console.WriteLine(<span class="hljs-string">&quot;StaticValue: &quot;</span> + Example.StaticValue); <span class="hljs-comment">// 触发静态构造函数</span><br>        Console.WriteLine(<span class="hljs-string">&quot;访问静态成员之后。&quot;</span>);<br><br>        Example obj = <span class="hljs-keyword">new</span> Example(); <span class="hljs-comment">// 触发实例构造函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">访问静态成员之前。<br>静态构造函数被调用。<br><span class="hljs-section">StaticValue: 42</span><br><span class="hljs-section">StaticValue: 42</span><br>访问静态成员之后。<br>实例构造函数被调用。<br></code></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>在这个例子中，静态构造函数在访问 <code>StaticValue</code> 之前自动调用，而实例构造函数在创建 <code>Example</code> 类的实例时调用。这表明静态构造函数确实在类的实例化之前运行，即使没有创建实例。</p><h3 id="5-静态类（Static-Classes）"><a href="#5-静态类（Static-Classes）" class="headerlink" title="5. 静态类（Static Classes）"></a>5. 静态类（Static Classes）</h3><p>静态类只能包含静态成员，不能创建实例，也就是不能被new。它适用于只包含工具方法的类（如数学运算类）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utility</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Utility.PrintMessage(<span class="hljs-string">&quot;Hello, world!&quot;</span>); <span class="hljs-comment">// 调用静态类的方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-静态操作符（Static-Operators）"><a href="#6-静态操作符（Static-Operators）" class="headerlink" title="6. 静态操作符（Static Operators）"></a>6. 静态操作符（Static Operators）</h3><p>可以定义静态操作符重载，如重载<code>+</code>、<code>-</code>等操作符。它们也是类级别的操作，不需要类实例。其实和static没关系，就是需要这样用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector <span class="hljs-keyword">operator</span> +(Vector a, Vector b) <span class="hljs-comment">// 静态操作符</span><br>    <span class="hljs-comment">// 运算符重载必须是静态方法，因为运算符通常在两个操作数之间操作，不依赖于单个实例的状态</span><br>    <span class="hljs-comment">// 并且必须是public的</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector &#123; X = a.X + b.X, Y = a.Y + b.Y &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Vector v1 = <span class="hljs-keyword">new</span> Vector &#123; X = <span class="hljs-number">1</span>, Y = <span class="hljs-number">2</span> &#125;;<br>        Vector v2 = <span class="hljs-keyword">new</span> Vector &#123; X = <span class="hljs-number">3</span>, Y = <span class="hljs-number">4</span> &#125;;<br>        Vector result = v1 + v2;<br>        Console.WriteLine(<span class="hljs-string">$&quot;X: <span class="hljs-subst">&#123;result.X&#125;</span>, Y: <span class="hljs-subst">&#123;result.Y&#125;</span>&quot;</span>); <span class="hljs-comment">// 输出: X: 4, Y: 6</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-静态成员的特点"><a href="#7-静态成员的特点" class="headerlink" title="7. 静态成员的特点"></a>7. 静态成员的特点</h3><ul><li>静态成员只能通过类名访问，不能通过对象实例访问。</li><li>静态方法和字段在程序的整个生命周期中只会存在一个实例。</li><li>静态构造函数没有访问修饰符，不能有参数，只能定义一个。</li></ul><h1 id="18-C-中const和static的区别"><a href="#18-C-中const和static的区别" class="headerlink" title="18. C#中const和static的区别"></a>18. C#中const和static的区别</h1><p>在 C# 中，<code>const</code> 和 <code>static</code> 都与类的成员有关，但它们有不同的用途和特点。以下是它们的主要区别：</p><h3 id="1-定义与初始化"><a href="#1-定义与初始化" class="headerlink" title="1. 定义与初始化"></a>1. 定义与初始化</h3><ul><li><strong>const</strong>:<ul><li>用于定义常量，值在编译时确定，并且不可更改。（C++const也是编译期间确定）</li><li>必须在声明时初始化。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MaxValue = <span class="hljs-number">100</span>; <span class="hljs-comment">// 必须初始化</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>static</strong>:<ul><li>用于定义静态成员，属于类本身而不是类的实例。</li><li>可以在定义时或在类的静态构造函数中初始化。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Count; <span class="hljs-comment">// 可以在其他地方初始化</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        Count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态构造函数中初始化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-值的可变性"><a href="#2-值的可变性" class="headerlink" title="2. 值的可变性"></a>2. 值的可变性</h3><ul><li><strong>const</strong>:<ul><li>一旦定义，值无法改变。</li></ul></li><li><strong>static</strong>:<ul><li>可以在程序运行期间修改静态字段的值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span><br>&#123;<br>    <span class="hljs-comment">// 定义静态字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> Count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 增加计数的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Increment</span>()</span><br>    &#123;<br>        Count++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 输出初始值</span><br>        Console.WriteLine(<span class="hljs-string">&quot;初始计数: &quot;</span> + Counter.Count); <span class="hljs-comment">// 输出：0</span><br><br>        <span class="hljs-comment">// 调用静态方法增加计数</span><br>        Counter.Increment();<br>        Counter.Increment();<br><br>        <span class="hljs-comment">// 输出修改后的值</span><br>        Console.WriteLine(<span class="hljs-string">&quot;修改后的计数: &quot;</span> + Counter.Count); <span class="hljs-comment">// 输出：2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h3><ul><li><p><strong>const</strong>:</p><ul><li><p>常量可以是类级别的（static）或实例级别的，通常与类一起使用时，会被视为静态成员。但是C++还是static方法不能访问const常量</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MathConstants</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个静态常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> Pi = <span class="hljs-number">3.14159</span>;<br><br>    <span class="hljs-comment">// 定义一个实例常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> E = <span class="hljs-number">2.71828</span>;<br><br>    <span class="hljs-comment">// 静态方法访问静态常量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayConstants</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Pi: &quot;</span> + Pi); <span class="hljs-comment">// 访问静态常量</span><br>    &#125;<br><br>    <span class="hljs-comment">// 实例方法访问实例常量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayE</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;E: &quot;</span> + E); <span class="hljs-comment">// 访问实例常量</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 调用静态方法</span><br>        MathConstants.DisplayConstants();<br>        Console.WriteLine(<span class="hljs-string">&quot;MathConstants.E: &quot;</span> + MathConstants.E); <span class="hljs-comment">// 访问实例常量</span><br><br><br>        <span class="hljs-comment">// 创建实例并调用实例方法</span><br>        MathConstants mathConstants = <span class="hljs-keyword">new</span> MathConstants();<br>        mathConstants.DisplayE();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MathConstants</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 定义静态常量</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi;<br><span class="hljs-comment">// 定义实例常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> E;<br><br><span class="hljs-comment">// 构造函数初始化实例常量</span><br><span class="hljs-built_in">MathConstants</span>() : <span class="hljs-built_in">E</span>(<span class="hljs-number">2.71828</span>) &#123;&#125;<br><br><span class="hljs-comment">// 静态方法访问静态常量</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DisplayConstants</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Pi: &quot;</span> &lt;&lt; Pi &lt;&lt; std::endl; <span class="hljs-comment">// 访问静态常量</span><br><span class="hljs-comment">// std::cout &lt;&lt; &quot;E: &quot; &lt;&lt; E &lt;&lt; std::endl; // 报错，无法访问实例常量</span><br>&#125;<br><br><span class="hljs-comment">// 实例方法访问实例常量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayE</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;E: &quot;</span> &lt;&lt; E &lt;&lt; std::endl; <span class="hljs-comment">// 访问实例常量</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 静态常量的定义</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> MathConstants::Pi = <span class="hljs-number">3.14159</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 调用静态方法</span><br>MathConstants::<span class="hljs-built_in">DisplayConstants</span>();<br><br><span class="hljs-comment">// 创建实例并调用实例方法</span><br>MathConstants mathConstants;<br>mathConstants.<span class="hljs-built_in">DisplayE</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>static</strong>:</p><ul><li>仅与类相关，所有实例共享同一份数据。</li></ul></li></ul><h3 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. 性能</h3><ul><li><strong>const</strong>:<ul><li>编译时常量，直接替换为其值，因此在性能上通常更高效。</li></ul></li><li><strong>static</strong>:<ul><li>访问静态成员需要查找类的静态表，相比之下可能稍慢。</li></ul></li></ul><h3 id="5-书写顺序"><a href="#5-书写顺序" class="headerlink" title="5. 书写顺序"></a>5. 书写顺序</h3><ul><li><strong>const</strong>:<ul><li>public const</li></ul></li><li><strong>static</strong>:<ul><li>public static</li><li>static public</li></ul></li></ul><h3 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> Pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 常量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> InstanceCount; <span class="hljs-comment">// 静态字段</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        InstanceCount++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(Example.Pi); <span class="hljs-comment">// 输出：3.14</span><br>        Console.WriteLine(Example.InstanceCount); <span class="hljs-comment">// 输出：0</span><br><br>        Example ex1 = <span class="hljs-keyword">new</span> Example();<br>        Example ex2 = <span class="hljs-keyword">new</span> Example();<br>    <br>        Console.WriteLine(Example.InstanceCount); <span class="hljs-comment">// 输出：2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const和static-readonly的区别"><a href="#const和static-readonly的区别" class="headerlink" title="const和static readonly的区别"></a><code>const</code>和<code>static readonly</code>的区别</h3><p><code>const</code>和<code>static</code>不能一起使用，但如果你需要一个可以在运行时初始化并且不允许更改的静态值，可以使用<code>static readonly</code>，它允许在静态构造函数中初始化值：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> StaticReadOnlyValue;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        StaticReadOnlyValue = <span class="hljs-number">100</span>; <span class="hljs-comment">// 可以在静态构造函数中初始化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>在C#中，<code>readonly</code>关键字用于定义字段，这些字段在运行时初始化后，其值不能被修改。与<code>const</code>和<code>static</code>结合使用时，<code>readonly</code>可以帮助开发者更好地控制数据的不可变性。以下是<code>readonly</code>的详细说明及其用法：</p><h4 id="readonly的特点"><a href="#readonly的特点" class="headerlink" title="readonly的特点"></a><code>readonly</code>的特点</h4><ol><li><p><strong>初始化</strong>：</p><ul><li><code>readonly</code>字段可以在声明时初始化，或者在类的构造函数中初始化。这意味着你可以在对象创建时设定字段的值。</li><li>一旦被赋值（无论是在声明时还是在构造函数中），<code>readonly</code>字段就不能再被修改。</li></ul></li><li><p><strong>运行时可变性</strong>：</p><ul><li>与<code>const</code>不同，<code>readonly</code>字段的值可以在运行时决定（如通过构造函数），而<code>const</code>字段的值在编译时确定。</li></ul></li><li><p><strong>与<code>static</code>结合使用</strong>：</p><ul><li><code>readonly</code>字段可以与<code>static</code>结合使用，表示该字段是类级别的，并且在所有实例之间共享，但仍然具有只读特性。</li></ul></li></ol><h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><h4 id="1-使用readonly字段"><a href="#1-使用readonly字段" class="headerlink" title="1. 使用readonly字段"></a>1. 使用<code>readonly</code>字段</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-comment">// 只读字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> ReadOnlyValue;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Example</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        ReadOnlyValue = <span class="hljs-keyword">value</span>; <span class="hljs-comment">// 在构造函数中初始化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-与static结合使用"><a href="#2-与static结合使用" class="headerlink" title="2. 与static结合使用"></a>2. 与<code>static</code>结合使用</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    <span class="hljs-comment">// 静态只读字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">int</span> StaticReadOnlyValue;<br><br>    <span class="hljs-comment">// 静态构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">Example</span>()</span><br>    &#123;<br>        StaticReadOnlyValue = <span class="hljs-number">100</span>; <span class="hljs-comment">// 只在类加载时初始化一次</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Example ex = <span class="hljs-keyword">new</span> Example(<span class="hljs-number">10</span>);<br>        Console.WriteLine(ex.ReadOnlyValue); <span class="hljs-comment">// 输出: 10</span><br>        Console.WriteLine(Example.StaticReadOnlyValue); <span class="hljs-comment">// 输出: 100</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="主要区别-3"><a href="#主要区别-3" class="headerlink" title="主要区别"></a>主要区别</h4><ul><li><code>const</code> vs <code>readonly</code>：<ul><li><code>const</code>是编译时常量，值在编译时确定并且无法修改。</li><li><code>readonly</code>允许在运行时根据逻辑进行赋值（如通过构造函数），但赋值后不可修改。</li></ul></li><li><code>static readonly</code> vs <code>static</code>：<ul><li><code>static</code>字段可以被修改，而<code>static readonly</code>字段在类的构造完成后就不能被更改。</li></ul></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li><code>const</code>：编译时常量，隐含静态，值不可更改。用于定义不可更改的常量。</li><li><code>readonly</code>允许在运行时根据逻辑进行赋值（如通过构造函数），但赋值后不可修改。</li><li><code>static</code>：类级成员，运行时初始化，可更改。用于定义与类相关的共享成员，值可以在运行时改变。</li><li><code>static readonly</code>：运行时初始化（可在静态构造函数中设置），但一旦初始化，值不可更改。</li></ul><h1 id="19-拓展方法"><a href="#19-拓展方法" class="headerlink" title="19. 拓展方法"></a>19. 拓展方法</h1><blockquote><p>扩展方法（Extension Method）是C#中的一种功能，允许为现有类型（<code>非静态</code>）添加新的方法，而无需修改类型本身的源代码或创建子类。扩展方法是通过定义<code>一个静态类</code>，其中包含<code>静态方法</code>，并在方法的第一个参数前加上 <code>this</code> 关键字来实现的。这个第一个参数指定了要扩展的类型。</p></blockquote><p><strong>示例</strong>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringExtensions</span><br>&#123;<br>    <span class="hljs-comment">// 扩展方法: 为string类型添加一个ToWordCount方法，统计单词数量</span><br>    <span class="hljs-comment">// 访问修饰符 static 返回值 函数名(this 扩展类名 参数名, 参数类型 参数名, 参数类型 参数名...)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">ToWordCount</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> str</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">string</span>.IsNullOrEmpty(str))<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span> &#125;, StringSplitOptions.RemoveEmptyEntries).Length;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;Hello, how many words are in this sentence?&quot;</span>;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        <span class="hljs-built_in">int</span> wordCount = sentence.ToWordCount();<br>        <span class="hljs-comment">// The sentence has 8 words.</span><br>        Console.WriteLine(<span class="hljs-string">$&quot;The sentence has <span class="hljs-subst">&#123;wordCount&#125;</span> words.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>ToWordCount</code> 方法被定义为 <code>string</code> 类型的扩展方法，能够像调用实例方法一样使用扩展方法。扩展方法通常用于增强第三方库或框架中的类，或者在不修改原始类型的情况下添加辅助功能。</p><p>扩展方法可以为以下类型添加新方法：</p><ol><li><strong>普通类和结构体</strong>：可以为任何已存在的类或结构体（包括 .NET 框架中的类型或自定义的类型）添加扩展方法。例如，为 <code>string</code>、<code>int</code>、<code>List&lt;T&gt;</code> 等常见类型添加扩展方法。类只可以是非静态。</li><li><strong>接口</strong>：可以为接口添加扩展方法，这样接口的所有实现类都可以使用该扩展方法。例如，为 <code>IEnumerable&lt;T&gt;</code> 添加扩展方法来简化 LINQ 查询。</li><li><strong>泛型类型</strong>：可以为泛型类型添加扩展方法。例如，为 <code>List&lt;T&gt;</code> 或 <code>Dictionary&lt;TKey, TValue&gt;</code> 添加方法来处理泛型数据。</li><li><strong>枚举</strong>：可以为枚举类型添加扩展方法，以提供一些便捷的功能，如转换或格式化枚举值。<br><strong>注意</strong>：</li></ol><ul><li>扩展方法必须定义在一个静态类中。</li><li>扩展方法不能为静态类添加方法</li><li>扩展方法本质上是静态方法，但可以像实例方法一样调用。</li><li>在C#中，如果扩展方法的名字和已有的方法名字一样，原有方法会优先被调用。这是因为扩展方法的解析规则优先级较低，只有当编译器找不到匹配的实例方法时，才会尝试使用扩展方法。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ExtensionMethodDemo</span><br>&#123;<br>    <span class="hljs-comment">// 定义一个普通类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是原始类中的方法&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个扩展类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClassExtensions</span><br>    &#123;<br>        <span class="hljs-comment">// 定义一个扩展方法，与原有方法同名</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> MyClass myClass</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这是扩展方法&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            MyClass myClass = <span class="hljs-keyword">new</span> MyClass();<br>            myClass.PrintMessage(); <span class="hljs-comment">// 调用原有方法</span><br>            MyClassExtensions.PrintMessage(myClass); <span class="hljs-comment">// 调用扩展方法</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>在这个例子中，<code>MyClass</code>的实例方法<code>PrintMessage</code>优先于扩展方法，因此会输出“这是原始类中的方法”。如果要调用扩展方法，就需要给扩展方法取一个不同的名字，或者避免在类中定义相同名称的方法。- 解决方法</p><ol><li><strong>使用不同的名字</strong>：避免扩展方法与原有方法同名。</li><li><strong>显式调用扩展方法</strong>：如果确实需要调用扩展方法，可以通过反射或直接使用静态方法调用的方式：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MyClassExtensions.PrintMessage(myClass);<br></code></pre></td></tr></table></figure>这样可以绕过实例方法的优先级限制，直接调用扩展方法。</li></ol><h3 id="扩展方法的第一个参数干嘛的，后面的是参数，那第一个干嘛的"><a href="#扩展方法的第一个参数干嘛的，后面的是参数，那第一个干嘛的" class="headerlink" title="扩展方法的第一个参数干嘛的，后面的是参数，那第一个干嘛的"></a>扩展方法的第一个参数干嘛的，后面的是参数，那第一个干嘛的</h3><p>扩展方法的</p><p>第一个参数通过<code>this</code>关键字来指定要扩展的类型。它定义了该扩展方法应用于哪个类型的对象，<code>this</code>后面跟着类型名称，表示这个方法可以像该类型的实例方法一样被调用。</p><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><ul><li>第一个参数使用<code>this</code>关键字来表示该方法是一个扩展方法，<code>this</code>后面的类型是被扩展的类型。</li><li>扩展方法的第一个参数（<code>this</code>后面的参数）是指向被扩展对象的引用。在调用扩展方法时，这个对象将作为参数传递给方法。</li><li>而更后面的参数是该方法的其他输入参数，类似于普通方法的参数。</li></ul><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringExtensions</span><br>&#123;<br>    <span class="hljs-comment">// 扩展方法，第一个参数是要扩展的类型（string），表示这个方法可以用于string类型的对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">WordCount</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> str</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展的字符串对象</span><br>        <span class="hljs-keyword">return</span> str.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span>[] &#123; <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span> &#125;, StringSplitOptions.RemoveEmptyEntries).Length;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用扩展方法</span><br><span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;Hello world, this is an extension method example.&quot;</span>;<br><span class="hljs-built_in">int</span> count = sentence.WordCount();  <span class="hljs-comment">// 相当于 StringExtensions.WordCount(sentence)</span><br>Console.WriteLine(count);  <span class="hljs-comment">// 输出: 7</span><br></code></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li><code>WordCount</code>方法的第一个参数是<code>this string str</code>，表示这个方法是用来扩展<code>string</code>类型的对象的。</li><li>当<code>sentence.WordCount()</code>被调用时，<code>sentence</code>对象被传递给<code>str</code>参数，相当于执行了<code>StringExtensions.WordCount(sentence)</code>。</li></ol><p>因此，扩展方法的第一个参数<code>this</code>后面的类型就是要扩展的类型，指定了这个方法适用于哪些对象，并使其能够像实例方法一样调用。而str则表示什么样的对象调用了这个方法，可以对调用的对象进行操作</p><h3 id="为普通类和结构体、接口、泛型类型、枚举类型编写扩展方法的示例"><a href="#为普通类和结构体、接口、泛型类型、枚举类型编写扩展方法的示例" class="headerlink" title="为普通类和结构体、接口、泛型类型、枚举类型编写扩展方法的示例"></a>为普通类和结构体、接口、泛型类型、枚举类型编写扩展方法的示例</h3><h3 id="1-普通类和结构体的扩展方法"><a href="#1-普通类和结构体的扩展方法" class="headerlink" title="1. 普通类和结构体的扩展方法"></a>1. 普通类和结构体的扩展方法</h3><h4 id="扩展普通类"><a href="#扩展普通类" class="headerlink" title="扩展普通类"></a>扩展普通类</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-comment">// 普通类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 扩展方法类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PersonExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Greet</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Person person</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;Hello, <span class="hljs-subst">&#123;person.Name&#125;</span>!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>        person.Greet();  <span class="hljs-comment">// 输出: Hello, Alice!</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="扩展结构体"><a href="#扩展结构体" class="headerlink" title="扩展结构体"></a>扩展结构体</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 结构体</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 扩展方法类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PointExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">DistanceToOrigin</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Point point</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.Sqrt(point.X * point.X + point.Y * point.Y);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">new</span> Point &#123; X = <span class="hljs-number">3</span>, Y = <span class="hljs-number">4</span> &#125;;<br>        Console.WriteLine(point.DistanceToOrigin());  <span class="hljs-comment">// 输出: 5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-接口的扩展方法"><a href="#2-接口的扩展方法" class="headerlink" title="2. 接口的扩展方法"></a>2. 接口的扩展方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span>;<br>&#125;<br><br><span class="hljs-comment">// 扩展方法类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShapeExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintArea</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IShape shape</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;The area is <span class="hljs-subst">&#123;shape.GetArea()&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类，这里扩展方法可以不用重写了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        IShape circle = <span class="hljs-keyword">new</span> Circle &#123; Radius = <span class="hljs-number">5</span> &#125;;<br>        circle.PrintArea();  <span class="hljs-comment">// 输出: The area is 78.5398163397448</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-泛型类型的扩展方法"><a href="#3-泛型类型的扩展方法" class="headerlink" title="3. 泛型类型的扩展方法"></a>3. 泛型类型的扩展方法</h3><ul><li>感觉这个泛型很好用了啊</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 泛型类型的扩展方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GenericExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintTypeName</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> T obj</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">$&quot;The type of the object is <span class="hljs-subst">&#123;<span class="hljs-keyword">typeof</span>(T).Name&#125;</span>&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        <span class="hljs-built_in">int</span> number = <span class="hljs-number">42</span>;<br>        number.PrintTypeName();  <span class="hljs-comment">// 输出: The type of the object is Int32</span><br><br>        <span class="hljs-built_in">string</span> text = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        text.PrintTypeName();    <span class="hljs-comment">// 输出: The type of the object is String</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-枚举的扩展方法"><a href="#4-枚举的扩展方法" class="headerlink" title="4. 枚举的扩展方法"></a>4. 枚举的扩展方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 枚举</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> DayOfWeek<br>&#123;<br>    Monday,<br>    Tuesday,<br>    Wednesday,<br>    Thursday,<br>    Friday,<br>    Saturday,<br>    Sunday<br>&#125;<br><br><span class="hljs-comment">// 扩展方法类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DayOfWeekExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsWeekend</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> DayOfWeek day</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> day == DayOfWeek.Saturday || day == DayOfWeek.Sunday;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用扩展方法</span><br>        DayOfWeek today = DayOfWeek.Saturday;<br>        Console.WriteLine(today.IsWeekend());  <span class="hljs-comment">// 输出: True</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些示例展示了如何为普通类、结构体、接口、泛型类型和枚举编写扩展方法。每种类型的扩展方法通过<code>this</code>关键字为目标类型增加新功能，方便开发和代码的可读性。</p><h1 id="20-C-的泛型和C-的模板有什么区别呢"><a href="#20-C-的泛型和C-的模板有什么区别呢" class="headerlink" title="20. C#的泛型和C++的模板有什么区别呢"></a>20. C#的泛型和C++的模板有什么区别呢</h1><p>C#的泛型和C++的模板虽然看起来有些相似，但它们的工作方式和设计初衷存在一些关键区别。</p><h3 id="1-编译机制"><a href="#1-编译机制" class="headerlink" title="1. 编译机制"></a>1. <strong>编译机制</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>C++的模板是在编译期间进行代码的生成，称为模板实例化。模板是基于文本替换的宏机制，编译器会根据使用模板时传递的类型生成特定类型的代码。这种方式导致代码膨胀（代码冗余）。</li><li>模板允许类型参数进行特殊化（模板特化），可以为某些特定类型实现不同的模板行为。</li></ul></li><li><strong>C# 泛型</strong><ul><li>C#的泛型在编译期间会被编译成中间语言（IL），并在运行时通过JIT（即时编译器）生成类型安全的代码。编译生成的泛型代码只需要一份，所有的具体类型共享相同的代码，这样可以减少代码的膨胀。</li><li>C# 泛型没有模板特化的概念。泛型的类型参数只能在运行时提供，所有类型参数在使用时都必须满足编译时的类型约束。</li></ul></li></ul><h3 id="2-类型安全"><a href="#2-类型安全" class="headerlink" title="2. 类型安全"></a>2. <strong>类型安全</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>由于C++模板是基于代码替换的宏机制，编译器会根据模板的具体使用来生成代码，在编译期间进行类型检查。因此，如果模板代码不符合类型要求，会在模板实例化时出现编译错误。</li></ul></li><li><strong>C# 泛型</strong><ul><li>C#的泛型提供类型安全的机制，允许在定义泛型时指定类型约束（如<code>where T : class</code>）。编译器在编译期间会检查这些约束，确保类型的安全性。</li></ul></li></ul><h3 id="3-运行时与编译时的行为"><a href="#3-运行时与编译时的行为" class="headerlink" title="3. 运行时与编译时的行为"></a>3. <strong>运行时与编译时的行为</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>模板实例化是在编译时完成的。编译器为每种使用的模板参数生成独立的代码，因此没有额外的运行时开销。</li><li>模板的元编程能力强大，可以实现复杂的编译时计算和类型变换。</li></ul></li><li><strong>C# 泛型</strong><ul><li>C#的泛型是在运行时通过JIT进行类型参数化，允许在运行时决定使用的类型。</li><li>泛型无法在编译时进行元编程计算，只能使用运行时的反射等方式来进行类似的操作。</li></ul></li></ul><h3 id="4-模板特化与泛型约束"><a href="#4-模板特化与泛型约束" class="headerlink" title="4. 模板特化与泛型约束"></a>4. <strong>模板特化与泛型约束</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>支持模板特化，可以为某些特定类型定义不同的实现。</li><li>模板特化分为全特化和偏特化，灵活性更高。</li></ul></li><li><strong>C# 泛型</strong><ul><li>不支持模板特化，但支持泛型约束，可以用<code>where</code>关键字为类型参数指定一定的约束条件，如必须实现某接口或继承某基类。</li></ul></li></ul><h3 id="5-编译器错误信息"><a href="#5-编译器错误信息" class="headerlink" title="5. 编译器错误信息"></a>5. <strong>编译器错误信息</strong></h3><ul><li><strong>C++ 模板</strong><ul><li>由于模板的复杂性和模板元编程的灵活性，模板相关的编译器错误通常非常冗长且难以理解。</li></ul></li><li><strong>C# 泛型</strong><ul><li>由于C#的泛型设计简单，错误信息相对直观。泛型约束的限制也使得类型安全检查更加明确。</li></ul></li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li>C++模板是基于编译期的宏替换机制，支持编译期的元编程和模板特化，灵活性高，但可能会带来代码膨胀。</li><li>C#的泛型是类型安全的运行时机制，支持类型约束，减少了代码冗余，更易于使用，但不具备C++模板的编译期元编程能力。</li></ul><p>两者的设计目的是不同的：C++模板主要为了性能和灵活性，而C#泛型更注重类型安全和代码重用性。</p><h1 id="21-什么叫元编程"><a href="#21-什么叫元编程" class="headerlink" title="21. 什么叫元编程"></a>21. 什么叫元编程</h1><p>元编程（Metaprogramming）是一种编程技术，在这种技术中，程序可以将其他程序作为数据进行操作、分析或生成。换句话说，<code>元编程的目标是编写能够生成、修改或编译代码的代码</code>。它能够提升代码的灵活性、可重用性和性能。元编程主要体现在以下几个方面：</p><h3 id="1-代码生成"><a href="#1-代码生成" class="headerlink" title="1. 代码生成"></a>1. <strong>代码生成</strong></h3><ul><li>通过编写元程序来自动生成某些重复性较强或复杂的代码，从而减少手工编写的工作量。常见的例子有代码生成器和宏。</li></ul><h3 id="2-编译期计算"><a href="#2-编译期计算" class="headerlink" title="2. 编译期计算"></a>2. <strong>编译期计算</strong></h3><ul><li>元编程允许在编译时执行计算。这使得可以利用编译器在编译阶段执行某些逻辑，从而优化程序运行时的性能。例如，C++的模板元编程可以在编译期计算出一些结果，而不是在运行时执行。</li></ul><h3 id="3-反射和动态类型"><a href="#3-反射和动态类型" class="headerlink" title="3. 反射和动态类型"></a>3. <strong>反射和动态类型</strong></h3><ul><li>一些编程语言（如Python、Java、C#）支持在运行时检查和操作类型信息，这种机制称为反射。通过反射，程序可以动态地创建和修改对象、调用方法或访问属性。</li></ul><h3 id="4-宏和预处理器"><a href="#4-宏和预处理器" class="headerlink" title="4. 宏和预处理器"></a>4. <strong>宏和预处理器</strong></h3><ul><li>在C和C++等语言中，预处理器宏是一种简单的元编程工具。它们在编译前处理源代码，用于定义常量、条件编译、代码替换等。</li></ul><h3 id="5-泛型编程"><a href="#5-泛型编程" class="headerlink" title="5. 泛型编程"></a>5. <strong>泛型编程</strong></h3><ul><li>泛型编程是一种特殊的元编程形式，允许编写适用于多种数据类型的代码。例如，C++中的模板和C#中的泛型使得函数和类可以针对任意类型编写。</li></ul><h3 id="6-模板元编程（Template-Metaprogramming）"><a href="#6-模板元编程（Template-Metaprogramming）" class="headerlink" title="6. 模板元编程（Template Metaprogramming）"></a>6. <strong>模板元编程（Template Metaprogramming）</strong></h3><ul><li>C++中广泛应用的元编程技术，允许在编译期通过模板实现复杂的逻辑推导和代码生成。例如，可以利用模板递归计算阶乘或实现编译期类型检查。</li></ul><h3 id="7-编译器插件和自定义编译器"><a href="#7-编译器插件和自定义编译器" class="headerlink" title="7. 编译器插件和自定义编译器"></a>7. <strong>编译器插件和自定义编译器</strong></h3><ul><li>一些语言和编译器允许开发者编写插件或自定义编译器来进行元编程，从而可以在编译过程中自动进行代码优化、生成和修改。</li></ul><h3 id="8-领域特定语言（DSL）"><a href="#8-领域特定语言（DSL）" class="headerlink" title="8. 领域特定语言（DSL）"></a>8. <strong>领域特定语言（DSL）</strong></h3><ul><li>元编程有时还用于创建领域特定语言，这些语言是针对某个特定领域设计的，可以通过扩展已有的语言或创建新的语法来简化编程。</li></ul><h3 id="元编程的优缺点"><a href="#元编程的优缺点" class="headerlink" title="元编程的优缺点"></a>元编程的优缺点</h3><p><strong>优点：</strong></p><ul><li><strong>减少代码重复性</strong>：通过生成代码或编写通用的模板，可以大大减少重复性代码。</li><li><strong>提升性能</strong>：利用编译期计算和优化，可以生成更高效的代码。</li><li><strong>增强灵活性</strong>：程序可以根据不同的条件动态生成或调整代码，增加程序的适应性。<br><strong>缺点：</strong></li><li><strong>复杂性</strong>：元编程的代码往往较为复杂，难以理解和维护。</li><li><strong>编译时间</strong>：编译期元编程可能会显著增加编译时间，尤其是在复杂的模板元编程中。</li><li><strong>调试困难</strong>：由于元编程代码是在编译期生成的，调试错误会更加困难。</li></ul><h3 id="举例：C-模板元编程示例"><a href="#举例：C-模板元编程示例" class="headerlink" title="举例：C++模板元编程示例"></a>举例：C++模板元编程示例</h3><p>在C++中，可以使用模板元编程来计算编译期的阶乘：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 模板结构体，用于计算阶乘</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = N * Factorial&lt;N - <span class="hljs-number">1</span>&gt;::value; <span class="hljs-comment">// 递归计算阶乘</span><br>&#125;;<br><br><span class="hljs-comment">// 模板特化，用于终止递归</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = <span class="hljs-number">1</span>; <span class="hljs-comment">// 0! = 1</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 输出5的阶乘</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Factorial of 5: &quot;</span> &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Factorial&lt;5&gt;::value</code>在编译期被计算为120，不需要运行时进行计算。</p><h4 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h4><ol><li><strong>模板递归定义</strong>：<ul><li><code>template &lt;int N&gt; struct Factorial</code> 定义了一个模板结构体，用来计算整数 <code>N</code> 的阶乘。</li><li><code>static const int value = N * Factorial&lt;N - 1&gt;::value;</code> 这一行表示 <code>Factorial&lt;N&gt;::value</code> 等于 <code>N</code> 乘以 <code>Factorial&lt;N - 1&gt;::value</code>。这是一种递归定义，类似于数学上的阶乘定义：<code>N! = N * (N-1)!</code>。</li></ul></li><li><strong>模板特化</strong>：<ul><li><code>template &lt;&gt; struct Factorial&lt;0&gt;</code> 是一个模板特化，用来终止递归计算。它指定当 <code>N</code> 为 0 时，<code>Factorial&lt;0&gt;::value</code> 等于 1。</li></ul></li><li><strong>使用 <code>Factorial&lt;5&gt;::value</code> 进行取值</strong>：<ul><li><code>Factorial&lt;5&gt;::value</code> 的含义是通过模板递归计算 5 的阶乘，即 <code>5 * 4 * 3 * 2 * 1 = 120</code>。</li><li><code>::value</code> 是用来访问 <code>Factorial</code> 结构体中的 <code>value</code> 成员，它保存了计算结果。</li></ul></li></ol><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>输出为：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Factorial</span> <span class="hljs-variable">of</span> <span class="hljs-number">5</span><span class="hljs-operator">:</span> <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>这段代码使用模板元编程在编译时计算阶乘，<code>Factorial&lt;5&gt;::value</code> 中的 <code>::value</code> 是访问结构体 <code>Factorial</code> 的静态成员变量，用于获取计算结果。</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>元编程可以提高代码的灵活性和效率，通过编写“生成代码的代码”，解决某些问题变得更加优雅和高效。然而，由于它增加了程序的复杂性，使用时需要权衡和谨慎。</p><p><a href="https://learn.microsoft.com/zh-cn/">MS-Learning</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-游戏（二）</title>
    <link href="/2024/09/10/%E6%9D%82%E8%B0%88-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/09/10/%E6%9D%82%E8%B0%88-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>往电脑游戏上靠吧，尽量还是自己能够慢慢玩的游戏，不是类似每几个月就更新的游戏<br>自己确实没时间玩<br>多分析，可以写攻略啥的，至少比第一篇详细</p></blockquote><h3 id="游戏杂谈"><a href="#游戏杂谈" class="headerlink" title="游戏杂谈"></a>游戏杂谈</h3><h4 id="大江湖之苍龙与白鸟"><a href="#大江湖之苍龙与白鸟" class="headerlink" title="大江湖之苍龙与白鸟"></a>大江湖之苍龙与白鸟</h4><!-- ![双人成行.png](https://s2.loli.net/2022/07/20/dxheYjZ9R7vU5iw.png) --><p>占坑</p><h4 id="骰子浪游者"><a href="#骰子浪游者" class="headerlink" title="骰子浪游者"></a>骰子浪游者</h4><p>占坑</p><h4 id="深岩银河"><a href="#深岩银河" class="headerlink" title="深岩银河"></a>深岩银河</h4><p>占坑</p><h4 id="土豆兄弟"><a href="#土豆兄弟" class="headerlink" title="土豆兄弟"></a>土豆兄弟</h4><p>占坑</p><h4 id="学生时代"><a href="#学生时代" class="headerlink" title="学生时代"></a>学生时代</h4><p>占坑</p><h4 id="墨境"><a href="#墨境" class="headerlink" title="墨境"></a>墨境</h4><p>占坑</p><h4 id="暖雪"><a href="#暖雪" class="headerlink" title="暖雪"></a>暖雪</h4><p>占坑</p><h4 id="沉默的蟋蟀"><a href="#沉默的蟋蟀" class="headerlink" title="沉默的蟋蟀"></a>沉默的蟋蟀</h4><p>占坑</p><h4 id="太吾绘卷"><a href="#太吾绘卷" class="headerlink" title="太吾绘卷"></a>太吾绘卷</h4><p>占坑</p><h4 id="孤星猎人"><a href="#孤星猎人" class="headerlink" title="孤星猎人"></a>孤星猎人</h4><p>占坑</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VSCode基本使用和Emmet语法</title>
    <link href="/2024/09/10/VSCode%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8CEmmet%E8%AF%AD%E6%B3%95/"/>
    <url>/2024/09/10/VSCode%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8CEmmet%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="VSCode基本使用和Emmet语法"><a href="#VSCode基本使用和Emmet语法" class="headerlink" title="VSCode基本使用和Emmet语法"></a>VSCode基本使用和Emmet语法</h3><h4 id="Emmet语法"><a href="#Emmet语法" class="headerlink" title="Emmet语法"></a>Emmet语法</h4><blockquote><p>Emmet用于加快HTML和CSS代码的编写速度。</p><p>能够通过简短的表达式就可以生成HTML或CSS代码片段。</p><p>截至2022年，主流的编辑器工具如Visual Studio Code、WebStorm都已经继承了<code>Emmet</code>工具，无需手动安装即可使用</p><p>文档地址：<a href="https://docs.emmet.io/cheat-sheet/">https://docs.emmet.io/cheat-sheet/</a></p></blockquote><p>test.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 单个标签 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- p --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 父子关系标签 --&gt;</span><br>  <span class="hljs-comment">&lt;!--   div&gt;ul&gt;li --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 生成多个标签 --&gt;</span><br>  <span class="hljs-comment">&lt;!--   div&gt;ul&gt;li*5 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 兄弟关系标签 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- div+p --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dic</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dic</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 属性 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- #box --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- p#box --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- dic.cls .cls --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 同时生成id和类 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- div.title.#header --&gt;</span><br>  <span class="hljs-comment">&lt;!-- div.title#header --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 自动生成内容 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- p&#123;Hello你好！&#125; --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--   p&#123;Hello你好$&#125;*5 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好4<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello你好5<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- a[href=&quot;https//www.baidu.com&quot;] --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https//www.baidu.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- input[data-content=&#x27;AAAA&#x27;] --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">data-content</span>=<span class="hljs-string">&quot;AAAA&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- div&gt;p*2+ul&gt;li*2 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- p&gt;span.cls$*6 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls6&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="快捷键以及其他命令"><a href="#快捷键以及其他命令" class="headerlink" title="快捷键以及其他命令"></a>快捷键以及其他命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">code #在windows中的命令行输入code会打开vscode软件<br>CRTL + / #单行注释或取消<br>ALT + UP/DOWN # 移动行<br>SHIFT + ALT + UP/DOWN # 复制当前行<br>CTRL + &#x27;+或-&#x27; # 设置IDE整体字体大小<br>CTRL + ALT + UP/DOWN # 多行编辑<br>SHIFT + CTRL + K # 删除当前行<br></code></pre></td></tr></table></figure><h4 id="VSCode插件推荐"><a href="#VSCode插件推荐" class="headerlink" title="VSCode插件推荐"></a>VSCode插件推荐</h4><ul><li><p>Auto Rename Tag</p><blockquote><p>自动将标签全部修改</p><p></p> 修改其中的p，另一个p也会修改</blockquote></li><li><p>Code Runner</p><blockquote><p>运行多种语言的代码段或代码文件,实际上还要安装其他插件，不知道是不是自带的</p></blockquote></li><li><p>Code Translate</p><blockquote><p>能翻译代码中的英文</p></blockquote></li><li><p>ESLint</p><blockquote><p>vue代码格式化</p></blockquote></li><li><p>JavaScript(ES6) code snippets</p><blockquote><p>js语法报错提示</p></blockquote></li><li><p>Live Server</p><blockquote><p>使用服务器（本地）运行html文件</p></blockquote></li><li><p>Material Icon Theme</p><blockquote><p>修改文件目录的图标</p></blockquote></li><li><p>open in browser</p><blockquote><p>使用浏览器打开html文件</p></blockquote></li><li><p>Prettier Code formatter</p><blockquote><p>代码格式化</p><p>参考<a href="https://huaweicloud.csdn.net/638ee1f6dacf622b8df8d8c0.html">https://huaweicloud.csdn.net/638ee1f6dacf622b8df8d8c0.html</a></p></blockquote></li><li><p>Vetur </p><blockquote><p>Vue代码格式化</p></blockquote></li><li><p>Vue Language Feature(Volur)</p><blockquote><p>Vue代码格式化</p></blockquote></li></ul><p><a href="https://imgse.com/i/pSjl7RI"><img src="https://s1.ax1x.com/2023/02/21/pSjl7RI.png" alt="pSjl7RI.png"></a></p><p><a href="https://imgse.com/i/pSjlOL8"><img src="https://s1.ax1x.com/2023/02/21/pSjlOL8.png" alt="pSjlOL8.png"></a></p><h4 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h4><p>左下角齿轮-&gt;setting</p><p>过一段时间自动保存</p><p><a href="https://imgse.com/i/pSjlxoQ"><img src="https://s1.ax1x.com/2023/02/21/pSjlxoQ.png" alt="pSjlxoQ.png"></a></p><p>去除右上角的迷你窗口</p><p><a href="https://imgse.com/i/pSj1pJs"><img src="https://s1.ax1x.com/2023/02/21/pSj1pJs.png" alt="pSj1pJs.png"></a></p><p>增加Ctrl+鼠标滑轮缩放代码字体大小</p><p><a href="https://imgse.com/i/pSj19Wn"><img src="https://s1.ax1x.com/2023/02/21/pSj19Wn.png" alt="pSj19Wn.png"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>本地双人塔防游戏Demo</title>
    <link href="/2024/09/10/%E6%9C%AC%E5%9C%B0%E5%8F%8C%E4%BA%BA%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8FDemo/"/>
    <url>/2024/09/10/%E6%9C%AC%E5%9C%B0%E5%8F%8C%E4%BA%BA%E5%A1%94%E9%98%B2%E6%B8%B8%E6%88%8FDemo/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本 Demo 来自 B 站课程学习的改进</p><p>作为自己的整理和找工作的项目 Demo</p><p>添加了自己的想法，记录在做这个 Demo 过程中比较重要的内容，可能会贴出部分源码</p></blockquote><h1 id="导入-SDL-相关的包"><a href="#导入-SDL-相关的包" class="headerlink" title="导入 SDL 相关的包"></a>导入 SDL 相关的包</h1><p><a href="https://wiki.libsdl.org/SDL2/CategoryAPI">SDL2 API 文档总览</a></p><p><a href="https://github.com/DaveGamble/cJSON">cJSON 仓库链接</a><br><a href="https://github.com/libsdl-org/SDL">SDL2 仓库链接</a><br><a href="https://github.com/libsdl-org/SDL_ttf">SDL_ttf 仓库链接</a><br><a href="https://github.com/libsdl-org/SDL_mixer">SDL_mixer 仓库链接</a><br><a href="https://github.com/libsdl-org/SDL_image">SDL_image 仓库链接</a><br><a href="https://www.ferzkopp.net/wordpress/2016/01/02/sdl_gfx-sdl2_gfx/">SDL2_gfx 官网链接</a></p><h2 id="下载-SDL2-的时候的-release-版本的信息解读"><a href="#下载-SDL2-的时候的-release-版本的信息解读" class="headerlink" title="下载 SDL2 的时候的 release 版本的信息解读"></a>下载 SDL2 的时候的 release 版本的信息解读</h2><p><img src="/BlogImg/image-20240909230926905.png" alt="image-20240909230926905"></p><p>文件名 <code>SDL2-devel-2.30.7-VC.zip</code> 中的各个部分通常遵循一定的命名规则，以下是对其命名含义的解释：</p><ol><li><p><strong><code>SDL2</code></strong>:</p><ul><li>代表 Simple DirectMedia Layer 2.0，即 SDL2，这是一个跨平台的多媒体开发库，广泛用于游戏开发、图形渲染和音频处理等领域。</li></ul></li><li><p><strong><code>devel</code></strong>:</p><ul><li><code>devel</code> 是 <code>development</code> 的缩写，表示这是一个开发版本的文件包，通常包含开发库、头文件和相关的工具，用于软件开发而不是仅仅用于运行时。这意味着你可以使用它来编译和开发依赖于 SDL2 的应用程序。</li></ul></li><li><p><strong><code>2.30.2</code></strong>:</p><ul><li><p>这是 SDL2 的版本号，表示这是 2.30.7 版本。版本号通常以</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">主版本号.次版本号.修订号<br></code></pre></td></tr></table></figure><p>的形式表示，例如在此例中：</p><ul><li><code>2</code> 是主版本号，表示这是 SDL2 的第二个大版本。</li><li><code>30</code> 是次版本号，表示自主版本 2 以来进行了 30 次功能更新或改进。</li><li><code>7</code> 是修订号，表示这个版本在 <code>2.30</code> 基础上进行了七次小的修复或改进。</li></ul></li></ul></li><li><p><strong><code>VC</code></strong>:</p><ul><li><code>VC</code> 代表 Visual C++，表示这个文件包是为 Microsoft Visual C++ 编译器和开发环境准备的。这通常意味着它包含了适用于 Visual Studio 的动态链接库（DLLs）、静态库（LIBs）、头文件（headers）等。</li></ul></li><li><p><strong><code>.zip</code></strong>:</p><ul><li>这是文件的扩展名，表示该文件是一个压缩包，使用 ZIP 压缩格式。你需要解压缩它以访问其中的内容。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>文件名 <code>SDL2-devel-2.30.2-VC.zip</code> 可以理解为：</p><ul><li>这是 SDL2 库的开发版（包含开发所需的文件），</li><li>版本号是 2.30.2，</li><li>专门为 Visual C++ 编译器准备，</li><li>文件被打包为 ZIP 格式的压缩包。</li></ul><h2 id="VS-Studio-的一些设置"><a href="#VS-Studio-的一些设置" class="headerlink" title="VS Studio 的一些设置"></a>VS Studio 的一些设置</h2><h3 id="运行库设置"><a href="#运行库设置" class="headerlink" title="运行库设置"></a>运行库设置</h3><p><img src="/BlogImg/image-20240909233156816.png" alt="属性页操作"></p><p><img src="/BlogImg/image-20240909233309479.png" alt="右键项目最下面能看到属性"></p><p><img src="/BlogImg/image-20240909233333704.png" alt="找到属性中的运行库"></p><h3 id="不同选项的解释，来自-chatgpt-4o"><a href="#不同选项的解释，来自-chatgpt-4o" class="headerlink" title="不同选项的解释，来自 chatgpt-4o"></a>不同选项的解释，来自 chatgpt-4o</h3><p>在 Visual Studio 中，当你编译一个 C&#x2F;C++ 程序时，可以选择不同的运行库（Runtime Library）选项。每个选项都有不同的特性，主要影响程序在运行时如何链接到 C&#x2F;C++ 标准库以及线程安全性。以下是常见的运行库选项及其区别：</p><h3 id="1-多线程-单线程"><a href="#1-多线程-单线程" class="headerlink" title="1. 多线程&#x2F;单线程"></a>1. <strong>多线程&#x2F;单线程</strong></h3><ul><li><strong>&#x2F;MT</strong> (Multithreaded): 编译器使用多线程的、静态链接的运行库。这意味着标准库的代码将被编译进生成的二进制文件中，不依赖外部的 DLL 文件。此选项适用于编译需要多线程支持的独立可执行文件。</li><li><strong>&#x2F;MTd</strong> (Multithreaded Debug): 和 <code>/MT</code> 类似，但用于调试版本，包含调试信息。</li><li><strong>&#x2F;MD</strong> (Multithreaded DLL): 编译器使用多线程的、动态链接的运行库。这意味着标准库的代码不会被编译进生成的二进制文件中，而是依赖外部的 <code>msvcrt.dll</code>（或调试版本的 <code>msvcrtd.dll</code>）。这是默认的运行库选项，适用于需要分发较小的可执行文件并且使用了动态链接库的项目。</li><li><strong>&#x2F;MDd</strong> (Multithreaded DLL Debug): 和 <code>/MD</code> 类似，但用于调试版本，包含调试信息。</li></ul><h3 id="2-静态链接-vs-动态链接"><a href="#2-静态链接-vs-动态链接" class="headerlink" title="2. 静态链接 vs 动态链接"></a>2. <strong>静态链接 vs 动态链接</strong></h3><ul><li><strong>静态链接</strong> (<code>/MT</code>, <code>/MTd</code>):<ul><li>所有的运行时库代码都被嵌入到最终的可执行文件或库文件中。</li><li>不依赖任何外部 DLL 文件。</li><li>生成的文件较大，但在部署时不需要依赖额外的库文件。</li></ul></li><li><strong>动态链接</strong> (<code>/MD</code>, <code>/MDd</code>):<ul><li>运行时库代码保存在外部的 DLL 文件中，最终的可执行文件中只包含对这些 DLL 的引用。</li><li>生成的可执行文件较小，但在运行时必须确保相关的 DLL 文件可用。</li><li>如果不同的模块使用不同的运行时库（比如一个模块用 <code>/MD</code>，另一个用 <code>/MT</code>），可能会导致内存管理问题（如内存分配与释放的不一致）。</li></ul></li></ul><h3 id="3-调试版-vs-发布版"><a href="#3-调试版-vs-发布版" class="headerlink" title="3. 调试版 vs 发布版"></a>3. <strong>调试版 vs 发布版</strong></h3><ul><li><strong>调试版</strong> (<code>/MTd</code>, <code>/MDd</code>):<ul><li>包含调试信息，便于在调试器中运行程序。</li><li>使用了调试版本的运行库，运行时性能可能较低，但提供了更多的错误检查机制。</li></ul></li><li><strong>发布版</strong> (<code>/MT</code>, <code>/MD</code>):<ul><li>不包含调试信息，优化后的代码适用于发布版本。</li><li>使用了非调试版本的运行库，运行时性能更好。</li></ul></li></ul><h3 id="选择哪个运行库？"><a href="#选择哪个运行库？" class="headerlink" title="选择哪个运行库？"></a>选择哪个运行库？</h3><ul><li><strong>单独的可执行文件</strong>: <font color="red">如果你需要一个不依赖外部 DLL 的独立可执行文件，可以选择 <code>/MT</code> 或 <code>/MTd</code>。</font></li><li><strong>使用动态链接库</strong>: 如果你希望通过动态链接库减小可执行文件的大小并共享库代码，使用 <code>/MD</code> 或 <code>/MDd</code> 是更好的选择。</li><li><strong>调试 vs 发布</strong>: 在开发和调试阶段，选择调试版运行库（如 <code>/MDd</code>），在发布时切换到发布版运行库（如 <code>/MD</code>）。</li></ul><h2 id="第三方库的导入"><a href="#第三方库的导入" class="headerlink" title="第三方库的导入"></a>第三方库的导入</h2><ul><li>导入头文件(include 文件夹)和静态(lib)或者动态链接库(dll)</li></ul><p><img src="/BlogImg/image-20240909233954841.png" alt="导入头文件和库文件"></p><ul><li>导入头文件(include 文件夹)和源文件</li></ul><p><img src="/BlogImg/image-20240909234021144.png" alt="导入头文件和源文件"></p><h2 id="头文件目录设置"><a href="#头文件目录设置" class="headerlink" title="头文件目录设置"></a>头文件目录设置</h2><p><img src="/BlogImg/image-20240909234813783.png" alt="附加包含目录"></p><p>在 Visual Studio 中，“附加包含目录”（Additional Include Directories）是一个项目属性设置项，用于指定编译器在编译项目时需要查找的头文件目录。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>当你在代码中使用 <code>#include</code> 指令引用头文件时，编译器需要知道这些头文件的位置。编译器默认会在以下地方查找头文件：</p><ol><li><strong>当前源文件所在的目录</strong>。</li><li><strong>系统默认的包含目录</strong>（如 C++ 标准库的头文件目录）。</li></ol><p>如果你的项目中使用了自定义的头文件，或者你依赖于外部库的头文件，这些头文件可能位于编译器默认查找路径之外。此时，你需要通过“附加包含目录”将这些头文件所在的路径告诉编译器。</p><h3 id="如何设置"><a href="#如何设置" class="headerlink" title="如何设置"></a>如何设置</h3><p>在 Visual Studio 中，你可以通过以下步骤设置“附加包含目录”：</p><ol><li>右键点击你的项目，选择“属性”（Properties）。</li><li>在项目属性窗口中，导航到“配置属性”（Configuration Properties） -&gt; “C&#x2F;C++” -&gt; “常规”（General）。</li><li>在右侧的“附加包含目录”一栏中，添加需要包含的头文件目录路径。可以手动输入路径，或点击旁边的按钮选择目录。</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设你正在编译一个 C++ 项目，并且你使用了一个外部库 <code>MyLibrary</code>，它的头文件存放在 <code>C:\Libraries\MyLibrary\include</code> 目录下。在你的代码中，你可能会有这样的包含语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;MyLibrary.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>为了让编译器找到 <code>MyLibrary.h</code> 文件，你需要将 <code>C:\Libraries\MyLibrary\include</code> 路径添加到“附加包含目录”中。</p><h2 id="库文件目录设置"><a href="#库文件目录设置" class="headerlink" title="库文件目录设置"></a>库文件目录设置</h2><p><img src="/BlogImg/image-20240909235154768.png" alt="库文件目录设置"></p><p>在 Visual Studio 中，“附加库目录”（Additional Library Directories）是项目属性设置中的一项，用于指定链接器在链接阶段需要查找库文件（如 <code>.lib</code> 文件）的目录。</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>当你编写的程序需要链接到外部库（如第三方库或自己编写的库）时，链接器需要知道这些库文件的位置。库文件通常包含了程序中使用的函数、类等的预编译代码，而链接器的任务就是将这些库与您的代码结合，生成最终的可执行文件。</p><p>默认情况下，链接器会在以下地方查找库文件：</p><ol><li><strong>系统默认的库目录</strong>（例如，Windows SDK 中的库目录）。</li><li><strong>项目文件所在的目录</strong>。</li></ol><p>如果你的项目使用的库文件不在这些默认目录中，你就需要通过“附加库目录”告诉链接器这些库文件所在的位置。</p><h3 id="如何设置-1"><a href="#如何设置-1" class="headerlink" title="如何设置"></a>如何设置</h3><p>在 Visual Studio 中，你可以通过以下步骤设置“附加库目录”：</p><ol><li>右键点击你的项目，选择“属性”（Properties）。</li><li>在项目属性窗口中，导航到“配置属性”（Configuration Properties） -&gt; “链接器”（Linker） -&gt; “常规”（General）。</li><li>在右侧的“附加库目录”一栏中，添加需要包含的库文件目录路径。你可以手动输入路径，也可以点击旁边的按钮来选择目录。</li></ol><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>假设你正在编译一个 C++ 项目，并且使用了一个外部库 <code>MyLibrary</code>，其库文件存放在 <code>C:\Libraries\MyLibrary\lib</code> 目录下。在你的代码中，你可能需要链接到这个库的 <code>.lib</code> 文件。</p><p>为了让链接器找到这些库文件，你需要将 <code>C:\Libraries\MyLibrary\lib</code> 路径添加到“附加库目录”中。</p><h3 id="关联设置：附加依赖项"><a href="#关联设置：附加依赖项" class="headerlink" title="关联设置：附加依赖项"></a>关联设置：附加依赖项</h3><p>在设置了“附加库目录”后，你还需要在“附加依赖项”（Additional Dependencies）中指定要链接的具体库文件名（如 <code>MyLibrary.lib</code>），这个选项也位于链接器的属性设置中。设置路径后，链接器会在指定的“附加库目录”中查找这些库文件。</p><h3 id="lib-和-dll-的区别"><a href="#lib-和-dll-的区别" class="headerlink" title="lib 和 dll 的区别"></a>lib 和 dll 的区别</h3><h4 id="1-lib-文件"><a href="#1-lib-文件" class="headerlink" title="1. lib 文件"></a>1. <strong><code>lib</code> 文件</strong></h4><p><code>lib</code> 文件通常有两种形式，分别用于不同的目的：</p><ul><li><strong>静态库（Static Library）</strong>:<ul><li><strong>作用</strong>: 在编译时将库代码直接嵌入到可执行文件中。</li><li><strong>链接</strong>: 编译器将静态库中的代码与应用程序的代码结合，生成一个包含所有必要代码的独立可执行文件。</li><li><strong>部署</strong>: 生成的可执行文件不依赖外部库，体积会比较大，但运行时不需要额外的库文件。</li><li><strong>扩展名</strong>: <code>.lib</code></li></ul></li><li><strong>导入库（Import Library）</strong>:<ul><li><strong>作用</strong>: 为动态链接库（DLL）提供链接信息。</li><li><strong>链接</strong>: 导入库不包含实际的代码，只包含 DLL 中函数和变量的符号信息。在编译时使用导入库，告诉链接器将来需要使用特定的 DLL 文件。</li><li><strong>部署</strong>: 可执行文件在运行时依赖 DLL 文件，导入库仅在编译和链接阶段使用。</li><li><strong>扩展名</strong>: <code>.lib</code></li></ul></li></ul><h4 id="2-dll-文件"><a href="#2-dll-文件" class="headerlink" title="2. dll 文件"></a>2. <strong><code>dll</code> 文件</strong></h4><ul><li><p>动态链接库（Dynamic Link Library）:</p><ul><li><strong>作用</strong>: 提供可在运行时加载并使用的库函数和数据。DLL 文件可以被多个程序同时使用，从而节省内存和减少重复代码。</li><li><strong>链接</strong>: 在运行时加载 DLL 文件，应用程序通过动态链接来调用其中的函数。编译时，程序通过导入库（<code>.lib</code> 文件）或使用 <code>LoadLibrary</code> 等 API 函数来引用 DLL 中的函数。</li><li><strong>部署</strong>: DLL 文件需要与可执行文件一起部署。当应用程序运行时，系统会在特定目录中查找并加载 DLL 文件。</li><li><strong>扩展名</strong>: <code>.dll</code></li></ul></li></ul><h4 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. <strong>主要区别</strong></h4><ul><li><strong>链接方式</strong>:<ul><li><strong>静态库</strong>: 在编译时链接，生成的可执行文件不需要依赖外部库。</li><li><strong>动态库</strong>: 在运行时链接，可执行文件在运行时需要加载对应的 DLL。</li></ul></li><li><strong>文件扩展名</strong>:<ul><li><strong>静态库&#x2F;导入库</strong>: <code>.lib</code></li><li><strong>动态库</strong>: <code>.dll</code></li></ul></li><li><strong>内存占用</strong>:<ul><li><strong>静态库</strong>: 由于库代码被嵌入到可执行文件中，多个应用程序会各自占用内存。</li><li><strong>动态库</strong>: DLL 可以被多个程序同时加载，节省内存。</li></ul></li><li><strong>更新与维护</strong>:<ul><li><strong>静态库</strong>: 如果库代码需要更新，必须重新编译所有使用该库的程序。</li><li><strong>动态库</strong>: 更新 DLL 文件后，所有使用该 DLL 的程序都能立即受益于更新，无需重新编译。</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><strong>静态库（.lib）</strong>: 编译时链接，库代码直接嵌入到可执行文件中。</li><li><strong>动态链接库（.dll）</strong>: 运行时链接，可执行文件依赖于外部的 DLL 文件。</li><li><strong>导入库（.lib）</strong>: 用于编译时链接到 DLL，提供符号信息，但不包含实际代码。</li></ul><h2 id="链接库文件"><a href="#链接库文件" class="headerlink" title="链接库文件"></a>链接库文件</h2><p><img src="/BlogImg/image-20240909235827283.png" alt="链接库文件"></p><p>在 Visual Studio 中，“附加依赖项”（Additional Dependencies）是一个链接器设置项，用于指定在编译和链接过程中，程序需要链接的库文件（通常是 <code>.lib</code> 文件）。</p><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>“附加依赖项”告诉链接器，除了默认的系统库外，还需要链接哪些特定的库文件。库文件包含预编译的代码或数据，程序在编译和链接时将这些库中的内容整合到最终生成的可执行文件或动态链接库中。</p><h3 id="如何设置-2"><a href="#如何设置-2" class="headerlink" title="如何设置"></a>如何设置</h3><p>你可以通过以下步骤在 Visual Studio 中设置“附加依赖项”：</p><ol><li>右键点击你的项目，选择“属性”（Properties）。</li><li>在项目属性窗口中，导航到“配置属性”（Configuration Properties） -&gt; “链接器”（Linker） -&gt; “输入”（Input）。</li><li>在右侧的“附加依赖项”一栏中，输入需要链接的库文件名，文件名之间用分号隔开。例如：<code>MyLibrary.lib;AnotherLibrary.lib</code>。</li></ol><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>假设你正在编译一个项目，该项目依赖于两个外部库 <code>MyLibrary.lib</code> 和 <code>AnotherLibrary.lib</code>。你需要将这两个库的名称添加到“附加依赖项”中，如下所示：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">MyLibrary.<span class="hljs-keyword">lib</span>;AnotherLibrary.<span class="hljs-keyword">lib</span><br></code></pre></td></tr></table></figure><h3 id="与“附加库目录”的关系"><a href="#与“附加库目录”的关系" class="headerlink" title="与“附加库目录”的关系"></a>与“附加库目录”的关系</h3><p>“附加依赖项”指定了需要链接的库文件名，而“附加库目录”指定了这些库文件所在的路径。链接器会在“附加库目录”中查找“附加依赖项”中列出的库文件。如果库文件不在默认路径中，你需要在“附加库目录”中指定正确的路径，否则链接器将无法找到并链接这些库文件。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>附加依赖项</strong>: 指定在链接阶段需要链接的库文件名（通常是 <code>.lib</code> 文件）。</li><li><strong>附加库目录</strong>: 指定这些库文件所在的路径。</li></ul><h2 id="DLL-的文件设置"><a href="#DLL-的文件设置" class="headerlink" title="DLL 的文件设置"></a>DLL 的文件设置</h2><blockquote><p>就放在 main.cpp 同级目录下，具体怎么加载还不知道</p></blockquote><p><img src="/BlogImg/image-20240910000249147.png" alt="dll文件缩放位置的参考"></p><h2 id="其他源文件的导入"><a href="#其他源文件的导入" class="headerlink" title="其他源文件的导入"></a>其他源文件的导入</h2><p><img src="/BlogImg/image-20240910000425931.png" alt="新建筛选器"></p><ul><li>源文件拖拽到新建筛选器下方，导入的时候会自己找到这个源文件的，不是复制</li></ul><p><img src="/BlogImg/image-20240910000502340.png" alt="源文件拖拽到新建筛选器下方"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>各种功能测试</title>
    <link href="/2024/09/10/%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/09/10/%E5%90%84%E7%A7%8D%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h4 id="LaTex-公式"><a href="#LaTex-公式" class="headerlink" title="LaTex 公式"></a>LaTex 公式</h4><p>$$<br>J_r^{-1}(e_{ij})\approx I +\frac { 1 } { 2 }<br>\begin{bmatrix}<br>\phi_e^ { \wedge } &amp; \rho_e^ { \wedge } \<br>0 &amp; \phi_e^{\wedge} \<br>\end{bmatrix}<br>$$</p><p>$$<br>E&#x3D;mc^2<br>$$</p><h4 id="提交并更新博客"><a href="#提交并更新博客" class="headerlink" title="提交并更新博客"></a>提交并更新博客</h4><ul><li>提交仓库并更新</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo c &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><ul><li>本地更新</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo c &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis的基本使用</title>
    <link href="/2024/09/10/Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/09/10/Redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="基本命令-包含centos命令和redis的命令"><a href="#基本命令-包含centos命令和redis的命令" class="headerlink" title="基本命令(包含centos命令和redis的命令)"></a>基本命令(包含centos命令和redis的命令)</h4><p>后面的是redis的命令</p><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>redis-server</td><td>前台启动redis服务</td></tr><tr><td>redis-server redis.conf目录</td><td>后台启动redis服务</td></tr><tr><td>redis-server &#x2F;etc&#x2F;redis.conf</td><td>后台启动redis服务</td></tr><tr><td>&gt;ping</td><td>返回PONG表示redis连接成功</td></tr><tr><td>ps -ef | grep redis</td><td>显示redis的所有进程</td></tr><tr><td>kill -9 ID</td><td>杀死 ID的进程</td></tr><tr><td>redis-cli -p 6379</td><td>用6379端口启动redis,默认使用6379端口可以不用写-p 6379</td></tr><tr><td>redis-cli shutdown</td><td>单实例redis关闭</td></tr><tr><td>&gt;shutdown</td><td>关闭进入的redis实例</td></tr><tr><td>redis-cli -p 6379 shutdown</td><td>多redis实例关闭，指定端口关闭</td></tr></tbody></table><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>set key value</td><td>添加键值对</td></tr><tr><td>get key</td><td>查询对应的键值</td></tr><tr><td>append key value</td><td>将给定的value 追加到原值的末尾</td></tr><tr><td>strlen key</td><td>获得值的长度</td></tr><tr><td>setnx key value</td><td>只有在key不存在时，设置key的值</td></tr><tr><td>incr key</td><td>将key中存储的数字值增加1，只能对数字值操作，如果为空，值设置为1</td></tr><tr><td>decr key</td><td>将key中存储的数字值减少1，只能对数字值操作，如果为空，值设置为-1</td></tr><tr><td>incrby&#x2F;decrby key&gt; 步长</td><td>将 key 中储存的数字值增减步长值，步长可以为负数</td></tr><tr><td>mset key1 value1 key2 value2 …</td><td>同时设置一个或多个key-value对</td></tr><tr><td>mget key2 value2 key2 value2</td><td>同时获取一个或多个value</td></tr><tr><td>msetnx key1 value1 key2 value2</td><td>同时设置一个或多个key-value对，当且仅当所有给定key都不存在</td></tr><tr><td>getrange key 起始位置 结束位置</td><td>获得值的范围，类似java中的substring，前包，后包</td></tr><tr><td>setrange key 起始位置 value</td><td>用value 覆写key所存储的字符串值，从起始位置开始(索引从0开始)</td></tr><tr><td>set key 过期时间 value</td><td>设置键值的同时，设置过期时间，单位秒</td></tr><tr><td>getset key value</td><td>依旧换新，设置新值同时输出旧值</td></tr></tbody></table><p>Redis列表(List)</p><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>lpush&#x2F;rpush  key1 value1 key2 value2  …</td><td>从左边&#x2F;右边插入一个或多个值</td></tr><tr><td>lpop&#x2F;rpop key</td><td>从左边&#x2F;右边吐出一个值。值在键在，值光键亡</td></tr><tr><td>rpop&#x2F;lpush key1 key2</td><td>从key1列表右边吐出一个值，插到key2列表左边</td></tr><tr><td>lrange key start stop</td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>lrange mylist 0 -1</td><td>0左边第一个，-1右边第一个<br />改命令表示获得所有</td></tr><tr><td>lindex key index</td><td>按照索引下标获得元素(从左到右)</td></tr><tr><td>llen key</td><td>获得列表长度</td></tr><tr><td>linsert key before value newvalue</td><td>在value前面插入newvalue</td></tr><tr><td>lrem key n value</td><td>从左边删除n个value(从左到右)</td></tr><tr><td>lset key index value</td><td>将列表key下标为index的值替换成value</td></tr></tbody></table><p>Redis集合(set)</p><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>sadd key value1 value2</td><td>将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略</td></tr><tr><td>smembers key</td><td>取出该集合的所有值</td></tr><tr><td>sismember key value</td><td>判断集合key是否为含有该value值，有1，没有0</td></tr><tr><td>scard key</td><td>返回该集合的元素个数</td></tr><tr><td>srem key value1 value2 …</td><td>删除集合中的某个元素</td></tr><tr><td>spop key</td><td>随机从该集合中吐出一个值</td></tr><tr><td>srandmember key n</td><td>随机从该集合中取出n个值，不会从集合中删除</td></tr><tr><td>smove source destination value</td><td>把集合中一个值从一个集合移动到另一个集合</td></tr><tr><td>sinnter key1 key2</td><td>返回两个集合的交集元素</td></tr><tr><td>sunion key1 key2</td><td>返回两个集合的并集元素</td></tr><tr><td>sdiff key1 key2</td><td>返回两个集合的差集元素(key1中的，不包含key2中的)</td></tr></tbody></table><h4 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>hset key field value</td><td>给key集合中的field键赋值value</td></tr><tr><td>hget key1 field</td><td>从key1集合field取出value</td></tr><tr><td>hmset key1 field1 value1 field2 value2…</td><td>批量设置hash的值</td></tr><tr><td>hexists &lt;key1 field</td><td>查看哈希表key中，给定域field是否存在</td></tr><tr><td>hkeys key</td><td>列出该hash集合的所有field</td></tr><tr><td>hvals key</td><td>列出该hash集合的所有value</td></tr><tr><td>hincrby key field increment</td><td>为哈希表key中的域field的值加上增量increment</td></tr><tr><td>hsetnx key field value</td><td>将哈希表key中的域field的值设置为value，当且仅当域field不存在</td></tr></tbody></table><h4 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h4><p>主要是根据score来排序</p><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>zadd key score1 value1 score2 value2 …</td><td>将一个或多个member元素及其score值加入到有序key当中</td></tr><tr><td>zrange key start stop [WITHSCORES]</td><td>返回有序集key中，下标在start stop 之间的元素<br />带WITHSCORES可以让分数一起和值返回到结果集</td></tr><tr><td>zrangebyscore key minmax [withscores] [limit offset count]</td><td>返回有序集key中，所有score值介于min和max之间(包括等于min或max)的成员，有序集成员按score值递增(从小到大)次序排列</td></tr><tr><td>zrevrangebyscore</td><td>同上，改为从大到小排列</td></tr><tr><td>zincrby key increment value</td><td>为元素的score加上增量</td></tr><tr><td>zrem key value</td><td>删除该集合下指定值的元素</td></tr><tr><td>zcount key min max</td><td>统计该集合，分数区间内的元素个数</td></tr><tr><td>zrank key value</td><td>返回该值在集合中的排名，从0开始</td></tr></tbody></table><h4 id="Redis的一些相关配置"><a href="#Redis的一些相关配置" class="headerlink" title="Redis的一些相关配置"></a>Redis的一些相关配置</h4><p>配置只有保存后，并重启查看进程才能生效</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&gt; <span class="hljs-keyword">shutdown</span><br>redis-server <span class="hljs-string">/redis.conf</span>的路径<br></code></pre></td></tr></table></figure><p>注释掉bind 127.0.0.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">bind</span> 127.0.0.1</span><br></code></pre></td></tr></table></figure><p>将本机的访问保护模式设置no</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">protected-<span class="hljs-keyword">mode</span> <span class="hljs-keyword">no</span><br></code></pre></td></tr></table></figure><p>端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>设置为后台进程</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>设置密码</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">requirepass</span> foobared <span class="hljs-comment">#将foobared改为自己的密码，去掉注释就行</span><br><span class="hljs-comment"># 之后使用redis-cli登录redis后使用命令：auth 你的密码</span><br><span class="hljs-comment"># 这样就可以密码登录了 或者redis-cli -a 你的密码</span><br></code></pre></td></tr></table></figure><h4 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>subscribe channel1</td><td>需要先进入redis，订阅channel1</td></tr><tr><td>publish channel1 hello</td><td>给channel1频道发信息</td></tr></tbody></table><h4 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h4><h5 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h5><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>setbit key offset value</td><td>设置Bitmaps中某个偏移量的值（0或1）</td></tr><tr><td>getbit key offset</td><td>获取Bitmaps中某个偏移量的值</td></tr><tr><td>bitcount key [start end]</td><td>统计字符串从start字节到end字节比特值为1的数量</td></tr><tr><td>bitop and(or&#x2F;not&#x2F;xor) destkey [key]</td><td>bitop是一个符合操作，他可以做多个Bitmaps的and(交集)、or(并集)、not(非)、xor(异或)操作并将结果保存在destkey中</td></tr></tbody></table><h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>pfadd key element [element …]</td><td>添加指定元素到HyperLogLog中</td></tr><tr><td>pfcount key [key…]</td><td>计算key的近似基数</td></tr><tr><td>pfmerge destkey sourcekey [sourcekey…]</td><td>将一个或多个key合并后的结果存在另一个key中，比如每月活跃用户可以使用每天的活跃用户来合并计算得到</td></tr></tbody></table><h5 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h5><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>geoadd key logitude latitude member [longitude latitude member …]</td><td>添加地理位置(经度，纬度，名称)</td></tr><tr><td>geopos key member [member…]</td><td>获得指定地区的坐标值</td></tr><tr><td>geodis key member1 member2 [m|km|ft|mi]</td><td>获取两个位置之间的直线距离<br />(m:米(默认值),km:千米,mi:英里,ft英尺)</td></tr><tr><td>georadius key longitude latitude radius m|km|ft|mi</td><td>以给定的经纬度为中心， 找出某一半径内的元素（经度 纬度 距离 单位）</td></tr></tbody></table><h4 id="Java连接Redis"><a href="#Java连接Redis" class="headerlink" title="Java连接Redis"></a>Java连接Redis</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;192.168.137.3&quot;</span>,<span class="hljs-number">6379</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">pong</span> <span class="hljs-operator">=</span> jedis.ping();<br>System.out.println(<span class="hljs-string">&quot;连接成功：&quot;</span>+pong);<br>jedis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis_事务"></a>Redis_事务</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>multi</td><td>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行。</td></tr><tr><td>exec</td><td>同上</td></tr><tr><td>discard</td><td>组队的过程中可以通过 discard 来放弃组队</td></tr></tbody></table><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>后面还有持久化-RDB和AOF，用的时候查一下“尚硅谷的笔记”或者百度吧，暂时没练过，不知道记录啥，本人还是主要想去学一下C#和unity，要不是大数据作业，估计不会看这个[-_-||]</p><p>主从复制</p><p>lua脚本</p><p>集群</p><ul><li>缓存穿透</li><li>缓存击穿</li><li>缓存雪崩</li></ul><h4 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h4><p><a href="https://www.bilibili.com/video/BV1Rv41177Af" title="B站尚硅谷Redis学习视频">参考B站视频</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB的简单使用</title>
    <link href="/2024/09/10/MongoDB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/09/10/MongoDB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>show databases</td><td>显示当前数据库</td></tr><tr><td>show dbs</td><td>显示当前数据库</td></tr><tr><td>use 数据库名</td><td>进入指定数据库</td></tr><tr><td>db</td><td>显示当前所处数据库</td></tr><tr><td>show collections</td><td>显示数据库中所有的集合</td></tr></tbody></table><h4 id="CRUD操作（create-read-update-delete）"><a href="#CRUD操作（create-read-update-delete）" class="headerlink" title="CRUD操作（create read update delete）"></a>CRUD操作（create read update delete）</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>db.&lt;collection&gt;.insert(doc)</td><td>向集合中插入一个文档</td></tr><tr><td>db.stus.insert({name:”孙悟空”,age:18,gender:”男”})</td><td>向当前的数据库中的stus集合中插入一个学生对象{name:”孙悟空”,age:18,gender:”男”}</td></tr><tr><td>db.stus.insert([{name:”孙悟空”,age:18,gender:”男”},{name:”沙和尚”,age:22,gender:”男”},{name:”猪八戒”,age:24,gender:”男”}])</td><td>一次性插入多个</td></tr><tr><td>db.stus.insert([{_id:”hello”,name:”孙悟空”,age:18,gender:”男”},])</td><td>会自定义id</td></tr><tr><td>db.stus.insertOne({name:”孙悟空”,age:18,gender:”男”},)<br />db.stus.insertMany([{name:”孙悟空”,age:18,gender:”男”},{name:”孙悟空”,age:18,gender:”男”}])</td><td>insertOne()和insertMany()分别是用来插入一个和多个数据</td></tr><tr><td>db.&lt;collection&gt;.find()<br />-find()用来查看集合中所有符合条件的文档<br />-find()可以接收一个对象作为条件参数<br />{}表示查询集合中所有的文档<br />{属性：值}查询属性是指定值的文档</td><td>查询当前集合中的所有文档</td></tr><tr><td>db.stus.find({_id:”hello”})<br />db.stus.find({age:28,name:”白骨精”})</td><td>查询id为hello的文档<br />查询年龄为28，name为白骨精的文档</td></tr><tr><td>db.stus.find()<br />db.stus.find()[0]<br />db.stus.find()[0].name<br />db.stus.find({}).count()<br />db.stus.find().length()</td><td>查询stus中所有文档<br />查询第一个文档<br />查询第一个文档的name属性<br />查询stus集合中文档的数量，find()中有{}效果是一样的<br />作用同count()</td></tr><tr><td>db.&lt;collectioin&gt;.findOne()<br />db.&lt;collection&gt;.findOne().name</td><td>用来查询集合中符合条件的第一个<br />查询集合中第一个的name属性</td></tr><tr><td>db.&lt;collection&gt;.findOne()</td><td>查询集合中符合条件的第一个文档</td></tr></tbody></table><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>db.collection.update(查询条件，新对象)</td><td>修改查询到的对象为新对象<br />update()默认情况下会使用新对象替换旧的对象，默认替换修改一个符合条件的</td></tr><tr><td>db.stus.update({“_id”:”hello”},{$set:{name:”沙和尚”}})<br />db.stus.update({“_id”:”hello”},{$set:{gender:”女”,address:”流沙河”}})</td><td>$set: 用来修改文档中的指定属性<br />修改_id为hello的对象中name为沙和尚<br />修改_id为hello的对象中的gender为女，添加address属性</td></tr><tr><td>db.stus.update({“name”:”孙悟空”},{$set:{address:”花果山2”}},{multi:true})</td><td>添加一个{multi:true}</td></tr><tr><td>db.stus.update({“_id”:”hello”},{$unset:{address:{}}})</td><td>$unset:用来删除文档中的指定属性<br />删除_id为hello的对象中address属性，删除是根据属性删除，属性后面的值不管，可以用{}或””或者随便什么值（1也可以，简单就行）代替</td></tr><tr><td>db.&lt;collection&gt;.updateMany()</td><td>同时修改多个符合条件的文档</td></tr><tr><td>db.stus.updateMany({“name”:”孙悟空”},{$set:{address:”花果山”}})</td><td>同时将name属性为孙悟空的对象中添加一个address属性</td></tr><tr><td>db.&lt;collection&gt;.updateOne()</td><td>修改一个符合条件的文档</td></tr><tr><td>db.&lt;collection&gt;.replaceOne()</td><td>替换一个文档</td></tr></tbody></table><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>db.&lt;collection&gt;.remove()</td><td>可以根据条件来删除文档，传递的条件和find()一样，默认情况下删除符合条件的所有文档</td></tr><tr><td>db.stus.remove({age:28},true)</td><td>可以根据条件来删除stus集合中的文档,只删除一个</td></tr><tr><td>db.stus.remove({})</td><td>删除stus中的所有文档（性能略差），stus集合还在</td></tr><tr><td>db.stus.drop()</td><td>删除stus集合,如果stus集合是数据库中的最后一个，那么数据库也会被删除</td></tr><tr><td>db.dropDatabase()</td><td>删除所在的数据库</td></tr><tr><td>db.&lt;collection&gt;.deleteOne()</td><td>删除集合中的一个对象</td></tr><tr><td>db.&lt;collection&gt;.deleteMany()</td><td>删除集合中的多个对象</td></tr></tbody></table><ul><li><p>文档之间的关系</p><ul><li><p>一对一(one to one)</p><ul><li><p>夫妻（一个丈夫 对应 一个妻子）</p></li><li><p>在MongoDB可以通过内嵌文档的形式来体现出一对一的关系</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">use wifeAndHusband;<br>db.wifeAndHusband.insert([<br>&#123;<br>name:&quot;黄蓉&quot;,<br>husband:<br>&#123;<br>name:&quot;郭靖&quot;,<br>&#125;<br>&#125;,<br>&#123;<br>name:&quot;&quot;,<br>husband:<br>&#123;<br>name:&quot;武大郎&quot;,<br>&#125;<br>&#125;<br>]);<br><br>db.wifeAndHusband.find();<br></code></pre></td></tr></table></figure></li></ul></li><li><p>一对多(one to many)&#x2F;多对一(many to one)</p><ul><li><p>也可以通过内嵌文档来映射一对多的关系</p></li><li><p>父母 – 孩子</p></li><li><p>用户 – 订单</p></li><li><p>文章 – 评论</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql">db.users.insert(<br>[<br>&#123;<br>username:&quot;swk&quot;,<br>&#125;,<br>&#123;<br>username:&quot;zbj&quot;,<br>&#125;<br><br>]<br>);<br>db.users.find();<br><br>db.order.insert(<br>&#123;<br>list:[&quot;苹果&quot;,&quot;香蕉&quot;,&quot;大鸭梨&quot;],<br>user_id:ObjectId(&quot;6352bdd40a470000750024d8&quot;),<br>&#125;<br><br>);<br>db.order.find();<br><br>db.order.insert(<br>&#123;<br>list:[&quot;西瓜&quot;,&quot;葡萄&quot;,&quot;桃子&quot;],<br>user_id:ObjectId(&quot;6352bdd40a470000750024d9&quot;),<br>&#125;<br><br>);<br>db.order.find();<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查找用户swk的订单<br>var user_id <span class="hljs-operator">=</span> db.users.findOne(&#123;username:&quot;swk&quot;&#125;)._id;<br>db.order.find(&#123;user_id:user_id&#125;);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>多对多(many to many)</p><ul><li><p>分类 – 商品</p></li><li><p>老师 – 学生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>多对多<br>db.teachers.insert(<br>[<br>&#123;name:&quot;洪七公&quot;&#125;,<br>&#123;name:&quot;黄药师&quot;&#125;,<br>&#123;name:&quot;龟仙人&quot;&#125;,<br>]<br><br>);<br>db.teachers.find()<br><br><br>db.stus.insert(<br>[<br>&#123;<br>name:&quot;郭靖&quot;,<br>tech_isd:<br>[<br>ObjectId(&quot;6352c0260a470000750024dc&quot;),<br>ObjectId(&quot;6352c0260a470000750024dd&quot;),<br>]<br>&#125;,<br>&#123;<br>name:&quot;孙悟空&quot;,<br>tech_isd:<br>[<br>ObjectId(&quot;6352c0260a470000750024dc&quot;),<br>ObjectId(&quot;6352c0260a470000750024dd&quot;),<br>ObjectId(&quot;6352c0260a470000750024de&quot;),<br>]<br>&#125;,<br>]<br>);<br>db.stus.find()<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="排序和投影"><a href="#排序和投影" class="headerlink" title="排序和投影"></a>排序和投影</h4><table><thead><tr><th>命令&#x2F;示例</th><th>作用</th></tr></thead><tbody><tr><td>db.&lt;collection&gt;.find({}).sort([属性:1&#x2F;-1])</td><td>对集合中的数据进行排序<br />1表示升序，-1表示降序</td></tr><tr><td>db.stus.find({}).sort({age:1,name:-1})</td><td>对stus集合中所有的数据按照年龄升序，name降序进行排序</td></tr><tr><td>db.&lt;collection&gt;.find({},{属性:1&#x2F;0})</td><td>对集合中的数据字段进行筛选<br />1表示显示，0表示不显示</td></tr><tr><td>db.stus.find({},{name:1,_id:0,gender:1});</td><td>对stus集合中的数据，显示name和gender字段，不显示_id字段，默认显示_id字段</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询文档时，默认情况是按照创建的时间进行排序（升序），视频上说是按照_id，实际上我测试不是的，是根据创建时间进行排序<br>db.stus.find(&#123;&#125;);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>sort()可以用来指定文档的排序规则，sort()需要传递一个对象来指定排序规则，<span class="hljs-number">1</span>表示升序，<span class="hljs-number">-1</span>表示降序<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>limit <span class="hljs-keyword">skip</span> sort 可以以任意的顺序进行调用<br>db.stus.find(&#123;&#125;).sort(&#123;age:<span class="hljs-number">1</span>,name:<span class="hljs-number">-1</span>&#125;)<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>在查询时，可以在第二个参数的位置来设置查询结果的投影，<span class="hljs-number">1</span>表示显示，<span class="hljs-number">0</span>表示不显示<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>显示name，不显示_id,显示gender<br>db.stus.find(&#123;&#125;,&#123;name:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>,gender:<span class="hljs-number">1</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="mongoose的使用"><a href="#mongoose的使用" class="headerlink" title="mongoose的使用"></a>mongoose的使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.安装Mongoose</span><br><span class="hljs-comment">准备：</span><br><span class="hljs-comment">切换为淘宝镜像命令</span><br><span class="hljs-comment">npm config set registry https://registry.npm.taobao.org</span><br><span class="hljs-comment">查看当前使用的镜像地址命令</span><br><span class="hljs-comment">npm config get registry</span><br><span class="hljs-comment">如果返回 https://registry.npm.taobao.org，说明镜像配置成功。</span><br><span class="hljs-comment">切换回原镜像（安装一些package不容易报错）</span><br><span class="hljs-comment">npm config set registry https://registry.npmjs.org</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">正式安装：</span><br><span class="hljs-comment">    cnpm i mongoose --save</span><br><span class="hljs-comment">2. 在项目中引入mongoose</span><br><span class="hljs-comment">    var mongoose = require(&quot;mongoose&quot;);</span><br><span class="hljs-comment">3. 连接MongoDB数据库</span><br><span class="hljs-comment">    mongoose.connect(&#x27;mongodb://数据库Ip地址:端口号/数据库名称&#x27;,&#123;useMongoClient:true&#125;);</span><br><span class="hljs-comment">    - 如果端口号是默认端口号(27017)则可以省略不写</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4. 断开数据库连接(一般不需要调用)</span><br><span class="hljs-comment">    - MongoDB数据库，一般情况下，只需要连接一次，连接一次后，除非项目停止，服务器关闭，否则连接一般不会断开</span><br><span class="hljs-comment">    mongoose.disconnect()</span><br><span class="hljs-comment">    - 监听MongoDB数据库的连接状态</span><br><span class="hljs-comment">        - 在Mongoose对象中，有一个属性叫做connection,该对象表示的就是数据库连接</span><br><span class="hljs-comment">            通过监视该对象的状态，可以来监听数据库的连接与断开</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        数据库连接成功的事件</span><br><span class="hljs-comment">            mongoose.connection.once(&quot;open&quot;,function()&#123;&#125;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        数据库断开的事件</span><br><span class="hljs-comment">            mongoose.connection.once(&quot;close&quot;,function()&#123;&#125;);</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br><br><br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;);<br><br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;close&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接已经断开&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">//断开数据库连接</span><br>mongoose.<span class="hljs-title function_">disconnect</span>();<br></code></pre></td></tr></table></figure><h5 id="Schema和Model"><a href="#Schema和Model" class="headerlink" title="Schema和Model"></a>Schema和Model</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//import mongoose from &#x27;mongoose&#x27;;</span><br><br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;)<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Schema</span> &#125; = mongoose;<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> stuSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-attr">title</span>:  <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">gender</span>:&#123;<br>        <span class="hljs-comment">//gender是个对象，类型是String,默认值是female</span><br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&quot;female&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">address</span>:<span class="hljs-title class_">String</span>,<br>&#125;);<br><br><span class="hljs-comment">//通过Schema来创建Model</span><br><span class="hljs-comment">//Model代表的是数据库中的集合，通过Model才能鬼数据库进行操作</span><br><span class="hljs-comment">//mongoose.model(modelName, schema)</span><br><span class="hljs-comment">//modelName:就是要映射的集合名,实际映射的是students集合，mongoose会自动将集合名称变为负数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;student&#x27;</span>, stuSchema);<br><br><span class="hljs-comment">//向数据库中插入一个文档</span><br><span class="hljs-comment">//stuModel.create(doc,function(err)&#123;&#125;);</span><br><span class="hljs-comment">//doc:要插入的文档  function(err)&#123;&#125;:回调函数</span><br><span class="hljs-comment">// StuModel.create(&#123;</span><br><span class="hljs-comment">//     name:&quot;孙悟空&quot;,</span><br><span class="hljs-comment">//     age:18,</span><br><span class="hljs-comment">//     gender:&quot;male&quot;,</span><br><span class="hljs-comment">//     address:&quot;花果山&quot;,</span><br><span class="hljs-comment">// &#125;,function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;插入成功~~~&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">//会自动将属性gender设置为female</span><br><span class="hljs-title class_">StuModel</span>.<span class="hljs-title function_">create</span>(&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;白骨精&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">16</span>,<br>    <span class="hljs-attr">address</span>:<span class="hljs-string">&quot;白骨洞&quot;</span>,<br>&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!err)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;插入成功~~~&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="Model的方法"><a href="#Model的方法" class="headerlink" title="Model的方法"></a>Model的方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;)<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Schema</span> &#125; = mongoose;<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> stuSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-comment">//原本这里是title:String,自己怎么插入name都无法插入，改成name就能够插入了</span><br>    <span class="hljs-attr">name</span>:  <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">gender</span>:&#123;<br>        <span class="hljs-comment">//gender是个对象，类型是String,默认值是female</span><br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&quot;female&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">address</span>:<span class="hljs-title class_">String</span>,<br>&#125;);<br><br><span class="hljs-comment">//通过Schema来创建Model</span><br><span class="hljs-comment">//Model代表的是数据库中的集合，通过Model才能鬼数据库进行操作</span><br><span class="hljs-comment">//mongoose.model(modelName, schema)</span><br><span class="hljs-comment">//modelName:就是要映射的集合名,实际映射的是students集合，mongoose会自动将集合名称变为负数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;students&#x27;</span>, stuSchema);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * - 有了Model，我们就可以来对数据库进行增删改查的操作</span><br><span class="hljs-comment"> *  添加</span><br><span class="hljs-comment"> *  Model.create(docs,[options],[callback])</span><br><span class="hljs-comment"> *  用来创建一个文档并添加到数据库中</span><br><span class="hljs-comment"> *  参数：</span><br><span class="hljs-comment"> *  docs:可以是一个文档对象，也可以是一个文档对象的数组</span><br><span class="hljs-comment"> *  callback:当操作完成以后调用的回调函数</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  查找</span><br><span class="hljs-comment"> *  Model.find(filter,[projection],[options],[callback])</span><br><span class="hljs-comment"> *      查询所有符合条件的文档,总会返回一个数组(即便是空数组)</span><br><span class="hljs-comment"> *      filter:查询的条件</span><br><span class="hljs-comment"> *      project:投影 需要获取到的字段</span><br><span class="hljs-comment"> *          - 两种方式</span><br><span class="hljs-comment"> *              &#123;name:1,_id:0&#125;</span><br><span class="hljs-comment"> *              &quot;name -_id&quot;</span><br><span class="hljs-comment"> *      options:查询选项(skip limit)</span><br><span class="hljs-comment"> *          跳过前三个，只显示后面的一个</span><br><span class="hljs-comment"> *          &#123;skip:3,limit:1&#125;</span><br><span class="hljs-comment"> *      callback:回调函数,查询结果会通过回调函数返回，回调函数必须传，如果不传回调函数,根本不会查询</span><br><span class="hljs-comment"> *  Model.findById(id,[projection],[options],[callback])</span><br><span class="hljs-comment"> *      根据文档的id属性查询文档 总会返回一个具体的文档对象</span><br><span class="hljs-comment"> *  Model.findOne([conditioins],[projection],[options],[callback])</span><br><span class="hljs-comment"> *      查询符合条件的第一个文档 总会返回一个具体的文档对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  修改</span><br><span class="hljs-comment"> *  Model.update(filter,update,[options],[callback])</span><br><span class="hljs-comment"> *  Model.updateMany(filter,update,[options],[callback])</span><br><span class="hljs-comment"> *  Model.updateOne(filter,update,[options],[callback])</span><br><span class="hljs-comment"> *      - 用来修改一个或多个文档</span><br><span class="hljs-comment"> *      - 参数</span><br><span class="hljs-comment"> *          filter 查询条件</span><br><span class="hljs-comment"> *          update 修改后的对象</span><br><span class="hljs-comment"> *          options 配置参数</span><br><span class="hljs-comment"> *          callback 回调函数</span><br><span class="hljs-comment"> *  Model.replaceOne(filter,doc,[options],[callback])</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  删除</span><br><span class="hljs-comment"> *  Model.remove([options],[fn])</span><br><span class="hljs-comment"> *  Model.deleteOne(conditions,[options],[callback])</span><br><span class="hljs-comment"> *  Model.deleteMany(conditions,[options],[callback])</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  统计文档的数量</span><br><span class="hljs-comment"> *  Model.count(filter,[callback])</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// StuModel.create([</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         name:&quot;猪八戒&quot;,</span><br><span class="hljs-comment">//         age:28,</span><br><span class="hljs-comment">//         gender:&quot;male&quot;,</span><br><span class="hljs-comment">//         address:&quot;高老庄&quot;,</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//     &#125;,</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         name:&quot;唐僧&quot;,</span><br><span class="hljs-comment">//         age:16,</span><br><span class="hljs-comment">//         gender:&quot;male&quot;,</span><br><span class="hljs-comment">//         address:&quot;女儿国&quot;,</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//     &#125;,</span><br><span class="hljs-comment">// ],function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;插入成功~~~&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">// StuModel.create([</span><br><span class="hljs-comment">//     &#123;</span><br><span class="hljs-comment">//         name:&quot;沙僧&quot;,</span><br><span class="hljs-comment">//         age:36,</span><br><span class="hljs-comment">//         gender:&quot;male&quot;,</span><br><span class="hljs-comment">//         address:&quot;流沙河&quot;,</span><br><span class="hljs-comment">//     &#125;,</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ],function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(arguments);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">// 运行后的输出结果</span><br><span class="hljs-comment">// 0:应该就是err参数</span><br><span class="hljs-comment">// 1:就是我们插入的文档</span><br><span class="hljs-comment">// [Arguments] &#123;</span><br><span class="hljs-comment">//     &#x27;0&#x27;: null,</span><br><span class="hljs-comment">//         &#x27;1&#x27;: [</span><br><span class="hljs-comment">//         &#123;</span><br><span class="hljs-comment">//             age: 36,</span><br><span class="hljs-comment">//             gender: &#x27;male&#x27;,</span><br><span class="hljs-comment">//             address: &#x27;流沙河&#x27;,</span><br><span class="hljs-comment">//             _id: new ObjectId(&quot;6353a555d75ad742ba9e5e3d&quot;),</span><br><span class="hljs-comment">//             __v: 0</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//     ]</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 只要name属性，不要_id属性</span><br><span class="hljs-comment">// StuModel.find(&#123;name:&quot;唐僧&quot;&#125;,&#123;name:1,_id:0&#125;,function (err,docs) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(docs);</span><br><span class="hljs-comment">//         console.log(docs[0].name);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">//-_id指不要_id</span><br><span class="hljs-comment">// skip:1 指跳过第一个，显示后面的</span><br><span class="hljs-comment">// limit:1 指只显示一个</span><br><span class="hljs-comment">// StuModel.find(&#123;&#125;,&#x27;name age -_id&#x27;,&#123;skip:1,limit:1&#125;,function (err,docs) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(docs);</span><br><span class="hljs-comment">//         console.log(docs[0].name);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">//返回的是具体的对象</span><br><span class="hljs-comment">// StuModel.findOne(&#123;&#125;,function (err,doc) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(doc);</span><br><span class="hljs-comment">//         console.log(doc.name);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">//返回的是具体的对象</span><br><span class="hljs-comment">// StuModel.findById(&quot;6353ad5d5bd5fcedc0b7658b&quot;,function (err,doc) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         // console.log(doc);</span><br><span class="hljs-comment">//         // 通过find()查询的结果，返回的对象就是Document,文档对象</span><br><span class="hljs-comment">//         // Document对象是Model的实例，就是集合（StuModel）的实例</span><br><span class="hljs-comment">//         // 返回true，表示doc是StuModel的实例</span><br><span class="hljs-comment">//         console.log(doc instanceof StuModel)</span><br><span class="hljs-comment">//         // console.log(doc.name);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">// 修改唐僧的年龄为20</span><br><span class="hljs-comment">// StuModel.updateOne(&#123;name:&quot;唐僧&quot;&#125;,&#123;$set:&#123;age:20&#125;&#125;,function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;修改成功&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-comment">// collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.</span><br><span class="hljs-comment">// StuModel.remove(&#123;name:&quot;唐僧&quot;&#125;,function (err) &#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;删除成功&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br>统计集合中的文档数量<br><span class="hljs-title class_">StuModel</span>.<span class="hljs-title function_">count</span>(&#123;&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err,count</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!err)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="Document的方法"><a href="#Document的方法" class="headerlink" title="Document的方法"></a>Document的方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;)<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Schema</span> &#125; = mongoose;<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> stuSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-attr">name</span>:  <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">gender</span>:&#123;<br>        <span class="hljs-comment">//gender是个对象，类型是String,默认值是female</span><br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&quot;female&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">address</span>:<span class="hljs-title class_">String</span>,<br>&#125;);<br><br><span class="hljs-comment">//通过Schema来创建Model</span><br><span class="hljs-comment">//Model代表的是数据库中的集合，通过Model才能鬼数据库进行操作</span><br><span class="hljs-comment">//mongoose.model(modelName, schema)</span><br><span class="hljs-comment">//modelName:就是要映射的集合名,实际映射的是students集合，mongoose会自动将集合名称变为负数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;student&#x27;</span>, stuSchema);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Document 和集合中的文档一一对应，Document是Model的实例</span><br><span class="hljs-comment"> * 通过Model查询到的结果都是Document</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * document的方法</span><br><span class="hljs-comment"> *  Model#save(&#123;options&#125;,[fn])</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> stu = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StuModel</span>(&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;奔波霸&quot;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">48</span>,<br>    <span class="hljs-attr">gender</span>:<span class="hljs-string">&quot;male&quot;</span>,<br>    <span class="hljs-attr">address</span>:<span class="hljs-string">&quot;碧波谭&quot;</span>,<br>&#125;);<br><br><span class="hljs-comment">//会将文档中的信息进行保存</span><br><span class="hljs-comment">// stu.save(function(err)&#123;</span><br><span class="hljs-comment">//     if(!err)&#123;</span><br><span class="hljs-comment">//         console.log(&quot;保存成功&quot;);</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;);</span><br><br><span class="hljs-title class_">StuModel</span>.<span class="hljs-title function_">findOne</span>(&#123;&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err,doc</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!err)&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * update(update,[options],[callback])</span><br><span class="hljs-comment">         *  - 修改对象</span><br><span class="hljs-comment">         * remove([callback])</span><br><span class="hljs-comment">         *  - 删除对象</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// console.log(doc);</span><br>        <span class="hljs-comment">//这个doc就是指findOne()找到的那个对象，直接修改该对象</span><br>        <span class="hljs-comment">// doc.update(&#123;$set:&#123;age:38&#125;&#125;,function (err) &#123;</span><br>        <span class="hljs-comment">//     if(!err)&#123;</span><br>        <span class="hljs-comment">//         console.log(&quot;修改成功&quot;);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// &#125;);</span><br>        <span class="hljs-comment">//也可以直接修改findOne()获得的对象</span><br>        <span class="hljs-comment">// doc.age = 18;</span><br>        <span class="hljs-comment">// doc.save();</span><br>        <span class="hljs-comment">//直接删除findOne()获得的对象</span><br>        <span class="hljs-comment">// doc.remove(function (err) &#123;</span><br>        <span class="hljs-comment">//     if(!err)&#123;</span><br>        <span class="hljs-comment">//         console.log(&quot;二师兄再见&quot;);</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// &#125;);</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * get(name)</span><br><span class="hljs-comment">         *  - 直接获取文档中指定属性值</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *  set(name,value)</span><br><span class="hljs-comment">         *  - 设置文档的指定的属性值</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *  id</span><br><span class="hljs-comment">         *      获取文档的_id属性值</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *  toObject()</span><br><span class="hljs-comment">         *      - 将Document对象转换为一个普通的js对象</span><br><span class="hljs-comment">         *          转换为普通的js对象以后，注意所有的Document对象的方法或属性都不能使用</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 下面两个的效果相同</span><br>        <span class="hljs-comment">// console.log(doc.get(&quot;name&quot;));</span><br>        <span class="hljs-comment">// console.log(doc.name);</span><br><br>        <span class="hljs-comment">// doc.set(&quot;name&quot;,&quot;猪小小&quot;);</span><br>        <span class="hljs-comment">// doc.name = &quot;猪小小&quot;;</span><br>        <span class="hljs-comment">// console.log(doc);</span><br><br>        <span class="hljs-comment">// console.log(doc._id);</span><br>        <span class="hljs-comment">// new ObjectId(&quot;6353ee24148021db079f47db&quot;)</span><br><br>        <span class="hljs-comment">// console.log(doc.id);</span><br>        <span class="hljs-comment">// 6353ee24148021db079f47db</span><br><br>        <span class="hljs-comment">//转换为一个普通的对象</span><br>        <span class="hljs-comment">// var o = doc.toObject();</span><br>        <span class="hljs-comment">// console.log(o);</span><br><br>        <span class="hljs-comment">//转换为普通的Object后能够删除其中的address,否则不能使用delete删除数据</span><br>        doc = doc.<span class="hljs-title function_">toObject</span>();<br>        <span class="hljs-keyword">delete</span> doc.<span class="hljs-property">address</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doc);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doc.<span class="hljs-property">id</span>);<br>        <span class="hljs-comment">//undefined</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doc.<span class="hljs-property">_id</span>);<br>        <span class="hljs-comment">// new ObjectId(&quot;6353ee24148021db079f47db&quot;)</span><br>    &#125;<br><br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="mongoose的模块化"><a href="#mongoose的模块化" class="headerlink" title="mongoose的模块化"></a>mongoose的模块化</h5><p>可以在models包中创建模型，后面可以直接使用该模型，如index.js中的使用，tools包中主要是放连接mongoDB的代码，可以不用每次都重复写</p><p><a href="https://imgse.com/i/xguig1"><img src="https://s1.ax1x.com/2022/10/22/xguig1.png" alt="xguig1.png"></a></p><p>conn_mongo.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个模块，用来连接MongoDB数据库</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>student.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来定义Student的模型</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//引入</span><br><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mongoose&quot;</span>);<br><span class="hljs-comment">//连接数据库</span><br>mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://localhost:27017/test&#x27;</span>);<br>mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;open&quot;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;数据库连接成功&quot;</span>);<br>&#125;)<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">Schema</span> &#125; = mongoose;<br><br><span class="hljs-comment">//创建Schema(模式)对象</span><br><span class="hljs-keyword">const</span> stuSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(&#123;<br>    <span class="hljs-comment">//原本这里是title:String,自己怎么插入name都无法插入，改成name就能够插入了</span><br>    <span class="hljs-attr">name</span>:  <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">gender</span>:&#123;<br>        <span class="hljs-comment">//gender是个对象，类型是String,默认值是female</span><br>        <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">default</span>:<span class="hljs-string">&quot;female&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">address</span>:<span class="hljs-title class_">String</span>,<br>&#125;);<br><br><span class="hljs-comment">//定义模型</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">StuModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;students&#x27;</span>, stuSchema);<br><br><span class="hljs-comment">// exports.model = StuModel;</span><br><span class="hljs-comment">//使用该语句在index.js中就不需要.model了</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">StuModel</span>;<br></code></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入会直接执行该模块</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./tools/conn_mongo&quot;</span>);<br><span class="hljs-comment">// const Student = require(&quot;./models/student&quot;).model;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Student</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./models/student&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Student</span>);<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-title function_">find</span>(&#123;&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err,docs</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!err)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(docs);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="https://blog.csdn.net/weixin_45182409/article/details/117981169" title="csdn博客npm相关使用">npm相关配置</a></p><h4 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h4><p><a href="https://www.bilibili.com/video/BV18s411E78K" title="尚硅谷MongoDB学习视频">参考B站视频</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LaTex表示数学符号</title>
    <link href="/2024/09/10/LaTex%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"/>
    <url>/2024/09/10/LaTex%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h4 id="长期更新-慢慢添加"><a href="#长期更新-慢慢添加" class="headerlink" title="长期更新,慢慢添加"></a>长期更新,慢慢添加</h4><ul><li>因为自己有时候会学一些数学相关的东西,会用公式表示,用 LaTex 的好看啊</li><li>目录在右边,可以导航用</li><li>可能一些自己用的比较熟悉的就不添加了，目前主要添加平时会用到，但是会忘记的表示方法</li></ul><h4 id="上标-下标"><a href="#上标-下标" class="headerlink" title="上标,下标"></a>上标,下标</h4><p>$$<br>a^b<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a^b<br></code></pre></td></tr></table></figure><p>$$<br>a_b<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a_b<br></code></pre></td></tr></table></figure><p>$$<br>a^{ab}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a^&#123;ab&#125;<br></code></pre></td></tr></table></figure><p>$$<br>a_{ab}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a_&#123;ab&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\overset{B}{\rightarrow}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">\overset&#123;B&#125;&#123;\rightarrow&#125;<br></code></pre></td></tr></table></figure><p>$$<br>\underset{B}{\rightarrow}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">\underset&#123;B&#125;&#123;\rightarrow&#125;<br></code></pre></td></tr></table></figure><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><blockquote><p> 强制一个空格<br>如果需要强制插入一个空格（通常在命令中需要分隔时使用），使用 \ （反斜杠+空格）：</p></blockquote><p>$$<br>This\ is\ a\ sentence\ with\ manual\ spaces.<br>$$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs LaTex">This<span class="hljs-keyword">\ </span>is<span class="hljs-keyword">\ </span>a<span class="hljs-keyword">\ </span>sentence<span class="hljs-keyword">\ </span>with<span class="hljs-keyword">\ </span>manual<span class="hljs-keyword">\ </span>spaces.<br></code></pre></td></tr></table></figure><h5 id="不同宽度的空格"><a href="#不同宽度的空格" class="headerlink" title="不同宽度的空格"></a>不同宽度的空格</h5><blockquote><p> 调整空格的宽度</p></blockquote><table><thead><tr><th>命令</th><th>宽度</th><th>示例</th></tr></thead><tbody><tr><td><code>\,</code></td><td>1&#x2F;6 个四分之一空格</td><td><code>a\,b</code> → $a ba,bab$</td></tr><tr><td><code>\:</code></td><td>1&#x2F;2 个四分之一空格</td><td><code>a\:b</code> → $a ba:bab$</td></tr><tr><td><code>\;</code></td><td>一个四分之一空格</td><td><code>a\;b</code> → $a  ba;bab$</td></tr><tr><td><code>\quad</code></td><td>一个全宽空格</td><td><code>a\quad b</code> → $aba\quad bab$</td></tr><tr><td><code>\qquad</code></td><td>两个全宽空格</td><td><code>a\qquad b</code> → $aba\qquad bab$</td></tr><tr><td><code>\hspace&#123;n&#125;</code></td><td>自定义宽度空格</td><td><code>\hspace&#123;10pt&#125;</code></td></tr></tbody></table><h5 id="不间断空格"><a href="#不间断空格" class="headerlink" title="不间断空格"></a>不间断空格</h5><blockquote><p> 这两个单词不会分开换行</p></blockquote><p>$$<br>a~b<br>$$</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">a~b<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/10/hello-world/"/>
    <url>/2024/09/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Hello World</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用记录</title>
    <link href="/2024/09/10/git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/09/10/git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="Git-干嘛的"><a href="#Git-干嘛的" class="headerlink" title="Git 干嘛的"></a>Git 干嘛的</h4><ul><li>分布式版本控制系统</li></ul><h4 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h4><h5 id="查看-git-版本"><a href="#查看-git-版本" class="headerlink" title="查看 git 版本"></a>查看 git 版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git -v<br></code></pre></td></tr></table></figure><h5 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置用户名</span><br>git config --global user.name &quot;wing2791&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上述的用户名可以省略双引号,如果用户名有空格，则无法省略</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">省略(<span class="hljs-built_in">local</span>):本地配置,只对本地仓库有效</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--global: 全局配置,所有仓库生效</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--system: 系统配置,对所有用户生效</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置邮箱</span><br>git config --global user.email wing2791@163.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存用户名和密码，这样就不用每次都输入了</span><br>git config --global credential.helper store<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看配置信息</span><br>git config --global --list<br></code></pre></td></tr></table></figure><h5 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir learn-git<br>cd learn-git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化空仓库,会以learn-git为仓库</span><br>git init<br><span class="hljs-meta prompt_"># </span><span class="language-bash">会在learn-git文件夹下创建一个my-repo文件夹,以my-repo文件夹为仓库</span><br>git init my-repo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加仓库地址，克隆仓库到本地</span><br>git clone https//....git<br></code></pre></td></tr></table></figure><h5 id="添加和提交文件"><a href="#添加和提交文件" class="headerlink" title="添加和提交文件"></a>添加和提交文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span><br>git status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态的简略模式,??表示为跟踪，M表示修改</span><br>git status -s<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将文件添加到暂存区</span><br>git add filename.suffix<br><span class="hljs-meta prompt_"># </span><span class="language-bash">git add 支持使用通配符,只添加.txt结尾的文件</span><br>git add *.txt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以提交文件夹，提交当前文件夹</span><br>git add .<br><span class="hljs-meta prompt_"># </span><span class="language-bash">提交文件,-m表示提交时对文件信息的描述,只提交暂存区中的文件</span><br>git commit -m &quot;the first commit&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看提交记录</span><br>git log<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看简洁信息</span><br>git log --oneline<br></code></pre></td></tr></table></figure><h5 id="git-reset-回退版本"><a href="#git-reset-回退版本" class="headerlink" title="git reset 回退版本"></a>git reset 回退版本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --soft # 回退到某个版本,并且保留工作区和暂存区中的所有修改内容<br>git reset --hard # 回退到某个版本,并且丢弃工作区和暂存区的所有修改内容<br>git reset --mixed # 回退到某个版本,并且只保留工作区的修改内容，而丢弃暂存区中的内容（reset默认参数）<br>git reset --soft ID # 需要添加回退版本ID,这个需要用git log查看<br>git ls-files # 查看暂存区内容<br>git reset HEAD^ # 使用--mixed模式，HEAD^指当前 HEAD 的前一个提交<br>git reflog # 查看操作历史记录，可以查看操作的ID号，用于回退<br></code></pre></td></tr></table></figure><h5 id="git-diff-查看差异"><a href="#git-diff-查看差异" class="headerlink" title="git diff 查看差异"></a>git diff 查看差异</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git diff # 可以查看修改的内容具体是什么，默认比较工作区和暂存区的区别<br>git diff HEAD # 查看工作区和版本库的区别,HEAD指的是最新提交节点<br>git diff --cached # 查看暂存库和版本库的区别<br>git diff ID1 ID2 # 比较两个特定版本库的差异，HEAD~表示上一个版本，HEAD~2表示之前的两个版本<br>git diff ID1 ID2 file1.txt # 只查看file1.txt的修改内容<br></code></pre></td></tr></table></figure><h5 id="版本库中删除文件"><a href="#版本库中删除文件" class="headerlink" title="版本库中删除文件"></a>版本库中删除文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm file1.txt # 删除工作区中文件file1.txt<br>git add . # 更新暂存区，删除暂存区中的file1.txt<br>git rm file2.txt # 会在工作区和暂存区中都删除file2.txt<br>git commit -m &quot;information&quot;<br></code></pre></td></tr></table></figure><h5 id="gitignore-忽略文件"><a href="#gitignore-忽略文件" class="headerlink" title=".gitignore 忽略文件"></a>.gitignore 忽略文件</h5><ul><li>.gitignore 中的内容就是指所有忽略的文件名，也可以是文件夹名，文件夹名是相对于 <code>.gitignore</code> ,例如<code>temp/</code></li><li>如果文件夹是空文件夹，不会被版本管理</li><li><a href="https://git-scm.com/docs/gitignore">git 官网匹配规则</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">*.log # 就是忽略所有的.log文件<br>!a.log # 表示在*.log忽略的规则下，不忽略a.log文件<br>/TODO # 表示只忽略当前目录下的TODO文件，不忽略subdir/TODO<br>build/ # 忽略任何目录下名为build的文件夹<br>doc/*.txt # 只忽略doc文件夹下的所有.txt文件,但是不忽略doc/subdir/*.txt的文件，即不忽略子文件夹下的文件<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果某个文件已经被添加到仓库中,如忽略*.<span class="hljs-built_in">log</span>，但是仓库中有other.log，更新other.log文件的时候，也会一起更新other.log文件</span><br>doc/**/*.pdf # 葫芦doc/目录及其所有子目录下的.pdf文件<br>git rm --cached other.log # 从暂存区中移除文件 other.log<br></code></pre></td></tr></table></figure><h5 id="github-的使用和远程仓库操作"><a href="#github-的使用和远程仓库操作" class="headerlink" title="github 的使用和远程仓库操作"></a>github 的使用和远程仓库操作</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">git@github.com:wing2791/wing2791.github.io.git</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">git开头的仓库使用的是SSH协议,在push的时候不需要验证用户名和密码,但是需要在github上添加ssh公钥的配置，添加密钥的时候如果修改了名称，需要额外配置，这里不赘述</span><br>git push &lt;remote&gt; &lt;branch&gt; # 本地仓库的指定分支推送到远程仓库，这里配置好一般直接git push，配置在后面<br>git pull &lt;remote&gt; # 远程仓库拉取到本地<br></code></pre></td></tr></table></figure><h5 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git remote add &lt;shortname&gt; &lt;url&gt; # 关联一个远程仓库<br><span class="hljs-meta prompt_"># </span><span class="language-bash">git remote add roigin git@....git</span><br>git remote -v # 查看当前仓库对应的远程仓库的别名和地址<br>git branch -M main # 指定分支名为main<br>git push -u origin main:main # u是upstream的缩写,把本地仓库和别名为origin仓库的远程仓库关联起来，把本地仓库的main分支推送给远程仓库的main分支，如果本地分支和远程仓库分支名称一样,可以main:main改为main，第一个main本地分支,第二个main远程分支<br><br>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; # 拉取远程仓库修改内容，起其中仓库名和分支名都可以省略，默认为拉取仓库别名为orgin的main分支<br>git fetch # 只会获取远程仓库的修改，但是并不合并到本地仓库中，需要手动合并<br></code></pre></td></tr></table></figure><h5 id="分支的使用"><a href="#分支的使用" class="headerlink" title="分支的使用"></a>分支的使用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch 分支名 # 创建一个新的分支<br>git checkout 分支1 # 切换到分支1，checkout也可以用来恢复文件，会产生歧义，故换一个切换分支的命令切换到分支1<br>git switch 分支1 # 切换到分支1<br>git merge 分支1 # 假如现在处在main分支，运行该命令可以将分支1中的内容合并到main中<br>git log --graph --oneline --decorate --all # 查看分支图<br>git branch -d branch-name # 当branch-name被合并后，可以用-d进行删除<br>git branch -D branch-name # 强制删除分支branch-name<br></code></pre></td></tr></table></figure><h5 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -a -m &quot;commit content&quot; # -a参数会直接添加到暂存区，然后提交到本地仓库，完成两个步骤，这个只对已经添加过的文件生效，新文件无法使用，-a -m 可以写成-am<br>git status # 可以查看冲突文件的列表<br>git diff # 可以查看冲突的具体内容<br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后直接查看原文件，可以手动修改冲突内容，重新添加，提交即可</span><br>git add .<br>git commit -m &quot;commit content&quot;<br>git merge --abort # 中止合并<br></code></pre></td></tr></table></figure><h5 id="回退和-rebase"><a href="#回退和-rebase" class="headerlink" title="回退和 rebase"></a>回退和 rebase</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase branch-name<br>git checkout -b dev ID # 从指定的 ID 创建一个新分支 dev，并立即切换到这个新分支上<br>alias graph=&quot;git log --graph --oneline --decorate --all&quot; # 可以把查看图形化的提交记录命令改为graph<br></code></pre></td></tr></table></figure><p><a href="https://imgse.com/i/pA6aUaT"><img src="https://s21.ax1x.com/2024/11/09/pA6aUaT.md.png" alt="pA6aUaT.md.png"></a></p><p>merge</p><ul><li>优点<ul><li>不会破坏原分支的提交历史，方便回溯和查看</li></ul></li><li>缺点<ul><li>会产生额外的提交节点，分支图比较复杂</li></ul></li></ul><p>rebase</p><ul><li>优点<ul><li>不会新增额外的提交记录，形成线性历史，比较直观和干净</li></ul></li><li>缺点<ul><li>会改变提交历史，改变了当前分支 branch out 的节点，避免在共享分支使用</li></ul></li></ul><h5 id="分支管理和工作流模型"><a href="#分支管理和工作流模型" class="headerlink" title="分支管理和工作流模型"></a>分支管理和工作流模型</h5><p><a href="https://imgse.com/i/pA6a0G4"><img src="https://s21.ax1x.com/2024/11/09/pA6a0G4.md.png" alt="pA6a0G4.md.png"></a></p><p><a href="https://imgse.com/i/pA6aBRJ"><img src="https://s21.ax1x.com/2024/11/09/pA6aBRJ.md.png" alt="pA6aBRJ.md.png"></a></p><p><a href="https://imgse.com/i/pA6aDz9"><img src="https://s21.ax1x.com/2024/11/09/pA6aDz9.md.png" alt="pA6aDz9.md.png"></a></p><h4 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h4><h5 id="SSH设置"><a href="#SSH设置" class="headerlink" title="SSH设置"></a>SSH设置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096 -C &quot;yourname&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注：yourname为你git上的用户名或者邮箱，可以随便取，不重要</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">一般全部回车，如果之前生成过，覆盖的话输入y</span><br></code></pre></td></tr></table></figure><ul><li><p><code>ssh-keygen</code>：启动密钥生成工具。</p></li><li><p><code>-t rsa</code>：指定密钥类型为 RSA。</p></li><li><p><code>-b 4096</code>：设置密钥长度为 4096 位，增加密钥的安全性。缺省长度为 2048 位。</p></li><li><p><code>-C &quot;yourname&quot;</code>：为密钥添加注释，方便识别。注释通常是邮箱或用户名，这里使用 <code>&quot;yourname&quot;</code> 作为注释。</p></li><li><p>生成的密钥在<code>C:/Users/username/.ssh/</code>(windows)或者<code>~/.ssh/</code>(linux)下，有两个重要的文件在这个文件夹下</p></li><li><p>id_rsa</p><ul><li>私钥</li></ul></li><li><p>id_rsa.pub</p><ul><li>公钥</li></ul></li><li><p>下面用Github和windows的可视化界面操作，linux纯命令行我暂时没研究</p></li><li><p>打开<a href="https://github.com/">Github</a>，点击右上角头像</p></li></ul><p><a href="https://imgse.com/i/pA6LBM4"><img src="https://s21.ax1x.com/2024/11/10/pA6LBM4.png" alt="点击右上角头像"></a></p><ul><li><p>点击Settings设置<br><a href="https://imgse.com/i/pA6L4Qe"><img src="https://s21.ax1x.com/2024/11/10/pA6L4Qe.png" alt="点击Settings设置"></a></p></li><li><p>找到SSH and GPG keys，点击</p></li><li><p>点击 new SSH key按钮<br> <a href="https://imgse.com/i/pA6L7dI"><img src="https://s21.ax1x.com/2024/11/10/pA6L7dI.png" alt="SSH and GPG keys =&gt; new SSH key"></a></p></li><li><p>添加电脑公钥<br><a href="https://imgse.com/i/pA6LjSS"><img src="https://s21.ax1x.com/2024/11/10/pA6LjSS.png" alt=" 添加电脑公钥"></a></p></li></ul><h5 id="Github创建仓库"><a href="#Github创建仓库" class="headerlink" title="Github创建仓库"></a>Github创建仓库</h5><ul><li>找到创建仓库的按钮(New repository)<br><a href="https://imgse.com/i/pA6OKT1"><img src="https://s21.ax1x.com/2024/11/10/pA6OKT1.png" alt="找的创建仓库的按钮(New repository)"></a></li><li>创建仓库选项设置<br><a href="https://imgse.com/i/pA6OQFx"><img src="https://s21.ax1x.com/2024/11/10/pA6OQFx.png" alt="创建仓库选项设置"></a></li><li>仓库地址链接获取</li><li>HTTPS和SSH都可以，SSH需要配置上面的SSH设置</li><li>建议使用SSH<br><a href="https://imgse.com/i/pA6OlY6"><img src="https://s21.ax1x.com/2024/11/10/pA6OlY6.png" alt="仓库地址链接获取"></a></li></ul><h5 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h5><blockquote><p>这里就暂时不展示没有仓库，自己本地建一个，后续自己进阶学习的时候再补充，仓库就用上面Github创建仓库的空白仓库吧</p></blockquote><h6 id="打开VsCode终端"><a href="#打开VsCode终端" class="headerlink" title="打开VsCode终端"></a>打开VsCode终端</h6><ul><li>以VsCode为例</li><li>以某个文件夹为workspace（工作区），打开VsCode，这里就不演示了</li><li>按照下面图片打开一个新终端</li></ul><p><a href="https://imgse.com/i/pA6O20s"><img src="https://s21.ax1x.com/2024/11/10/pA6O20s.png" alt="打开一个新终端"></a></p><ul><li>右下角换一个终端，Command Prompt</li><li>我这里PowerShell没配置好，有的命令不能用</li><li>换哪个都行，我哪个能用就换哪个</li></ul><p><a href="https://imgse.com/i/pAcuUBj"><img src="https://s21.ax1x.com/2024/11/11/pAcuUBj.png" alt="换成Command Prompt终端"></a></p><ul><li><p>输入下面的命令克隆远程仓库到本地</p></li><li><p>因为我们已经进行了SSH设置，可以直接用SSH的链接进行克隆</p></li><li><p>如果代码库很大，只克隆前十次的提交结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone git@github.com:xxx/xxx.git --depth 10<br>git submodule update --init --recursive # 对于一些久远的分支，需要用这个更新子模块，暂时好像不能用，以后再说<br>git status # 查看状态，确定是否有尚未track的子模块<br># 上面两个命令我也没用过，以后再说<br></code></pre></td></tr></table></figure><p><a href="https://imgse.com/i/pAcuaHs"><img src="https://s21.ax1x.com/2024/11/11/pAcuaHs.png" alt="SSH 方式克隆代码到本地仓库"></a></p></li><li><p>因为刚下载仓库，会自动生成一个文件夹，文件夹名称就是仓库名</p></li><li><p>进入文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd 文件夹名<br></code></pre></td></tr></table></figure><p><a href="https://imgse.com/i/pAcuwEn"><img src="https://s21.ax1x.com/2024/11/11/pAcuwEn.png" alt="cd 进入克隆下来的文件夹"></a></p></li></ul><h6 id="安装插件Git-Graph"><a href="#安装插件Git-Graph" class="headerlink" title="安装插件Git Graph"></a>安装插件<code>Git Graph</code></h6><p><a href="https://imgse.com/i/pAcu0Nq"><img src="https://s21.ax1x.com/2024/11/11/pAcu0Nq.png" alt="安装插件Git Graph"></a></p><h6 id="配置Git全局信息"><a href="#配置Git全局信息" class="headerlink" title="配置Git全局信息"></a>配置Git全局信息</h6><ul><li>设置 Git 配置中的全局用户名和电子邮件地址，它们将影响你在 Git 仓库中的提交记录</li><li>如果没有设置 <code>user.name</code> 和 <code>user.email</code>，Git 会在你第一次提交时提示你配置这两个项。Git 无法在提交记录中存储作者信息，导致提交时无法使用有效的用户名和电子邮件地址。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git config --global user.name &quot;yourname&quot; # 设置 Git 提交的全局用户名为 `&quot;yourname&quot;`<br>git config --global user.email &quot;your@email.com&quot; # 设置 Git 提交的全局电子邮件地址为 `&quot;your@email.com&quot;`<br></code></pre></td></tr></table></figure></li><li>错误信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Please enter the commit message <span class="hljs-keyword">for</span> your changes. Lines starting</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">with <span class="hljs-string">&#x27;#&#x27;</span> will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># On branch main</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Your branch is up to <span class="hljs-built_in">date</span> with <span class="hljs-string">&#x27;origin/main&#x27;</span>.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Changes to be committed:</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">new file:   makefile</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">new file:   test.cpp</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">new file:   test.h</span><br></code></pre></td></tr></table></figure></li></ul><h6 id="测试的提交文件设置"><a href="#测试的提交文件设置" class="headerlink" title="测试的提交文件设置"></a>测试的提交文件设置</h6><ul><li>我这里创建了三个文件</li><li>最右边的U表示Update，M表示Modified<br><a href="https://imgse.com/i/pAcus3T"><img src="https://s21.ax1x.com/2024/11/11/pAcus3T.png" alt="添加头文件，Cpp源文件，makefile管理文件"></a></li><li>test.h<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure></li><li>test.cpp<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>makefile<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: test</span><br><br><span class="hljs-section">test: test.cpp</span><br>g++ -o test test.cpp test.h<br><br><span class="hljs-section">clean:</span><br>rm -f test<br></code></pre></td></tr></table></figure></li></ul><h6 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h6><ul><li>文字说明会在commit上，在github上能看见<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git"># 这里其实需要先提交到暂存区才行<br>git add . # 提交当前所有可提交的文件到暂存区<br># 提交文件,-m表示提交时对文件信息的描述,只提交暂存区中的文件，如果暂存区中没有文件，那么就会说no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br>git commit -m &quot;the first commit&quot; <br># git commit 只会提交该文件，并不会提交其他已暂存的文件，就算没有用add暂存到暂存区，则会个命令也可以执行成功<br># git commit -m &quot;提交某个文件的描述&quot; path/to/yourfile.txt<br></code></pre></td></tr></table></figure><a href="https://imgse.com/i/pAcu2DJ"><img src="https://s21.ax1x.com/2024/11/11/pAcu2DJ.png" alt="Commit提交VsCode操作"></a></li><li>只提交了test.h文件的修改（此时只是在本地进行了commit，还需要提交到远程仓库上）<br><a href="https://imgse.com/i/pAcGIjP"><img src="https://s21.ax1x.com/2024/11/12/pAcGIjP.png" alt="pAcGIjP.png"></a><br><a href="https://imgse.com/i/pAcGynK"><img src="https://s21.ax1x.com/2024/11/12/pAcGynK.png" alt="pAcGynK.png"></a></li></ul><h6 id="同步到远程仓库上"><a href="#同步到远程仓库上" class="headerlink" title="同步到远程仓库上"></a>同步到远程仓库上</h6><ul><li>文字说明会在提交的分支上<br><a href="https://imgse.com/i/pAcuRb9"><img src="https://s21.ax1x.com/2024/11/11/pAcuRb9.png" alt="同步到远程仓库上"></a><br><a href="https://imgse.com/i/pAcufER"><img src="https://s21.ax1x.com/2024/11/11/pAcufER.png" alt="commit提交文字说明的位置"></a></li><li>使用命令来进行提交到远程分支上<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">git push<br># 如果需要无法提交，可能是分支尚未在远程上创建，可以先publish分支，再同步<br># 或者下面命令，如果是VsCode上面直接Sync Changes，也可以<br># git push --set-upstream origin wing2791/20241111_test<br></code></pre></td></tr></table></figure><a href="https://imgse.com/i/pAcG60O"><img src="https://s21.ax1x.com/2024/11/12/pAcG60O.png" alt="pAcG60O.png"></a></li></ul><h6 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch 分支名 # 创建一个新的分支，分支叫&quot;分支名&quot;<br></code></pre></td></tr></table></figure><ul><li>创建分支wing2791&#x2F;20241111_test，并且切换到该分支<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -b wing2791/20241111_test<br></code></pre></td></tr></table></figure></li><li><strong><code>-b</code> 参数</strong>：<code>-b</code> 是 <code>git checkout</code> 命令的一个选项，它的作用是新建一个分支并立即切换到该分支上。这里的新分支基于当前所在的分支（通常是 <code>main</code> 或 <code>master</code>）。</li><li>**<code>wing2791/20241111_test</code>**：这个是新分支的名称。分支名中可以使用斜杠 <code>/</code> 来创建一种目录结构的效果。<ul><li><code>wing2791</code> 可能是开发者的标识或名字。</li><li><code>20241111_test</code> 可能表示创建分支的日期（2024年11月11日）和用途（比如“test”代表测试）。<br><a href="https://imgse.com/i/pAcGc7D"><img src="https://s21.ax1x.com/2024/11/12/pAcGc7D.png" alt="pAcGc7D.png"></a></li></ul></li><li>能看到左边有个Publish分支的按钮</li><li>按过之后就能够在github（远程仓库上）上看见新建的分支了<br><a href="https://imgse.com/i/pAcG2Ae"><img src="https://s21.ax1x.com/2024/11/12/pAcG2Ae.png" alt="pAcG2Ae.png"></a><br><a href="https://imgse.com/i/pAcGWhd"><img src="https://s21.ax1x.com/2024/11/12/pAcGWhd.png" alt="pAcGWhd.png"></a></li></ul><h6 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git switch 分支1 # 切换到分支1<br></code></pre></td></tr></table></figure><h6 id="随便修改了源文件，能看见git那里多了这个"><a href="#随便修改了源文件，能看见git那里多了这个" class="headerlink" title="随便修改了源文件，能看见git那里多了这个"></a>随便修改了源文件，能看见git那里多了这个</h6><ul><li>四个图标意思是<ul><li>打开修改的文件</li><li>撤销本次修改</li><li>将修改暂存在暂存区中，类似上面的Staged Changes  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git"># 对应命令为,添加test.h文件到暂存区中<br>git add test.h<br></code></pre></td></tr></table></figure></li><li>M 表示文件被修改，Modify<br><a href="https://imgse.com/i/pAcGh9A"><img src="https://s21.ax1x.com/2024/11/12/pAcGh9A.png" alt="pAcGh9A.png"></a></li></ul></li><li>点击test.cpp那里，可以看到具体的文件修改了哪里<br><a href="https://imgse.com/i/pAcG41I"><img src="https://s21.ax1x.com/2024/11/12/pAcG41I.png" alt="pAcG41I.png"></a></li></ul><h6 id="如果想要某一次提交的基础上创建新分支，怎么办"><a href="#如果想要某一次提交的基础上创建新分支，怎么办" class="headerlink" title="如果想要某一次提交的基础上创建新分支，怎么办"></a>如果想要某一次提交的基础上创建新分支，怎么办</h6><p><a href="https://imgse.com/i/pAgP1TU"><img src="https://s21.ax1x.com/2024/11/13/pAgP1TU.png" alt="pAgP1TU.png"></a></p><p><a href="https://imgse.com/i/pAgP8kF"><img src="https://s21.ax1x.com/2024/11/13/pAgP8kF.png" alt="pAgP8kF.png"></a></p><p><a href="https://imgse.com/i/pAgPGY4"><img src="https://s21.ax1x.com/2024/11/13/pAgPGY4.png" alt="pAgPGY4.png"></a></p><ul><li><p>空心圆表示当前在这里<br><a href="https://imgse.com/i/pAgPJfJ"><img src="https://s21.ax1x.com/2024/11/13/pAgPJfJ.png" alt="pAgPJfJ.png"></a></p></li><li><p>此时创建新分支，就是在某个提交点上创建的新分支<br><a href="https://imgse.com/i/pAgPtp9"><img src="https://s21.ax1x.com/2024/11/13/pAgPtp9.png" alt="pAgPtp9.png"></a><br><a href="https://imgse.com/i/pAgPU61"><img src="https://s21.ax1x.com/2024/11/13/pAgPU61.png" alt="pAgPU61.png"></a></p></li><li><p>用命令就比较麻烦，需要知道第一列（提交哈希值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git log --oneline<br></code></pre></td></tr></table></figure><p><a href="https://imgse.com/i/pAgPaOx"><img src="https://s21.ax1x.com/2024/11/13/pAgPaOx.png" alt="pAgPaOx.png"></a></p></li><li><p>进入<code>20241111测试冲突1</code>的提交的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git switch --detach 1ac9efa<br></code></pre></td></tr></table></figure><p><code>--detach</code> 参数使 Git 进入分离头指针模式（detached HEAD），这样你可以查看或操作该提交的内容而不会影响当前分支。<br><a href="https://imgse.com/i/pAgPBTO"><img src="https://s21.ax1x.com/2024/11/13/pAgPBTO.png" alt="pAgPBTO.png"></a></p></li><li><p>先创建新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git branch switch转换多步创建的新分支<br></code></pre></td></tr></table></figure></li><li><p>再进入新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git switch switch转换多步创建的新分支<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/13/w3AzTZofuKH1gEy.png" alt="Pasted image 20241111113459.png"><br><img src="https://s2.loli.net/2024/11/13/O8fuWaCi6EQ1lN7.png" alt="Pasted image 20241111113508.png"></p></li><li><p>使用下面的命令可以直接进入某个提交节点，然后创建并进入新分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -b new-branch-name 提交哈希值<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/13/1XdzvksOFA3jtCa.png" alt="Pasted image 20241111113225.png"></p></li></ul><h6 id="撤回上一次修改"><a href="#撤回上一次修改" class="headerlink" title="撤回上一次修改"></a>撤回上一次修改</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --soft HEAD^<br># git push -f # 如果提交不上去，使用强制提交<br></code></pre></td></tr></table></figure><p><code>git reset --soft HEAD^</code> 的作用是将当前分支的指针（<code>HEAD</code>）回退到上一个提交（<code>HEAD^</code>），但保留工作区和暂存区的内容。指的是当前分支中最新的一次提交，如果自己在当前分支的其他很久之前的提交的地方，它修改的也是最新的上一次提交，而不是当前的提交</p><p>具体解释如下：</p><ol><li><strong>HEAD^</strong>：表示上一个提交。<code>HEAD</code> 指向当前提交，而 <code>HEAD^</code> 就是它的上一个提交。</li><li>**<code>--soft</code>**：表示回退提交时只移动 <code>HEAD</code> 的位置，不会影响暂存区或工作区。也就是说，回退后的代码依然会停留在暂存区中，文件的修改依旧可以直接提交。<br><img src="https://s2.loli.net/2024/11/13/yLlsUzo8xROnuqJ.png" alt="Pasted image 20241111113827.png"><br><img src="https://s2.loli.net/2024/11/13/V64DrTk7WpmGF1O.png" alt="Pasted image 20241111113821.png"><br><img src="https://s2.loli.net/2024/11/13/Y73wPtTKR4IzVbN.png" alt="Pasted image 20241111113933.png"></li></ol><h6 id="如何切换远程仓库呢"><a href="#如何切换远程仓库呢" class="headerlink" title="如何切换远程仓库呢?"></a>如何切换远程仓库呢?</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git remote -v<br></code></pre></td></tr></table></figure><p><code>git remote -v</code> 命令用于查看当前 Git 仓库的远程仓库 URL 配置。它会显示所有关联的远程仓库及其 URL，通常用于验证远程仓库的配置，或查看你项目所连接的 Git 远程仓库。<br>输出格式通常是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">origin  https://github.com/username/repository.git (fetch)<br>origin  https://github.com/username/repository.git (push)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>origin</code> 是远程仓库的名称（默认远程仓库通常叫做 <code>origin</code>）。</li><li><code>https://github.com/username/repository.git</code> 是仓库的 URL。</li><li><code>(fetch)</code> 和 <code>(push)</code> 分别表示该 URL 用于拉取（fetch）和推送（push）操作。</li></ul><p>如果有多个远程仓库，<code>git remote -v</code> 会列出所有远程仓库的 URL 配置信息。<br><img src="https://s2.loli.net/2024/11/13/SNXHEZUehR5FipV.png" alt="Pasted image 20241111114506.png"></p><ul><li><p>添加一个新的远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git remote add origin2 git@github.com:wing2791/ProjectTest.git<br></code></pre></td></tr></table></figure><p><code>git remote add origin2 git@github.com:wing2791/ProjectTest.git</code> 这个命令的作用是向当前 Git 仓库添加一个新的远程仓库，并命名为 <code>origin2</code>。</p></li><li><p>解释</p><ul><li>**<code>git remote add</code>**：用于添加一个新的远程仓库。</li><li>**<code>origin2</code>**：这是远程仓库的别名（你可以自由命名，常见的是使用 <code>origin</code> 来指代默认的远程仓库）。在这个例子中，使用 <code>origin2</code> 作为别名，你可以通过这个别名来引用远程仓库。</li><li>**<code>git@github.com:wing2791/ProjectTest.git</code>**：这是远程仓库的 URL。这里使用的是 SSH 协议（<code>git@github.com</code>），它通过 SSH 密钥进行认证。<br><img src="https://s2.loli.net/2024/11/13/OMYvIaNu3wlpAhW.png" alt="Pasted image 20241111114849.png"></li></ul></li><li><p>获取别名为origin2的仓库的数据<br><code>git fetch origin2 --depth 10</code> 这个命令的作用是从名为 <code>origin2</code> 的远程仓库获取数据，并且仅限于获取最新的 10 次提交（深度为 10）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git fetch origin2 --depth 10<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/13/XtWMoGj8JusSbzI.png" alt="Pasted image 20241111115310.png"><br>例如，如果你要从远程仓库 <code>origin2</code> 的 <code>feature_branch</code> 分支切换到本地，命令如下：</p></li><li><p>作用是本地创建一个新的分支<code>feature_branch</code>，从远程的<code>origin2/feature_branch</code>下分出来的</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature_branch origin2/feature_branch<br></code></pre></td></tr></table></figure><ul><li>但是如果只是切换到指定的分支，在该分支下操作，暂时没找到，可以可视化操作，命令必须指定实际分支名，不能是哈希值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git switch master<br></code></pre></td></tr></table></figure></li><li>这里是每个分支名都不一样，如果原来的两个分支名一样，是不是不能导入呢</li><li>测试过了可以导入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git switch --detach origin2/master # origin2是仓库别名，master是origin2下的分支名<br>git switch master # 重新切换origin2下的master就可以啦<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2024/11/13/5WGNhPkmi64doHj.png" alt="Pasted image 20241111130053.png"><br><img src="https://s2.loli.net/2024/11/13/ylwTrgvZMtmQAb9.png" alt="Pasted image 20241111130738.png"><br><img src="https://s2.loli.net/2024/11/13/ZcUQv7CARa6Xnux.png" alt="Pasted image 20241111130819.png"></p><p>在 Git 中，<code>--detach</code> 选项用于让你进入“分离头指针（detached HEAD）”状态。</p><p>当你使用 <code>git switch --detach origin2/master</code> 时，你会切换到 <code>origin2/master</code> 远程分支的最新提交，但 <strong>不会创建本地分支</strong>，并且 <strong>HEAD 不再指向任何本地分支</strong>，而是直接指向该提交。这种状态叫做“分离头指针”状态。</p><ul><li>分离头指针（detached HEAD）状态</li></ul><ol><li><strong>没有本地分支</strong>：在“分离头指针”状态下，HEAD 直接指向某个提交（如 <code>origin2/master</code>），而不是本地的某个分支。</li><li><strong>临时状态</strong>：你仍然可以在该状态下查看和修改代码，但如果在此状态下提交更改，这些更改将不会直接影响任何分支。除非你显式创建新的分支，否则这些提交将“游离”，无法轻易访问。</li><li><strong>提交后不会自动保存</strong>：如果你在 <code>--detach</code> 状态下进行了提交，但没有创建一个新的分支来保存这些提交，那么这些提交可能会丢失。如果你切换回其他分支或退出当前状态，这些提交将不再可访问。</li></ol><ul><li>举个例子：<br>假设你在 <code>origin2/master</code> 上使用 <code>git switch --detach</code>，你处于一个分离头指针的状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch --detach origin2/master<br></code></pre></td></tr></table></figure>此时，你可以修改文件并提交更改，但这些更改并不会直接影响 <code>master</code> 分支。如果你想保留这些更改，你需要创建一个新的本地分支：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch -c new-branch<br></code></pre></td></tr></table></figure></li></ul><p>这样，你就创建了一个新的本地分支，且它会包含你在分离头指针状态下所做的提交。</p><ul><li>为什么使用 <code>--detach</code>？<ul><li><strong>临时查看历史</strong>：如果你想查看远程分支上的提交，但不想修改本地分支的状态，可以使用 <code>--detach</code>，它允许你暂时查看和操作历史，而不会改变当前分支的内容。</li><li><strong>避免影响本地工作</strong>：它通常用于查阅历史、测试某些提交或操作代码而不想立即创建新分支或改变工作状态。</li></ul></li></ul><h6 id="git-fetch和git-pull，git-clone有啥区别呢"><a href="#git-fetch和git-pull，git-clone有啥区别呢" class="headerlink" title="git fetch和git pull，git clone有啥区别呢"></a>git fetch和git pull，git clone有啥区别呢</h6><p><code>git fetch</code>、<code>git pull</code> 和 <code>git clone</code> 是 Git 中用来与远程仓库交互的不同命令，它们的作用有所不同。下面是它们的区别：</p><ol><li><code>git clone</code>：</li></ol><ul><li><strong>作用</strong>：<code>git clone</code> 是用来从远程仓库复制整个仓库到本地的命令。它不仅会下载远程仓库的所有提交记录，还会创建一个新的本地仓库，并将当前远程仓库的内容和分支设置为本地仓库的默认内容。</li><li><strong>特点</strong>：<ul><li>一开始使用 <code>git clone</code> 会把远程仓库的整个历史记录、分支等数据拉取到本地。</li><li>克隆时，会自动创建 <code>origin</code> 作为远程仓库的默认名称，指向你克隆的仓库。</li><li>克隆会包括所有分支、标签和文件。</li></ul></li><li><strong>使用场景</strong>：适用于第一次从远程仓库创建本地仓库时。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/username/repository.git<br></code></pre></td></tr></table></figure><p>这会将远程仓库复制到本地。</p><ol start="2"><li><code>git fetch</code>：</li></ol><ul><li><strong>作用</strong>：<code>git fetch</code> 是用来从远程仓库获取最新的提交、分支、标签等信息，但不会自动将其合并到本地分支。它更新本地远程跟踪分支的内容，并且不会影响当前的工作目录或本地分支。</li><li><strong>特点</strong>：<ul><li>只拉取数据到本地，并更新远程追踪分支。</li><li>不会自动合并，用户需要手动决定如何处理远程的更新（通常使用 <code>git merge</code> 或 <code>git rebase</code>）。</li></ul></li><li><strong>使用场景</strong>：适用于你想查看远程仓库更新，但不想立刻合并的情况。通过 <code>git fetch</code>，你可以先查看远程仓库的更新，再决定是否合并到本地分支。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin<br></code></pre></td></tr></table></figure>这会拉取 <code>origin</code> 仓库的所有更新，但不会自动合并到当前分支。</li></ul><ol start="3"><li><code>git pull</code>：</li></ol><ul><li><strong>作用</strong>：<code>git pull</code> 是 <code>git fetch</code> 和 <code>git merge</code> 的结合。它先从远程仓库拉取最新的更新，再自动将这些更新合并到当前分支。如果没有冲突，合并会直接完成；如果有冲突，则需要手动解决。</li><li><strong>特点</strong>：<ul><li>拉取数据并自动合并更新到当前分支。</li><li>默认情况下，<code>git pull</code> 会执行一次 <code>git fetch</code>，然后执行一次合并（<code>git merge</code>）。</li></ul></li><li><strong>使用场景</strong>：适用于你希望获取远程仓库的更新并立即与本地分支合并的情况。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin master<br></code></pre></td></tr></table></figure></li></ul><p>这会拉取远程 <code>origin</code> 仓库的 <code>master</code> 分支的更新，并合并到当前的本地分支。</p><ul><li>总结：<ul><li><code>git clone</code>：用于克隆远程仓库到本地，第一次从远程仓库创建本地副本。</li><li><code>git fetch</code>：从远程仓库拉取最新的数据（如提交、分支等），但不会自动合并到本地分支。</li><li><code>git pull</code>：从远程仓库拉取数据并自动合并到当前本地分支。</li></ul></li></ul><h6 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h6><ul><li>将<code>switch转换多部创建的新分支</code>合并到main分支上（也就是当前操作的分支）<br><img src="https://s2.loli.net/2024/11/13/GDVYiWwQeXUoCM1.png" alt="Pasted image 20241111120255.png"></li><li>发生冲突，需要手动解决冲突<br><img src="https://s2.loli.net/2024/11/13/Bx2gI37YKuAJr8i.png" alt="Pasted image 20241111120400.png"></li></ul><p><img src="https://s2.loli.net/2024/11/13/mlyqp3wuVBPDZge.png" alt="Pasted image 20241111120719.png"></p><ul><li><p>Accept Incomming&#x2F; Accept表示冲突接收当前文档的修改</p></li><li><p>Accept Combination(Incoming First)&#x2F;Accept Combination(Current First)表示合并两个冲突的文档，但是谁放在前面的修改</p></li><li><p>Ignore 表示不需要文档的这个内容</p></li><li><p>修改完冲突后，直接commit就可以啦<br><img src="https://s2.loli.net/2024/11/13/3YIptP1dbLkNDHG.png" alt="Pasted image 20241111120804.png"><br><img src="https://s2.loli.net/2024/11/13/A9q3Nesbfg4nxHv.png" alt="Pasted image 20241111121257.png"></p></li><li><p>回退上一次合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git reset --hard HEAD~1<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/11/13/ERlI4nJf63pvMHu.png" alt="Pasted image 20241111121611.png"></p></li><li><p>将某个特定的提交，引入当前分支</p></li><li><p>不过还是需要有某个特定提交的哈希值，使用<code>git log --oneline</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git cherry-pick &lt;commit_hash&gt;<br></code></pre></td></tr></table></figure></li><li><p>或者使用git Graph看一下，这个Commit就是提交哈希值<br><img src="https://s2.loli.net/2024/11/13/vYkJC5dexBqtOWE.png" alt="Pasted image 20241111122737.png"></p></li><li><p>合并后有冲突，解决冲突<br><img src="https://s2.loli.net/2024/11/13/ET56cPaqGnAS8Np.png" alt="Pasted image 20241111122838.png"><br><img src="https://s2.loli.net/2024/11/13/eFh5yXSR2U9vzDm.png" alt="Pasted image 20241111122924.png"></p></li></ul><h4 id="其他待补充"><a href="#其他待补充" class="headerlink" title="其他待补充"></a>其他待补充</h4><ul><li>git 的权限管理</li><li>在不同编辑器上的使用（Vstudio）</li><li>可视化 git 管理工具</li><li><del>实际使用的例子</del></li></ul><h4 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h4><p><a href="https://www.bilibili.com/video/BV1HM411377j">【GeekHour】一小时 Git 教程</a><br><a href="https://www.bilibili.com/video/BV1Fw4m1C7Tq/">SSH+Git+Gitee+Vscode 学会了就是代码管理大师</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>github部署个人博客</title>
    <link href="/2024/09/10/github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/09/10/github%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/clearloe/article/details/139879493">Hexo 博客搭建并部署到 GitHub Pages(2024 最新详细版)</a></p><h4 id="安装-VsCode"><a href="#安装-VsCode" class="headerlink" title="安装 VsCode"></a>安装 VsCode</h4><p><a href="https://blog.csdn.net/msdcp/article/details/127033151">VSCode 安装配置使用教程（最新版超详细保姆级含插件）一文就够了</a></p><p><a href="https://code.visualstudio.com/Download">VsCode 下载链接</a></p><ul><li>如果无法下载，可以选择在电脑的应用商城里面下载，我记得是要挂梯子才能官网下载</li><li>安装就是正常安装，建议别 C 盘</li></ul><h4 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h4><p><a href="https://blog.csdn.net/qq_45730223/article/details/131693287">Git 安装详解（写吐了，看完不后悔）</a></p><ul><li>很常用的软件，程序员必装，按照教程装就好了，不过有时候验证有问题，也要梯子</li></ul><h4 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h4><p><a href="https://blog.csdn.net/weixin_44893902/article/details/121788104">node.js 安装及环境配置超详细教程【Windows 系统安装包方式】</a></p><blockquote><p>搬运上述链接评论<br>Node.js Express 安装报错总结<br>express 4.x 版本之前 全局安装 express 命令是 npm install express -g<br>express 4.x 版本之后 全局安装 express 命令是 npm install -g express-generator</p></blockquote><h4 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h4><p><a href="https://www.cnblogs.com/zhujingxiu/articles/7462025.html" title="发布于 2017-09-01 10:34">Win10 任意目录下默认快速以管理员身份运行 CMD</a><br><a href="https://blog.csdn.net/clearloe/article/details/139879493">安装 hexo 参考博客链接</a><br><a href="https://blog.csdn.net/qq_42786011/article/details/123895927">运行 npm install 不动时</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">//  配置nmp代理来提高速度，如设置淘宝镜像<br>npm config set registry  https://registry.npmmirror.com/<br><br>// 查看配置是否成功<br>npm config get registry<br><br>// 成功后重新npm install安装<br>// npm install 。。。<br></code></pre></td></tr></table></figure><h4 id="更新文章"><a href="#更新文章" class="headerlink" title="更新文章"></a>更新文章</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">提交远程仓库更新</span><br>hexo c &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">本地更新</span><br>hexo c &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><h4 id="遇上的错误，解决方法供参考"><a href="#遇上的错误，解决方法供参考" class="headerlink" title="遇上的错误，解决方法供参考"></a>遇上的错误，解决方法供参考</h4><h5 id="fatal-detected-dubious-ownership-in-repository"><a href="#fatal-detected-dubious-ownership-in-repository" class="headerlink" title="fatal: detected dubious ownership in repository"></a>fatal: detected dubious ownership in repository</h5><p><a href="https://stackoverflow.com/questions/73408170/git-fatal-detected-dubious-ownership">参考博客</a></p><p><img src="https://s21.ax1x.com/2024/09/10/pAm8py6.png" alt="202407281829173"></p><ul><li>解决方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global --add safe.directory *<br></code></pre></td></tr></table></figure><h5 id="安装-Pandoc，运行-Pandoc-有误，说找不到命令"><a href="#安装-Pandoc，运行-Pandoc-有误，说找不到命令" class="headerlink" title="安装 Pandoc，运行 Pandoc 有误，说找不到命令"></a>安装 Pandoc，运行 Pandoc 有误，说找不到命令</h5><blockquote><p>主要问题是我的 360 会自动删除 pandoc.exe,我在 360 软件管家中的隔离区恢复了就行</p></blockquote><p><a href="https://github.com/jgm/pandoc/blob/master/INSTALL.md">pandoc 安装地址</a></p><p>正常安装是有下面的四个文件，如果少了 exe 需要按照上面的进行恢复</p><p><img src="https://s21.ax1x.com/2024/09/10/pAm8iwD.png" alt="202407281832443"></p><h5 id="Hexo-使用-markdown-插入图片无法显示解决方法（废弃，直接找网络图床，https-的）"><a href="#Hexo-使用-markdown-插入图片无法显示解决方法（废弃，直接找网络图床，https-的）" class="headerlink" title="Hexo 使用 markdown 插入图片无法显示解决方法（废弃，直接找网络图床，https 的）"></a>Hexo 使用 markdown 插入图片无法显示解决方法（废弃，直接找网络图床，https 的）</h5><blockquote><p>免费图床：<a href="https://imgse.com/">https://imgse.com/</a><br>每天八张</p></blockquote><p><a href="https://www.jianshu.com/p/04814a816caf">参考博客</a></p><ul><li><p>安装插件</p><ul><li><p>先进入自己 blog 的目录<br><img src="https://s21.ax1x.com/2024/09/10/pAm8PeO.png" alt="image-20240728203701626"></p></li><li><p>用命令安装（如果第二次使用还是失效，重新运行下列命令，会重新安装一遍，再弄就是可以了，具体的解决方案没找到）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># npm install https://github.com/7ym0n/hexo-asset-image --save # 已经失效，换一个</span><br>npm install hexo-asset-img --save<br></code></pre></td></tr></table></figure></li><li><p>运行下列命令，提交本地查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s # 本地查看<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d # 上传到github<br></code></pre></td></tr></table></figure></li></ul></li><li><p>修改 hexo 根目录下的_config.yml 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">post_asset_folder: <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br>url: http://yourname.github.io<br></code></pre></td></tr></table></figure></li><li><p>插入图片</p><ul><li>我用的是 typora，直接设置如下，然后复制图片，直接到文件中即可</li></ul><p><img src="https://s21.ax1x.com/2024/09/10/pAm8FTe.png" alt="image-20240728204034558"></p><p><img src="https://s21.ax1x.com/2024/09/10/pAm8AFH.png" alt="image-20240728204107912"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">![xx](xx/xx.png)<br></code></pre></td></tr></table></figure></li></ul><h4 id="其他可能用得上的网址"><a href="#其他可能用得上的网址" class="headerlink" title="其他可能用得上的网址"></a>其他可能用得上的网址</h4><p><a href="https://hexo.io/zh-cn/docs">Hexo 官方中文文档</a><br><a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-游戏(一)</title>
    <link href="/2024/09/10/%E6%9D%82%E8%B0%88-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/09/10/%E6%9D%82%E8%B0%88-%E6%B8%B8%E6%88%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="游戏杂谈"><a href="#游戏杂谈" class="headerlink" title="游戏杂谈"></a>游戏杂谈</h3><h4 id="双人成行"><a href="#双人成行" class="headerlink" title="双人成行"></a>双人成行</h4><p><img src="https://s2.loli.net/2022/07/20/dxheYjZ9R7vU5iw.png" alt="双人成行.png"></p><p>游玩：本人也是正经的玩过全流程的，和 Z 同学一点点摸索着玩，但是由于 origin 平台实在是连接困难，加上网络不好，在线游玩属实是体验不好，总是会掉线，玩着玩着就开始卡顿，掉线，每次重新连接大概五分钟，挺折磨人的耐心。</p><p>另外关于游玩方面，Z 同学和我都不是高玩，玩起来其实也挺痛苦的，某些关卡对我们来说还挺需要操作和反应速度的，比如有的关卡自己需要在几秒内就跑到指定的位置，错了就要重来，但好在只要成功一次就能够过关，后面会自动保存。有些 Boss 打起来也挺费时间的，例如有个黄蜂的 Boss，那个需要科迪先喷糖浆，小梅后面才能够攻击，而 Boss 还有一些小兵蜜蜂保护，这是一个需要跨过去的坎，游玩过程自己的鼠标都快费了，虽然是自动瞄准，但也是有判定范围的，最后鼠标都移动困难了。</p><p>关卡在设计方面非常有新意，是我玩过的游戏中不可多得的必玩游戏，可惜需要有一个朋友，配置要求极高。前期的关卡设计挺多，也有剧情，不过都 Q 掉了，后面几大章节明显不如前几关，而且神庙逃亡太多了，颜色也过于鲜艳，属于虎头蛇尾了，但是质量还是高于大多数同类游戏。音乐方面不评价，没咋注意，游戏难度听说是动态的，在某一关待久了听说会降低难度，方便手残玩家，但耗时间，适合平时时间长放松可以试一下，没时间不适合玩，比如累死晚上十点回家，这个游戏建议别试着玩了。</p><h4 id="影之诗"><a href="#影之诗" class="headerlink" title="影之诗"></a>影之诗</h4><p><img src="https://s2.loli.net/2022/07/20/jKwHk72dgOFYVmi.jpg" alt="影之诗.jpg"></p><p>游玩：算是老玩家了，在起焉之光版本入坑，大概一两周后碧蓝骑士版本（在国服，当时国际服应该早就碧蓝骑士版本了），中间退坑过一年的时间，大概就是疫情那段时间，去玩昆特牌了，没碰影之诗，拿过三个版本 GM，优点是无聊，缺点也是无聊。国服的福利极好，随便肝一下每日任务就行，基本上每个版本的所有卡都能拿到，还会有剩余的资源。但是为什么退坑，就是太无聊了，稍微娱乐一点点的卡组就不能玩，而且渐渐的很多东西都脱离实际了，很多职业特色都没有了，像暗夜伯爵原本非常好的一张鬼妈（8 费用，4 攻击，4 生命，虹卡，荣耀再临版本），原来效果是从卡堆里抽到手上时消失，直接无条件复仇，俗称点灯，后来削过后就没意思了，主战者生命上限直接少了一半，对手稍微打一下就输了，而且国服版本特别难玩，稍微有一点不顺就会输，任务有时候打三四个小时都做不好，而且后面设计的卡越来越膨胀，膨胀就算了，还膨胀的特别快，官方削弱卡牌一削弱就不能用，会不会削弱啊，卡牌不会设计就算了，削弱也是一刀切。我最关心的其实是双人模式，可惜一直没出，出不出都不会去玩了，毕竟是二次元游戏，我反而重视游戏性，玩 steam 挺好。</p><h4 id="洛克王国"><a href="#洛克王国" class="headerlink" title="洛克王国"></a>洛克王国</h4><p><img src="https://s2.loli.net/2022/07/20/lRL6wrIn75jkmyX.png" alt="洛克王国.png"></p><p>游玩：也算是个老玩家，基本前期游玩的样子都知道，疫情的时候也是玩到了高级训练师，系别排位也是圣魔导师。前期洛克王国感觉更像是经营类的游戏，战斗没有任何技巧可言，就是想办法控制对面（催眠粉，以及后面的瓦斯叮当的生命火焰，或者雪影娃娃的冰晶结界和冰龙王的嗜血寒冰冰冻），找一个 C 位进行强化进行推队，简单得很，看运气。但是现在的战斗很有趣，基本都是会玩的能够碾压不会玩的，已经不是以前的过家家了，从前期的收集、逛街重点倾向于战斗了，我玩过，很有趣，但是也无聊，每场战斗少则二十分钟，多则上小时，每天十把，累死人，而且网络极度不稳定，极度极度不稳定，退坑原因一方面就是这个，战斗我觉得比王者啥的好多了，操作运营一点不输王者那些游戏，另一方面是 flash 游戏，已经淘汰的技术，网页大多数不支持且有广告。另外前期洛克王国剧情极好，后期就是现在的剧情完全就是白开水，只会玩梗，一点感情没有，看其他大佬分析，游戏封面也敷衍起来了，以前是剧情为主，每周任务也很好，至少挺人性化，现在随便放几个花盆宠，而且每周任务特别恶心人，费时费力，不用辅助手刷我是时间多了没事干啊，游戏已经到了末期了，另外论坛也是很让人头疼的地方。最后提一嘴，氪金吗？也挺氪金的，不过比不上王者一套皮肤的钱，不氪金可以玩，也是大佬，要肝一肝的。最近洛克王国手游也被大众关注，我不看好，不为什么，就是不看好，洛克王国页游都不行，手游也大概率不行，都是刷刷刷的，剧情和所寄托的文化没有，算不上好游戏。原神也火出去了啊？我不玩原神，但那个是手游和 PC 端互通啊，手机方便，但其性能现在远远弱于电脑。</p><h4 id="觅长生"><a href="#觅长生" class="headerlink" title="觅长生"></a>觅长生</h4><p><img src="https://s2.loli.net/2022/07/20/fHcmsZepbixJzMv.png" alt="觅长生.png"></p><p>游玩：依然是 steam 游戏，我很早就在 B 站上看见了，当时还没 ea 版本呢，可惜当时不看好，卡牌？？金木水火土的牌能做出来什么战斗呢，就没管，最近改成灵气球了，无所谓，玩多了都可以。后来鬼谷八荒火了，当时也不知道怎么回事，对修仙游戏极度渴望，找到了觅长生，当时鬼谷八荒还没出事，就是 bug 多，更新慢，饼很多。当时看了飞羽仙狂的游玩，会了打劫流，渐渐熟悉了，制作组诚意很足，每周都更新，还有了 B 站的 wiki，体系完善，就等制作组继续更新了，不过好慢啊，都好多年了，还在 ea 阶段，游戏最近的创意工坊也出来了，玩家实力大大增加，难度降低很多，不过觅长生我更喜欢看看剧情了，飞不飞升要等正式版了（虽然我也化神了），喜欢修仙游戏的可以尝试，至少没有坑，也没有饼，缺点就像 steam 里面说的，可以玩的修仙小说，看剧情和装大佬才是王道啦。另外有一款了不起的修仙模拟器（玩法是修仙门派模拟器）也很好，但学习成本高。有额外资金且对修仙感兴趣可以尝试这两款游戏（觅长生和了不起的休闲模拟器，鬼谷八荒有大坑，别去）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
