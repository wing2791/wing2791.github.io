---
title: 知识点四_如何标记废弃方法_命令行操作cout和cerr
math: true
---

# 如何标记废弃方法
## Cpp
在C++中，如果要标记某个方法已经废弃，可以使用 `[[deprecated]]` 属性（attribute）。这是一种现代、清晰的方法，用于提醒开发者某些函数或方法不推荐使用。编译器会在调用这些标记为废弃的方法时生成警告信息。

### 使用方式：
1. **简单标记废弃**
	```cpp
	[[deprecated]]
	void oldFunction() {
	    // Implementation of old function
	}
	```
   
2. **带有自定义消息**  
	- 如果需要说明废弃的原因或建议替代方案，可以加上自定义的警告信息：
	```cpp
	[[deprecated("This function is deprecated, use newFunction() instead.")]]
	void oldFunction() {
	    // Implementation of old function
	}
	```
   
3. **适用于类或变量**  
	- `[[deprecated]]` 也可以用于类或变量：
	```cpp
	[[deprecated("This class is deprecated, use NewClass instead.")]]
	class OldClass {
	    // ...
	};
	
	[[deprecated]]
	int oldVariable;
	```

### 示例：
```cpp
#include <iostream>

class [[deprecated("Use NewClass instead.")]] OldClass {
public:
    void display() {
        std::cout << "OldClass method" << std::endl;
    }
};

[[deprecated("Use newFunction instead.")]]
void oldFunction() {
    std::cout << "This is an old function" << std::endl;
}

int main() {
    OldClass obj;         // 编译器会发出警告
    obj.display();        // 编译器会发出警告

    oldFunction();        // 编译器会发出警告

    return 0;
}
```

### 注意事项：
- 需要使用支持 C++14 或更高版本的编译器。
- 不同编译器对 `[[deprecated]]` 的支持和警告信息的详细程度可能会有所不同。
	- Vstudio 2022在编译阶级就报错

## Csharp
在C#中，可以通过使用 `Obsolete` 特性来标记方法、属性、类等为已废弃。这种方式不仅可以提醒开发者，还可以在使用时生成编译警告或错误。
### 使用方法
1. **简单标记为废弃：**
	```csharp
	[Obsolete]
	public void OldMethod()
	{
	    Console.WriteLine("This method is deprecated.");
	}
	```
	**效果：** 调用 `OldMethod` 时，编译器会发出警告。
2. **提供自定义消息：**
	```csharp
	[Obsolete("This method is deprecated. Use NewMethod instead.")]
	public void OldMethod()
	{
	    Console.WriteLine("This method is deprecated.");
	}
	```
	**效果：** 调用 `OldMethod` 时，警告信息会显示提供的自定义消息。
3. **强制阻止使用（将警告升级为错误）：**
	```csharp
	[Obsolete("This method is deprecated. Use NewMethod instead.", true)]
	public void OldMethod()
	{
	    Console.WriteLine("This method is deprecated.");
	}
	```
	**效果：** 调用 `OldMethod` 时，编译器会报错，而不是仅仅发出警告。
4. **应用于类或属性：**
	```csharp
	[Obsolete("This class is deprecated. Use NewClass instead.")]
	public class OldClass
	{
	    public void Display()
	    {
	        Console.WriteLine("Old class method.");
	    }
	}
	```

### 示例代码
```csharp
using System;

public class Program
{
    [Obsolete("Use NewMethod instead.")]
    public static void OldMethod()
    {
        Console.WriteLine("Old method called.");
    }

    public static void NewMethod()
    {
        Console.WriteLine("New method called.");
    }

    public static void Main()
    {
        OldMethod(); // 会触发警告
        NewMethod(); // 正常调用
    }
}
```
### 注意事项
- `Obsolete` 特性主要用于提醒开发者，实际的逻辑仍然会执行。
- 将 `Obsolete` 特性与 `true` 参数结合使用时，会阻止编译通过，从而强制开发者迁移到新的实现。





# 命令行操作cout和cerr

## ./program > output.log 2> error.log

`./program > output.log 2> error.log` 是一个用于运行程序并将输出分别重定向到文件的命令，主要用于处理程序运行时的输出流（标准输出和标准错误输出）。

### **分解解释**

1. **`./program`**
   - 表示运行当前目录下的可执行文件 `program`。
2. **`>`**
   - 用于将标准输出（`stdout`）重定向到指定文件。
   - 例如：`./program > output.log` 表示将程序的正常输出保存到 `output.log` 文件，而不是显示在终端。
3. **`2>`**
   - 用于将标准错误输出（`stderr`）重定向到指定文件。
   - 例如：`./program 2> error.log` 表示将程序的错误信息保存到 `error.log` 文件，而不是显示在终端。
4. **`output.log` 和 `error.log`**
   - 这两个文件是重定向的目标文件。
   - `output.log` 用于保存标准输出的信息（由 `std::cout` 产生的内容）。
   - `error.log` 用于保存标准错误输出的信息（由 `std::cerr` 产生的内容）。

------

### **完整流程**

运行 `./program > output.log 2> error.log` 后：

1. 如果程序通过 `std::cout` 输出正常消息，这些消息将被写入 `output.log`。
2. 如果程序通过 `std::cerr` 输出错误消息或警告信息，这些消息将被写入 `error.log`。
3. 终端上不会显示任何输出。

------

### **示例**

假设有以下程序 `program.cpp`：

```cpp
#include <iostream>
int main() {
    std::cout << "This is normal output." << std::endl;
    std::cerr << "This is an error message." << std::endl;
    return 0;
}
```

编译并运行：

```bash
g++ program.cpp -o program
./program > output.log 2> error.log
```

#### **运行结果**

- `output.log`文件内容：

  ```
  This is normal output.
  ```

- `error.log`文件内容：
  
  ```
  This is an error message.

------

### **扩展**

1. **同时输出到文件和终端**：

   - 如果想让标准输出和标准错误既显示在终端，又保存到文件：

     ```
     bashCopy code./program | tee output.log
     ./program 2> >(tee error.log >&2)
     ```

2. **合并标准输出和错误输出**：

   - 将两者合并输出到同一个文件：

     ```bash
     ./program > combined.log 2>&1
     ```
     
   - 这里的 `2>&1` 表示将标准错误（`stderr`）重定向到标准输出（`stdout`）的位置。
   
3. **只输出错误到终端**：

   ```bash
   ./program > /dev/null
   ```
   
   - `/dev/null` 是一个特殊的设备文件，所有重定向到它的内容都会被丢弃。
   - 这种情况下，只有错误信息会显示在终端上。



## `./program | tee output.log` 和 `./program 2> >(tee error.log >&2)`

在 Linux 或类似的操作系统中，一次只运行一行命令是默认行为，但通过使用管道 (`|`)、重定向 (`>`)、以及子进程或多任务特性，可以在一行命令中实现复杂的操作。让我们逐行解析：

------

### 第一行：

```bash
./program | tee output.log
```

#### **解释**

1. **`./program`**
   - 运行当前目录下的程序 `program`。
2. **`|`（管道符）**
   - 将 `program` 的 **标准输出** (`stdout`) 重定向到另一个命令的输入。
3. **`tee output.log`**
   - `tee` 是一个工具，用于将接收到的数据**同时**写入文件和显示到终端。
   - `output.log` 是文件名，`tee` 将 `program` 的标准输出写入到 `output.log`，并在终端上显示。

#### **结果**

- 标准输出会显示在终端上，并且被保存到 `output.log` 文件中。

------

### 第二行：

```bash
./program 2> >(tee error.log >&2)
```

#### **解释**

1. **`./program`**
   - 运行当前目录下的程序 `program`。
2. **`2>`**
   - 将 **标准错误** (`stderr`) 重定向。
   - 标准错误是通过 `std::cerr` 等生成的输出内容。
3. **`>`** 和 `>(...)`
   - `>(...)` 表示将输出通过一个**子进程**处理。这是一种命令替换操作，内部的命令会接收数据并立即处理。
   - 在这里，`>(tee error.log >&2)` 将标准错误作为输入传递给 `tee`。
4. **`tee error.log`**
   - 将标准错误输出**同时**保存到 `error.log` 文件，并将副本传递给它的标准输出。
5. **`>&2`**
   - 将 `tee` 的标准输出重定向回标准错误流，以确保终端能够正确显示原本属于标准错误的内容。

#### **结果**

- 标准错误会显示在终端上，并且被保存到 `error.log` 文件中。

------

### **总结区别**

#### **第一行**

- 捕获和显示**标准输出**。
- 输出保存到 `output.log`，且在终端可见。

#### **第二行**

- 捕获和显示**标准错误**。
- 错误信息保存到 `error.log`，且在终端可见。

------

### **关于一行命令限制**

一般来说，命令一行只能执行一个主要任务。但通过以下方式实现复杂功能：

1. **管道 (`|`)**：将一个命令的输出作为另一个命令的输入。

2. **子进程 (`(...)`)**：在子进程中执行命令。

3. 组合操作 (`&&`, `||`, `;`)

   ：

   - `&&`：前一个命令成功时执行后一个命令。
   - `||`：前一个命令失败时执行后一个命令。
   - `;`：无论前一个命令是否成功，均执行后一个命令。

------

#### **示例：将两行合并成一行**

可以使用 `;` 或 `&&`：

```bash
./program | tee output.log && ./program 2> >(tee error.log >&2)
```
